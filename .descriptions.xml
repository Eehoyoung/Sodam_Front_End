<inspections profile="Project Default"><group name="Node.js" path="JavaScript 및 TypeScript"><inspection shortName="NodeCoreCodingAssistance" defaultSeverity="WARNING" displayName="해결되지 않은 Node.js API" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Node.js의 &lt;code&gt;require&lt;/code&gt;나 코어 모듈('path', 'http', 'fs' 등)에 대해 코딩 지원을 구성할 것을 제안합니다.
&lt;p&gt;
전체 목록은 &lt;a href="https://nodejs.org/api/"&gt;https://nodejs.org/api/&lt;/a&gt;을 참고하십시오.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NodeCoreCodingAssistance&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Ktor" path=""><inspection shortName="KtorYamlConfig" defaultSeverity="WARNING" displayName="Ktor application.yaml" enabled="false" language="yaml" pluginId="intellij.ktor" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Ktor 애플리케이션 &lt;code&gt;.yaml&lt;/code&gt; 구성 파일에서 지원이 중단된 구성 키 및 잘못된 값을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KtorYamlConfig&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KtorOpenApiUpdate" defaultSeverity="WARNING" displayName="현재 모듈의 OpenAPI 문서가 오래되었습니다" enabled="false" language="yaml" pluginId="intellij.ktor" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
현재 Ktor 모듈의 OpenAPI 문서가 오래된 경우 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KtorOpenApiUpdate&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 언어 수준 마이그레이션 지원" path="Java"><inspection shortName="UseCompareMethod" defaultSeverity="WARNING" displayName="'compare()' 메서드를 사용해 숫자 비교 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
더 장황하거나 덜 효율적인 구문 대신 &lt;code&gt;Integer.compare()&lt;/code&gt; 메서드 호출이나 &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt; 혹은 &lt;code&gt;Float&lt;/code&gt; 클래스의 비슷한 메서드 호출로 대체될 수 있는 표현식을 보고합니다.
&lt;p&gt;&lt;code&gt;x&lt;/code&gt;와 &lt;code&gt;y&lt;/code&gt;가 모두 박싱된 정수라면 &lt;code&gt;x.compareTo(y)&lt;/code&gt;가 제안되며, 기본 타입인 경우 &lt;code&gt;Integer.compare(x, y)&lt;/code&gt;가 제안됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int compare(int x, int y) {
    return x &gt; y ? 1 : x &amp;lt; y ? -1 : 0;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int compare(int x, int y) {
    return Integer.compare(x, y);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;Double.compare&lt;/code&gt;와 &lt;code&gt;Float.compare&lt;/code&gt;이 코드의 의미를 약간 변경시키는 것에 유의하세요. 특히 &lt;code&gt;-0.0&lt;/code&gt;과 &lt;code&gt;0.0&lt;/code&gt;을 구분합니다(&lt;code&gt;Double.compare(-0.0, 0.0)&lt;/code&gt;의 값은 -1입니다).
  또한, &lt;code&gt;NaN&lt;/code&gt; 값을 일관적으로 처리합니다. 대부분의 경우 이 의미 변경은 실제로 코드를 향상합니다. 이러한 의미 변경이 본인의 경우에는 적절하지 않은 경우 부동소수점에 대한 이 검사를 체크박스에서 비활성화하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UseCompareMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfCanBeSwitch" defaultSeverity="WARNING" displayName="'if'를 'switch'로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;switch&lt;/code&gt; 문으로 바꿀 수 있는 &lt;code&gt;if&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;교체 결과는 일반적으로 더 짧고 명확해집니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(String str) {
    if (str.equals("1")) {
      System.out.println(1);
    } else if (str.equals("2")) {
      System.out.println(2);
    } else if (str.equals("3")) {
      System.out.println(3);
    } else {
      System.out.println(4);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(String str) {
    switch (str) {
      case "1" -&amp;gt; System.out.println(1);
      case "2" -&amp;gt; System.out.println(2);
      case "3" -&amp;gt; System.out.println(3);
      default -&amp;gt; System.out.println(4);
    }
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 7 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;'if' 조건 브랜치의 최소 수&lt;/b&gt; 필드를 사용하여 보고할 필요가 있는 &lt;code&gt;if&lt;/code&gt; 문의 &lt;code&gt;if&lt;/code&gt; 조건 브랜치의 최소 수를 지정합니다. 터미널의 &lt;code&gt;else&lt;/code&gt; 브랜치(&lt;code&gt;if&lt;/code&gt; 없음)는 계산되지 않습니다.&lt;/p&gt;
&lt;p&gt;
&lt;b&gt;숫자에 대한 switch 제안&lt;/b&gt; 옵션을 사용하여 박싱된 기본 숫자와 문자에 대한 &lt;code&gt;switch&lt;/code&gt; 문의 제안을 활성화합니다.
&lt;p&gt;
&lt;b&gt;열거형에 대한 switch 제안&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;enum&lt;/code&gt; 상수에 대한 &lt;code&gt;switch&lt;/code&gt; 문의 제안을 활성화합니다.
&lt;p&gt;
  &lt;b&gt;null 안전 표현식&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;NullPointerException&lt;/code&gt;만을 삽입할 수는 없는 &lt;code&gt;switch&lt;/code&gt; 문을 제안합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IfCanBeSwitch&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnumerationCanBeIteration" defaultSeverity="WARNING" displayName="열거형은 반복이 될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
컬렉션에 대해 사용되었으며 동등한 &lt;code&gt;Iterator&lt;/code&gt; 구문으로 바꿀 수 있는 &lt;code&gt;Enumeration&lt;/code&gt; 메서드 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Enumeration&amp;lt;String&amp;gt; keys = map.keys();
  while (keys.hasMoreElements()) {
    String name = keys.nextElement();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Iterator&amp;lt;String&amp;gt; iterator = map.keySet().iterator();
  while (iterator.hasNext()) {
    String name = iterator.next();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EnumerationCanBeIteration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="RESTful 웹 서비스(JAX-RS)" path=""><inspection shortName="VoidMethodAnnotatedWithGET" defaultSeverity="WARNING" displayName="@GET 어노테이션이 추가된 메서드가 void 값을 반환" enabled="false" language="JAVA" pluginId="com.jetbrains.restWebServices" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;아무것도 반환하지 않는 &lt;code&gt;@GET&lt;/code&gt; 어노테이션이 추가된 메서드를 보고합니다.
  &lt;code&gt;@GET&lt;/code&gt; 어노테이션이 추가된 메서드에는 void가 아닌 반환 타입이 있어야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VoidMethodAnnotatedWithGET&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PathAnnotation" defaultSeverity="WARNING" displayName="잘못된 @Path URI 템플릿" enabled="false" language="JAVA" pluginId="com.jetbrains.restWebServices" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;@Path&lt;/code&gt; 어노테이션 내부의 구문 오류 및 사용되지 않는 URI 템플릿을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @GET
  @Path("/&lt;b&gt;{unused}&lt;/b&gt;") // 템플릿 'unused'가 한 번도 사용되지 않습니다
  public String get() {
    return "";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PathAnnotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="WadlDomInspection" defaultSeverity="ERROR" displayName="잘못된 WADL 구성" enabled="false" language="XML" pluginId="com.jetbrains.restWebServices" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;WADL 파일 내 구성 오류를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: WadlDomInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RestResourceMethodInspection" defaultSeverity="ERROR" displayName="리소스 메서드가 없는 @Path 클래스" enabled="false" language="JAVA" pluginId="com.jetbrains.restWebServices" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;리소스 메서드가 없고 &lt;code&gt;@Path&lt;/code&gt; 어노테이션이 추가된 클래스를 보고합니다.
  루트 리소스 클래스에는 &lt;code&gt;@Path&lt;/code&gt; 또는 &lt;code&gt;@HttpMethod&lt;/code&gt; 어노테이션(&lt;code&gt;@GET&lt;/code&gt;, &lt;code&gt;@POST&lt;/code&gt; 등) 중 하나가 추가된 리소스 메서드가 한 개 이상 있어야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RestResourceMethodInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RestWrongDefaultValueInspection" defaultSeverity="ERROR" displayName="@DefaultValue 매개변수의 잘못된 값" enabled="false" language="JAVA" pluginId="com.jetbrains.restWebServices" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;지정된 매개변수 타입으로 변환할 수 없는 경우 &lt;code&gt;@DefaultValue&lt;/code&gt; 값을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @GET
  @Path("/{n}")
  public String get(@PathParam("n") @DefaultValue("&lt;b&gt;III&lt;/b&gt;") int n) { // 오류: 'III'을 int로 변환할 수 없습니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RestWrongDefaultValueInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnresolvedRestParam" defaultSeverity="ERROR" displayName="해결되지 않은 @PathParam 참조" enabled="false" language="UAST" pluginId="com.jetbrains.restWebServices" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;메서드 시그니처에 선언되어 있으나 URL 경로에서 누락되었거나 그 반대인 &lt;code&gt;@PathParam&lt;/code&gt; 매개변수를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;예:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Get("/path/{myVariable}/")
  public String handler(@PathParam("&lt;b&gt;name_is_not_equal_to_myVariable&lt;/b&gt;") String myVariable) { // 오류
    return "...";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnresolvedRestParam&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleMethodDesignatorsInspection" defaultSeverity="ERROR" displayName="여러 개의 HTTP 메서드 어노테이션이 있는 리소스 메서드" enabled="false" language="JAVA" pluginId="com.jetbrains.restWebServices" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;여러 HTTP 메서드 어노테이션(&lt;code&gt;@GET&lt;/code&gt;, &lt;code&gt;@POST&lt;/code&gt;, &lt;code&gt;@PUT&lt;/code&gt; 등)이 추가된 리소드 메서드를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MultipleMethodDesignatorsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Spring Modulith" path=""><inspection shortName="SpringModulithEventListenerInspection" defaultSeverity="WEAK WARNING" displayName="이벤트 리스너 선언을 간소화할 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.spring.modulith" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단순화 가능한 비동기 트랜잭션 이벤트 리스너 선언을 보고합니다.
&lt;pre&gt;&lt;code&gt;
@Component
public class MyEventListener {

    @Async
    @Transactional
    @TransactionalEventListener
    public void on(MyEvent e) {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;code&gt;@ApplicationModuleListener&lt;/code&gt;를 사용하는 경우:
&lt;pre&gt;&lt;code&gt;
@Component
public class MyEventListener {

    @ApplicationModuleListener
    public void on(MyEvent e) {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringModulithEventListenerInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringModulithAllowedDependencyInspection" defaultSeverity="ERROR" displayName="잘못된 종속 요소 선언" enabled="false" language="JAVA" pluginId="com.intellij.spring.modulith" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명명된 인터페이스나 해당 모듈이 없을 때 허용된 종속성을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringModulithAllowedDependencyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringModulithApiUsageInspection" defaultSeverity="ERROR" displayName="제한된 모듈 API 사용" enabled="false" language="UAST" pluginId="com.intellij.spring.modulith" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://docs.spring.io/spring-modulith/reference/index.html"&gt;Spring Modulith&lt;/a&gt;의 관점에서 제한된 내부 API 사용을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringModulithApiUsageInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="유닛 테스트" path="JavaScript 및 TypeScript"><inspection shortName="JSTestFailedLine" defaultSeverity="WARNING" displayName="테스트 코드에서 실패 줄 강조 표시" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
테스트 내 실패한 메서드 호출이나 어설션을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSTestFailedLine&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KarmaConfigFile" defaultSeverity="WARNING" displayName="잘못된 Karma 구성 파일" enabled="false" language="JavaScript" pluginId="Karma" pluginVersion="252.25204.0" isGlobalTool="false">&lt;!--
  ~ Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
  --&gt;

&lt;html&gt;
&lt;body&gt;
  Karma 구성 파일(예: &lt;code&gt;karma.conf.js&lt;/code&gt;)의 파일 경로('basePath', 'files') 내 잠재적 오류를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KarmaConfigFile&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="가져오기" path="Java"><inspection shortName="OnDemandImport" defaultSeverity="WARNING" displayName="'*' 가져오기" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
전체 패키지('* imports')를 포괄하는 모든 &lt;code&gt;import&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;일부 코딩 표준에서는 그러한 &lt;code&gt;import&lt;/code&gt; 문을 금지합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;import 문 최적화&lt;/b&gt; 명령어로 그러한 구문을 탐지하고 수정하도록 IntelliJ IDEA를 구성할 수 있습니다. &lt;a href="settings://preferences.sourceCode.Java?Use%20single%20class%20import"&gt;설정 | 에디터 | 코드 스타일 | Java | import 문&lt;/a&gt;으로 이동하여 &lt;b&gt;단일 클래스 import 문 사용&lt;/b&gt; 옵션이 활성화되어 있는지 확인하고 &lt;b&gt;'*'가 포함된 import 문을 사용하는 클래스 수&lt;/b&gt; 및 &lt;b&gt;'*'가 포함된 정적 import 문을 사용하는 이름 수&lt;/b&gt; 필드에 값을 지정하세요.
  그러므로 이 검사는 주로 변경할 의도가 없는 코드 베이스에 대한 오프라인 보고에 유용합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: OnDemandImport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SamePackageImport" defaultSeverity="WARNING" displayName="동일한 패키지의 불필요한 import 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
포함하는 파일과 같은 패키지를 참조하는 &lt;code&gt;import&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;
  same-package 파일은 항상 묵시적으로 가져와지므로 그러한 import 문은 불필요하며 혼동됩니다.
&lt;/p&gt;
&lt;p&gt;
  IntelliJ IDEA는 &lt;b&gt;Import 문 최적화&lt;/b&gt; 명령어를 사용하여 그러한 구문을 자동으로 탐지하여 수정할 수 있으므로 이 검사는 주로 변경할 의도가 없는 코드 베이스에 대한 오프라인 보고에 유용합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SamePackageImport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SingleClassImport" defaultSeverity="WARNING" displayName="단일 클래스 import 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
하나의 클래스(전체 패키지가 아닌)를 가져오는 &lt;code&gt;import&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;일부 코딩 표준에서는 그러한 &lt;code&gt;import&lt;/code&gt; 문을 금지합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;import 문 최적화&lt;/b&gt; 명령어로 그러한 구문을 탐지하고 수정하도록 IntelliJ IDEA를 구성할 수 있습니다. &lt;a href="settings://preferences.sourceCode.Java?Use%20single%20class%20import"&gt;설정 | 에디터 | 코드 스타일 | Java | import 문&lt;/a&gt; 체크박스로 이동하여 &lt;b&gt;단일 클래스 import 문 사용&lt;/b&gt; 체크박스를 삭제하세요. 그러므로 이 검사는 주로 변경할 의도가 없는 코드 베이스에 대한 오프라인 보고에 유용합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SingleClassImport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticImport" defaultSeverity="WARNING" displayName="static import 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;import static&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;그러한 &lt;code&gt;import&lt;/code&gt; 문은 Java 1.4 이전 JVM에서 지원되지 않습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;아래 테이블을 사용하여 &lt;code&gt;import static&lt;/code&gt; 문에서 사용되는 경우 검사에서 무시될 클래스를 지정하세요.&lt;/li&gt;
  &lt;li&gt;단일 필드 &lt;code&gt;import static&lt;/code&gt; 문을 무시하려면 &lt;b&gt;단일 필드 static import 문 무시&lt;/b&gt; 체크박스를 사용하세요.&lt;/li&gt;
  &lt;li&gt;단일 메서드 &lt;code&gt;import static&lt;/code&gt; 문을 무시하려면 &lt;b&gt;단일 메서드 static import 문 무시&lt;/b&gt; 체크박스를 사용하세요.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StaticImport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticImportCanBeUsed" defaultSeverity="WARNING" displayName="static import 문 사용 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;on-demand import static&lt;/code&gt; 구문으로 바꿀 수 있는 한정자를 보고합니다.
확인할 클래스의 목록은 &lt;a href="settings://editor.preferences.import"&gt;Settings(설정) | Editor(에디터) | General(일반) | Auto Import(자동으로 가져오기) | Java | Include auto-import of static members in completion(완성 시 static 멤버 자동으로 가져오기)&lt;/a&gt;에서 구성될 수 있습니다.
&lt;/body&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2025.1에서 추가&lt;/small&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: StaticImportCanBeUsed&lt;/small&gt;&lt;/p&gt;
&lt;/html&gt;</inspection><inspection shortName="MISSORTED_IMPORTS" defaultSeverity="INFORMATION" displayName="잘못 정렬된 import 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
현재 코드 스타일에 따라 정리되지 않은 &lt;code&gt;import&lt;/code&gt; 문을 보고합니다(설정 | 에디터 | 코드 스타일 참조).
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.List;
  import java.util.ArrayList;

  public class Example {
    List list = new ArrayList();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;'import 문 최적화' 빠른 수정 적용 후:
&lt;pre&gt;&lt;code&gt;
  import java.util.ArrayList;
  import java.util.List;

  public class Example {
    List list = new ArrayList();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MISSORTED_IMPORTS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UNUSED_IMPORT" defaultSeverity="WARNING" displayName="사용되지 않는 import 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
불필요한 &lt;code&gt;import&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;소스 파일의 가져온 클래스 및 패키지를 사용하지 않을 경우 일반 &lt;code&gt;import&lt;/code&gt; 문은 불필요합니다. 
소스 파일에서 사용되지 않는 가져온 &lt;code&gt;static&lt;/code&gt; 필드 및 메서드도 마찬가지입니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.ArrayList;
  public class Example {
    public static void main(String[] args) {
      System.out.println("Hello World!");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:
&lt;pre&gt;&lt;code&gt;
  public class Example {
    public static void main(String[] args) {
      System.out.println("Hello World!");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UNUSED_IMPORT&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaLangImport" defaultSeverity="WARNING" displayName="'java.lang' 패키지의 불필요한 import 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang&lt;/code&gt; 패키지를 참조하는 &lt;code&gt;import&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;
  &lt;code&gt;java.lang&lt;/code&gt; 클래스는 항상 묵시적으로 가져와지므로 그러한 import 문은 불필요하며 혼란을 일으킵니다.
&lt;/p&gt;
&lt;p&gt;
  IntelliJ IDEA는 &lt;b&gt;Import 문 최적화&lt;/b&gt; 명령어를 사용하여 그러한 구문을 자동으로 탐지하여 수정할 수 있으므로 이 검사는 주로 변경할 의도가 없는 코드 베이스에 대한 오프라인 보고에 유용합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavaLangImport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="PowerShell" path=""><inspection shortName="PSScriptAnalyzer" defaultSeverity="SERVER PROBLEM" displayName="PSScriptAnalyzer" enabled="false" language="PowerShell" pluginId="com.intellij.plugin.adernov.powershell" pluginVersion="2.11.0" isGlobalTool="false">&lt;html lang="en"&gt;Reports problems found by &lt;a href='https://github.com/PowerShell/PSScriptAnalyzer'&gt;PSScriptAnalyzer&lt;/a&gt; code checker.&lt;/html&gt;</inspection></group><group name="Thymeleaf" path=""><inspection shortName="ThymeleafVariablesResolveInspection" defaultSeverity="WEAK WARNING" displayName="Thymeleaf 표현식 변수 내 해결되지 않은 참조" enabled="false" language="ThymeleafExpressions" pluginId="com.intellij.thymeleaf" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;해결되지 않은 참조 및 잘못된 Thymeleaf 표현식을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="html"&gt;
&amp;lt;html xmlns:th="https://www.thymeleaf.org"&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;form th:object="${&lt;strong&gt;unknownPet&lt;/strong&gt;}"  &amp;lt;!-- 'unknownPet'을 해결할 수 없습니다  --&amp;gt;
        class="form-horizontal" method="post"&amp;gt;
    &amp;lt;input type="hidden" name="id" th:value="*{&lt;strong&gt;id&lt;/strong&gt;}" /&amp;gt; &amp;lt;!-- 'id'를 해결할 수 없습니다  --&amp;gt;
  &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ThymeleafVariablesResolveInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThymeleafDialectDomInspection" defaultSeverity="ERROR" displayName="Thymeleaf 파생 언어 확장 오류" enabled="false" language="ThymeleafExpressions" pluginId="com.intellij.thymeleaf" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Thymeleaf Dialect Extension &lt;code&gt;&amp;lt;dialect&amp;gt;&lt;/code&gt; 파일에서 잘못된 요소를 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인스턴스화할 수 없는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;필요한 클래스를 확장하지 않는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;부적절한 범위를 가진 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;빈 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 패턴(예: Java 식별자)과 일치하지 않는 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 하위 태그 또는 속성을 포함하지 않는 태그&lt;/li&gt;
  &lt;li&gt;이름이 중복된 객체를 정의하는 태그&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ThymeleafDialectDomInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThymeleafMessagesResolveInspection" defaultSeverity="ERROR" displayName="해결되지 않은 메시지 리소스 키" enabled="false" language="ThymeleafExpressions" pluginId="com.intellij.thymeleaf" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;해결되지 않은 메시지 리소스 키를 보고합니다.&lt;/p&gt;

&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="html"&gt;
&amp;lt;html xmlns:th="https://www.thymeleaf.org"&amp;gt;
 &amp;lt;body&amp;gt;
    &amp;lt;h1 th:text="#{&lt;strong&gt;welcome.unknown&lt;/strong&gt;}"&amp;gt;Hallo, World&amp;lt;/h1&amp;gt; &amp;lt;!-- 프로퍼티 키를 해결할 수 없습니다  --&amp;gt;
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ThymeleafMessagesResolveInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Compliance" path=""><inspection shortName="AndroidLintPlaySdkIndexNonCompliant" defaultSeverity="ERROR" displayName="Library has policy issues in SDK Index" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Library has policy issues in SDK Index&lt;br&gt;&lt;br&gt;This library version has policy issues that will block publishing in the Google Play Store.&lt;br&gt;&lt;br&gt;Issue id: PlaySdkIndexNonCompliant&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/distribute/sdk-index"&gt;https://developer.android.com/distribute/sdk-index&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPlaySdkIndexVulnerability" defaultSeverity="ERROR" displayName="Library has vulnerability issues in SDK Index" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Library has vulnerability issues in SDK Index&lt;br&gt;&lt;br&gt;This library version has vulnerability issues that could block publishing in the Google Play Store.&lt;br&gt;&lt;br&gt;Issue id: PlaySdkIndexVulnerability&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/distribute/sdk-index"&gt;https://developer.android.com/distribute/sdk-index&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOutdatedLibrary" defaultSeverity="WARNING" displayName="Outdated Library" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Outdated Library&lt;br&gt;&lt;br&gt;Your app is using an outdated version of a library. This may cause violations of Google Play policies (see &lt;a href="https://play.google.com/about/monetization-ads/ads/"&gt;https://play.google.com/about/monetization-ads/ads/&lt;/a&gt;) and/or may affect your app&amp;#8217;s visibility on the Play Store.&lt;br/&gt;
&lt;br/&gt;
Please try updating your app with an updated version of this library, or remove it from your app.&lt;br&gt;&lt;br&gt;Issue id: OutdatedLibrary&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/distribute/sdk-index"&gt;https://developer.android.com/distribute/sdk-index&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExpiredTargetSdkVersion" defaultSeverity="ERROR" displayName="TargetSdkVersion No Longer Supported" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TargetSdkVersion No Longer Supported&lt;br&gt;&lt;br&gt;Configuring your app or sdk to target a recent API level ensures that users benefit from significant security and performance improvements, while still allowing your app to run on older Android versions (down to the &lt;code&gt;minSdkVersion&lt;/code&gt;).&lt;br/&gt;
&lt;br/&gt;
To update your &lt;code&gt;targetSdkVersion&lt;/code&gt;, follow the steps from "Meeting Google Play requirements for target API level", &lt;a href="https://developer.android.com/distribute/best-practices/develop/target-sdk.html"&gt;https://developer.android.com/distribute/best-practices/develop/target-sdk.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: ExpiredTargetSdkVersion&lt;br&gt;&lt;br&gt;&lt;a href="https://support.google.com/googleplay/android-developer/answer/113469#targetsdk"&gt;https://support.google.com/googleplay/android-developer/answer/113469#targetsdk&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPlaySdkIndexGenericIssues" defaultSeverity="ERROR" displayName="Library has issues in SDK Index" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Library has issues in SDK Index&lt;br&gt;&lt;br&gt;This library version has issues that could block publishing in the Google Play Store.&lt;br&gt;&lt;br&gt;Issue id: PlaySdkIndexGenericIssues&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/distribute/sdk-index"&gt;https://developer.android.com/distribute/sdk-index&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExpiringTargetSdkVersion" defaultSeverity="ERROR" displayName="TargetSdkVersion Soon Expiring" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TargetSdkVersion Soon Expiring&lt;br&gt;&lt;br&gt;Configuring your app or sdk to target a recent API level ensures that users benefit from significant security and performance improvements, while still allowing your app or sdk to run on older Android versions (down to the &lt;code&gt;minSdkVersion&lt;/code&gt;).&lt;br/&gt;
&lt;br/&gt;
To update your &lt;code&gt;targetSdkVersion&lt;/code&gt;, follow the steps from "Meeting Google Play requirements for target API level", &lt;a href="https://developer.android.com/distribute/best-practices/develop/target-sdk.html"&gt;https://developer.android.com/distribute/best-practices/develop/target-sdk.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: ExpiringTargetSdkVersion&lt;br&gt;&lt;br&gt;&lt;a href="https://support.google.com/googleplay/android-developer/answer/113469#targetsdk"&gt;https://support.google.com/googleplay/android-developer/answer/113469#targetsdk&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintQueryAllPackagesPermission" defaultSeverity="ERROR" displayName="Using the QUERY_ALL_PACKAGES permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using the QUERY_ALL_PACKAGES permission&lt;br&gt;&lt;br&gt;If you need to query or interact with other installed apps, you should be using a &lt;code&gt;&amp;lt;queries&gt;&lt;/code&gt; declaration in your manifest. Using the QUERY_ALL_PACKAGES permission in order to see all installed apps is rarely necessary, and most apps on Google Play are not allowed to have this permission.&lt;br&gt;&lt;br&gt;Issue id: QueryAllPackagesPermission&lt;br&gt;&lt;br&gt;&lt;a href="https://g.co/dev/packagevisibility"&gt;https://g.co/dev/packagevisibility&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Javadoc" path="Java"><inspection shortName="MissingPackageInfo" defaultSeverity="WARNING" displayName="'package-info.java' 누락" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
클래스를 포함하지만 &lt;code&gt;package-info.java&lt;/code&gt; 또는 &lt;code&gt;package.html&lt;/code&gt; 파일을 포함하지 않으므로
패키지 문서가 누락된 패키지를 보고합니다.
&lt;p&gt;빠른 수정은 초기 &lt;code&gt;package-info.java&lt;/code&gt; 파일을 생성합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MissingPackageInfo&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocDeclaration" defaultSeverity="WARNING" displayName="Javadoc 선언 문제" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음 문제가 있는 Javadoc 주석 및 태그를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;잘못된 태그 이름&lt;/li&gt;
  &lt;li&gt;불완전한 태그 설명&lt;/li&gt;
  &lt;li&gt;중복된 태그&lt;/li&gt;
  &lt;li&gt;누락된 Javadoc 설명&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * 잘못된 태그 이름
   * @poram param description
   */
  public void sample(int param){
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * 자기 참조 {@link #sample(int)}
   */
  public void sample(int param){
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 알 수 없는 Javadoc 태그를 사용자 정의된 추가 태그 목록에 추가합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavadocDeclaration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DanglingJavadoc" defaultSeverity="WARNING" displayName="허상 Javadoc 주석" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스, 메서드 또는 필드에 속하지 않는 Javadoc 주석을 보고합니다.
Javadoc 도구는 속한 곳이 없는 Javadoc 주석을 무시하며 생성된 HTML 문서에 포함하지 않습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
    /**
     * Dangling comment
     */
    /**
     * Method javadoc
     */
     public void m(){}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 통해 해당 주석을 완전히 삭제하거나 블록 주석으로 변환할 수 있습니다. 빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
    /*
      Dangling comment
    */
    /**
     * Method javadoc
     */
    public void m(){}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;Javadoc 서식의 파일 헤더 무시&lt;/b&gt; 옵션을 사용하여 Java 파일 시작 부분의 주석을 무시합니다.
이것은 보통 저작권 문구입니다.
&lt;p&gt;&lt;small&gt;Inspection ID: DanglingJavadoc&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocReference" defaultSeverity="ERROR" displayName="선언에 Javadoc 참조 문제가 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Javadoc 주석 내에서 해결되지 않은 참조를 보고합니다.
&lt;p&gt;다음 예시에서 &lt;code&gt;someParam&lt;/code&gt; 매개변수가 누락되었으므로 강조 표시됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class A {
    /**
     * @param someParam 설명
     **/
    void foo() {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;액세스할 수 없는 심볼 보고&lt;/b&gt; 옵션을 비활성화하여 누락된 메서드 매개변수, 클래스, 필드 및 메서드를 참조하는 태그를 무시합니다.&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: JavadocReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnnecessaryJavaDocLink" defaultSeverity="WARNING" displayName="불필요한 Javadoc 링크" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Javadoc의 태그 중, 주석을 소유한 메서드나 주석을 소유한 메서드의 상위 메서드, 주석을 포함하는 클래스를 참조하는 &lt;code&gt;@see&lt;/code&gt;, &lt;code&gt;{@link}&lt;/code&gt;, &lt;code&gt;{@linkplain}&lt;/code&gt; 태그를 보고합니다.
&lt;p&gt;관련 링크는 불필요하며 검사의 빠른 수정을 통해 안전하게 제거할 수 있습니다. 빠른 수정에서는 태그가 주석의 유일한 내용인 경우 전체 Javadoc 주석을 제거합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example {
    /**
     * @see Example#method
     */
    public void method() { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Example {
  public void method() { }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
아래의 체크박스를 사용하여 상위 메서드의 인라인 링크(&lt;code&gt;{@link}&lt;/code&gt; 및 &lt;code&gt;{@linkplain}&lt;/code&gt;)를 무시합니다. 모든 상위 메서드의 링크는 Javadoc 도구에 자동으로 추가되지만, 상위 메서드의 인라인 링크는 Javadoc 주석의 텍스트 내에서 필요한 경우가 있습니다.

&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryJavaDocLink&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingDeprecatedAnnotation" defaultSeverity="WARNING" displayName="'@Deprecated' 어노테이션 누락" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@deprecated&lt;/code&gt; Javadoc 태그가 있지만 &lt;code&gt;@java.lang.Deprecated&lt;/code&gt; 어노테이션은 없는
모듈 선언, 클래스, 필드 또는 메서드를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @deprecated use {@code example()} instead
   */
  void sample(){ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @deprecated use {@code example()} instead
   */
  @Deprecated
  void sample(){ }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;code&gt;@Deprecated&lt;/code&gt; 어노테이션이 있지만 Javadoc &lt;code&gt;@deprecated&lt;/code&gt; 태그에 설명이 없는 멤버를 보고하려면 아래의 체크박스를 사용하세요.

&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;어노테이션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MissingDeprecatedAnnotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryInheritDoc" defaultSeverity="WARNING" displayName="불필요한 '{@inheritDoc}' Javadoc 주석" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;{@inheritDoc}&lt;/code&gt; 태그만을 포함하는 Javadoc 주석을 보고합니다. 주석이 없는 경우 Javadoc은 상위 클래스의 주석을 복사하므로 &lt;code&gt;{@inheritDoc}&lt;/code&gt;만을 포함하는 주석은 아무것도 추가하지 않습니다.
&lt;p&gt;또한 유효하지 않은 위치(예: 필드)의 &lt;code&gt;{@inheritDoc}&lt;/code&gt; 사용을 보고합니다.&lt;/p&gt;
&lt;p&gt;불필요한 Javadoc 주석의 제거를 권장합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example implements Comparable&amp;lt;Example&amp;gt; {
    /**
     * {@inheritDoc}
     */
    @Override
    public int compareTo(Example o) {
      return 0;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example implements Comparable&amp;lt;Example&amp;gt; {
    @Override
    public int compareTo(Example o) {
      return 0;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryInheritDoc&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlTagCanBeJavadocTag" defaultSeverity="WARNING" displayName="'&lt;code&gt;…&lt;/code&gt;'를 '{@code …}'로 대체 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Javadoc 주석 내 &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; 태그의 사용을 보고합니다.
JDK 5부터 이러한 태그는 &lt;code&gt;{@code ...}&lt;/code&gt; 구문으로 바꿀 수 있습니다.
이렇게 하면 HTML 문자 엔티티 대신 주석 내에 대괄호 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 사용이 허용됩니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @return empty &amp;lt;code&amp;gt;ArrayList&amp;amp;lt;Integer&amp;amp;gt;&amp;lt;/code&amp;gt;
   */
  List&amp;lt;Integer&amp;gt; getList(){ ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @return empty {@code ArrayList&amp;lt;Integer&amp;gt;}
   */
  List&amp;lt;Integer&amp;gt; getList(){ ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: HtmlTagCanBeJavadocTag&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MismatchedJavadocCode" defaultSeverity="WARNING" displayName="Javadoc과 코드의 불일치" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 선언과 일치하는 영어로 작성된 메서드 사양의 일부를 보고합니다. 여기에는 다음이 포함됩니다.
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt;를 반환하도록 지정되었지만, 반환 타입이 부울이 아닌 메서드.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;null&lt;/code&gt;을 반환하도록 지정되었지만, &lt;code&gt;@NotNull&lt;/code&gt;로 어노테이션이 추가되거나 반환 타입이 기본형인 메서드.&lt;/li&gt;
  &lt;li&gt;목록을 반환하도록 지정되었지만, 반환 타입이 세트 또는 배열인 메서드.&lt;/li&gt;
  &lt;li&gt;기타 등등.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @사용자가 있으면 true를 반환하고 그렇지 않으면 false를 반환
   */
  User findUser(String name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  이 검사에서는 인간의 언어를 해석하려고 하기 때문에 거짓 양성이 발생할 수 있습니다. 검사 보고가 잘못되면 설명이 혼란스러워 다시 작성해야 할 수도 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;small&gt;2022.3의 새로운 기능&lt;/small&gt;
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MismatchedJavadocCode&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceWithJavadoc" defaultSeverity="INFORMATION" displayName="Javadoc으로 대체 가능한 주석" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Javadoc 주석으로 대체할 수 있는 필드, 메서드 또는 클래스에 속하는 일반 주석을 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Main {
    /*
    * Hello,
    */
    // World!
    void f() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Main {
    /**
     * Hello,
     * World!
     */
    void f() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceWithJavadoc&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MissingJavadoc" defaultSeverity="WARNING" displayName="Javadoc 누락" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
누락된 Javadoc 주석 및 태그를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * '@param' 누락이 보고됩니다(구성된 경우).
   */
  public void sample(int param){
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 누락된 태그 또는 누락된 Javadoc 주석을 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * '@param' 누락이 보고됩니다(구성된 경우).
   * @param param
   */
  public void sample(int param){
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
지원 중단된 요소 또는 단순한 접근자 메서드(예: &lt;code&gt;getField()&lt;/code&gt; 또는 &lt;code&gt;setField()&lt;/code&gt;)를 무시하도록 검사를 구성할 수 있습니다.
&lt;/p&gt;
아래 옵션을 사용하여 특정 코드 요소(예: 메서드, 필드, 클래스, 패키지, 모듈)에 대한 최소한의 필요 가시성 및 필요한 태그를 구성할 수도 있습니다.
&lt;p&gt;&lt;small&gt;Inspection ID: MissingJavadoc&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageInfoWithoutPackage" defaultSeverity="WARNING" displayName="'package' 문이 없는 'package-info.java'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;package&lt;/code&gt; 문이 없는 &lt;code&gt;package-info.java&lt;/code&gt; 파일을 보고합니다.
&lt;p&gt;
Javadoc 도구는 파일이 다른 곳에 있을 경우에도 디폴트 패키지의 해당 파일 문서를 검토합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PackageInfoWithoutPackage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocHtmlLint" defaultSeverity="ERROR" displayName="Javadoc(DocLint)의 HTML 문제" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Java 8부터 DocLint에서 보고된 Javadoc 주석의 동일한 HTML 문제를 보고합니다.
&lt;p&gt;이 검사는 다음과 같은 문제를 탐지합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;닫는 태그가 불필요한 태그, 닫히지 않은 태그, 알 수 없는 태그, 위치가 잘못된 태그 또는 빈 태그&lt;/li&gt;
  &lt;li&gt;알 수 없거나 잘못된 속성&lt;/li&gt;
  &lt;li&gt;잘못 배치된 텍스트&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * 알 수 없는 태그: List&amp;lt;String&amp;gt;
 * 닫히지 않은 태그: error&amp;lt;/b&amp;gt;
 * 잘못 배치된 텍스트 또는 태그: &amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;one&amp;lt;/li&amp;gt;, &amp;lt;li&amp;gt;two&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
 * 잘못된 속성 또는 빈 속성: &amp;lt;a href=""&amp;gt;&amp;lt;/a&amp;gt;
 * 닫는 태그가 불필요한 태그: &amp;lt;br/&amp;gt;
 * ...
 */
void sample(){ }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JavadocHtmlLint&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageDotHtmlMayBePackageInfo" defaultSeverity="WARNING" displayName="'package.html'을 'package-info.java'로 변환할 수 있음" enabled="false" language="HTML" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
패키지를 문서화하기 위해 사용하는 &lt;code&gt;package.html&lt;/code&gt; 파일을 보고합니다.
&lt;p&gt;JDK 1.5 버전부터는 패키지 어노테이션까지 포함 가능한 &lt;code&gt;package-info.java&lt;/code&gt; 파일을 사용하는 것이 좋습니다. 이러한 package-info.java는 패키지 수준의 어노테이션과 문서화를 위한 유일한 저장소가 됩니다.&lt;/p&gt;
&lt;p&gt;예: &lt;code&gt;package.html&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    Documentation example.
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후: &lt;code&gt;package-info.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * Documentation example.
 */
package com.sample;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PackageDotHtmlMayBePackageInfo&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocLinkAsPlainText" defaultSeverity="WARNING" displayName="지정된 항목을 평문으로 연결" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Javadoc 주석의 일반 텍스트 링크를 보고합니다.
&lt;p&gt;
  빠른 수정에서는 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 태그로 링크를 래핑하도록 제안합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
   /**
    * https://en.wikipedia.org/
    */
    void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
   /**
    * &amp;lt;a href="https://en.wikipedia.org/"&amp;gt;https://en.wikipedia.org/&amp;lt;/a&amp;gt;
    */
    void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavadocLinkAsPlainText&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavadocBlankLines" defaultSeverity="WARNING" displayName="빈 줄은 &lt;p&gt;로 대체되어 줄을 나누어야 합니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Javadoc 주석의 빈 줄을 보고합니다.
&lt;p&gt;
  Javadoc의 빈 줄은 텍스트를 다른 단락으로 분할하려는 인텐션 신호일 수 있습니다. 하지만 Javadoc 도구 및 IntelliJ IDEA는 문서 주석을 렌더링할 때 이를 무시합니다.
&lt;/p&gt;
&lt;p&gt;
  빠른 수정에서는 빈 줄을 단락 태그(&amp;lt;p&amp;gt;)로 교체할 것을 제안합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    /**
     * 아무 작업도 하지 않습니다.
     *
     * 아무 작업도 하지 않습니다
     */
    void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    /**
     * 아무 작업도 하지 않습니다.
     * &amp;lt;p&amp;gt;
     * 아무 작업도 하지 않습니다
     */
    void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavadocBlankLines&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Bean 유효성 검사" path=""><inspection shortName="BvConfigDomInspection" defaultSeverity="ERROR" displayName="Bean Validation &lt;validation-config&gt; 파일 내 잘못된 요소" enabled="false" language="XML" pluginId="com.intellij.beanValidation" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Bean Validation &lt;code&gt;&amp;lt;validation-config&amp;gt;&lt;/code&gt; 파일 내 잘못된 요소를 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인스턴스화할 수 없는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;필요한 클래스를 확장하지 않는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;부적절한 범위를 가진 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;빈 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 패턴(예: Java 식별자)과 일치하지 않는 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 하위 태그 또는 속성을 포함하지 않는 태그&lt;/li&gt;
  &lt;li&gt;이름이 중복된 객체를 정의하는 태그&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;예:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;validation-config&amp;gt;
  &amp;lt;default-provider&amp;gt;&lt;strong&gt;foo.UnknownProvider&lt;/strong&gt;&amp;lt;/default-provider&amp;gt;  &amp;lt;!-- 클래스 또는 패키지 'UnknownProvider'를 해결할 수 없습니다  --&amp;gt;
  &amp;lt;message-interpolator&amp;gt;my.Interpolator&amp;lt;/message-interpolator&amp;gt;
  &amp;lt;constraint-mapping&amp;gt;META-INF/ConstraintMappings.xml&amp;lt;/constraint-mapping&amp;gt;
  &amp;lt;constraint-mapping&amp;gt;META-INF/&lt;strong&gt;unknown.xml&lt;/strong&gt;&amp;lt;/constraint-mapping&amp;gt;
&amp;lt;/validation-config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: BvConfigDomInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MinMaxValuesInspection" defaultSeverity="WARNING" displayName="Bean Validation 어노테이션 내 잘못된 'min' 및 'max' 값" enabled="false" language="JAVA" pluginId="com.intellij.beanValidation" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Bean Validation 제약 어노테이션 내 잘못된 &lt;code&gt;max&lt;/code&gt; 및 &lt;code&gt;min&lt;/code&gt; 값을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Car {
  @NotNull
  @Size(min = 14, max = &lt;strong&gt;2&lt;/strong&gt;) // 'max' 값이 'min' 값보다 작습니다
  private String licensePlate;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MinMaxValuesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BvConstraintMappingsInspection" defaultSeverity="ERROR" displayName="Bean Validation &lt;constraint-mappings&gt; 파일 내 잘못된 요소" enabled="false" language="XML" pluginId="com.intellij.beanValidation" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Bean Validation &lt;code&gt;&amp;lt;constraint-mappings&amp;gt;&lt;/code&gt; 파일 내 잘못된 요소를 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인스턴스화할 수 없는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;필요한 클래스를 확장하지 않는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;부적절한 범위를 가진 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;빈 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 패턴(예: Java 식별자)과 일치하지 않는 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 하위 태그 또는 속성을 포함하지 않는 태그&lt;/li&gt;
  &lt;li&gt;이름이 중복된 객체를 정의하는 태그&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;예:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;constraint-mappings version="1.1"&amp;gt;
    &amp;lt;bean class="my.UserClass" ignore-annotations="false"&amp;gt;
        &amp;lt;field name="name"&amp;gt;
            &amp;lt;constraint annotation="&lt;strong&gt;java.lang.String&lt;/strong&gt;"/&amp;gt;  &amp;lt;!--'java.lang.String'은 Java 어노테이션이 아닙니다 --&amp;gt;
        &amp;lt;/field&amp;gt;

        &amp;lt;field name="name"&amp;gt;
            &amp;lt;constraint annotation="javax.validation.constraints.Size"&amp;gt;
                &amp;lt;element name="min"&amp;gt;&lt;strong&gt;non-number&lt;/strong&gt;&amp;lt;/element&amp;gt;    &amp;lt;!--숫자 범위가 '-2,147,483,648' ~ '2,147,483,647'여야 합니다 --&amp;gt;
            &amp;lt;/constraint&amp;gt;
        &amp;lt;/field&amp;gt;

        &amp;lt;getter name="&lt;strong&gt;zzz&lt;/strong&gt;"&amp;gt; &amp;lt;!--심볼 'zzz'를 해결할 수 없습니다 --&amp;gt;
            &amp;lt;valid/&amp;gt;
        &amp;lt;/getter&amp;gt;

    &amp;lt;/bean&amp;gt;
&amp;lt;/constraint-mappings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: BvConstraintMappingsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Screen sizes" path="Android/Lint"><inspection shortName="LocaleText" defaultSeverity="WARNING" displayName="Locale text" enabled="false" language="" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
로케일이 달라지면 다르게 동작하는 텍스트가 있는 레이아웃을 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LocaleText&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BottomNav" defaultSeverity="WARNING" displayName="Bottom nav" enabled="false" language="" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
BottomNavigationView가 600dp보다 넓은 레이아웃을 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: BottomNav&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ButtonSize" defaultSeverity="WARNING" displayName="Button size" enabled="false" language="" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
버튼이 권장된 320dp보다 더 넓은 레이아웃을 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ButtonSize&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Overlap" defaultSeverity="WARNING" displayName="Overlap" enabled="false" language="" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
다른 형제 뷰가 뷰의 50% 이상을 차지하고 있는 레이아웃을 탐지합니다.
텍스트 뷰가 다른 뷰에 의해 잘못 덮여 있을 가능성이 크기 때문에 이 분석은 텍스트 뷰가 덮여 있는 경우로 제한됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Overlap&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TextFieldSize" defaultSeverity="WARNING" displayName="Text field size" enabled="false" language="" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
텍스트 필드가 권장된 488dp보다 더 넓은 레이아웃을 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TextFieldSize&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WearMargin" defaultSeverity="WARNING" displayName="Wear margins" enabled="false" language="" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
뷰가 Wear OS 기기의 측면과 너무 가까운 레이아웃을 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: WearMargin&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AccessibilityTestFramework" defaultSeverity="WARNING" displayName="Accessibility" enabled="false" language="" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
접근성 문제가 있는 레이아웃을 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AccessibilityTestFramework&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BottomAppBar" defaultSeverity="WARNING" displayName="Bottom app bar" enabled="false" language="" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
BottomAppBar가 콤팩트하지 않은 화면에서 사용되는 레이아웃을 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: BottomAppBar&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Bounds" defaultSeverity="WARNING" displayName="Bounds" enabled="false" language="" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
하위 뷰가 상위 요소의 바운드 내에 완전히 포함되지 않은 레이아웃을 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Bounds&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LongText" defaultSeverity="WARNING" displayName="Long text" enabled="false" language="" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
텍스트 한 줄이 120자를 초과한 레이아웃을 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LongText&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="로그 관련" path="Java"><inspection shortName="StringConcatenationArgumentToLogCall" defaultSeverity="WEAK WARNING" displayName="로깅 호출에 대한 인수로서의 비상수 문자열 연결" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;b&gt;SLF4J&lt;/b&gt; 및 &lt;b&gt;Log4j 2&lt;/b&gt; 로그 메서드에 대한 인수로 사용되는 비상수 문자열 연결을 보고합니다.
비상수 연결은 로깅 메시지가 기록되지 않는 경우에도 런타임에 평가됩니다. 이 과정은 성능에 부정적인 영향을 줍니다.
대신에 매개변수화된 로그 메시지를 사용하는 것이 좋습니다. 이 메시지는 로깅이 비활성화되면 평가되지 않습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Vital {
    &lt;b&gt;private static final&lt;/b&gt; Logger LOG = LoggerFactory.getLogger(Vital.class);

    &lt;b&gt;public void&lt;/b&gt; saveTheWorld(&lt;b&gt;int&lt;/b&gt; i, String s, &lt;b&gt;boolean&lt;/b&gt; b) {
      LOG.info("saveTheWorld(" + i + ", " + s + ", "  + b + ")");
      // todo
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Vital {
    &lt;b&gt;private static final&lt;/b&gt; Logger LOG = LoggerFactory.getLogger(Vital.class);

    &lt;b&gt;public void&lt;/b&gt; saveTheWorld(&lt;b&gt;int&lt;/b&gt; i, String s, &lt;b&gt;boolean&lt;/b&gt; b) {
      LOG.info("saveTheWorld({}, {}, {})", i, s, b);
      // 작업 수행
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 구성:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;b&gt;경고 대상&lt;/b&gt; 목록을 사용하여 특정한 상위 로깅 수준을 무시합니다. 상위 로깅 수준은 프로덕션 과정에서도 활성화할 수 있으며, 인수는 항상 평가됩니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringConcatenationArgumentToLogCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithoutLogger" defaultSeverity="WARNING" displayName="로거가 없는 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
선언된 로거가 없는 클래스를 보고합니다.
&lt;p&gt;각 클래스에 하나의 전용 로거를 포함시키는 것은 애플리케이션에 대한 통합 로깅 구현을 제공하는 데 중요한 단계입니다. 이 검사는 인터페이스, 열거형, 어노테이션, 내부 클래스 및 추상 클래스를 보고하지 않습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; NoLoggerDeclared {

    &lt;b&gt;int&lt;/b&gt; calculateNthDigitOfPi(&lt;b&gt;int&lt;/b&gt; n) {
      // todo
      &lt;b&gt;return&lt;/b&gt; 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;옵션&lt;/b&gt; 섹션의 테이블을 사용하여 로거 클래스 이름을 지정합니다.
지정된 클래스 중 하나의 타입을 가진 필드를 선언하지 않는 클래스는 이 검사에서 보고됩니다.

&lt;p&gt;&lt;small&gt;Inspection ID: ClassWithoutLogger&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonStaticFinalLogger" defaultSeverity="WARNING" displayName="비상수 로거" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;static&lt;/code&gt; 및/또는 &lt;code&gt;final&lt;/code&gt;로 선언되지 않은 로거 필드를 보고합니다.
각 클래스 로거가 사실상 상수이고 해당 클래스에 바운딩되도록 하면 애플리케이션에 대한 통합 로깅 구현을 제공하는 작업을 단순화할 수 있습니다.
&lt;p&gt;로거 제어자를 &lt;code&gt;static final&lt;/code&gt;로 변경하기 위한 빠른 수정이 제공됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Significant {
    &lt;b&gt;private&lt;/b&gt; Logger LOG = Logger.getLogger(Critical.class);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Significant {
    &lt;b&gt;private static final&lt;/b&gt; Logger LOG = Logger.getLogger(Critical.class);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 구성:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;로거 클래스 이름&lt;/b&gt; 필드를 사용하여, 로거 클래스 이름을 지정합니다. 이 검사는 &lt;code&gt;static&lt;/code&gt; 및 &lt;code&gt;final&lt;/code&gt;이 아니고, 지정된 클래스 이름 중 하나와 같은 타입인 필드를 보고합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonStaticFinalLogger&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoggerInitializedWithForeignClass" defaultSeverity="WEAK WARNING" displayName="로거가 외부 클래스로 초기화됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Logger&lt;/code&gt;가 포함되어 있는 클래스와 다른 클래스의 &lt;code&gt;class&lt;/code&gt; 리터럴로 초기화된 &lt;code&gt;Logger&lt;/code&gt; 인스턴스를 보고합니다. 이는 다른 클래스의 일부 코드를 복사하여 붙여넣을 때 쉽게 발생할 수 있으며, 이벤트가 예기치 않은 카테고리에 기록되고 필터가 잘못 적용될 수 있습니다.
&lt;p&gt;외부 클래스 리터럴을 주변 클래스 리터럴 중 하나로 대체하는 빠른 수정이 제공됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Paramount {
    &lt;b&gt;protected static final&lt;/b&gt; Logger LOG = Logger.getLogger(Critical.class);

    // ... 기타 필드 및 메서드
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Paramount {
    &lt;b&gt;protected static final&lt;/b&gt; Logger LOG = Logger.getLogger(Paramount.class);

    // ... 기타 필드 및 메서드
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 구성:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이 테이블을 사용하여 이 검사에 의해 인식되는 로거 factory 클래스 및 로거 factory 메서드를 지정합니다.&lt;/li&gt;
  &lt;li&gt;로거를 포함하는 클래스의 상위 클래스로 초기화된 로거를 무시하려면 &lt;b&gt;상위 클래스로 초기화된 로거 무시&lt;/b&gt; 옵션을 사용하세요.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;public&lt;/code&gt; 클래스 내 로거에 대해서만 경고하려면 &lt;b&gt;public이 아닌 클래스 내 로거 무시&lt;/b&gt;를 사용하세요.&lt;/li&gt;
  &lt;li&gt;final 필드에서 초기화된 로거만 보고하려는 경우 &lt;b&gt;final 필드에서 초기화되지 않은 로거는 무시&lt;/b&gt;를 사용하세요. 다른 케이스는 무시됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LoggerInitializedWithForeignClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicMethodWithoutLogging" defaultSeverity="WARNING" displayName="로깅 없는 'public' 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
로깅 구문을 포함하지 않는 모든 public 메서드를 보고합니다. 이 검사는 단순한 getter 및 setter를 보고하지 않습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Crucial {
    &lt;b&gt;private static final &lt;/b&gt;Logger LOG = LoggerFactory.getLogger(Crucial.class);
    &lt;b&gt;public void&lt;/b&gt; doImportantStuff() {
      // 이 메서드에 대해 경고
    }

    &lt;b&gt;public void&lt;/b&gt; doOtherStuff() {
      LOG.info("do other stuff");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
아래 테이블을 사용하여 Logger 클래스 이름을 지정하세요.
이 검사는 특정한 클래스의 인스턴스 메서드를 사용하지 않는 public 메서드를 보고합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: PublicMethodWithoutLogging&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithMultipleLoggers" defaultSeverity="WARNING" displayName="여러 로거가 있는 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
여러 개의 로거가 선언된 클래스를 보고합니다.
각 클래스에 하나의 전용 로거를 포함시키는 것은 애플리케이션에 통합 로깅 구현을 제공하는 데 중요한 단계입니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Critical {
    &lt;b&gt;protected static final&lt;/b&gt; Logger LOG = Logger.getLogger(Critical.class);

    &lt;b&gt;protected static final&lt;/b&gt; Logger myLogger = Logger.getLogger(getClass());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
아래 테이블을 사용하여 Logger 클래스 이름을 지정하세요.
지정된 클래스 중 하나의 타입을 가진 여러 필드를 선언하는 클래스는 이 검사에서 보고됩니다.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ClassWithMultipleLoggers&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="코드 구문이 혼동될 수 있습니다." path="Groovy"><inspection shortName="ClashingTraitMethods" defaultSeverity="WARNING" displayName="특성 메서드 충돌" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
시그니처가 같은 메서드를 포함하는 특성을 두 개 이상 구현하는 클래스를 보고합니다.
&lt;p&gt;그러한 메서드를 호출하면 예상하지 못한 결과가 나올 수 있습니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 명시적인 재정의 메서드를 추가합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait T1 {
      def foo() {}
  }

  trait T2 {
      def foo() {}
  }

  class X implements T1, T2 {}

  // T2.foo()가 호출됩니다
  new X().foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X implements T1, T2 {
      @Override
      Object foo() {
          return T2.super.foo()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ClashingTraitMethods&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOctalInteger" defaultSeverity="WARNING" displayName="8진 정수" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
8진수 정수 리터럴을 보고합니다.
&lt;p&gt;
  일부 코딩 표준에서는 10진수 리터럴과 혼동될 수 있으므로 8진수 리터럴의 사용을 금지합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyOctalInteger&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNestedConditional" defaultSeverity="WARNING" displayName="중첩된 조건식" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 조건식 내부에 중첩된 조건 삼항식을 보고합니다.
그러한 중첩된 조건식은 매우 혼동될 수 있습니다. 이 검사에서는 'Elvis' 표현식을 조건식으로 간주합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
return (condition ? "result" : null) ?: "fail"
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyNestedConditional&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryQualifiedReference" defaultSeverity="WARNING" displayName="불필요한 정규화된 참조" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;import 문으로 바꿀 수 있는 정규화된 참조를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def swingBuilder = new groovy.swing.SwingBuilder()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import groovy.swing.SwingBuilder
 
  def swingBuilder = new SwingBuilder()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryQualifiedReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOverlyComplexBooleanExpression" defaultSeverity="WARNING" displayName="지나치게 복잡한 부울 표현식" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
항이 너무 많은 bool 표현식을 보고합니다.
&lt;p&gt;
  그러한 표현식은 혼동을 일으키고 버그가 발생하기 쉽습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 &lt;b&gt;최대 항 수&lt;/b&gt; 필드를 사용하여 bool 표현식에 허용되는 항의 최대 개수를 지정하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyOverlyComplexBooleanExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNegatedConditional" defaultSeverity="WARNING" displayName="부정된 조건식" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
조건이 부정된 조건식을 보고합니다.
조건식 브랜치의 순서를 반전시키면 보통 해당 구문의 명확도가 높아집니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
~condition ? "1" : "2"
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyNegatedConditional&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOverlyComplexArithmeticExpression" defaultSeverity="WARNING" displayName="지나치게 복잡한 산술 표현식" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
항이 너무 많은 산술 표현식을 보고합니다.
&lt;p&gt;
  그러한 표현식은 혼동을 일으키고 버그가 발생하기 쉽습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 &lt;b&gt;최대 항 수&lt;/b&gt; 필드를 사용하여 산술 표현식에 허용되는 항의 최대 개수를 지정하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyOverlyComplexArithmeticExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDoubleNegation" defaultSeverity="WARNING" displayName="이중 부정" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단순화할 수 있는 이중 부정을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (!!functionCall()) {} // 이중 부정
if (!(a != b)) {} // 이중 부정
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (functionCall()) {}
if (a == b) {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyDoubleNegation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GroovyPointlessArithmetic" defaultSeverity="WARNING" displayName="무의미한 산술 표현식" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
무의미한 산술 표현식을 보고합니다.
&lt;p&gt;
  그러한 표현식에는 0 더하기 또는 빼기, 0 또는 1로 곱하기, 1로 나누기 및 0으로 시프트 연산이 포함됩니다. 그러한 표현식은 코드 완성이 수반되지 않은 자동화된 리팩터링의 결과일 수 있으며 개발자가 의도한 결과가 아닐 확률이 높습니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a + 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyPointlessArithmetic&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyImplicitNullArgumentCall" defaultSeverity="WEAK WARNING" displayName="묵시적 null 인수" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
매개변수가 하나만 있는 메서드에 대해 인수 없이 수행된 호출을 보고합니다.
이는 &lt;code&gt;null&lt;/code&gt;로 호출하는 것과 같으며 그러한 동작은 종종 혼란스럽고 의도하지 않았을 것입니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def foo(String s){}
foo() // 이 호출은 사실 'foo(null)' 호출입니다
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyImplicitNullArgumentCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrPackage" defaultSeverity="WARNING" displayName="패키지 불일치" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
필요한 패키지와 일치하지 않는 선언된 패키지가 있는 파일을 보고합니다. 또한 클래스가 소스 루트 디렉터리에 바로 있지 않은 경우 &lt;code&gt;package&lt;/code&gt; 문이 없는 파일을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrPackage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyPointlessBoolean" defaultSeverity="WARNING" displayName="무의미한 부울 표현식" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
의미가 없거나 쓸데없이 복잡한 bool 표현식을 보고합니다.
&lt;p&gt;
  이러한 표현식에는 true 연결 연산, false 분리 연산, 부울 리터럴을 이용한 상등 비교 또는 부울 리터럴의 부정이 포함됩니다. 그러한 표현식은 코드 완성이 수반되지 않은 자동화된 리팩터링의 결과일 수 있으며 개발자가 의도한 결과가 아닐 확률이 높습니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (someBool &amp;&amp; true) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (someBool) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyPointlessBoolean&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNegatedIf" defaultSeverity="WARNING" displayName="부정된 if 조건식" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
조건이 부정된 &lt;code&gt;else&lt;/code&gt; 브랜치를 포함하는 &lt;code&gt;if&lt;/code&gt; 문을 보고합니다.
&lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 브랜치의 순서를 반전시키면 보통 그러한 구문의 명확도가 높아집니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (!condition) {
  return "1"
} else {
  return "2"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyNegatedIf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrReassignedInClosureLocalVar" defaultSeverity="WARNING" displayName="지역 변수가 클로저 또는 익명 클래스에 다시 대입됨" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클로저 또는 익명 클래스 내부에서 타입이 다른 표현식에 대입된 지역 변수를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int sum = 0
  [1, 2, 3].each { sum += 'as' }
  println(sum)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;결과적으로 &lt;code&gt;integer&lt;/code&gt; 변수 &lt;b&gt;sum&lt;/b&gt;이 &lt;code&gt;String&lt;/code&gt; 식으로 재대입됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrReassignedInClosureLocalVar&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrDeprecatedAPIUsage" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 API 사용" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지원 중단된 클래스, 필드 및 메서드에 대한 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrDeprecatedAPIUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyEmptyStatementBody" defaultSeverity="WARNING" displayName="본문이 비어 있는 구문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 빈 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt; 또는 &lt;code&gt;for&lt;/code&gt; 문을 보고합니다. 의도된 경우도 있으나 이러한 생성은 혼동될 수 있으며 보통 오타가 난 결과입니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (condition) {}
while(true){}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyEmptyStatementBody&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNestedSwitch" defaultSeverity="WARNING" displayName="부정된 switch 문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 &lt;code&gt;switch&lt;/code&gt; 문 내부에 중첩된 &lt;code&gt;switch&lt;/code&gt; 문을 보고합니다.
그렇게 중첩된 switch 문은 혼란스러우며 예상치 못한 동작을 초래할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
switch (outer) {
  case 1:
    switch (inner) {
      case 1:
        print "inner 1"
        break
      default:
        print "inner default"
    }
    break
  default:
    print "default"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyNestedSwitch&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GroovyGStringKey" defaultSeverity="WARNING" displayName="GString 맵 키" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;groovy.lang.GString&lt;/code&gt; 객체를 키 또는 맵으로 사용하는 구문을 보고합니다.
일반적으로 &lt;code&gt;GString&lt;/code&gt; 객체는 변경 가능하므로 키로 사용해서는 안 될 가능성이 높습니다.
또한 &lt;code&gt;GString&lt;/code&gt; 항목은 같은 값을 가지고 있는 &lt;code&gt;java.lang.String&lt;/code&gt; 객체를 사용해 액세스할 수 없습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = [:]
def key = 'foo'
map &amp;lt&amp;lt ["${key}": 'bar']
assert map[key] == null // 혼동되기 쉬운 비교의 'true' 결과
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyGStringKey&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NewInstanceOfSingleton" defaultSeverity="WARNING" displayName="@groovy.lang.Singleton 어노테이션이 추가된 클래스의 새 인스턴스" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;@groovy.lang.Singleton&lt;/code&gt; 어노테이션이 추가된 클래스의 새 인스턴스 생성을 보고합니다.
  그러한 구문은 &lt;b&gt;싱글턴을 초기화할 수 없습니다&lt;/b&gt;라는 런타임 예외를 발생시킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton
  class Foo{
  }
  
  Foo foo = &lt;b&gt;new Foo()&lt;/b&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton
  class Foo{
  }
  
  Foo foo = &lt;b&gt;Foo.instance&lt;/b&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NewInstanceOfSingleton&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ClashingGetters" defaultSeverity="WARNING" displayName="getter 충돌" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
같은 프로퍼티 이름으로 액세스할 수 있는 bool 메서드를 보고합니다.
&lt;p&gt;그러한 프로퍼티에 액세스하면 예상하지 못한 결과가 나올 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
      boolean isFoo() { true }
      boolean getFoo() { false }
  }

  // getFoo()가 호출됩니다
  new X().foo
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ClashingGetters&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyResultOfIncrementOrDecrementUsed" defaultSeverity="WARNING" displayName="사용된 증분 또는 감소의 결과" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 표현식 내에서 중첩된 증분 또는 감소 표현식을 보고합니다.
&lt;p&gt;
  그러한 표현식은 혼란을 일으킬 수 있으며 지정된 구문은 정확히 한 가지 동작을 수행해야 한다는 일반적인 설계 규칙을 위반합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyResultOfIncrementOrDecrementUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="성능" path="Java"><inspection shortName="ObjectAllocationInLoop" defaultSeverity="WARNING" displayName="루프 내 객체 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루프 내의 객체 또는 배열 할당을 보고합니다. 반드시 문제가 되는 것은 아니지만, 루프 내의 객체 할당은 메모리 누수 및 성능 문제를 찾기에 좋은 위치입니다.
&lt;p&gt;
  이 검사는 다음과 같은 구문을 보고합니다.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;new&lt;/code&gt; 연산자를 통한 명시적 할당&lt;/li&gt;
  &lt;li&gt;새로운 객체를 반환하는 것으로 알려진 메서드&lt;/li&gt;
  &lt;li&gt;인스턴스 바운드된 메서드 참조&lt;/li&gt;
  &lt;li&gt;변수 또는 &lt;code&gt;this&lt;/code&gt; 참조를 캡처하는 람다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 명시적 할당
  for (Status status : Status.values()) {
    declarationsMap.put(status, new ArrayList&amp;lt;&amp;gt;());
  }

  // 람다가 변수를 캡처합니다
  String message = "Engine running.";
  for (Engine engine : engines) {
      if (!isRunning(engine)) {
          logger.warn(() -&gt; {
              return String.format(message);
          });
      }
  }

  // 인스턴스 바운드된 메서드 참조
  for(Node node : nodes) {
    descriptor = node.getDescription();
    descriptor.ifPresent(dynamicTestExecutor::execute);
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ObjectAllocationInLoop&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BoxingBoxedValue" defaultSeverity="WARNING" displayName="이미 박싱된 값을 박싱" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이미 박싱된 값을 박싱한 경우 보고합니다.
&lt;p&gt;
  박싱된 값은 해당 값을 다시 박싱하기 전 먼저 자동으로 언박싱되므로 이는 불필요한 작업입니다. 내부 루프에서 수행될 경우, 이러한 코드는 성능 문제를 초래할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer value = 1;
  method(Integer.valueOf(value));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer value = 1;
  method(value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BoxingBoxedValue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectEqualsCanBeEquality" defaultSeverity="INFORMATION" displayName="'equals()' 호출을 '=='로 바꾸기 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
의미를 변경하지 않고 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 표현식으로 바꿀 수 있는 &lt;code&gt;equals()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;이러한 호출은 자체 &lt;code&gt;equals()&lt;/code&gt; 구현을 포함하지 않지만 디폴트 &lt;code&gt;Object.equals()&lt;/code&gt;를 사용하는 &lt;code&gt;final&lt;/code&gt; 클래스를 비교하기 위해 사용되는 경우 바꿀 수 있습니다.
이러한 교체는 성능을 향상시킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;enum&lt;/code&gt; 값에서의 &lt;code&gt;equals()&lt;/code&gt; 호출(Enum 값에서 호출된 'equals()')에 대한 별도의 검사가 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;!--&lt;p&gt;&lt;small&gt;New in 2017.3&lt;/small&gt;--&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ObjectEqualsCanBeEquality&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassInitializerMayBeStatic" defaultSeverity="WARNING" displayName="인스턴스 이니셜라이저를 'static'으로 설정할 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
오류 없이 &lt;code&gt;static&lt;/code&gt;으로 만들 수 있는 인스턴스 이니셜라이저를 보고합니다.
&lt;p&gt;
  인스턴스 이니셜라이저가 클래스의 static이 아닌 멤버를 참조하지 않는 경우 static일 수 있습니다.
  static 이니셜라이저는 클래스가 확인되면 실행되며 인스턴스 이니셜라이저는 클래스가 인스턴스화될 때마다 실행됩니다.&lt;/p&gt;
&lt;p&gt;이 검사는 인스턴스가 비어 있는 이니셜라이저와 익명 클래스의 이니셜라이저를 보고하지 않습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
     public static String CONSTANT;
     {
        CONSTANT = "Hello";
     }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
     public static String CONSTANT;
     static {
        CONSTANT = "Hello"; // 클래스당 1회만 초기화됩니다
     }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassInitializerMayBeStatic&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LengthOneStringInIndexOf" defaultSeverity="WARNING" displayName="'String.indexOf()' 호출의 단일 문자열 인수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;String.indexOf()&lt;/code&gt; 및 &lt;code&gt;String.lastIndexOf()&lt;/code&gt; 호출에서 인수로 사용되고 있는 단일 문자열을 보고합니다.
&lt;p&gt;이러한 문자열 리터럴을 동등한 문자 리터럴로 대체하고 성능을 개선하는 빠른 수정을 사용하는 것이 좋습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return s.indexOf("x");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return s.indexOf('x');
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LengthOneStringInIndexOf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryTemporaryOnConversionToString" defaultSeverity="WARNING" displayName="'String'으로 변환 시 불필요한 임시 객체" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
기본 타입에서 &lt;code&gt;String&lt;/code&gt;으로 변환할 경우 임시 객체의 불필요한 생성을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String foo = new Integer(3).toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String foo = Integer.toString(3);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryTemporaryOnConversionToString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DynamicRegexReplaceableByCompiledPattern" defaultSeverity="WARNING" displayName="동적 정규식을 컴파일링된 'Pattern'으로 대체 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상수 인수를 사용하는 &lt;code&gt;java.lang.String&lt;/code&gt;의 정규 표현식 메서드(예: &lt;code&gt;matches()&lt;/code&gt; 또는 &lt;code&gt;split()&lt;/code&gt;) 호출을 보고합니다.
&lt;p&gt;
  정규 표현식을 사용할 때마다 컴파일할 필요가 없도록 이러한 호출은 &lt;code&gt;private static final Pattern&lt;/code&gt; 필드로
  유리하게 대체할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  text.replaceAll("abc", replacement);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private static final Pattern ABC = Pattern.compile("abc", Pattern.LITERAL);
  ABC.matcher(text).replaceAll(Matcher.quoteReplacement(replacement));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DynamicRegexReplaceableByCompiledPattern&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AutoUnboxing" defaultSeverity="WARNING" displayName="자동 언박싱" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
언박싱 변환(원시 값으로 객체 자동 래핑 해제)의 영향을 받는 표현식을 보고합니다.
원시 타입이 아닌 객체를 사용하지 않도록 하세요. 이는 성능에 상당한 영향을 미칠 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int x = new Integer(42);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 변환을 명시적으로 만듭니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int x = new Integer(42).intValue();&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;AutoUnboxing&lt;/i&gt;은 Java 5에 등장했습니다.
  이 검사는 이전 Java 버전과의 하위 호환성을 위해 다운그레이드하는 데 도움이 될 수 있습니다.
&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: AutoUnboxing&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ManualArrayToCollectionCopy" defaultSeverity="WARNING" displayName="수동 배열에서 컬렉션으로 복사" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루프를 사용하여 배열의 내용을 컬렉션으로 복사하는 코드를 보고합니다.
&lt;p&gt;
  이 작업을 더 간편하고 빠르게(컬렉션 구현에 따라 다름) 수행하려면 &lt;code&gt;Collection.addAll(Arrays.asList())&lt;/code&gt; 또는 &lt;code&gt;Collections.addAll()&lt;/code&gt;을 사용하면 됩니다.
&lt;/p&gt;
&lt;p&gt;
&lt;p&gt;내부에 추가 구문이 없는 루프만 보고됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void addAll(List&amp;lt;String&amp;gt; list, String[] arr) {
    for (int i = 0; i &amp;lt; arr.length; i++) {
      String s = arr[i];
      list.add(s);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void addAll(List&amp;lt;String&amp;gt; list, String[] arr) {
    Collections.addAll(list, arr);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ManualArrayToCollectionCopy&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ListRemoveInLoop" defaultSeverity="WARNING" displayName="루프에서 'List.remove()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;List.subList().clear()&lt;/code&gt;로 대체 가능하며 루프에서 호출된 &lt;code&gt;List.remove(index)&lt;/code&gt;를 보고합니다.
&lt;p&gt;대부분 &lt;code&gt;List&lt;/code&gt; 구현은 많은 요소가 삭제될 경우 대체하는 편이 한층 효율적입니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void removeRange(List&amp;lt;String&amp;gt; list, int from, int to) {
    for (int i = from; i &amp;lt; to; i++) {
        list.remove(from);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void removeRange(List&amp;lt;String&amp;gt; list, int from, int to) {
    if (to &amp;gt; from) {
      list.subList(from, to).clear();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  빠른 수정은 최솟값이 최댓값보다 클 경우 가능한 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;을 방지하기 위해 범위 검사를 자동으로 추가합니다. 코드에서 이러한 경우가 불가능하면 검사를 제거할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ListRemoveInLoop&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MapReplaceableByEnumMap" defaultSeverity="WARNING" displayName="'Map'을 'EnumMap'으로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
키 타입이 열거형 클래스인 &lt;code&gt;java.util.Map&lt;/code&gt; 객체의 인스턴스화를 보고합니다. 이러한 &lt;code&gt;java.util.Map&lt;/code&gt; 객체는 &lt;code&gt;java.util.EnumMap&lt;/code&gt; 객체로 대체될 수 있습니다.
&lt;p&gt;
  기본 데이터 구조가 단순한 배열이기 때문에 &lt;code&gt;java.util.EnumMap&lt;/code&gt; 구현이 훨씬 더 효율적일 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Map&amp;lt;MyEnum, String&amp;gt; myEnums = new HashMap&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Map&amp;lt;MyEnum, String&amp;gt; myEnums = new EnumMap&amp;lt;&amp;gt;(MyEnum.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MapReplaceableByEnumMap&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExplicitArgumentCanBeLambda" defaultSeverity="INFORMATION" displayName="명시적 인수를 람다로 만들 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
자명하지 않은 표현식을 허용하고, 람다가 대신 허용되는 동등한 메서드 호출로 대체 가능한 메서드 호출을 보고합니다.
&lt;p&gt;
표현식을 람다로 변환하면 메서드에서 해당 표현식이 사용되지 않을 경우 표현식을 평가하지 않습니다. 예를 들어 &lt;code&gt;optional.orElse(createDefaultValue())&lt;/code&gt;를 &lt;code&gt;optional.orElseGet(this::createDefaultValue)&lt;/code&gt;로 변환할 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;람다 식&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ExplicitArgumentCanBeLambda&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CollectionAddAllCanBeReplacedWithConstructor" defaultSeverity="WARNING" displayName="불필요한 'Collection.addAll()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인수가 없는 생성자를 사용하여 컬렉션을 인스턴스화한 직후 실행되는 &lt;code&gt;Collection.addAll()&lt;/code&gt; 및 &lt;code&gt;Map.putAll()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;이러한 구문은 매개변수화된 생성자에 대한 단일 호출로 바꿀 수 있으며, 이렇게 하면 코드가 간소화됩니다. 또한 일부 대체 컬렉션은
  보다 잘 작동할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
  set.addAll(Arrays.asList("alpha", "beta", "gamma"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(Arrays.asList("alpha", "beta", "gamma"));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  기본적으로 JDK 컬렉션 클래스가 지원됩니다.
  &lt;b&gt;체크할 클래스&lt;/b&gt; 패널에서 추가적으로 다른 클래스를 지정할 수 있습니다.
&lt;p&gt;&lt;small&gt;Inspection ID: CollectionAddAllCanBeReplacedWithConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseBulkOperation" defaultSeverity="WARNING" displayName="반복 대신 대량 연산을 사용할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
일괄 메서드로 대체 가능한 루프 내 단일 연산을 보고합니다.
&lt;p&gt;
  대량 메서드는 길이가 짧을 뿐 아니라 성능 면에서 더 뛰어난 경우도 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void test(Collection&amp;lt;Integer&amp;gt; numbers) {
    List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&gt;();
    for (Integer i : numbers) {
      result.add(i);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Collection&amp;lt;Integer&amp;gt; numbers) {
    List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&gt;();
    result.addAll(numbers);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;Use Arrays.asList() to wrap arrays(Arrays.asList()를 사용해 배열 래핑)&lt;/b&gt; 옵션을 사용하면 대량 메서드에 컬렉션이 필요한 경우에도 배열을 보고할 수 있습니다.
  이 경우 빠른 수정이 &lt;code&gt;Arrays.asList()&lt;/code&gt; 호출의 배열을 자동으로 줄 바꿈합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UseBulkOperation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SetReplaceableByEnumSet" defaultSeverity="WARNING" displayName="'Set'을 'EnumSet'으로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
내용의 타입이 열거형 클래스인 &lt;code&gt;java.util.Set&lt;/code&gt; 객체의 인스턴스화를 보고합니다. &lt;code&gt;Set&lt;/code&gt; 객체는 &lt;code&gt;java.util.EnumSet&lt;/code&gt; 객체로 바꿀 수 있습니다.
&lt;p&gt;
  &lt;code&gt;EnumSet&lt;/code&gt; 구현은 기본 데이터 구조가 비트 벡터이므로 다른 조합과 비교 시 더욱 효과적일 수 있습니다. 빠른 수정을 사용하여 이니셜라이저를 &lt;code&gt;EnumSet.noneOf()&lt;/code&gt; 호출로 바꿉니다. 이 빠른 수정은 변수 타입이 &lt;code&gt;Set&lt;/code&gt;의 하위 클래스인 경우에는 사용할 수 없습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum MyEnum { FOO, BAR; }

  Set&amp;lt;MyEnum&amp;gt; enums = new HashSet&amp;lt;MyEnum&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum MyEnum { FOO, BAR; }

  Set&amp;lt;MyEnum&amp;gt; enums = EnumSet.noneOf(MyEnum.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SetReplaceableByEnumSet&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantStringFormatCall" defaultSeverity="WARNING" displayName="'String.format()' 중복 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전하게 제거하거나 간소화할 수 있는 &lt;code&gt;format()&lt;/code&gt; 및 &lt;code&gt;printf()&lt;/code&gt; 등의 메서드 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(String.format("Total count: %d", 42));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.printf("Total count: %d%n", 42);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantStringFormatCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SlowListContainsAll" defaultSeverity="WARNING" displayName="'list.containsAll(collection)' 호출의 성능이 낮아질 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.List&lt;/code&gt;에서 &lt;code&gt;containsAll()&lt;/code&gt;에 대한 호출을 보고합니다.
&lt;p&gt;
  이 메서드 호출의 시간복잡도는 O(n&amp;middot;m)입니다. 여기서 n은 메서드가 호출되는 목록에 있는 요소의 개수이며, m은 메서드에 매개변수로 전달되는 컬렉션 내 요소의 개수입니다.
  목록이 클 때 이는 소모가 매우 큰 작업이 될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;java.util.List&lt;/code&gt;에서 &lt;code&gt;java.util.HashSet&lt;/code&gt;을 생성하고 &lt;code&gt;java.util.HashSet&lt;/code&gt; 에서 &lt;code&gt;containsAll()&lt;/code&gt;을 실행하는 데 필요한 시간이 O(n+m)이므로 빠른 수정에서는 목록을 &lt;code&gt;new java.util.HashSet&amp;lt;&amp;gt;()&lt;/code&gt;으로 래핑합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public boolean check(List&amp;lt;String&amp;gt; list, Collection&amp;lt;String&amp;gt; collection) {
    // O(n&amp;middot;m) 복잡도
    return list.containsAll(collection);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public boolean check(List&amp;lt;String&amp;gt; list, Collection&amp;lt;String&amp;gt; collection) {
    // O(n+m) 복잡도
    return new HashSet&amp;lt;&amp;gt;(list).containsAll(collection);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SlowListContainsAll&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StringConcatenationInsideStringBufferAppend" defaultSeverity="WARNING" displayName="'StringBuilder.append()' 호출에 대한 인수로서의 문자열 연결" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;StringBuffer.append()&lt;/code&gt;,
&lt;code&gt;StringBuilder.append()&lt;/code&gt; 또는 &lt;code&gt;Appendable.append()&lt;/code&gt;의 인수로 사용된 &lt;code&gt;String&lt;/code&gt; 연결을 보고합니다.
&lt;p&gt;
  해당 호출은 기존 &lt;code&gt;StringBuffer/Builder/Appendable&lt;/code&gt;의 체인 append 호출로 유용하게 변환되어 &lt;code&gt;StringBuffer/Builder&lt;/code&gt; 할당의 추가  비용을 줄일 수 있습니다.
  이 검사는 컴파일 타임 평가된 &lt;code&gt;String&lt;/code&gt; 연결을 무시합니다. 이러한 연결에서는 변환으로 인해 성능이 악화될 뿐입니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void bar(StringBuilder builder, String name) {
    builder.append("Hello," + name);    //경고
    builder.append("Hello," + "world"); //경고 없음
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: StringConcatenationInsideStringBufferAppend&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringEqualsEmptyString" defaultSeverity="WARNING" displayName="'String.equals()'를 'String.isEmpty()'로 바꿀 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;String&lt;/code&gt;을 빈 문자열과 비교하여 호출하는 &lt;code&gt;equals()&lt;/code&gt;를 보고합니다.
이 경우 &lt;code&gt;.isEmpty()&lt;/code&gt;를 사용하면 확인할 대상이 명확하게 표시되기 때문에 더 좋습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void checkString(String s){
    if ("".equals(s)) throw new IllegalArgumentException();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void checkString(String s){
    if (s != null &amp;&amp; s.isEmpty()) throw new IllegalArgumentException();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;"".equals(str)&lt;/code&gt;는 &lt;code&gt;str&lt;/code&gt;이 null인 경우 false를 반환합니다. 검사의 빠른 수정에서는 안전을 위해 &lt;code&gt;equals()&lt;/code&gt; 인수가 null 가능한 경우 명시적인 null 확인을 삽입합니다. 옵션을 사용하여 검사 시 이러한 경우를 무시하도록 합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringEqualsEmptyString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringReplaceableByStringBuffer" defaultSeverity="WARNING" displayName="비상수 'String'을 StringBuilder로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
반복적으로 추가되는 &lt;code&gt;java.lang.String&lt;/code&gt;으로 선언된 변수를 보고합니다. 이러한 변수는 &lt;code&gt;java.lang.StringBuffer&lt;/code&gt; 또는 &lt;code&gt;java.lang.StringBuilder&lt;/code&gt;로 더욱 효율적으로 선언할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "";
  for (int i = 0; i &amp;lt; names.length; i++) {
    String name = names[i] + (i == names.length - 1 ? "" : " ");
    s = s + name;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이러한 루프는 다음으로 바꿀 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  StringBuilder s = new StringBuilder();
  for (int i = 0; i &amp;lt; names.length; i++) {
    String name = names[i] + (i == names.length - 1 ? "" : " ");
    s.append(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;또는 다음과 바꿀 수도 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = String.join(" ", names);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  옵션을 사용하여 이 검사를 통해 변수가 루프에서 추가될 때 보고할 수 있도록 합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringReplaceableByStringBuffer&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RandomDoubleForRandomInteger" defaultSeverity="WARNING" displayName="'Random.nextDouble()'을 사용하여 임의의 정수 얻기" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
호출에 인자 배수를 곱하고 정수형으로 변환하여 정수를 생성하기 위해 사용한 &lt;code&gt;java.util.Random.nextDouble()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  범위 내의 무작위 정수를 생성하기 위해 &lt;code&gt;java.util.Random.nextInt(int)&lt;/code&gt;를 사용하는 것이 더 간단하고 효율적입니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int getRandomInt() {
    return (int) ((new Random()).nextDouble() * SIZE);
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int getRandomInt() {
    return (new Random()).nextInt(SIZE);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: RandomDoubleForRandomInteger&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SlowAbstractSetRemoveAll" defaultSeverity="WARNING" displayName="'set.removeAll(list)' 호출은 느리게 작동할 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.List&lt;/code&gt; 인수가 있는 &lt;code&gt;java.util.Set.removeAll()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  인수의 크기가 세트의 크기 이상이며 세트가 &lt;code&gt;java.util.AbstractSet&lt;/code&gt;의 하위 클래스인 경우 해당 호출의 속도가 저하될 수 있습니다.
  이 경우 &lt;code&gt;List.contains()&lt;/code&gt;가 세트의 각 요소에 대해 호출되며, 선형 검색이 수행됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void check(String... ss) {
    // possible O(n^2) complexity
    mySet.removeAll(List.of(ss));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void check(String... ss) {
    // O(n) complexity
    List.of(ss).forEach(mySet::remove);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SlowAbstractSetRemoveAll&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ArraysAsListWithZeroOrOneArgument" defaultSeverity="WARNING" displayName="인수가 너무 적은 'Arrays.asList()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
최대 1개의 인수가 있는 &lt;code&gt;Arrays.asList()&lt;/code&gt;에 대한 호출을 보고합니다.
&lt;p&gt;
  JDK 9 이상 버전에서 해당 호출을 &lt;code&gt;Collections.singletonList()&lt;/code&gt;, &lt;code&gt;Collections.emptyList()&lt;/code&gt; 또는 &lt;code&gt;List.of()&lt;/code&gt;로 대체하여 메모리를 아낄 수 있습니다.&lt;/p&gt;
&lt;p&gt;특히 인수가 없는 &lt;code&gt;Collections.emptyList()&lt;/code&gt; 및 &lt;code&gt;List.of()&lt;/code&gt;는 항상 공유 인스턴스를 반환합니다. 반면 인수가 없는 &lt;code&gt;Arrays.asList()&lt;/code&gt;가 호출되면 항상 새 객체를 생성합니다.&lt;/p&gt;
&lt;p&gt;참고: &lt;code&gt;Collections.singletonList()&lt;/code&gt; 및 &lt;code&gt;List.of()&lt;/code&gt;를 통해 반환된 목록은 불변이지만 &lt;code&gt;Arrays.asList()&lt;/code&gt;가 반환된 목록은 &lt;code&gt;set()&lt;/code&gt; 메서드 호출을 허용합니다.
이렇게 하면 드물지만 코드 손상이 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; empty = Arrays.asList();
  List&amp;lt;String&amp;gt; one = Arrays.asList("one");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; empty = Collections.emptyList();
  List&amp;lt;String&amp;gt; one = Collections.singletonList("one");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ArraysAsListWithZeroOrOneArgument&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfStatementMissingBreakInLoop" defaultSeverity="WARNING" displayName="'if' 조건문에서 루프 조기 종료" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
의미 변경 없이 &lt;code&gt;break&lt;/code&gt;로 끝나는 &lt;code&gt;if&lt;/code&gt; 문이 포함된 루프를 보고합니다.
이를 통해 불필요한 루프 반복이 방지됩니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean found = false;
  for (int i = 0; i &amp;lt; arr.length; i++) {
    if (Objects.equals(value, arr[i])) {
      found = true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean found = false;
  for (int i = 0; i &amp;lt; arr.length; i++) {
    if (Objects.equals(value, arr[i])) {
      found = true;
      break;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IfStatementMissingBreakInLoop&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceInefficientStreamCount" defaultSeverity="WARNING" displayName="count()로 끝나는 비효율적 Stream API 호출 체인" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
최적화될 수 있는 &lt;code&gt;count()&lt;/code&gt; 연산으로 끝나는 Stream API 호출 체인을 보고합니다.
&lt;p&gt;
  이 검사를 통해 다음 호출 체인이 대체됩니다.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Collection.stream().count()&lt;/code&gt; &amp;rarr; &lt;code&gt;Collection.size()&lt;/code&gt;. Java 8에서는 &lt;code&gt;Collection.stream().count()&lt;/code&gt;가 컬렉션 요소의 개수를 세기 위해 컬렉션 요소를 실제로 반복합니다. 그러나 대부분 컬렉션의 경우 &lt;code&gt;Collection.size()&lt;/code&gt;를 사용하면 훨씬 빠릅니다.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Stream.flatMap(Collection::stream).count()&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.mapToLong(Collection::size).sum()&lt;/code&gt;. 마찬가지로 중첩된 컬렉션 전체를 반복할 필요가 없습니다. 대신 크기를 합산할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Stream.filter(o -&gt; ...).count() &gt; 0&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.anyMatch(o -&gt; ...)&lt;/code&gt;. 원본 호출과는 달리 &lt;code&gt;anyMatch()&lt;/code&gt;는 일치하는 요소가 발견된 즉시 계산을 중단할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Stream.filter(o -&gt; ...).count() == 0&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.noneMatch(o -&gt; ...)&lt;/code&gt; 위와 유사합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  대체 항목에 &lt;code&gt;anyMatch()&lt;/code&gt;와 같은 단락 연산이 포함된 경우, 중간 스트림 연산에 의해 부수 효과가 발생하면 눈에 보이는 동작 변화가 일어날 수 있습니다. 일반적으로 스트림 API 호출에서는 부수 효과를 피해야 합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceInefficientStreamCount&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BulkFileAttributesRead" defaultSeverity="WARNING" displayName="일괄 'Files.readAttributes()' 호출을 사용할 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음과 같은 복수의 &lt;code&gt;java.io.File&lt;/code&gt; 연속 속성 확인을 보고합니다.
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;isDirectory()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;isFile()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;lastModified()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;length()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
이러한 호출은 일괄 &lt;code&gt;Files.readAttributes()&lt;/code&gt; 호출로 바꿀 수 있습니다.
일반적으로 이렇게 하는 것이 여러 개의 속성 검사를 개별적으로 하는 것보다 더 성능이 좋습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean isNewFile(File file, long lastModified) throws IOException {
    return file.isFile() &amp;&amp; file.lastModified() &gt; lastModified;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean isNewFile(File file, long lastModified) throws IOException {
    var fileAttributes = Files.readAttributes(file.toPath(), BasicFileAttributes.class);
    return fileAttributes.isRegularFile() &amp;&amp; fileAttributes.lastModifiedTime().toMillis() &gt; lastModified;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;code&gt;IOException&lt;/code&gt;이 현재 컨텍스트에서 처리되지 않지만 빠른 수정이 여전히 사용 가능하면 이 검사에 경고가 표시되지 않습니다.&lt;/p&gt;
&lt;p&gt;일반적으로 교체 코드는 완전히 동일하지 않으며 주의해서 적용해야 합니다. 특히 파일이 전혀 없는 경우에는 동작이 달라질 수 있습니다.&lt;/p&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 7 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2022.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BulkFileAttributesRead&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringBufferMustHaveInitialCapacity" defaultSeverity="WARNING" displayName="초기 용량이 없는 'StringBuilder'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
초기 용량을 지정하지 않고 새로운 &lt;code&gt;StringBuffer&lt;/code&gt; 또는 &lt;code&gt;StringBuilder&lt;/code&gt; 객체를 인스턴스화하는 시도를 보고합니다.
&lt;p&gt;
  초기 용량을 지정하지 않으면 디폴트 용량이 사용되지만, 이것이 최적인 경우는 거의 없습니다.
  &lt;code&gt;StringBuffer&lt;/code&gt;의 초기 용량을 지정하지 못하면, 초기 용량을 초과하는 시점에 공간을 재할당하고 메모리를 복사할 필요가 있는 경우 성능 문제가 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 용량이 지정되지 않았습니다
  var sb = new StringBuilder();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringBufferMustHaveInitialCapacity&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryTemporaryOnConversionFromString" defaultSeverity="WARNING" displayName="'String'에서 변환할 때 불필요한 임시 객체" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;String&lt;/code&gt;을 기본 타입으로 변환할 경우 임시 객체의 불필요한 생성을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Integer("3").intValue()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer.valueOf("3")
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryTemporaryOnConversionFromString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToSimpleGetterInClass" defaultSeverity="WARNING" displayName="클래스 내에서 간단한 getter 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
프로퍼티의 클래스 내에서 간단한 프로퍼티 getter 호출을 보고합니다.
&lt;p&gt;
  간단한 프로퍼티인 getter는 단순히 필드의 값을 반환하는 프로퍼티로 정의되어 있으며,
  다른 계산은 수행하지 않습니다. 이러한 간단한 getter 호출은 빠른 수정을 사용하여 안전하게 인라인화할 수 있습니다.
  또한 코드 명확성을 위해 일부 코딩 표준에서는 간단한 getter 사용이 권장되지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Salient {
    private String name;

    public String getName() {
      return name;
    }

    @Override
    public String toString() {
      return getName();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Salient {
    private String name;

    public String getName() {
      return name;
    }

    @Override
    public String toString() {
      return name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;다음 옵션을 사용해 검사를 구성하세요.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;매개변수로 전달된 동일한 타입의 객체가 아닌 &lt;code&gt;this&lt;/code&gt;에 대한 getter 호출만 보고할지 여부.&lt;/li&gt;
  &lt;li&gt;비 &lt;code&gt;private&lt;/code&gt; getter를 무시할지 여부.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: CallToSimpleGetterInClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ToArrayCallWithZeroLengthArrayArgument" defaultSeverity="WARNING" displayName="'Collection.toArray()' 호출 스타일" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
기본 스타일이 아닌 &lt;code&gt;Collection.toArray()&lt;/code&gt; 호출을 보고하고 기본 스타일을 적용할 것을 제안합니다.
&lt;p&gt;컬렉션을 배열로 변환하는 스타일에는 다음 두 가지가 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;크기가 사전 설정된 배열. 예: &lt;code&gt;c.toArray(new String[c.size()])&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;빈 배열. 예: &lt;code&gt;c.toArray(new String[0])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이전 Java 버전에서는 적절한 크기의 배열을 생성하는 데 필요한 리플렉션 호출의 속도가 매우 느렸으므로 크기가 사전 설정된 배열이 권장되었습니다.&lt;/p&gt;
&lt;p&gt;하지만 OpenJDK 6의 최신 업데이트 이후로 이 호출이 기본 제공되어 빈 배열 버전의 성능이 크기가 사전 설정된 버전과 같거나 더 높을 때도 있습니다. 또한 크기가 사전 설정된 배열을 전달하면 &lt;code&gt;size&lt;/code&gt; 및 &lt;code&gt;toArray&lt;/code&gt;호출 간에 데이터 경합이 발생할 수 있으므로 동시 또는 동기화된 컬렉션에서 위험합니다. 이 때문에 컬렉션이 작업 도중 동시에 축소된 경우 배열 끝에 여분의 &lt;code&gt;null&lt;/code&gt;이 발생할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 옵션을 사용하여 기본 스타일을 선택하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ToArrayCallWithZeroLengthArrayArgument&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WrapperTypeMayBePrimitive" defaultSeverity="WARNING" displayName="래퍼 타입을 기본 타입으로 만들 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대부분 기본 타입으로 사용되는 래퍼 타입의 지역 변수를 보고합니다.
&lt;p&gt;일부 사례에서, 특히 루프에서 박싱은 중대한 성능 저하의 원인이 될 수 있습니다.&lt;/p&gt;
&lt;p&gt;박싱 연산의 개수를 평가하는 데에는 경험적 지식이 적용됩니다. 예를 들어, 루프 내부의 변환은 훨씬 더 많은 것으로 간주됩니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public void example() {
    Integer value = 12;
    needBox(value);
    for (int i = 0; i &amp;lt; 10; i++) {
      // Loop usages considered as happening more often
      needPrimitive(value);
    }
  }

  void needPrimitive(int value) {}
  void needBox(Integer value) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public void example() {
    int value = 12;
    needBox(value);
    for (int i = 0; i &amp;lt; 10; i++) {
      // 루프 사용은 더 자주 발생하는 것으로 간주됩니다
      needPrimitive(value);
    }
  }

  void needPrimitive(int value) {}
  void needBox(Integer value) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;small&gt;2018.2의 새로운 기능&lt;/small&gt;
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: WrapperTypeMayBePrimitive&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstantiatingObjectToGetClassObject" defaultSeverity="WARNING" displayName="'Class' 객체를 얻기 위해 객체를 인스턴스화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스 객체를 얻기 위해 클래스를 인스턴스화하는 코드를 보고합니다.
&lt;p&gt;이름을 통해 바로 클래스 객체에 액세스하면 성능이 더 향상됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Class&amp;lt;?&amp;gt; c = new Sample().getClass();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Class&amp;lt;?&amp;gt; c = Sample.class;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InstantiatingObjectToGetClassObject&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenationInLoops" defaultSeverity="WARNING" displayName="루프 내 문자열 연결" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루프의 String 연결을 보고합니다.
&lt;p&gt;
  모든 String 연결은 전체 문자열을 복사하므로 &lt;code&gt;StringBuilder.append()&lt;/code&gt; 또는 &lt;code&gt;StringBuffer.append()&lt;/code&gt;에 대한 명시적 호출로 대체하는 편이 일반적으로 선호됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String str = "";
  for(int i=0; i&amp;lt;10; i++) {
    str += i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String str = "";
  StringBuilder strBuilder = new StringBuilder(str);
  for(int i = 0; i&amp;lt;10; i++) {
    strBuilder.append(i);
  }
  str = strBuilder.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  빠른 수정을 통해 &lt;code&gt;String&lt;/code&gt; 변수를 &lt;code&gt;StringBuilder&lt;/code&gt;로 변환하거나 새로운 &lt;code&gt;StringBuilder&lt;/code&gt;를 삽입할 수 있는 경우도 있습니다. 대체 시 의미 변경이 발생할 수 있으므로 기존 코드가 &lt;code&gt;null&lt;/code&gt; 값을 특별히 취급하는 경우 주의해야 합니다. &lt;code&gt;null&lt;/code&gt; 값이 가능한 경우 필수 null 검사를 생성하는 null 세이프한 수정이 제안됩니다. 또한 자동 대체의 성능이 항상 더 뛰어난 것은 아닙니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringConcatenationInLoops&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TailRecursion" defaultSeverity="INFORMATION" displayName="꼬리 재귀" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
꼬리 재귀, 즉 메서드가 반환 전 마지막 액션으로 그 자체를 호출하는 경우를 보고합니다.
&lt;p&gt;
  꼬리 재귀는 항상 루프로 대체할 수 있으며, 그래야 훨씬 빠르게 처리됩니다.
  일부 JVM에서는 tail-call 최적화가 수행됩니다. 그러므로 꼬리 재귀 솔루션은 가상 머신에 따라 성능 특성이 상당히 다를 수 있습니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int factorial(int val, int runningVal) {
    if (val == 1) {
      return runningVal;
    } else {
      return factorial(val - 1, runningVal * val);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int factorial(int val, int runningVal) {
    while (true) {
      if (val == 1) {
        return runningVal;
      } else {
        runningVal = runningVal * val;
        val = val - 1;
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: TailRecursion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodMayBeStatic" defaultSeverity="WARNING" displayName="메서드를 'static'으로 만들 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전하게 &lt;code&gt;static&lt;/code&gt;으로 만들 수 있는 메서드를 보고합니다.
가능한 경우 메서드를 static으로 설정하면 메모리 사용량을 줄이고 코드 품질을 향상시킬 수 있습니다.
&lt;p&gt;다음과 같은 경우 메서드가 &lt;code&gt;static&lt;/code&gt;일 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;synchronized&lt;/code&gt;, &lt;code&gt;native&lt;/code&gt; 또는 &lt;code&gt;abstract&lt;/code&gt;가 아닙니다.
  &lt;/li&gt;
  &lt;li&gt;
    포함하는 클래스의 비 static 메서드 및 비 static 필드를 참조하지 않습니다.
  &lt;/li&gt;
  &lt;li&gt;
    재정의가 아니며 하위 클래스에서 재정의되지 않습니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;다음 옵션을 사용해 검사를 구성하세요.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이 검사의 성능을 향상시키기 위해, &lt;code&gt;private&lt;/code&gt; 및 &lt;code&gt;final&lt;/code&gt; 메서드만 보고할지 여부.&lt;/li&gt;
  &lt;li&gt;빈 메서드를 무시할지 여부.&lt;/li&gt;
  &lt;li&gt;Java 8 이상을 사용할 때 인터페이스의 기본 메서드를 무시할지 여부.&lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;static&lt;/code&gt;으로 설정된 메서드 호출에서 빠른 수정이 인스턴스 한정자를 클래스 참조로 바꾸도록 허용할지(즉, &lt;code&gt;myClass.m()&lt;/code&gt; 호출을 &lt;code&gt;MyClass.m()&lt;/code&gt;으로 대체) 여부.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MethodMayBeStatic&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LengthOneStringsInConcatenation" defaultSeverity="INFORMATION" displayName="단일 문자 문자열 연결" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자 하나로 구성된 문자열 리터럴과 연결을 보고합니다.
&lt;p&gt;이러한 리터럴을 동등한 문자 리터럴로 대체하여 성능을 개선할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String hello = hell + "o";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String hello = hell + 'o';
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: LengthOneStringsInConcatenation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AutoBoxing" defaultSeverity="WARNING" displayName="자동 박싱" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
자동 박싱 변환(객체로 원시 값 자동 래핑)의 영향을 받는 표현식을 보고합니다.
원시 타입이 아닌 객체를 사용하지 않도록 하세요. 이는 성능에 상당한 영향을 미칠 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Integer x = 42;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 변환을 명시적으로 만듭니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Integer x = Integer.valueOf(42);&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;AutoBoxing&lt;/i&gt;은 Java 5에 등장했습니다.
  이 검사는 이전 Java 버전과의 하위 호환성을 위해 다운그레이드하는 데 도움이 될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AutoBoxing&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldMayBeStatic" defaultSeverity="WARNING" displayName="필드를 'static'으로 만들 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전하게 &lt;code&gt;static&lt;/code&gt;으로 만들 수 있는 인스턴스 변수를 보고합니다. 필드가 &lt;code&gt;final&lt;/code&gt;로 선언되고 상수로 초기화되면 이 필드는 static이 될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public final String str = "sample";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  묵시적으로 쓰기될 수 있는 final 필드는 보고하지 않습니다. '어노테이션' 버튼을 사용하여 묵시적 필드 쓰기를 가정하는 어노테이션의 목록을 수정하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FieldMayBeStatic&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KeySetIterationMayUseEntrySet" defaultSeverity="WARNING" displayName="'keySet()' 반복을 최적화할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Map&lt;/code&gt; 인스턴스의 &lt;code&gt;keySet()&lt;/code&gt; 반복을 보고합니다. 여기서 반복의 키는 맵에서 값을 검색하는 데 사용됩니다.
&lt;p&gt;
  &lt;code&gt;entrySet()&lt;/code&gt; 또는 &lt;code&gt;values()&lt;/code&gt; 반복으로 대체되는 경우 이러한 반복이 더 효율적일 수 있습니다(키가 실제로 사용되지 않는 경우).
&lt;/p&gt;
&lt;p&gt;
  유사하게, 람다 내에서 값을 검색하는 경우 &lt;code&gt;keySet().forEach(key -&amp;gt; ...)&lt;/code&gt;를
  &lt;code&gt;forEach((key, value) -&amp;gt; ...)&lt;/code&gt;로 바꿀 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Object key : map.keySet()) {
   Object val = map.get(key);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Object val : map.values()) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: KeySetIterationMayUseEntrySet&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CollectionsMustHaveInitialCapacity" defaultSeverity="WARNING" displayName="초기 용량이 없는 컬렉션" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
초기 용량을 지정하지 않고 새로운 &lt;code&gt;Collection&lt;/code&gt; 객체를 인스턴스화하는 시도를 보고합니다.
&lt;p&gt;
  초기 용량을 지정하지 않으면 디폴트 용량이 사용되지만, 이것이 최적인 경우는 거의 없습니다. 컬렉션의 초기 용량을 지정하지 못하면 초기 용량을 초과하는 시점에 공간을 재할당하고 메모리를 복사해야 하는 경우 성능 문제가 발생할 수 있습니다.
  이 검사는 검사의 설정에 나열된 클래스 할당을 확인합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new HashMap&amp;lt;String, String&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;다음 옵션을 사용해 검사를 구성하세요.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;확인해야 하는 컬렉션 클래스를 나열합니다.&lt;/li&gt;
  &lt;li&gt;필드 이니셜라이저를 무시할지 여부.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CollectionsMustHaveInitialCapacity&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanConstructor" defaultSeverity="WARNING" displayName="부울 생성자 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Boolean&lt;/code&gt; 객체의 생성을 보고합니다.
&lt;p&gt;
  &lt;code&gt;Boolean&lt;/code&gt; 객체를 새롭게 생성하는 것은 거의 불필요하며, 빈번히 생성할 경우 성능 문제가 발생할 수 있습니다. 또한 Java 9부터 &lt;code&gt;Boolean&lt;/code&gt; 생성자가 사용되지 않으므로 이후 Java 버전에서는 제거되거나 액세스가 불가능할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Boolean b1 = new Boolean(true);
  Boolean b2 = new Boolean(str);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Boolean b1 = Boolean.TRUE;
  Boolean b2 = Boolean.valueOf(str);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BooleanConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ManualArrayCopy" defaultSeverity="WARNING" displayName="수동 배열 복사" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;System.arraycopy()&lt;/code&gt; 호출로 대체 가능한 배열 내용의 수동 복사를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i = 0; i &amp;lt; array.length; i++) {
    newArray[i] = array[i];
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.arraycopy(array, 0, newArray, 0, array.length);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ManualArrayCopy&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IOStreamConstructor" defaultSeverity="WARNING" displayName="'InputStream'과 'OutputStream'은 'Files' 메서드로 생성될 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
각각 &lt;code&gt;Files.newInputStream()&lt;/code&gt; 및 &lt;code&gt;Files.newOutputStream()&lt;/code&gt; 호출로 대체될 수 있는 &lt;code&gt;new FileInputStream()&lt;/code&gt; 혹은 &lt;code&gt;new FileOutputStream()&lt;/code&gt; 표현식을 보고합니다.
&lt;br&gt;
&lt;code&gt;Files&lt;/code&gt; 메서드를 사용하여 생성된 스트림은 스트림 생성자로 생성한 것보다 보통 더 효율적입니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  InputStream is = new BufferedInputStream(new FileInputStream(file));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  InputStream is = new BufferedInputStream(Files.newInputStream(file.toPath()));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;언어 수준이 10 이상이지만 빠른 수정이 여전히 사용 가능하면 이 검사에 경고가 표시되지 않습니다.&lt;/p&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 7 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2022.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IOStreamConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToSimpleSetterInClass" defaultSeverity="WARNING" displayName="클래스 내에서 간단한 setter 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
프로퍼티의 클래스 내에서 간단한 프로퍼티 setter 호출을 보고합니다.
&lt;p&gt;
  간단한 프로퍼티인 setter는 단순히 매개변수의 값을 대입하는 프로퍼티로 정의되어 있으며,
  다른 계산은 수행하지 않습니다. 이러한 간단한 setter 호출은 안전하게 인라인화할 수 있습니다.
  또한 코드 명확성을 위해 일부 코딩 표준에서는 간단한 setter 사용이 권장되지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
  private int index;
    public Foo(int idx) {
       setIndex(idx);
    }
    public void setIndex(int idx) {
       index = idx;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    private int index;
    public Foo(int idx) {
      index = idx;
    }
    public void setIndex(int idx) {
      index = idx;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;다음 옵션을 사용해 검사를 구성하세요.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;매개변수로 전달된 동일한 타입의 객체가 아닌 &lt;code&gt;this&lt;/code&gt;에 대한 setter 호출만 보고할지 여부.&lt;/li&gt;
  &lt;li&gt;비 &lt;code&gt;private&lt;/code&gt; setter를 무시할지 여부.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CallToSimpleSetterInClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectInstantiationInEqualsHashCode" defaultSeverity="WARNING" displayName="'equals()' 또는 'hashCode()' 내의 객체 인스턴스화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt;, &lt;code&gt;compareTo()&lt;/code&gt;, &lt;code&gt;Comparator.compare()&lt;/code&gt; 메서드 내의 (임시) 새로운 객체 생성을 보고합니다.
&lt;p&gt;
  생성자 호출 외에, 새로운 객체는 &lt;code&gt;foreach&lt;/code&gt; 문 내의 자동 박싱 또는 이터레이터 생성으로 새로운 객체를 만들 수 있습니다.
  이 경우 성능 문제가 발생할 수 있습니다. 예를 들면 메서드를 자주 호출하는 &lt;code&gt;Set&lt;/code&gt; 또는 &lt;code&gt;Map&lt;/code&gt;에 객체를 추가하는 경우 그렇습니다.
&lt;/p&gt;
&lt;p&gt;
  이 검사는 객체가 &lt;code&gt;throw&lt;/code&gt; 또는 &lt;code&gt;assert&lt;/code&gt; 문에서 생성되는 경우를 보고하지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    private String name;
    private int age;

    public boolean equals(Object o) {
      return Arrays.equals(new Object[] {name, age}, new Object[] {((Foo)o).name, ((Foo)o).age});
    }

    public int hashCode() {
      return (name + age).hashCode();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  이 예시에서 추가적인 2개의 배열은 &lt;code&gt;equals()&lt;/code&gt; 내에서 생성되고 &lt;code&gt;age&lt;/code&gt; 필드의 사용 위치에는 박싱이 필요하며 &lt;code&gt;name + age&lt;/code&gt;가 새로운 문자열을 묵시적으로 생성합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ObjectInstantiationInEqualsHashCode&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 14" path="Java/Java 언어 수준 마이그레이션 지원"><inspection shortName="EnhancedSwitchBackwardMigration" defaultSeverity="INFORMATION" displayName="향상된 'switch'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
개선된 &lt;code&gt;switch&lt;/code&gt; 문 또는 식을 보고합니다. 해당 문이나 식을 일반 &lt;code&gt;switch&lt;/code&gt; 문으로 바꾸도록 제안합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean even = switch (condition) {
    case 1, 3, 5, 7, 9 -&gt; false;
    default -&gt; true;
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean even;
  switch (condition) {
    case 1:
    case 3:
    case 5:
    case 7:
    case 9:
      even = false;
      break;
    default:
      even = true;
      break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;향상된&lt;/i&gt; &lt;code&gt;switch&lt;/code&gt;는 Java 14에 등장했습니다.
  이 검사는 이전 Java 버전과의 하위 호환성을 위해 다운그레이드하는 데 도움이 될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2019.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EnhancedSwitchBackwardMigration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnhancedSwitchMigration" defaultSeverity="WARNING" displayName="구문을 향상된 'switch' 문으로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
개선된 &lt;code&gt;switch&lt;/code&gt; 문 또는 식으로 자동 대체 가능한 &lt;code&gt;switch&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double getPrice(String fruit) {
    // Switch 문을 개선된 'switch'로 대체 가능합니다
    switch (fruit) {
      case "Apple":
        return 1.0;
      case "Orange":
        return 1.5;
      case "Mango":
        return 2.0;
      default:
        throw new IllegalArgumentException();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double getPrice(String fruit) {
    return switch (fruit) {
      case "Apple" -&gt; 1.0;
      case "Orange" -&gt; 1.5;
      case "Mango" -&gt; 2.0;
      default -&gt; throw new IllegalArgumentException();
    };
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;switch&lt;/code&gt; 문으로 변환될 때 경고를 표시하지 않으려는 경우 &lt;b&gt;표현식으로 변환할 수 있을 때만 경고 표시&lt;/b&gt; 옵션을 사용하세요.
  &lt;/li&gt;
  &lt;li&gt;
    표현식으로 변환 시에 각 브랜치의 구문 수가 설정된 수보다 적을 때만 경고를 표시하려는 경우 &lt;b&gt;한 브랜치 내에서 switch 식으로 변환할 최대 구문 수&lt;/b&gt; 옵션을 사용하세요.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;2019.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 14부터 사용할 수 있는 Java 기능 &amp;#39;향상된 &amp;#39;switch&amp;#39; 블록&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EnhancedSwitchMigration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Room" path="Android"><inspection shortName="AndroidRoomSqlBooleanLiteral" defaultSeverity="WARNING" displayName="Boolean literal used in a Room query" enabled="false" language="RoomSql" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!--
  ~ Copyright (C) 2023 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Android API 수준 30은 부울 리터럴 'TRUE' 및 'FALSE'를 지원하는 SQLite가 포함된 첫 Android 버전입니다. &lt;a href="https://sqlite.org/datatype3.html"&gt;SQLite 데이터타입&lt;/a&gt; 및 &lt;a href="https://developer.android.com/reference/android/database/sqlite/package-summary"&gt;Android SQLite 버전&lt;/a&gt; 문서를 참조하세요.&lt;/p&gt;
&lt;p&gt;그보다 낮은 API 수준에서는 동등한 정수 리터럴인 1(TRUE)과 0(FALSE)을 대신 사용해야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AndroidRoomSqlBooleanLiteral&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AndroidRoomQuestionMarkBindParameter" defaultSeverity="ERROR" displayName="'?' used as parameter in a Room query." enabled="false" language="RoomSql" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 없는 쿼리 매개변수(예: &lt;code&gt;WHERE id = ?&lt;/code&gt;)를 사용하는 Room SQL 쿼리를 보고합니다. 이는 Room 쿼리 분석기에서 지원되지 않습니다.
&lt;code&gt;@Query&lt;/code&gt; 어노테이션이 추가된 메서드의 인수에 상응하는 이름이 지정된 매개변수(예: &lt;code&gt;WHERE id = :id&lt;/code&gt;)가
필요합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AndroidRoomQuestionMarkBindParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AndroidUnresolvedRoomSqlReference" defaultSeverity="ERROR" displayName="Unresolved reference in Room SQL" enabled="false" language="RoomSql" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해결되지 않은 참조를 찾기 위해 Room SQL 쿼리를 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AndroidUnresolvedRoomSqlReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Spring AOP" path="Spring"><inspection shortName="MissingAspectjAutoproxyInspection" defaultSeverity="WARNING" displayName="aspectj-autoproxy 누락" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Spring 2.5 이전 버전에서 XML 구성에 &lt;strong&gt;&amp;lt;aop:aspectj-autoproxy/&amp;gt;&lt;/strong&gt; 요소가 없는 경우 &lt;code&gt;@Aspect&lt;/code&gt; 어노테이션을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
@Aspect // @AspectJ 지원이 활성화되어 있지 않습니다
class MyAspect {
   ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
&amp;lt;beans&amp;gt;
   &amp;lt;!-- &amp;lt;aop:aspectj-autoproxy/&amp;gt; --&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MissingAspectjAutoproxyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringAopWarningsInspection" defaultSeverity="WARNING" displayName="잘못된 Spring AOP 어스펙트 또는 포인트컷 요소" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 어스펙트 및 포인트컷을 보고합니다.
일부 AOP 어드바이스가 어스펙트 Bean과 일치하는 경우 런타임 오류가 발생할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;beans&amp;gt;
  &amp;lt;aop:config&amp;gt;
    &amp;lt;aop:pointcut expression="args()"/&amp;gt; &amp;lt;!--  포인트컷에 ID가 있어야 합니다 --&amp;gt;
    &amp;lt;aop:aspect/&amp;gt; &amp;lt;!-- 'ref' 속성이 정의되어야 합니다 --&amp;gt;
  &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;

&amp;lt;beans&amp;gt;
  &amp;lt;bean id="aspect1" class="Aspect1"/&amp;gt;
  &amp;lt;bean id="aspect2" class="Aspect2"/&amp;gt;
  &amp;lt;aop:config&amp;gt;
    &amp;lt;aop:aspect ref="aspect1"&amp;gt; &amp;lt;!-- 일부 어드바이스가 이 bean과 일치합니다 --&amp;gt;
    &amp;lt;aop:before method="xxx" pointcut="execution(* foo())"/&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;aop:aspect ref="aspect2"&amp;gt;
      &amp;lt;aop:before method="xxx" pointcut="execution(* foo())"/&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
  &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringAopWarningsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JdkProxiedBeanTypeInspection" defaultSeverity="ERROR" displayName="잘못된 JDK 프록시된 Bean 타입" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못 구성된 JDK 프록시 Bean 타입을 보고합니다.&lt;/p&gt;

&lt;p&gt;자세한 내용은 &lt;a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pfb-proxy-types"&gt;JDK 및 CGLIB 기반 프록시&lt;/a&gt;를 참조하세요.&lt;/p&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JdkProxiedBeanTypeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringAopErrorsInspection" defaultSeverity="ERROR" displayName="잘못된 Spring AOP 어드바이스 및 어드바이저 요소" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;pointcut&lt;/code&gt; 또는 &lt;code&gt;pointcut-ref&lt;/code&gt; 속성이 없는 경우 잘못된 어드바이스 및 어드바이저 요소를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;beans&amp;gt;
    &amp;lt;aop:config&amp;gt;
      &amp;lt;aop:pointcut id="zzz" expression="args()"/&amp;gt;
        &amp;lt;aop:aspect ref="xxx"&amp;gt;
            &amp;lt;aop:before method="writeArg1" pointcut="execution(* *(String))"/&amp;gt;
            &amp;lt;aop:after method="aaa" pointcut-ref="zzz"/&amp;gt;
            &amp;lt;&lt;strong&gt;aop:after-throwing&lt;/strong&gt; method="aaa"/&amp;gt; &amp;lt;!-- 'pointcut' 또는 'pointcut-ref' 속성이 정의되어야 합니다 --&amp;gt;
       &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringAopErrorsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringAopPointcutExpressionInspection" defaultSeverity="ERROR" displayName="잘못된 Spring AOP 포인트컷 표현식" enabled="false" language="PointcutExpression" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Spring에서 지원되지 않는 AspectJ 포인트컷 지정자를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
&amp;lt;beans&amp;gt;
  &amp;lt;aop:config &amp;gt;
      &amp;lt;aop:pointcut expression="&lt;strong&gt;@this&lt;/strong&gt;(Anno)  &amp;lt;!-- '@this' 포인트컷 지정자는 Spring에서 지원되지 않습니다 --&amp;gt;
                  and &lt;strong&gt;adviceexecution&lt;/strong&gt;()"/&amp;gt; &amp;lt;!--  'adviceexecution' 포인트컷 지정자는 Spring에서 지원되지 않습니다 --&amp;gt;
      &amp;lt;aop:pointcut expression="!@annotation(Anno)"/&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringAopPointcutExpressionInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="try 문 문제" path="JavaScript 및 TypeScript"><inspection shortName="ReturnFromFinallyBlockJS" defaultSeverity="WARNING" displayName="'finally' 블록 내 'return'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;finally&lt;/code&gt; 블록 내부의 &lt;code&gt;return&lt;/code&gt; 문을 보고합니다. 그러한 &lt;code&gt;return&lt;/code&gt; 문은 던져진 예외를 가리고 디버그를 복잡하게 만들 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReturnFromFinallyBlockJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyFinallyBlockJS" defaultSeverity="WARNING" displayName="빈 'finally' 블록" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
일반적으로 오류를 나타내는 빈 &lt;code&gt;finally&lt;/code&gt; 블록을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EmptyFinallyBlockJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedCatchParameterJS" defaultSeverity="WARNING" displayName="사용되지 않는 'catch' 매개변수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대응하는 블록에서 사용되지 않는 &lt;code&gt;catch&lt;/code&gt; 파라미터를 보고합니다.  &lt;code&gt;ignore&lt;/code&gt; 또는 &lt;code&gt;ignored&lt;/code&gt;로 이름이 지정된 &lt;code&gt;catch&lt;/code&gt; 파라미터는 무시됩니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
    주석이 있는 &lt;code&gt;catch&lt;/code&gt; 블록에 대해 이 검사를 비활성화하려면 아래 체크박스를 사용하십시오.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnusedCatchParameterJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyTryBlockJS" defaultSeverity="WARNING" displayName="빈 'try' 블록" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
보통 오류를 나타내는 빈 &lt;code&gt;try&lt;/code&gt; 블록을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EmptyTryBlockJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExceptionCaughtLocallyJS" defaultSeverity="WARNING" displayName="로컬 제어 흐름에 사용되는 예외" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
예외가 항상 자신을 포함하는 &lt;code&gt;try&lt;/code&gt; 문에 의해 포착되는 &lt;code&gt;throw&lt;/code&gt; 문을 보고합니다. 로컬 제어 흐름을 변경하기 위해 &lt;code&gt;goto&lt;/code&gt;처럼 &lt;code&gt;throw&lt;/code&gt; 문을 사용하는 것은 혼란을 일으킬 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ExceptionCaughtLocallyJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueOrBreakFromFinallyBlockJS" defaultSeverity="WARNING" displayName="'finally' 블록 내 'continue' 또는 'break'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;finally&lt;/code&gt; 블록 내부의 &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; 구문을 보고합니다. 그러한 구문은 혼란을 일으킬 가능성이 매우 크며 예외를 가리고 디버그를 복잡하게 만들 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ContinueOrBreakFromFinallyBlockJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyCatchBlockJS" defaultSeverity="WARNING" displayName="빈 'catch' 블록" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
빈 &lt;code&gt;catch&lt;/code&gt; 블록을 보고합니다. 이는 오류가 처리되지 않고 단순히 무시됨을 나타냅니다.
&lt;br/&gt;&lt;br/&gt;
&lt;code&gt;catch&lt;/code&gt; 블록 내 모든 주석은 해당 검사를 끕니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EmptyCatchBlockJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowFromFinallyBlockJS" defaultSeverity="WARNING" displayName="'finally' 블록 내 'throw'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;finally&lt;/code&gt; 블록 내부의 &lt;code&gt;throw&lt;/code&gt; 문을 보고합니다. 그러한 &lt;code&gt;throw&lt;/code&gt; 문은 던져진 예외를 가리고 디버그를 복잡하게 만들 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ThrowFromFinallyBlockJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="기타 문제" path="Kotlin"><inspection shortName="PublicApiImplicitType" defaultSeverity="WEAK WARNING" displayName="묵시적 반환 타입이 있는 public API 선언" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
    묵시적 반환 타입을 가지고 있는 &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; 함수 및 프로퍼티를 보고합니다.
    API 안정성을 고려해 그러한 타입은 명시적으로 지정하는 것이 좋습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun publicFunctionWhichAbusesTypeInference() =
      otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun publicFunctionWhichAbusesTypeInference(): &lt;b&gt;Api&lt;/b&gt; =
      otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PublicApiImplicitType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinAmbiguousActuals" defaultSeverity="ERROR" displayName="모호한 actual" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
멀티 플랫폼 모듈 구현 시 모호한 &lt;code&gt;actual&lt;/code&gt; 선언을 가진 &lt;code&gt;expect&lt;/code&gt; 선언을 보고합니다.
&lt;p&gt;
    예:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
// common.kt
expect class Foo
// middle.kt
actual class Foo
// bottom.kt
actual class Foo
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KotlinAmbiguousActuals&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnumValuesSoftDeprecate" defaultSeverity="WARNING" displayName="1.9부터 'Enum.values()'를 'Enum.entries'로 대체하는 것이 좋습니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;entries&lt;/code&gt; 프로퍼티 읽기로 바꿀 수 있는 열거형 클래스의 &lt;code&gt;values()&lt;/code&gt; 메서드에 대한 Kotlin으로부터의 호출을 보고합니다.
&lt;p&gt;
    &lt;code&gt;Enum.entries&lt;/code&gt;를 사용하면 코드 성능이 향상될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
    빠른 수정에서는 &lt;code&gt;values()&lt;/code&gt;를 &lt;code&gt;entries&lt;/code&gt;로 바꿉니다.
&lt;/p&gt;
&lt;p&gt;
    &lt;b&gt;세부 정보:&lt;/b&gt; &lt;a href="https://youtrack.jetbrains.com/issue/KT-48872"&gt;
    KT-48872, Enum.values()에 대한 최신 고성능 대체 항목을 제공&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;b&gt;참고:&lt;/b&gt; &lt;code&gt;entries&lt;/code&gt; 프로퍼티 타입은 &lt;code&gt;values()&lt;/code&gt; 메서드의 반환 타입과 다릅니다(&lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;에서 상속되는 &lt;code&gt;EnumEntries&amp;lt;T&amp;gt;&lt;/code&gt;).
    이로 인해 빠른 수정에서는 코드 손상을 방지하기 위해 추가적인 &lt;code&gt;.toTypedArray()&lt;/code&gt; 변환을 삽입할 때도 있지만, 대부분의 일반적인 경우에는 변환 없이 대체가 수행됩니다(예: &lt;code&gt;for&lt;/code&gt; 루프).
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    enum class Version {
        V1, V2
    }

    Version.&lt;b&gt;values()&lt;/b&gt;.forEach { /* .. */ }
    val firstVersion = Version.&lt;b&gt;values()&lt;/b&gt;[0]
    functionExpectingArray(Version.&lt;b&gt;values()&lt;/b&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    enum class Version {
        V1, V2
    }

    Version.&lt;b&gt;entries&lt;/b&gt;.forEach { /* .. */ }
    val firstVersion = Version.&lt;b&gt;entries&lt;/b&gt;[0]
    functionExpectingArray(Version.&lt;b&gt;entries.toTypedArray()&lt;/b&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EnumValuesSoftDeprecate&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplacePrintlnWithLogging" defaultSeverity="WARNING" displayName="'print()' 또는 'println()' 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;print&lt;/code&gt; 또는 &lt;code&gt;println&lt;/code&gt;의 사용 위치를 보고합니다.
&lt;p&gt;그러한 구문은 보통 일시적인 디버그에 자주 사용되기 때문에 프로덕션 코드에서 제거하거나 더욱 강력한 로깅 기능으로 바꿔야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplacePrintlnWithLogging&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertArgumentToSet" defaultSeverity="WEAK WARNING" displayName="성능 향상을 위해 인수를 'Set'으로 변환할 수 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인수를 &lt;code&gt;Set&lt;/code&gt;으로 변환하면 더 빠르게 동작할 수 있는 함수 호출을 탐지합니다.

&lt;p&gt;
    인수가 set인 경우 'minus' 또는 'intersect' 등의 연산이 더 효과적입니다.
    &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;를 &lt;code&gt;Set&amp;lt;T&amp;gt;&lt;/code&gt;으로 명시적으로 변환하면 코드를 더 효과적으로 만들 수 있습니다.
&lt;/p&gt;

&lt;p&gt;
    빠른 수정에서는 함수 호출로의 명시적 변환을 추가합니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun &amp;lt;T&amp;gt; f(a: Iterable&amp;lt;T&amp;gt;, b: Iterable&amp;lt;T&amp;gt;): Int =
      a.intersect(b).size
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun &amp;lt;T&amp;gt; f(a: Iterable&amp;lt;T&amp;gt;, b: Iterable&amp;lt;T&amp;gt;): Int =
      a.intersect(b.toSet()).size
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ConvertArgumentToSet&lt;/small&gt;&lt;/p&gt;
&lt;/html&gt;</inspection><inspection shortName="FloatingPointLiteralPrecision" defaultSeverity="WEAK WARNING" displayName="부동 소수점 리터럴이 사용 가능한 정확도를 초과" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://en.wikipedia.org/wiki/IEEE_754"&gt;IEEE 754&lt;/a&gt;의 &lt;code&gt;Float&lt;/code&gt; 및 &lt;code&gt;Double&lt;/code&gt; 타입을 사용하여, 필요한 정밀도로 표현할 수 없는 부동 소수점 리터럴을 보고합니다.

&lt;p&gt;
    예를 들어, &lt;code&gt;1.9999999999999999999&lt;/code&gt;에는 유효 숫자가 너무 많으므로 &lt;code&gt;Double&lt;/code&gt;로 표현하면 &lt;code&gt;2.0&lt;/code&gt;으로 반올림됩니다.
    계산 시 반올림된 값이 대신 사용된다는 사실은 숨겨지므로 숫자를 과하게 지정할 경우 오해의 소지가 있습니다.
&lt;/p&gt;

&lt;p&gt;
    빠른 수정에서는 해당 리터럴을 상수의 실제 표현과 일치하는 반올림된 값으로 대체합니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x: Float = 3.14159265359f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x: Float = 3.1415927f
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FloatingPointLiteralPrecision&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EnumValuesSoftDeprecateInJava" defaultSeverity="WARNING" displayName="Kotlin 1.9부터 'Enum.values()'를 'Enum.getEntries()'로 대체하는 것이 좋습니다" enabled="false" language="JAVA" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;getEntries()&lt;/code&gt;로 바꿀 수 있는 Java에서 Kotlin 열거형 클래스의 &lt;code&gt;values()&lt;/code&gt; 메서드에 대한 호출을 보고합니다.
&lt;p&gt;
    &lt;code&gt;Enum.getEntries()&lt;/code&gt;를 사용하면 코드 성능이 향상될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
    &lt;b&gt;세부 정보:&lt;/b&gt; &lt;a href="https://youtrack.jetbrains.com/issue/KT-48872"&gt;
    KT-48872, Enum.values()에 대한 최신 고성능 대체 항목을 제공&lt;/a&gt;
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EnumValuesSoftDeprecateInJava&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinNoActualForExpect" defaultSeverity="ERROR" displayName="expect 선언에 actual이 없음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구현하는 멀티플랫폼 모듈에서 대응하는 &lt;code&gt;actual&lt;/code&gt; 선언이 없는 &lt;code&gt;expect&lt;/code&gt; 선언을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KotlinNoActualForExpect&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="import 문 및 종속 요소" path="JavaScript 및 TypeScript"><inspection shortName="JSXNamespaceValidation" defaultSeverity="INFORMATION" displayName="JSX 네임스페이스 누락" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
네임스페이스를 가져오지 않고 JSX 구문을 사용한 경우를 보고합니다.
파일 범위에 네임스페이스가 있으면 코드 컴파일링이 올바르게 실행됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSXNamespaceValidation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6UnusedImports" defaultSeverity="WARNING" displayName="사용되지 않는 import 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 &lt;code&gt;import&lt;/code&gt; 문을 보고합니다.
이는 보통 가져온 심볼이 소스 파일에서 사용되지 않은 경우입니다.
부작용을 없애려면 일반 import가 아니라 bare import &lt;code&gt;import 'packageName'&lt;/code&gt;를 사용하는 방안을 검토하십시오.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ES6UnusedImports&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageJsonMismatchedDependency" defaultSeverity="WARNING" displayName="package.json에서 일치하지 않는 종속 요소" enabled="false" language="JSON" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
설치되어 있지 않거나 지정된 &lt;a href="https://docs.npmjs.com/about-semantic-versioning"&gt;버전 범위&lt;/a&gt;와 일치하지 않는 package.json의 종속성을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PackageJsonMismatchedDependency&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUrlImportUsage" defaultSeverity="INFORMATION" displayName="URL 가져오기가 사용되었습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JavaScript 언어로 사용된 URL 가져오기를 확인합니다.
지정된 원격 URL에 대한 모듈 다운로드를 제안합니다.
그러한 연결은 IDE가 적절한 코드 완성과 탐색을 제공하는 데 도움이 됩니다.
&lt;br/&gt;
&lt;br/&gt;
가져오기 지정자의 URL은 JavaScript 언어의 ECMAScript 모듈에 대해서만 지원됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSUrlImportUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UpdateDependencyToLatestVersion" defaultSeverity="INFORMATION" displayName="package.json 종속성을 최신 버전으로 업데이트" enabled="false" language="JSON" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지정된 버전을 무시하고 package.json 종속성을 최신 버전으로 업그레이드할 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UpdateDependencyToLatestVersion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NpmUsedModulesInstalled" defaultSeverity="WEAK WARNING" displayName="모듈 종속 요소 누락" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
설치되어 있지 않거나 package.json 종속성에 나열되어 있지 않은 &lt;code&gt;require()&lt;/code&gt; 호출의 모듈 또는 &lt;code&gt;import&lt;/code&gt; 구문을 보고합니다.
&lt;p&gt;모듈을 설치하고/거나 package.json에 포함할 것을 제안합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;require()&lt;/code&gt; 호출은 &lt;em&gt;Node.js Core&lt;/em&gt; JavaScript 라이브러리의 범위 내의 파일에서만 동작합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NpmUsedModulesInstalled&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="추상화 문제" path="Java"><inspection shortName="PublicMethodNotExposedInInterface" defaultSeverity="WARNING" displayName="인터페이스에 노출되지 않는 'public' 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인터페이스에 노출되지 않는 클래스 내 &lt;code&gt;public&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;인터페이스를 통해 모든 &lt;code&gt;public&lt;/code&gt; 메서드를 노출하는 것은 느슨한 결합을 유지하는 데 중요하며 특정 구성 요소 기반 프로그래밍 스타일을 위해 필수적일 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
interface Person {
  String getName();
}

class PersonImpl implements Person {
  private String name;

  // ok: 메서드가 인터페이스에서 노출됩니다
  @Override
  public String getName() {
    return name;
  }

  // 경고: 메서드가 public이지만
  // 인터페이스에서 노출되지 않습니다
  public void setName() {
    this.name = name;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;다음 어노테이션이 추가된 경우 무시&lt;/b&gt; 목록을 사용해 특수 어노테이션을 지정하세요. 이 어노테이션 중 하나가 추가된 인터페이스는 검사에서 무시됩니다.
&lt;p&gt;
  프로젝트의 인터페이스를 구현하지 않는 클래스의 메서드를 무시하려면 &lt;b&gt;포함하는 클래스가 비 라이브러리 인터페이스를 구현하지 않는 경우 무시&lt;/b&gt; 옵션을 사용하세요.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: PublicMethodNotExposedInInterface&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfConcreteClass" defaultSeverity="WARNING" displayName="구체 클래스 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인터페이스가 아닌 구체적 클래스의 사용을 보고합니다.
이 선언은 추상화의 실패를 나타낼 수 있으며, 테스트 과정은 더 어려워질 수 있습니다.
&lt;p&gt;
시스템 또는 제3자 라이브러리에서 유래하는 클래스 선언은 검사를 통해 보고되지 않습니다.
형 변환, instanceofs, 및 지역 변수는 &lt;code&gt;equals()&lt;/code&gt; 메서드 구현에서 보고되지 않습니다.
또는 형변환은 &lt;code&gt;clone()&lt;/code&gt; 메서드 구현에서 보고되지 않습니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface Entity {}
  class EntityImpl implements Entity {}

  void processObject(Object obj) {
    // 경고: 구체적 클래스의 instanceof
    if (obj instanceof EntityImpl) {
      // 경고: 인터페이스가 아닌
      // 구체적 클래스로의 형 변환
      processEntity((EntityImpl)obj);
    }
  }
  // 경고: 구체적 클래스의 매개변수
  void processEntity(EntityImpl obj) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;추상 클래스 타입 무시&lt;/b&gt; 옵션을 사용하여 추상 클래스로의 형 변환을 무시합니다.&lt;/p&gt;
&lt;p&gt;순차적인 옵션을 사용하여 문제가 보고된 컨텍스트를 제어합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UseOfConcreteClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeMayBeWeakened" defaultSeverity="WARNING" displayName="타입이 약화될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
더 추상적인(약한) 타입으로 변경 가능한 변수 및 메서드 반환 타입을 보고합니다.
이를 통해 더 추상적이며 재사용이 한층 용이한 코드를 만들 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 매개변수 타입을 java.util.List로 약화할 수 있습니다
  void processList(ArrayList&amp;lt;String&amp;gt; list) {
    if (list.isEmpty()) return;
    System.out.println("Processing");
    for (String s : list) {
      System.out.println("String: " + s);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  하단의 &lt;b&gt;인터페이스로 약화되는 경우만&lt;/b&gt; 체크박스를 활성화하면 해당 타입이 인터페이스 타입으로 약화될 수 있는 경우에만 문제가 보고됩니다.
&lt;/p&gt;
&lt;p&gt;
  하단의 &lt;b&gt;'var'로 선언된 변수 약화를 제안하지 않음&lt;/b&gt; 체크박스를 활성화하면 'var' 키워드를 사용해 선언된 지역 변수가 보고되지 않습니다(Java 10 이상).
&lt;/p&gt;
&lt;p&gt;
&lt;b&gt;stop 클래스&lt;/b&gt;는 가능한 경우 stop 클래스보다 낮은 클래스로 약화하지 않도록 방지합니다.
일부 경우엔 이를 통해 가독성을 개선할 수 있습니다.
&lt;p&gt;&lt;small&gt;Inspection ID: TypeMayBeWeakened&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InterfaceMethodClashesWithObject" defaultSeverity="WARNING" displayName="인터페이스 메서드가 'Object'의 메서드와 충돌" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;b&gt;java.lang.Object&lt;/b&gt; 클래스의 &lt;b&gt;protected&lt;/b&gt; 메서드 &lt;code&gt;clone()&lt;/code&gt; 및 &lt;code&gt;finalize()&lt;/code&gt;와 충돌하는 인터페이스 메서드를 보고합니다.
&lt;p&gt;인터페이스에서는 &lt;code&gt;java.lang.Object&lt;/code&gt; 메서드와 호환되지 않는 반환 타입을 갖는 이러한 메서드를 선언하는 것이 가능합니다.
  그러나 그러한 인터페이스를 구현하는 클래스는 컴파일할 수 없습니다.
  인터페이스가 함수형인 경우, 인터페이스에서 람다를 생성하는 것은 가능하지만 권장하지 않습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 경고: 이 인터페이스는 어떤 클래스에서도 구현될 수 없으며
  // 오로지 람다 또는 메서드 참조에 의해서만 구현될 수 있습니다
  interface MyInterface {
    double clone();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InterfaceMethodClashesWithObject&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalUsedAsFieldOrParameterType" defaultSeverity="WARNING" displayName="'Optional'이 필드 또는 매개변수 타입으로 사용되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;java.util.OptionalDouble&lt;/code&gt;, &lt;code&gt;java.util.OptionalInt&lt;/code&gt;, &lt;code&gt;java.util.OptionalLong&lt;/code&gt; 또는 &lt;code&gt;com.google.common.base.Optional&lt;/code&gt;이 필드 또는 매개변수의 타입으로 사용되는 경우를 보고합니다.
&lt;p&gt;"결과 없음"을 명확하게 나타낼 필요가 있는 라이브러리 메서드 반환 유형에 대한 제한된 메커니즘을 제공하기 위해 &lt;code&gt;Optional&lt;/code&gt; 설계되었습니다.&lt;/p&gt;
&lt;p&gt;클래스가 &lt;code&gt;Serializable&lt;/code&gt;이 되어야하는 경우 &lt;code&gt;java.util.Optional&lt;/code&gt;은 serializable이 아니므로 &lt;code&gt;java.util.Optional&lt;/code&gt; 타입을 사용하는 필드를 사용하면 문제가 될 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    Optional&amp;lt;String&amp;gt; name; // Optional 필드

    // Optional 매개변수
    void setName(Optional&amp;lt;String&amp;gt; name) {
      this.name = name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: OptionalUsedAsFieldOrParameterType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodOnlyUsedFromInnerClass" defaultSeverity="WARNING" displayName="내부 클래스에서만 사용되는 private 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드를 포함하는 클래스의 내부 클래스에서만 호출되는 &lt;code&gt;private&lt;/code&gt; 메서드를 보고합니다. 이러한 메서드는 해당 내부 클래스로 안전하게 이동할 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Outer {
  public static void main(String[] args) {
    new Inner().run(args[0]);
  }

  static class Inner {
    void run(String arg) {
      // isEmpty() 메서드는 내부 클래스에서만 사용됩니다
      // 내부 클래스로 이동을 고려해보세요
      if (!isEmpty(arg)) {
        System.out.println("Argument is supplied");
      }
    }
  }

  private static boolean isEmpty(String s) {
    return s != null &amp;&amp; s.trim().isEmpty();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
익명 또는 지역 클래스에서 호출되는 &lt;code&gt;private&lt;/code&gt; 메서드를 무시하려면 아래 첫 번째 체크박스를 사용합니다.
&lt;p&gt;
세 번째 체크박스는 &lt;code&gt;static&lt;/code&gt; 메서드를 보고할 때만 사용합니다.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: MethodOnlyUsedFromInnerClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyStrongTypeCast" defaultSeverity="WARNING" displayName="지나치게 강한 타입 형 변환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지나치게 강한 형 변환을 보고합니다. 예를 들어, 객체를 &lt;code&gt;List&lt;/code&gt;로 형 변환해도 적절하나 &lt;code&gt;ArrayList&lt;/code&gt;로 형 변환하는 경우가 있습니다.
&lt;p&gt;
  &lt;b&gt;참고:&lt;/b&gt; &lt;i&gt;불필요한 형 변환&lt;/i&gt; 검사와 마찬가지로, 의도적으로 지나치게 강한 형 변환을 사용하여 &lt;code&gt;ClassCastException&lt;/code&gt;을 생성한 경우 이 검사의 수정을 적용하면 프로그램의 의미가 변경될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface Super {
    void doSmth();
  }
  interface Sub extends Super { }

  void use(Object obj) {
    // 경고: ((Super)obj).doSmth()를 사용할 수 있습니다
    ((Sub)obj).doSmth();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  코드에 일치하는 &lt;code&gt;instanceof&lt;/code&gt; 검사가 있을 경우 형 변환을 무시하려면 아래 체크박스를 사용합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: OverlyStrongTypeCast&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceofThis" defaultSeverity="WARNING" displayName="'this'에 대한 'instanceof' 검사" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;this&lt;/code&gt; 표현식이 검사되는 &lt;code&gt;instanceof&lt;/code&gt; 또는 &lt;code&gt;getClass() == SomeClass.class&lt;/code&gt;의 사용 위치를 보고합니다.
&lt;p&gt;그러한 표현식은 객체 지향 디자인의 실패를 나타내며 다형성 생성으로 바꿔야 합니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Super {
  void process() {
    if (this instanceof Sub) { // 경고
      doSomething();
    } else {
      doSomethingElse();
    }
  }
}
  
class Sub extends Super {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;문제를 수정하려면 재정의 메서드를 사용하세요:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Super {
  void process() {
    doSomethingElse();
  }
}
  
class Sub extends Super {
  @Override
  void process() {
    doSomething();
  }
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InstanceofThis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MagicNumber" defaultSeverity="WARNING" displayName="매직 넘버" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상수 선언에서 이름이 지정되지 않은 숫자 리터럴인 '매직 넘버'를 보고합니다.
&lt;p&gt;매직 넘버를 사용하면 코드가 불분명해질 수 있으며, 매직 넘버가 한 위치에서는 변경되지만 다른 위치에서는 동일하게 유지되는 경우 오류가 발생할 수 있습니다. 숫자 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100, 1000, 0L, 1L, 2L, 0.0, 1.0, 0.0F 및 1.0F는 이 검사에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void checkFileSize(long bytes) {
    if (bytes &gt; 1_048_576) {
      throw new IllegalArgumentException("too big");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정은 새로운 상수를 도입합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static final int MAX_SUPPORTED_FILE_SIZE = 1_048_576;

  void checkFileSize(long bytes) {
    if (bytes &gt; MAX_SUPPORTED_FILE_SIZE) {
      throw new IllegalArgumentException("too big");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;'hashCode()' 메서드에서 상수 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;hashCode()&lt;/code&gt; 메서드 내에서 이 검사를 비활성화합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;어노테이션에서 무시&lt;/b&gt; 옵션을 사용하여 어노테이션의 매직 넘버를 무시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;StringBuilders 및 Collections의 초기 용량 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;Collection&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;StringBuilder&lt;/code&gt; 또는 &lt;code&gt;StringBuffer&lt;/code&gt; 객체 생성 시 초기 용량으로 사용된 매직 넘버를 무시합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: MagicNumber&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceofChain" defaultSeverity="WARNING" displayName="'instanceof' 검사 체인" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
조건이 모두 &lt;code&gt;instanceof&lt;/code&gt; 표현식 또는 클래스 상등 표현식인 &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; 문의 체인을 보고합니다(예: &lt;code&gt;String.class&lt;/code&gt;와 비교).
일반적으로 해당 구문은 타입 테스트의 명시적 체인보다는 다형적 메서드 호출을 통해 타입 기반 디스패치가 수행되도록 지시하는 객체 지향 설계의 실패를 의미합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double getArea(Shape shape) {
    // 경고: 추상화에 실패했습니다.
    // shape 인터페이스에서 getArea()
    // 추상 메서드를 선언하고
    // 모든 상속자에 구현하는 것이 좋습니다.
    if (shape instanceof Point) {
      return 0;
    }
    if (shape instanceof Circle) {
      return Math.PI *
        Math.pow(((Circle) shape).radius(), 2);
    }
    if (shape instanceof Rectangle) {
      return ((Rectangle) shape).width() *
        ((Rectangle) shape).height();
    }
    throw new IllegalArgumentException();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  하단의 체크박스를 사용하여 라이브러리 클래스의 &lt;code&gt;instanceof&lt;/code&gt; 표현식을 무시할 수 있습니다.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: InstanceofChain&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeclareCollectionAsInterface" defaultSeverity="WARNING" displayName="인터페이스가 아닌 클래스로 선언된 컬렉션" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
컬렉션 클래스를 적절한 인터페이스가 아닌 타입으로 사용하여 만든 &lt;code&gt;Collection&lt;/code&gt; 변수의 선언을 보고합니다. 변수 타입 약화로 컴파일 오류가 발생하면 경고가 표시되지 않습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 경고: 구체 컬렉션 클래스 ArrayList가 사용되어 있습니다.
  int getTotalLength(ArrayList&amp;lt;String&amp;gt; list) {
    return list.stream().mapToInt(String::length).sum();
  }

  // trimToSize() 메서드를 List 인터페이스에서
  // 사용할 수 없으므로 경고가 없습니다
  void addData(ArrayList&amp;lt;String&amp;gt; data) {
    data.add("Hello");
    data.add("World");
    data.trimToSize();
  }
&lt;/code&gt;&lt;/pre&gt;
빠른 수정은 적절한 컬렉션 인터페이스를 사용하도록 제안합니다(예: &lt;code&gt;Collection&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; 또는 &lt;code&gt;List&lt;/code&gt;).
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DeclareCollectionAsInterface&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassReferencesSubclass" defaultSeverity="WARNING" displayName="클래스가 하위 클래스 중 하나를 참조" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
하위 클래스 중 하나에 대한 참조를 포함하는 클래스를 보고합니다.
이러한 참조는 혼란을 유발하며 객체 지향 설계의 여러 규칙에 위배될 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Entity {
    // Warning: the class references its subclass
    void compare(SimpleEntity entity) {
      ...
    }
  }
  class SimpleEntity extends Entity {
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassReferencesSubclass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticMethodOnlyUsedInOneClass" defaultSeverity="WARNING" displayName="static 멤버가 다른 클래스에서만 사용됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
포함하는 클래스 외의 클래스에서만 사용되는 &lt;code&gt;static&lt;/code&gt; 메서드 및 필드를 보고합니다. 해당 멤버는 using 클래스로 이동할 수 있습니다.
이 검사는 멤버의 클래스 내부의 익명 클래스에서 액세스한 factory 메서드 및 멤버를 무시합니다.
동일 클래스에서 이름이 동일한 메서드를 호출하지만 매개변수 개수가 더 적은 편의 오버로드도 무시됩니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
static 멤버가 테스트 클래스에서만 사용되는 경우 첫 번째 체크박스를 선택하여 이 검사를 억제합니다.
&lt;p&gt;
익명 클래스, 지역 클래스 또는 static이 아닌 내부 클래스 내부의 멤버 사용을 무시하려면 아래의 두 번째 체크박스를 사용합니다.
&lt;p&gt;
문제 없이 이동이 불가능한 멤버에 대한 경고를 해제하려면 세 번째 체크박스를 사용합니다. 예를 들어, 시그니처가 동일한 메서드가 대상 클래스에 이미 있는 경우 혹은 메서드가 이동되면 메서드 내부에서 사용된 필드나 메서드에 액세스가 불가능한 경우 등이 이에 해당됩니다.
&lt;p&gt;
유틸리티 클래스에 있는 멤버를 무시하려면 네 번째 체크박스를 사용합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: StaticMethodOnlyUsedInOneClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FeatureEnvy" defaultSeverity="WARNING" displayName="기능에 대한 욕심" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;em&gt;기능에 대한 욕심&lt;/em&gt; 코드 스멜을 보고합니다. 메서드가 다른 클래스의 메서드를 세 번 이상 호출하면 경고가 발생합니다 라이브러리 클래스, 상위 클래스, 포함된 클래스 또는 포함하는 클래스에 대한 호출은 이 검사에서 고려되지 않습니다. 기능에 대한 욕심은 보통 해당 기능이 잘못된 클래스에 있다는 사실을 알려줍니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class JobManager {
    // 경고: 이 메서드는 Job 클래스의
    // 메서드 3개를 호출합니다
    // 이 호출 체인을
    // Job 클래스로 옮기는 것이 좋습니다
    void performJob(Job job) {
      job.beforeStart();
      job.process();
      job.afterProcessing();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FeatureEnvy&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanParameter" defaultSeverity="WARNING" displayName="'boolean' 매개변수가 있는 'public' 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;boolean&lt;/code&gt; 매개변수를 허용하는 public 메서드를 보고합니다.
&lt;p&gt;setter가 아닌 public 메서드(API의 일부)에 &lt;code&gt;boolean&lt;/code&gt; 매개변수를 추가하는 것은 대부분의 경우 나쁜 사례입니다.
그러한 메서드가 사용된 코드를 읽을 때 소스 또는 문서를 보지 않고는 &lt;code&gt;boolean&lt;/code&gt;이 무엇을 의미하는지 해석하기 어렵습니다.&lt;/p&gt;
&lt;p&gt;이 문제는 &lt;a href="https://ariya.io/2011/08/hall-of-api-shame-boolean-trap"&gt;boolean의 함정&lt;/a&gt;이라고도 불립니다.
  &lt;code&gt;boolean&lt;/code&gt; 매개변수는 보통 &lt;code&gt;enum&lt;/code&gt;으로 바꿀 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 경고: 이 메서드 호출을 보고
// boolean 매개변수의 의미를 이해하기 어렵습니다
  public boolean setPermission(File f,
                               int access,
                               boolean enable,
                               boolean ownerOnly) {
    // ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
메서드가 하나 이상의 부울 매개변수를 사용하는 경우에만 경고하려면 &lt;b&gt;부울 매개변수가 여러 개인 메서드만 보고&lt;/b&gt; 옵션을 사용합니다.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BooleanParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="불필요한 정의" path="Java/Lombok"><inspection shortName="RedundantSlf4jDefinition" defaultSeverity="WARNING" displayName="@Slf4j" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명시적으로 정의된 &lt;em&gt;Slf4j&lt;/em&gt; 로거를 보고합니다. &lt;code&gt;@Slf4j&lt;/code&gt; 어노테이션을 대신 사용할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantSlf4jDefinition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="코드 품질 도구" path="CSS"><inspection shortName="Stylelint" defaultSeverity="ERROR" displayName="Stylelint" enabled="false" language="CSS" pluginId="com.intellij.stylelint" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="http://stylelint.io"&gt;Stylelint&lt;/a&gt; linter에 의해 탐지된 차이를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;br/&gt;&lt;br/&gt;
강조 표시는 각각의 개별 규칙에 대한 &lt;a href="https://stylelint.io/user-guide/configure"&gt;Stylelint 구성 파일&lt;/a&gt;에 지정된 규칙 심각도를 기반으로 합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: Stylelint&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="SQL" path=""><inspection shortName="SqlUnicodeStringLiteralInspection" defaultSeverity="WARNING" displayName="SQL 내 유니코드 사용" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;N&lt;/code&gt; 접두사 없이 내셔널 문자를 사용하는 문자열 리터럴을 보고합니다.
&lt;p&gt;N 접두사가 없으면 문자열은 데이터베이스의 디폴트 코드 페이지로 변환됩니다. 이 디폴트 코드 페이지는 특정 문자를 인식하지 못할 수 있습니다. 더 자세한 내용은 &lt;a href="https://docs.microsoft.com/en-us/sql/t-sql/data-types/nchar-and-nvarchar-transact-sql" target="_blank"&gt;docs.microsoft.com에서 nchar 및 nvarchar(Transact-SQL)&lt;/a&gt;를 참고하세요.&lt;/p&gt;
&lt;p&gt;예시(Microsoft SQL 서버):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT 'abcde' AS a;
SELECT N'abcde' AS b;
SELECT 'абвгд' AS c;
SELECT N'абвгд' AS d;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SELECT 'абвгд' AS c;&lt;/code&gt;에는 &lt;code&gt;N&lt;/code&gt; 접두사가 없기 때문에 &lt;code&gt;'абвгд'&lt;/code&gt; 부분이 강조 표시됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlUnicodeStringLiteralInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlRedundantLimitInspection" defaultSeverity="WARNING" displayName="쿼리 내 불필요한 행 제한" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
쿼리 내에서 FETCH나 LIMIT과 같은 행 수를 제한하는 불필요한 절을 보고합니다.
&lt;p&gt;예시(PostgreSQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT);

SELECT * FROM foo WHERE EXISTS(SELECT * FROM foo LIMIT 2);
SELECT * FROM foo WHERE EXISTS(SELECT * FROM foo FETCH FIRST 2 ROWS ONLY);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경고를 해결하려면 제한하는 절에 OFFSET을 추가할 수 있습니다. OFFSET이 없는 경우 LIMIT은 EXISTS의 연산 결과에 영향을 주지 않기 때문에 불필요합니다. OFFSET이 있는 경우 첫 번째 &lt;code&gt;N&lt;/code&gt; 행을 건너뛰므로 출력에 영향을 미칩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM foo WHERE EXISTS(SELECT * FROM foo OFFSET 1 ROW LIMIT 2);
SELECT * FROM foo WHERE EXISTS(SELECT * FROM foo OFFSET 1 ROW FETCH FIRST 2 ROWS ONLY);&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlRedundantLimitInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlIllegalCursorStateInspection" defaultSeverity="WARNING" displayName="잘못된 커서 상태" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
SQL 루틴 내 잘못된 커서 상태를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;루틴에 CLOSE 또는 FETCH 구문이 있지만 커서가 닫혀 있을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;루틴에 OPEN 구문이 있지만 커서가 열려 있을 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시(Microsoft SQL 서버):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE t(col INT);

CREATE PROCEDURE foo() AS
BEGIN
DECLARE my_cursor CURSOR FOR SELECT * FROM t;
DECLARE a INT;
FETCH my_cursor INTO a;
CLOSE my_cursor;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/close-transact-sql"&gt;docs.microsoft.com의 CLOSE(Transact-SQL)&lt;/a&gt;에 따르면, CLOSE는 열린 커서에 발생되어야 하며, 선언되어 있기만 하거나 이미 닫혀 있는 커서에는 허용되지 않습니다. 그러므로 경고를 해결하려면 커서를 열어야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE PROCEDURE foo() AS
BEGIN
DECLARE my_cursor CURSOR FOR SELECT * FROM t;
DECLARE a INT;
OPEN my_cursor;
FETCH my_cursor INTO a;
CLOSE my_cursor;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlIllegalCursorStateInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlUnusedVariableInspection" defaultSeverity="WARNING" displayName="사용되지 않는 변수" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
사용되지 않은 인수, 변수, 또는 매개변수를 보고합니다.
&lt;p&gt;예시(PostgreSQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE FUNCTION foo(PARAMUSED INT, PARAMUNUSED INT) RETURNS INT AS
$$
BEGIN
    RETURN PARAMUSED;
END
$$ LANGUAGE plpgsql;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PARAMUNUSED&lt;/code&gt; 매개변수는 함수에서 사용되지 않으므로 삭제될 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlUnusedVariableInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlGotoInspection" defaultSeverity="WARNING" displayName="GOTO 문 사용 위치" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
역방향 GOTO 문 및 루프를 종료하기 위해 사용딘 GOTO 문의 사용 위치를 보고합니다.
&lt;p&gt;GOTO 문의 광범위한 사용은 일반적으로 권장되지 않습니다. 자세한 내용은 &lt;a href="https://www.ibm.com/docs/no/db2/11.5?topic=procedures-goto-statement-in-sql"&gt;ibm.com에서 SQL 프로시저의 GOTO 문&lt;/a&gt;을 참고하세요.&lt;/p&gt;

&lt;p&gt;GOTO를 사용해 이전 구문으로 돌아가는 대신 루프를 사용해 보세요.&lt;/p&gt;
&lt;p&gt;GOTO를 사용하여 WHILE 루프를 종료하는 대신 다른 흐름 제어 구문(예:RETURN 또는 BREAK)을 사용해 보세요.&lt;/p&gt;
&lt;p&gt;예시(Oracle):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE PROCEDURE test(n INT) AS
DECLARE
    x INT;
BEGIN
    x := 0;
    GOTO a;
    &amp;lt;&amp;lt;a&amp;gt;&amp;gt; x := 1;
    IF (n = 0) THEN
        GOTO a;
    END IF;
    WHILE TRUE
        LOOP
            GOTO b;
        END LOOP;
    &amp;lt;&amp;lt;b&amp;gt;&amp;gt; x := 3;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlGotoInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlDtInspection" defaultSeverity="WARNING" displayName="형식이 잘못된 날짜/시간 리터럴" enabled="false" language="SQLDateTime" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
날짜 및 시간 리터럴의 오류를 보고합니다. 이 검사는 MySQL, Oracle, Db2, H2에서 사용할 수 있습니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code lang="sql"&gt;SELECT TIME '10 -12:13:14' FROM dual;
SELECT TIME ' 12 : 13 : 14 ' FROM dual;
SELECT TIME '12 13 14' FROM dual;
SELECT TIME '12-13-14' FROM dual;
SELECT TIME '12.13.14' FROM dual;
SELECT TIME '12:13:' FROM dual;
SELECT TIME '12:13' FROM dual;
SELECT TIME '12:' FROM dual;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예시에서 날짜는 날짜 및 시간 리터럴에 관한 MySQL 표준을 무시합니다. 따라서 이는 강조 표시됩니다.
  날짜 및 시간 리터럴에 관한 더 자세한 내용은 &lt;a
    href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html"&gt;dev.mysql.com에서 날짜 및 시간 리터럴&lt;/a&gt;을 참고하세요.&lt;/p&gt;
&lt;p&gt;다음 날짜 및 시간 리터럴은 MySQL에서 유효합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code lang="sql"&gt;SELECT TIME '12:13:14' FROM dual;
SELECT TIME '12:13:14.555' FROM dual;
SELECT TIME '12:13:14.' FROM dual;
SELECT TIME '-12:13:14' FROM dual;
SELECT TIME '10 12:13:14' FROM dual;
SELECT TIME '-10 12:13:14' FROM dual;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlDtInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlTypeInspection" defaultSeverity="WARNING" displayName="타입 호환성" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
타입 관련 오류를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlTypeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlSignatureInspection" defaultSeverity="WARNING" displayName="함수 시그니처" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
기본 제공 함수에 대한 대표적인 이슈를 보고합니다.
&lt;p&gt;이 검사는 잘못된 인수 개수, 유효하지 않은 키워드, 잘못된 데이터 타입 등의 이슈를 보고합니다.&lt;/p&gt;
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo (a INT, b INT, c INT)

SELECT IFNULL() FROM foo; -- 오류
SELECT IFNULL(a) FROM foo; -- 오류
SELECT IFNULL(a, b) FROM foo; -- 문제 없음
SELECT IFNULL(a, b, c) FROM foo; -- 오류&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MySQL에서 &lt;code&gt;IFNULL()&lt;/code&gt; 함수는 엄격히 두 개의 인수를 수락합니다. 그러므로 &lt;code&gt;SELECT IFNULL(a, b) FROM foo;&lt;/code&gt;
쿼리만 올바릅니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlSignatureInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlUnreachableCodeInspection" defaultSeverity="WARNING" displayName="도달할 수 없는 코드" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
SQL 루틴 내 도달할 수 없는 구문을 보고합니다.
&lt;p&gt;예시(Microsoft SQL 서버):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE FUNCTION foo() RETURNS INT AS
BEGIN
    THROW;
    RETURN 1;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Microsoft SQL Server에서 &lt;code&gt;THROW&lt;/code&gt; 구문은 예외를 발생시키며 실행을 TRY...CATCH 구문의 CATCH 블록으로 보냅니다. 그러므로 &lt;code&gt;RETURN 1;&lt;/code&gt; 부분은 절대 실행되지 않습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlUnreachableCodeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlShouldBeInGroupByInspection" defaultSeverity="WARNING" displayName="열은 절 GROUP BY 절에 포함되어야 합니다" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
GROUP BY 절에서 또는 집계 함수 호출 내에서 사용되지 않는 열을 보고합니다.
&lt;p&gt;예시(Microsoft SQL 서버):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE t1 (a INT, b INT);
SELECT a, b FROM t1 GROUP BY a;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SELECT 쿼리를 실행하면 Microsoft SQL Server는 &lt;code&gt;b&lt;/code&gt; 열이 GROUP BY에서 사용되거나 집계 함수 내에서 사용될 것으로 기대하기 때문에 오류가 발생합니다. 다음 두 예시는 오류를 수정합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT a, b FROM t1 GROUP BY a, b;
SELECT a, max(b) max_b FROM t1 GROUP BY a;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlShouldBeInGroupByInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlCheckUsingColumnsInspection" defaultSeverity="WARNING" displayName="using 절의 열 검사" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
두 테이블 모두에 존재하지 않는 USING 절 내 열을 보고합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE t1 (i INT, j INT);
CREATE TABLE t2 (k INT, l INT);
SELECT * FROM t1 JOIN t2 USING (j);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;USING 절 안의 열 이름은 두 테이블 모두에 있어야 하며 SELECT 쿼리는 주어진 열 이름을 사용해 이 테이블을 자동으로 결합합니다. &lt;code&gt;t2&lt;/code&gt; 안에 &lt;code&gt;j&lt;/code&gt; 열이 없으므로 ON을 사용해 쿼리를 다시 작성할 수 있습니다. ON 절을 사용하면 두 테이블에서 열 이름이 일치하지 않는 경우 테이블을 결합할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM t1 JOIN t2 ON t1.j = t2.l;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlCheckUsingColumnsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlStringLengthExceededInspection" defaultSeverity="WARNING" displayName="묵시적 문자열 버림" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
정의된 문자 길이를 초과하는 변수를 보고합니다.
&lt;p&gt;예시(Microsoft SQL 서버):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE PROCEDURE test() AS
BEGIN
DECLARE myVarOk VARCHAR(5) = 'abcde';
DECLARE myVarExceeded VARCHAR(5) = 'abcde12345';

SET myVarOk = 'xyz';
SET myVarExceeded = '123456789';
END;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;myVarExceeded&lt;/code&gt; 변수는 &lt;code&gt;VARCHAR(5)&lt;/code&gt;로 정의되어 있으나 할당된 두 값(&lt;code&gt;'abcde12345'&lt;/code&gt; 및 &lt;code&gt;'123456789'&lt;/code&gt;)은 이 제한을 초과합니다. 할당된 값을 자르거나 정의된 길이를 늘릴 수 있습니다.
  길이를 늘리려면 &lt;b&gt;타입 길이 증가&lt;/b&gt; 빠른 수정을 사용하세요.
&lt;/p&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE PROCEDURE test() AS
BEGIN
DECLARE myVarOk VARCHAR(5) = 'abcde';
DECLARE myVarExceeded VARCHAR(10) = 'abcde12345';

SET myVarOk = 'xyz';
SET myVarExceeded = '123456789';
END;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlStringLengthExceededInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlConstantExpressionInspection" defaultSeverity="WARNING" displayName="상수 표현식" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
항상 true, false 또는 null인 조건 및 표현식을 보고합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE t1 (a TEXT, b INT, c BOOLEAN);
SELECT a FROM t1 WHERE 'Cat' = 'Cat';
SELECT a FROM t1 WHERE 'Cat' = null;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;'Cat' = 'Cat'&lt;/code&gt;은 항상 true이므로 보고됩니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;'Cat' = null&lt;/code&gt;은 항상 null이므로 보고됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlConstantExpressionInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlAutoIncrementDuplicateInspection" defaultSeverity="WARNING" displayName="자동 증분 중복" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
값이 자동으로 증가하는 두 열을 포함하는 테이블을 보고합니다. MySQL, Microsoft SQL Server 및 Db2 파생 언어에서 테이블은 값 자동 증가 옵션이 추가된 필드를 하나만 가질 수 있으며 이 필드는 키여야 합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE my_table
(
    id INT AUTO_INCREMENT,
    c2 INT AUTO_INCREMENT,
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;c1&lt;/code&gt;에 이 제약이 이미 추가되어 있으므로 &lt;code&gt;c2&lt;/code&gt;에 대한 AUTO_INCREMENT 제약이 강조 표시됩니다. 이 경고를 해결하려면 &lt;code&gt;id&lt;/code&gt;를 기본 키로 설정하고 &lt;code&gt;c2&lt;/code&gt;에 대한 AUTO_INCREMENT를 삭제하세요.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE my_table
(
    id INT AUTO_INCREMENT PRIMARY KEY,
    c2 INT,
);&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlAutoIncrementDuplicateInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SqlAmbiguousColumnInspection" defaultSeverity="WARNING" displayName="모호한 참조" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름은 동일하나 다른 테이블에 속한 열을 보고합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(id INT PRIMARY KEY);
CREATE TABLE bar(id INT PRIMARY KEY);

SELECT foo.id, bar.id FROM foo, bar WHERE id &gt; 0;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;id&lt;/code&gt; 열이 &lt;code&gt;foo&lt;/code&gt; 테이블과 &lt;code&gt;bar&lt;/code&gt; 테이블에 나타납니다. 열 이름을 정규화하여 쿼리를 올바르게 고쳐야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT foo.id, bar.id FROM foo, bar WHERE foo.id &gt; 0;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlAmbiguousColumnInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlDuplicateColumnInspection" defaultSeverity="WARNING" displayName="SELECT 내 열 이름 중복" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
SELECT 목록 내 중복된 열 별칭 이름을 보고합니다.
&lt;p&gt;예(Sybase ASE):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE t1 (a TEXT, b INT, c INT);

SELECT a AS x, b AS x FROM t1;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; 별칭 이름이 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 열에서 사용되었습니다. Sybase ASE에서는 여러 열에 대해 같은 별칭 이름을 사용할 수 없기 때문에 이러한 대입은 오류로 강조 표시됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlDuplicateColumnInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlShadowingAliasInspection" defaultSeverity="WARNING" displayName="별칭에 의해 가려진 열" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
FROM 절의 열 이름과 일치하는 이름을 사용하는 SELECT 별칭을 보고합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo (a INT, b INT, c INT);
SELECT a b, c FROM foo;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;a&lt;/code&gt; 열은 &lt;code&gt;b&lt;/code&gt; 별칭을 사용하지만 &lt;code&gt;b&lt;/code&gt; 이름은 &lt;code&gt;foo&lt;/code&gt; 테이블의 열에서도 사용됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlShadowingAliasInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlCurrentSchemaInspection" defaultSeverity="WARNING" displayName="현재 콘솔 스키마의 내부 검사 여부" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
현재 세션 내 내부 검사되지 않은 스키마 및 데이터베이스를 보고합니다.
&lt;p&gt;예를 들어, 이 경고는 내부 검사 되지 않은 스키마에서 테이블을 생성하려고 할 때 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;내부 검사는 데이터 소스를 검사하는 방법입니다. 내부 검사를 수행하면 테이블, 열, 함수, 그 외 요소와 속성을 탐지하기 위해 데이터 소스의 구조 정보가 검사됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlCurrentSchemaInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlAddNotNullColumnInspection" defaultSeverity="WARNING" displayName="디폴트 값 없이 not null 열 추가" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
DEFAULT 값 없이 NOT NULL 열을 생성하려는 시도를 보고합니다.
&lt;p&gt;예시(Microsoft SQL 서버):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo (a INT, b  INT)

ALTER TABLE foo ADD c INT NOT NULL;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;디폴트로 열은 NULL 값을 가집니다. 이 예에서는 열이 NULL 값을 수락하지 않도록 강제하는 NOT NULL 제약을 사용합니다.
  NULL 값 사용을 금지할 경우, 새 레코드 생성 시 SQL이 사용할 수 있는 DEFAULT 값을 설정해야 합니다.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE foo ADD c INT NOT NULL DEFAULT 42;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;디폴트 값 추가&lt;/b&gt; 빠른 수정을 사용하여 DEFAULT 값을 빠르게 추가할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlAddNotNullColumnInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlMisleadingReferenceInspection" defaultSeverity="WARNING" displayName="오해의 여지가 있는 참조" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
애매한 SQL 코드 참조를 보고합니다.
&lt;p&gt;예를 들어, 이름이 테이블 열과 루틴 매개변수를 둘 다 참조하는 경우를 말합니다. 그러한 코드를 실행하면 반직관적인 해결 로직으로 인해 오류 또는 예기치 않은 결과를 초래할 수 있습니다. 보통 더 좁은(로컬) 스코프를 가진 이름이 우선순위가 더 높습니다.&lt;/p&gt;
    &lt;p&gt;예시(PostgreSQL):&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;CREATE TABLE foo
(
    id   INT,
    name VARCHAR(5)
);
CREATE FUNCTION func(name VARCHAR(5)) RETURNS INT AS
$$
DECLARE
    b INT;
BEGIN
      -- 'name'은 열 이름 및 매개변수로 사용되므로 모호함
    SELECT COUNT(*) INTO b FROM foo t WHERE t.name = name;
    RETURN b;
END;
$$ LANGUAGE plpgsql;&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;PostgreSQL에서는 &lt;code&gt;#variable_conflict&lt;/code&gt; 지시문을 사용하여 올바른 참조를 명시적으로 지정할 수 있습니다. 예를 들어,
&lt;code&gt;#variable_conflict use_column&lt;/code&gt;를 사용해 열의 이름을 참조하거나 &lt;code&gt;#variable_conflict use_variable&lt;/code&gt;를 사용해 매개변수를 참조하세요.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo
(
    id   INT,
    name VARCHAR(5)
);
CREATE FUNCTION func(name VARCHAR(5)) RETURNS INT AS
$$
    #variable_conflict use_column
DECLARE
    b INT;
BEGIN
    SELECT COUNT(*) INTO b FROM foo t WHERE t.name = name;
    RETURN b;
END;
$$ LANGUAGE plpgsql;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlMisleadingReferenceInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SqlIdentifierInspection" defaultSeverity="WARNING" displayName="식별자는 따옴표로 묶어야 합니다" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
SQL 예약 키워드를 쿼리 안에서 식별자 이름으로 사용하는 경우를 보고합니다.
&lt;p&gt;예시(Microsoft SQL 서버):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE select (identity INT IDENTITY NOT NULL, order INT NOT NULL);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;테이블 및 열 이름으로 &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;identity&lt;/code&gt;, &lt;code&gt;order&lt;/code&gt;를 사용합니다.
  하지만 이러한 이름 역시 Microsoft SQL Server의 예약 키워드입니다.
  따라서 이러한 식별자를 객체 이름으로 사용하려면 따옴표로 묶어야 합니다. 식별자를 따옴표로 묶기 위해 &lt;b&gt;식별자에 따옴표 추가&lt;/b&gt; 빠른 수정을 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE [select] ([identity] INT IDENTITY NOT NULL, [order] INT NOT NULL);&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlIdentifierInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlInsertIntoGeneratedColumnInspection" defaultSeverity="WARNING" displayName="생성된 열로 삽입" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
생선된 열에 값을 할당하는 INSERT 문을 보고합니다. 생성된 열은 읽을 수 있지만 해당 열의 값은 직접 쓸 수는 없습니다.
&lt;p&gt;예시(PostgreSQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo
(
   col1 INT,
   col2 INT GENERATED ALWAYS AS (col1 + 1) STORED
);
INSERT INTO foo(col1, col2) VALUES (1, 2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt;를 생성된 열인 &lt;code&gt;col2&lt;/code&gt; 열에 삽입할 수 없습니다.
  이 스크립트가 작동하려면 &lt;code&gt;2&lt;/code&gt;를 DEFAULT로 변경해야 합니다.&lt;/p&gt;
&lt;code&gt;INSERT INTO foo(col1, col2) VALUES (1, DEFAULT);&lt;/code&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlInsertIntoGeneratedColumnInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlDerivedTableAliasInspection" defaultSeverity="WARNING" displayName="각 파생 테이블에는 별칭이 있어야 합니다" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
별칭이 없는 파생 테이블을 보고합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE table1 (id INT, name VARCHAR(20), cats FLOAT);
CREATE TABLE table2 (id INT, age INTEGER);

SELECT id AS ID, name, cats, age
FROM (SELECT table1.id, name, cats, age
FROM table1
JOIN table2 ON table1.id = table2.id);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/derived-tables.html"&gt;dev.mysql.com의 파생 테이블&lt;/a&gt;에 따르면 별칭은 필수입니다. &lt;b&gt;별칭 삽입&lt;/b&gt; 빠른 수정을 사용하여 별칭을 추가할 수 있습니다.&lt;/p&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT id AS ID, name, cats, age
FROM (SELECT table1.id, name, cats, age
FROM table1
JOIN table2 ON table1.id = table2.id);&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlDerivedTableAliasInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlTransactionStatementInTriggerInspection" defaultSeverity="WARNING" displayName="트리거 내 트랜잭션 관리 구문 사용" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
트리거 본문 내 COMMIT 또는 ROLLBACK과 같은 트랜잭션 관리 구문의 사용 위치를 보고합니다.
&lt;p&gt;트리거 본문 내 COMMIT 또는 ROLLBACK 구문을 사용하면 트리거는 컴파일되지 않습니다.
  트랜잭션 도중에 트리거가 시작되기 때문에 실패가 발생합니다. 트리거가 시작될 때 현재 트랜잭션은 아직 완료되지 않은 상태입니다. COMMIT이 트랜잭션을 종료하면 두 구문(COMMIT 및 ROLLBACK) 모두 예외를 일으킵니다.
  트리거 내에서 실행되는 변경은 트리거를 시작한 소유 트랜잭션에 의해 커밋(또는 롤백)되어야 합니다.&lt;/p&gt;
&lt;p&gt;예시(Oracle):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE employee_audit
(
    id          INT  NOT NULL,
    update_date DATE NOT NULL,
    old_name    VARCHAR2(100),
    new_name    VARCHAR2(100)
);

CREATE TABLE employees
(
    id   INT           NOT NULL,
    name VARCHAR2(100) NOT NULL
);

CREATE OR REPLACE TRIGGER trig_commit
    AFTER UPDATE OF name
    ON employees
    FOR EACH ROW
BEGIN
    INSERT INTO employee_audit VALUES (:old.id, SYSDATE, :old.name, :new.name);
    COMMIT;
END;

CREATE OR REPLACE TRIGGER trig_rollback
    AFTER UPDATE OF name
    ON employees
    FOR EACH ROW
BEGIN
    INSERT INTO employee_audit VALUES (:old.id, SYSDATE, :old.name, :new.name);
    ROLLBACK;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlTransactionStatementInTriggerInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlNamedArgumentsInspection" defaultSeverity="WARNING" displayName="이름이 지정된 인수를 사용해야 함" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루틴 호출 시 이름 없이 사용되는 인수를 보고합니다. 디폴트로 이 검사는 비활성화되어 있습니다.
&lt;p&gt;명명된 매개변수와 명명되지 않은 매개변수의 차이에 관한 더 자세한 내용은 &lt;a
    href="https://docs.microsoft.com/en-us/sql/odbc/reference/develop-app/binding-parameters-by-name-named-parameters"&gt;docs.microsoft.com에서 이름으로 매개변수 바인딩(명명된 매개변수)&lt;/a&gt;를 참고하세요.&lt;/p&gt;
&lt;p&gt;예시(Microsoft SQL 서버):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE FUNCTION foo(n INT, m INT) RETURNS INT AS
BEGIN
    RETURN n + m;
END;

CREATE PROCEDURE test AS
BEGIN
    foo n = 1, m = 2;

--- 다음 호출에 매개변수 이름이 누락되어 강조 표시됨
    foo 1, 2;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;foo 1, 2;&lt;/code&gt; 호출 내 매개변수 &lt;code&gt;1, 2&lt;/code&gt;는 이름이 없으므로 강조 표시됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlNamedArgumentsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlDeprecateTypeInspection" defaultSeverity="WARNING" displayName="더 이상 사용되지 않는 타입" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이후 버전의 DBMS에서 사용할 수 없게 될 타입의 사용 위치를 보고합니다.
&lt;p&gt;보고된 타입:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Oracle: LONG(&lt;a href="https://docs.oracle.com/cd/A91202_01/901_doc/server.901/a90120/ch4_dep.htm#6690" target="_blank"&gt;docs.oracle.com에서 지원이 중단되어 곧 사용할 수 없게 될 기능&lt;/a&gt;을 참고하세요).
  &lt;/li&gt;
  &lt;li&gt;Microsoft SQL Server: TEXT, NTEXT, IMAGE(&lt;a
      href="https://docs.microsoft.com/en-us/sql/database-engine/deprecated-database-engine-features-in-sql-server-2016?view=sql-server-ver15"
      target="_blank"&gt;docs.microsoft.com에서 SQL Server 2016에서 사용되지 않는 데이터베이스 엔진 기능&lt;/a&gt;을 참고하세요).
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시(Oracle):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE ot.foo(
a NUMBER GENERATED BY DEFAULT AS IDENTITY,
b LONG NOT NULL
);&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlDeprecateTypeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlCallNotationInspection" defaultSeverity="ERROR" displayName="이름 지정된 인수 및 위치 인수 사용" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
위치 인수가 명명된 인수 뒤에 오는 호출을 보고합니다. PostgreSQL, Oracle, Db2에서 작동합니다.
&lt;p&gt;예(PostgreSQL 내):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE FUNCTION foo(a int, b int, c int) RETURNS int
    LANGUAGE plpgsql AS
$$
BEGIN
    RETURN a + b + c;
END
$$;
SELECT foo(a =&gt; 1, b =&gt; 2, c =&gt; 3);
  -- '3'이 명명된 인수 뒤에 옴
SELECT foo(1, b =&gt; 2, 3);
  -- '1' 및 '3'이 명명된 인수 뒤에 옴 
SELECT foo(b =&gt; 2, 1, 3);&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlCallNotationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlCaseVsIfInspection" defaultSeverity="WARNING" displayName="조건 함수 대신 CASE 사용 및 그 반대" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
CASE 및 IF를 서로 교체할 수 있는 경우를 보고합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CASE
WHEN C1 IS NULL THEN 1
ELSE 0
END
FROM dual;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드를 간결하게 유지하기 위해 CASE 구조를 IF로 교체할 수 있습니다. &lt;b&gt;'IF' 호출로 바꾸기&lt;/b&gt; 인텐션 액션을 적용하여 실행할 수 있습니다. 예시 코드는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT IF(C1 IS NULL, 1, 0)
FROM dual;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IF를 CASE로 되돌리려면 IF를 클릭하고 &lt;b&gt;CASE 식으로 바꾸기&lt;/b&gt; 인텐션 액션을 적용하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlCaseVsIfInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlInsertNullIntoNotNullInspection" defaultSeverity="WARNING" displayName="NOT NULL 열에 NULL 삽입 " enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
NOT NULL 값 이외에는 받지 않는 열에 NULL 값을 삽입하는 경우를 보고합니다.
&lt;p&gt;예시(Microsoft SQL 서버):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE br2 (
id INT NOT NULL,
col1 NVARCHAR (20) NOT NULL,
col2 NVARCHAR (20) NOT NULL,
);
--
INSERT INTO br2 (id, col1, col2)
VALUES (1, NULL, NULL);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;col1&lt;/code&gt; 및 &lt;code&gt;col2&lt;/code&gt;는 NOT NULL로 정의되어 있기 때문에 이 열에는 NULL 값을 삽입할 수 없습니다. 스크립트를 그대로 실행하면 오류가 발생합니다. 이 코드를 수정하려면 VALUES 부분의 NULL을 어떤 값으로 바꾸세요(예: &lt;code&gt;42&lt;/code&gt; 및 &lt;code&gt;'bird'&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;INSERT INTO br2 (id, col1, col2)
VALUES (1, 42, 'bird');&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlInsertNullIntoNotNullInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlWithoutWhereInspection" defaultSeverity="WARNING" displayName="where 절 없는 구문 삭제 또는 업데이트" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
WHERE 절이 없는 DELETE 또는 UPDATE 구문을 보고합니다.
  &lt;p&gt;WHERE 절이 없으면 DELETE는 테이블의 모든 데이터를 삭제하며 UPDATE는 모든 테이블 행의 값을 덮어씁니다.&lt;/p&gt;
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE t1 (a TEXT, b INT, c BOOLEAN);
update t1 set  a = 'Smith';
delete from t1;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlWithoutWhereInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SqlMultipleLimitClausesInspection" defaultSeverity="WARNING" displayName="쿼리 내 여러 행 limiting/offset 절" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
하나의 쿼리 안에서 행 수를 제한하는 절이 여러 개 사용된 경우를 보고합니다.

&lt;p&gt;예시(Microsoft SQL 서버):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table foo(a int);
select top 1 * from foo order by a offset 10 rows fetch next 20 rows only;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;오직 1개의 레코드가 반환되어야 함을 지정하기 위해 SELECT TOP 절이 사용되었습니다. FETCH 절은 OFFSET 절이 처리된 후 반환할 행의 개수를 지정합니다. 하지만 SELECT TOP 제한 절이 이미 있으므로 FETCH 절은 불필요합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlMultipleLimitClausesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlJoinWithoutOnInspection" defaultSeverity="WARNING" displayName="'delete' 문의 안전하지 않은 'join' 절" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
데이터베이스 전체를 변경할 수 있는 구문에 대한 누락된 조건 검사를 보고합니다.
&lt;p&gt;예를 들어, DELETE 구문 내에서 ON 또는 WHERE이 없이 JOIN 절이 사용된 경우를 말합니다. JOIN 조건 검사가 없으면 
DELETE는 전체 테이블의 내용을 삭제합니다.&lt;/p&gt;
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo (a INT,b INT,c INT);
CREATE TABLE bar (a INT,b INT,c INT);

DELETE table1 FROM foo table1  INNER JOIN bar table2;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlJoinWithoutOnInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SqlRedundantCodeInCoalesceInspection" defaultSeverity="WARNING" displayName="COALESCE 호출 내 불필요한 코드" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
COALESCE 함수에서 NULL로 평가되지 않는 첫 번째 표현식을 제외한 모든 인수를 보고합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT COALESCE(NULL, NULL, NULL, 42, NULL, 'string') as a;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;첫 번째 NOT NULL 인수는 &lt;code&gt;42&lt;/code&gt;이며 다른 인수는 회색으로 표시됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlRedundantCodeInCoalesceInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlDialectInspection" defaultSeverity="WARNING" displayName="SQL 파생 언어 탐지" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
파생 언어가 SQL 파일에 할당되어 있지 않은 경우를 보고합니다.
&lt;p&gt;예를 들어, 파생 언어를 연결하지 않고 새 SQL 파일을 열면 가장 적절한 파생 언어를 권장하는 알림이 나타납니다. &lt;b&gt;&amp;lt;파생 언어&amp;gt;사용&lt;/b&gt;을 클릭하여 권장된 파생 언어를 사용하세요. 아니면 &lt;b&gt;파생 언어를 다음으로 변경...&lt;/b&gt; 링크를 클릭하여 다른 파생 언어를 선택하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlDialectInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlTriggerTransitionInspection" defaultSeverity="WARNING" displayName="트리거 내 의심스러운 코드" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
트리거 내 전이 테이블 변수의 잘못된 사용 위치를 보고합니다.
&lt;p&gt;예(HSQLDB):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT);

CREATE TRIGGER trg
 AFTER DELETE ON foo
BEGIN
   SELECT * FROM NEW;
END;

CREATE TRIGGER trig AFTER INSERT ON foo
   REFERENCING OLD ROW AS newrow
   FOR EACH ROW WHEN (a &gt; 1)
   INSERT INTO foo VALUES (1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HSQLDB에서 DELETE 트리거는 OLD 상태로만 사용될 수 있는 반면 INSERT 트리거는 NEW 상태만 가질 수 있습니다. 따라서 이전 예에서 &lt;code&gt;SELECT * FROM NEW;&lt;/code&gt;의 NEW는 &lt;code&gt;REFERENCING OLD ROW AS newrow&lt;/code&gt;의 OLD와 함께 강조 표시됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlTriggerTransitionInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlUnusedCteInspection" defaultSeverity="WARNING" displayName="사용되지 않는 공통 테이블 식" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
쿼리 내 사용되지 않은 공통 테이블 표현식(CTE)을 보고합니다.
&lt;p&gt;예시(PostgreSQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT);

WITH a AS (SELECT 1 AS x FROM foo)
SELECT 1 + 2 FROM foo;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;WITH를 사용하여 &lt;code&gt;a&lt;/code&gt;라는 이름이 임시로 지정된 결과 집합을 생성합니다. 이 결과 집합은 공통 테이블식(CTE)이라고도 불립니다. 하지만 나중에 코드에서 이 CTE를 사용하지 않습니다. 사용되지 않은 CTE는 회색으로 표시됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlUnusedCteInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlMissingReturnInspection" defaultSeverity="ERROR" displayName="return 문 누락" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
RETURN 문이 없는 함수를 보고합니다.

&lt;p&gt;예시(Oracle):&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;CREATE FUNCTION foo RETURN int AS
BEGIN
END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;foo&lt;/code&gt; 함수는 정수 값을 반환해야 하지만 함수 본문은 아무 것도 반환하지 않습니다. 이 오류를 수정하려면 RETURN 문을 추가하세요(예: &lt;code&gt;return 1;&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE FUNCTION foo RETURN int AS
BEGIN
 RETURN 1;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlMissingReturnInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlSideEffectsInspection" defaultSeverity="WARNING" displayName="부수 효과가 있는 구문" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
읽기 전용 연결 중에 데이터베이스를 변경할 수 있는 구문을 보고합니다. &lt;p&gt;연결에 대한 읽기 전용 모드를 활성화하려면 &lt;b&gt;데이터베이스&lt;/b&gt; 도구 창(&lt;b&gt;뷰 | 도구 창 | 데이터베이스&lt;/b&gt;)에서 데이터 소스를 오른쪽 클릭하고 &lt;b&gt;프로퍼티&lt;/b&gt;를 선택하세요.
  &lt;b&gt;드라이버 및 데이터 소스 및 드라이버&lt;/b&gt; 대화상자에서 &lt;b&gt;옵션&lt;/b&gt; 탭을 클릭하고 &lt;b&gt;읽기 전용&lt;/b&gt; 체크박스를 선택하세요.&lt;/p&gt;
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT);
INSERT INTO foo VALUES (1);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CREATE TABLE&lt;/code&gt; 및 &lt;code&gt;INSERT INTO&lt;/code&gt; 구문은 데이타베이스의 내용을 변경하기 때문에, 읽기 전용 연결 모드에서는 강조 표시됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlSideEffectsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlJoinCountInspection" defaultSeverity="WARNING" displayName="과도한 JOIN 수" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JOINS가 과도하게 많은 쿼리를 보고합니다.
&lt;p&gt;JOIN을 과도하게 사용하는 것은 성능을 고려하여 권장되지 않습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM a inner join b using(id) inner join c using (id) inner join d using (id) inner join e using (id)&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlJoinCountInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlSingleSessionModeInspection" defaultSeverity="WARNING" displayName="단일 세션 모드를 사용하지 않고 임시 테이블 생성" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단일 세션 모드가 아닐 때 임시 테이블이 생성되면 보고합니다.
&lt;p&gt;예시(PostgreSQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TEMPORARY TABLE foo(a INT, b INT);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlSingleSessionModeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlResolveInspection" defaultSeverity="ERROR" displayName="해결되지 않는 참조" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해결되지 않은 SQL 참조를 보고합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE users(id INT, name VARCHAR(40));
CREATE TABLE admins(id INT, col1 INT);

SELECT users.id, admins.id FROM admins WHERE admins.id &gt; 1;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;FROM 절에 &lt;code&gt;users&lt;/code&gt; 테이블이 누락되어 있기 때문에 &lt;code&gt;users.id&lt;/code&gt; 열을 해결할 수 없습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlResolveInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlUnusedSubqueryItemInspection" defaultSeverity="WARNING" displayName="사용하지 않는 하위 쿼리 항목" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
외부 쿼리 식에서 참조되지 않은 열, 별칭 등 하위 쿼리 항목 등을 보고합니다.
&lt;p&gt;예시(PostgreSQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE for_subquery(id INT);
SELECT a, q FROM (SELECT 1 AS a, 10 AS b, 2 + 3 AS q, id
      FROM for_subquery) x;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하위 쿼리에서 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;q&lt;/code&gt;를 참조합니다. 하지만 &lt;code&gt;b&lt;/code&gt; 별칭 및 &lt;code&gt;id&lt;/code&gt; 열은 외부 SELECT 문에서 참조되지 않습니다. 그러므로 &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;id&lt;/code&gt;가 회색으로 표시됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlUnusedSubqueryItemInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlRedundantElseNullInspection" defaultSeverity="WARNING" displayName="불필요한 ELSE NULL 절" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 ELSE NULL 절을 보고합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CASE WHEN 2 &gt; 1 THEN 'OK' ELSE NULL END AS alias FROM foo;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ELSE NULL&lt;/code&gt; 부분은 실행되지 않으므로 생략됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlRedundantElseNullInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlAggregatesInspection" defaultSeverity="WARNING" displayName="집계 관련 문제" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
SQL 집계 함수의 유효하지 않은 사용 위치를 보고합니다.
&lt;p&gt;다음 상황이 포함됩니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;HAVING 및 ORDER BY 절에서 사용되었으나 GROUP BY에서 누락된 열.&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;CREATE TABLE foo(id INT PRIMARY KEY, a INT, b INT);
SELECT a, MAX(b) FROM foo GROUP BY a HAVING b &gt; 0;
SELECT * FROM foo GROUP BY a ORDER BY b;&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;그룹화가 기본 키를 기준으로 이루어진 경우에는 이 규칙이 적용되지 않습니다.&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;SELECT * FROM foo GROUP BY id ORDER BY b;&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;p&gt;잘못된 컨텍스트에 사용된 집계 함수. 일반적으로 다음 컨텍스트에서 집계 함수를 사용할 수 있습니다: SELECT, HAVING 및 ORDER BY 섹션, 다른 파생 언어 전용 케이스 내 표현식 목록. 다음 쿼리를 실행하면 오류가 표시됩니다.&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;SELECT a FROM foo WHERE MAX(b) &gt; 0;
SELECT a FROM foo GROUP BY MAX(a);&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;p&gt;중첩된 집계 함수 호출.&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;SELECT MAX(SUM(a)) FROM foo GROUP BY a;&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;이 규칙은 분석 함수에 적용되지 않습니다. 다음 쿼리는 유효하며 올바릅니다.&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;SELECT MAX(SUM(a) OVER ()) FROM foo;&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;p&gt;집계 함수가 없이 HAVING을 사용한 경우입니다. 이 경우, WHERE 섹션을 사용해 코드를 다시 작성해 보세요.&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;SELECT a, MAX(b) FROM foo GROUP BY a HAVING a &gt; 0;&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlAggregatesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlNoDataSourceInspection" defaultSeverity="WARNING" displayName="구성된 데이터 소스가 없습니다" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;b&gt;Database&lt;/b&gt; 도구 창(&lt;b&gt;뷰 | 도구 창 | 데이터베이스&lt;/b&gt;) 내 데이터 소스의 부재를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlNoDataSourceInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlRedundantAliasInspection" defaultSeverity="WARNING" displayName="불필요한 별칭 표현식" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
테이블의 열 이름과 중복되어 불필요할 수 있는 별칭 표현식을 보고합니다.
&lt;p&gt;예시(PostgreSQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT, b INT);

SELECT * FROM foo foo(a, b);
SELECT * FROM foo foo(a);
SELECT * FROM foo foo(x);
SELECT * FROM foo foo(x, y);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;처음 두 별칭은 &lt;code&gt;foo&lt;/code&gt; 테이블의 열 이름과 같은 이름을 사용합니다. 이 두 별칭은 열 이름과 동일하므로 불필요한 것으로 간주됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlRedundantAliasInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlInsertValuesInspection" defaultSeverity="WARNING" displayName="VALUES 절 카디널리티" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
VALUES 내 매개변수 개수가 대상 테이블의 열 개수와 일치하지 않는 경우를 보고합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT, b INT, c INT);

INSERT INTO foo VALUES (1,2,3,4)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;foo&lt;/code&gt; 테이블에는 세 개의 열이 있으나 INSERT INTO 문에서 네 개의 열을 전달합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlInsertValuesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlRedundantOrderingDirectionInspection" defaultSeverity="WARNING" displayName="불필요한 정렬 방향" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
ORDER BY 절에서 ASC 및 DESC 등의 정렬 순서 지시가 불필요한 경우를 보고합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT, b INT, c INT);
SELECT * FROM foo ORDER BY a ASC, b DESC, c ASC;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ORDER BY 키워드는 디폴트로 레코드를 오름차순으로 나열합니다. 그러므로 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 열의 &lt;code&gt;ASC&lt;/code&gt; 키워드는 불필요합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlRedundantOrderingDirectionInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlDropIndexedColumnInspection" defaultSeverity="WARNING" displayName="색인은 열에 종속됨" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
색인화된 테이블에서 열을 삭제하려고 하는 경우를 보고합니다. 이 검사는 Microsoft SQL Server 및 Sybase ASE에서 사용할 수 있습니다.
&lt;p&gt;예시(Microsoft SQL 서버):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test_index
(
col  INT NOT NULL,
col2 INT NOT NULL,
col3 INT NOT NULL UNIQUE,
col4 VARCHAR(200)
);

CREATE UNIQUE INDEX aaaa ON test_index (col, col2);

ALTER TABLE test_index
DROP COLUMN col;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;col&lt;/code&gt; 열은 색인화된 테이블에 있기 때문에 삭제할 수 없습니다. 열을 삭제하려면 &lt;code&gt;aaaa&lt;/code&gt; 색인을 먼저 삭제해야 합니다(예: DROP INDEX aaaa).&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlDropIndexedColumnInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SqlCaseVsCoalesceInspection" defaultSeverity="WARNING" displayName="COALESCE 함수 대신 CASE 사용 및 그 반대" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
CASE 및 COALESCE 호출을 서로 교체할 수 있는 경우를 보고합니다. 이 검사는 &lt;b&gt;'COALESCE' 호출로 바꾸기&lt;/b&gt; 인텐션 액션 및 그 반대인 &lt;b&gt;CASE 식으로 바꾸기&lt;/b&gt; 인텐션 액션을 포함합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT
  -- 이 CASE는 COALESCE으로 바꿀 수 있음
	CASE
		WHEN C1 IS NOT NULL THEN C1
		ELSE 0
		END
FROM dual;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예에서, CASE 식은 동일한 결과를 출력하는 &lt;code&gt;SELECT COALESCE(C1, 0)&lt;/code&gt;로 바꿀 수 있습니다.&lt;/p&gt;
&lt;p&gt;CASE 식을 사용하고 싶은 경우는, 검사 페이지에서 &lt;b&gt;COALESCE 함수보다 CASE 식 선호&lt;/b&gt; 옵션을 선택하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlCaseVsCoalesceInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlStorageInspection" defaultSeverity="WARNING" displayName="SQL 소스 수정 탐지" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
데이터베이스 객체의 소스 코드가 변경된 경우를 보고합니다.
  &lt;p&gt;이 검사는 데이터베이스 또는 객체 내부 검사를 수행할 경우 촉발됩니다. 내부 검사는 객체의 소스 코드를 열거나 구문을 실행하거나 코드 리팩토링을 수행할 경우 실행됩니다.
  객체를 오른쪽 클릭하고 &lt;b&gt;새로고침&lt;/b&gt;을 선택하여 내부 검사를 실행할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;이 검사는 다음 경우를 포함합니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체 소스 코드가 데이터베이스에서 변경되었으나 에디터 내 코드가 업데이트되지 않은 경우. PostgreSQL, Microsoft SQL Server, Oracle, Sybase ASE에서 작동합니다.&lt;/li&gt;
  &lt;li&gt;객체 소스 코드를 변경하고 데이터베이스를 내부 검사했으나 소스 코드가 이미 다른 사람에 의해 변경된 경우.&lt;/li&gt;
  &lt;li&gt;데이터베이스 내부 검사기가 IDE에서 업데이트되었으며 이전 내부 검사기 버전에서 누락된 새 객체 프로퍼티를 다운로드해야 하는 경우.&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlStorageInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlMissingColumnAliasesInspection" defaultSeverity="WARNING" displayName="열 별칭 누락" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
출력 표현식(예: SELECT 구문 내)에 명시적 별칭이 없는 쿼리를 보고합니다.
&lt;p&gt;예시(PostgreSQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo(a INT, b INT);

SELECT 1, a + 1 AS A2, MAX(b) AS M
FROM foo;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SqlMissingColumnAliasesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="EL" path=""><inspection shortName="ELValidationInspection" defaultSeverity="WARNING" displayName="EL 유효성 검사" enabled="false" language="EL" pluginId="com.intellij.javaee.el" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해결되지 않은 참조 및 잘못된 EL 위치 등 가능한 EL 문제를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ELValidationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="이름 지정 규칙" path="Groovy"><inspection shortName="GroovyLocalVariableNamingConvention" defaultSeverity="WARNING" displayName="지역 변수 이름 지정 규칙" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길거나 지정된 정규 표현식 패턴을 따르지 않는 지역 변수를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 제공된 필드를 사용하여 지역 변수 이름에 필요한 최소 길이, 최대 길이 및 정규 표현식을 지정하세요.&lt;/p&gt;
&lt;p&gt;정규 표현식은 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식으로 지정되어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyLocalVariableNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInstanceVariableNamingConvention" defaultSeverity="WARNING" displayName="인스턴스 변수 이름 지정 규칙" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나, 너무 길거나, 지정된 정규 표현식 패턴을 따르지 않는
인스턴스 변수를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 아래 제공된 필드를 사용하여 인스턴스 변수 이름에 필요한 최소 길이, 최대 길이 및 정규 표현식을 지정하세요.&lt;/p&gt;
&lt;p&gt;정규 표현식은 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식으로 지정되어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyInstanceVariableNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NewGroovyClassNamingConvention" defaultSeverity="WARNING" displayName="클래스 이름 지정 규칙" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;이름이 너무 짧거나 너무 길거나 지정된 정규 표현식 패턴을 따르지 않는 클래스를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;각 클래스 타입에 대해 제공된 입력 필드를 사용하여 최소 길이, 최대 길이, 클래스 이름에 필요한 정규 표현식을 지정하세요.&lt;/p&gt;
&lt;p&gt;정규 표현식은 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식으로 지정되어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NewGroovyClassNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyStaticVariableNamingConvention" defaultSeverity="WARNING" displayName="static 변수 이름 지정 규칙" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길거나 지정된 정규 표현식 패턴을 따르지 않는 &lt;code&gt;static&lt;/code&gt; 변수를 보고합니다.
&lt;p&gt;
  상수(예: &lt;code&gt;static final&lt;/code&gt;을 선언한 불변 타입의 변수)는 여기에서 검사되지 않습니다
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 아래 제공된 필드를 사용하여 정적 변수 이름에 필요한 최소 길이, 최대 길이 및 정규 표현식을 지정하세요.
&lt;p&gt;정규 표현식은 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식으로 지정되어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyStaticVariableNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConstantNamingConvention" defaultSeverity="WARNING" displayName="상수 이름 지정 규칙" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지정한 규칙과 일치하지 않는 이름을 가진 상수를 보고합니다.
&lt;p&gt;상수는 &lt;code&gt;static&lt;/code&gt; 및 &lt;code&gt;final&lt;/code&gt; 제어자를 사용하여 선언된 불변 타입의 필드입니다.&lt;/p&gt;
이름이 너무 짧거나, 너무 길거나, 지정된 정규식 패턴을 따르지 않는 상수를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;상수 이름과 일치시킬 &lt;code&gt;java.util.regex.Pattern&lt;/code&gt;을 지정하려면 &lt;b&gt;Pattern&lt;/b&gt; 필드를 사용하세요.&lt;/li&gt;
  &lt;li&gt;상수 이름의 최소 길이를 지정하려면 &lt;b&gt;최소 길이&lt;/b&gt; 필드를 사용하세요.&lt;/li&gt;
  &lt;li&gt;상수 이름의 최대 길이를 지정하려면 &lt;b&gt;최대 길이&lt;/b&gt; 필드를 사용하세요.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyConstantNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInstanceMethodNamingConvention" defaultSeverity="WARNING" displayName="인스턴스 메서드 이름 지정 규칙" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나, 너무 길거나, 지정된 정규 표현식 패턴을 따르지 않는
인스턴스 메서드를 보고합니다. 라이브러리 메서드를 재정의하는 인스턴스 메서드는 이 검사에서 무시됩니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 제공된 필드를 사용하여 인스턴스 메서드 이름으로 기대되는 최소 길이, 최대 길이 및 정규 표현식을 지정하세요.&lt;/p&gt;
&lt;p&gt;정규 표현식은 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식으로 지정되어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyInstanceMethodNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyParameterNamingConvention" defaultSeverity="WARNING" displayName="메서드 매개변수 이름 지정 규칙" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길거나 지정된 정규 표현식 패턴을 따르지 않는 메서드 매개변수를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 제공된 필드를 사용하여 메서드 매개변수 이름에 필요한 최소 길이, 최대 길이 및 정규 표현식을 지정하세요.&lt;/p&gt;
&lt;p&gt;정규 표현식은 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식으로 지정되어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyParameterNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyStaticMethodNamingConvention" defaultSeverity="WARNING" displayName="static 메서드 이름 지정 규칙" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길거나 지정된 정규 표현식 패턴을 따르지 않는 static 메서드를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 제공된 필드를 사용하여 static 메서드 이름에 필요한 최소 길이, 최대 길이 및 정규 표현식을 지정하세요.&lt;/p&gt;
&lt;p&gt;정규 표현식은 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식으로 지정되어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyStaticMethodNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="테인트 구성" path=""><inspection shortName="TaintConfigAnnotator" defaultSeverity="WARNING" displayName="테인트 구성 어노테이터" enabled="false" language="JAVA" pluginId="com.intellij.jvm.dfa.analysis" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  &lt;p&gt;이 검사는 메서드 호출을 강조 표시하여 테인트 분석 구성을 시각화 합니다.&lt;/p&gt;
  &lt;p&gt;테인트 구성은 어떠한 메서드가 소스, 싱크, 패스스루 혹은 사용자 지정 전달 규칙으로 간주되는지 결정합니다.&lt;/p&gt;
  &lt;p&gt;정의된 테인트 분석 구성이 없는 메서드를 참조하는 메서드 호출의 경우 적절한 구성을 추가할 수 있도록 검사가 빠른 수정을 제공합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TaintConfigAnnotator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="코드 메트릭" path=""><inspection shortName="JvmLinesOfCodeInspection" defaultSeverity="WARNING" displayName="Kotlin 및 Java 코드 메트릭 계산" enabled="false" language="UAST" pluginId="org.intellij.qodana" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
코드 행 수를 셉니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JvmLinesOfCodeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="코드 스타일 이슈" path="JavaScript 및 TypeScript"><inspection shortName="ConstantOnLHSOfComparisonJS" defaultSeverity="WARNING" displayName="비교 중인 왼쪽의 상수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/ConstantOnWrongSideOfComparison.html --&gt;
&lt;html&gt;
&lt;body&gt;
왼쪽에 상수 값이 있는 비교 연산을 보고합니다. 코드 규칙에 따라
상수는 비교의 오른쪽에 위치해야 합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ConstantOnLHSOfComparisonJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantOnRHSOfComparisonJS" defaultSeverity="WARNING" displayName="비교 중인 오른쪽의 상수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/ConstantOnWrongSideOfComparison.html --&gt;
&lt;html&gt;
&lt;body&gt;
오른쪽에 상수가 있는 비교 연산을 보고합니다. 코드 규칙에 따라 
상수는 비교의 왼쪽에만 위치할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ConstantOnRHSOfComparisonJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ChainedFunctionCallJS" defaultSeverity="WARNING" displayName="체인 함수 호출" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대상이 다른 함수 호출인 함수 호출을 보고합니다(예: &lt;code&gt;foo().bar()&lt;/code&gt;).
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ChainedFunctionCallJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSRemoveUnnecessaryParentheses" defaultSeverity="INFORMATION" displayName="불필요한 소괄호" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 소괄호를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;표현식 내:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x = ((1) + 2) + 3&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;화살표 함수 인수 목록 내:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var incrementer = (x) =&gt; x + 1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TypeScript 및 Flow 타입 선언 내:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="typescript"&gt;type Card = (Suit &amp; Rank) | (Suit &amp; Number)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JSRemoveUnnecessaryParentheses&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonBlockStatementBodyJS" defaultSeverity="WARNING" displayName="중괄호가 없는 구문 본문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 블록 구문이 아닌 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, 또는 &lt;code&gt;with&lt;/code&gt; 구문을 보고합니다.  구문 내 코드 블록 사용은 보통 다운스트림 관리에 더 안전합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NonBlockStatementBodyJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnterminatedStatementJS" defaultSeverity="WARNING" displayName="종료되지 않은 구문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
세미콜론 또는 새 줄로 끝나지 않는 구문을 보고합니다.
&lt;p&gt;&lt;i&gt;에디터 | 코드 스타일 | JavaScript 또는 TypeScript - 문장 부호&lt;/i&gt;에서 '세미콜론으로 구문 종료' 옵션을 선택하여 새 줄이 사용된 경우라도 세미콜론으로 끝나지 않는 모든 구문을 보고하십시오.
일부 코드 스타일에 따르면 다른 언어와의 일관성을 위해 줄 바꿈보다 세미콜론을 선호합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnterminatedStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedFunctionCallJS" defaultSeverity="WARNING" displayName="중첩된 함수 호출" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 함수 호출에 인수로 사용된 함수 호출을 보고합니다(예: &lt;code&gt;foo(bar())&lt;/code&gt;).
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NestedFunctionCallJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSArrowFunctionBracesCanBeRemoved" defaultSeverity="INFORMATION" displayName="화살표 함수 본문 주변의 불필요한 중괄호" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 중괄호와 정확히 하나의 구문으로 구성되는 화살표 함수를 보고합니다.
중괄호가 없는 간결한 구문으로 변환할 것을 제안합니다.
&lt;!-- tooltip end --&gt;
&lt;pre&gt;&lt;code&gt;
    let incrementer = (x) =&gt; {return x + 1};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 코드 조각은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    let incrementer = (x) =&gt; x + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JSArrowFunctionBracesCanBeRemoved&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ChainedEqualityJS" defaultSeverity="WARNING" displayName="체인 상등" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
체인 상등 비교를 보고합니다(예: &lt;code&gt;a==b==c&lt;/code&gt;).  그러한 비교는 혼란을 일으킵니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ChainedEqualityJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSDeclarationsAtScopeStart" defaultSeverity="WEAK WARNING" displayName="'var'이 함수의 시작 부분에 선언되지 않음" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;b&gt;var&lt;/b&gt;로 선언된 지역 변수 선언이 함수 범위의 맨 위에 위치하는지 검사합니다.
&lt;br/&gt;&lt;br/&gt;
코드가 실행될 때 디폴트로 변수 선언이 항상 변수를 포함하는 스코프의 맨 위로 보이지 않게 이동됩니다(끌어올려집니다).
그러므로 스코프의 맨 위에서 변수를 선언하면 코드 내에서 이 동작을 나타내기 쉬워집니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSDeclarationsAtScopeStart&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUndefinedPropertyAssignment" defaultSeverity="WEAK WARNING" displayName="정의되지 않은 프로퍼티 대입" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
변수의 타입에 정의되지 않는 프로퍼티에 대한 대입을 보고합니다. &lt;p&gt;예: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * @type {{ property1: string, property2: number }}
 */
let myVariable = create();

myVariable.newProperty = 3; // 나쁨
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSUndefinedPropertyAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="AOP" path=""><inspection shortName="DeclareParentsInspection" defaultSeverity="ERROR" displayName="인트로덕션(상위 항목 선언) 오류" enabled="false" language="AOPTarget" pluginId="com.intellij.aop" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@AspectJ&lt;/code&gt; 도입 부정합을 보고합니다. &lt;code&gt;default Impl&lt;/code&gt;이 필요한지 확인하고, 필요한 경우 주어진 인터페이스를 구현하는지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DeclareParentsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointcutMethodStyleInspection" defaultSeverity="WARNING" displayName="포인트컷 메서드 스타일" enabled="false" language="AOPTarget" pluginId="com.intellij.aop" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@Pointcut&lt;/code&gt; 메서드의 유효성(&lt;code&gt;void&lt;/code&gt; 반환 타입, 누락된 &lt;code&gt;throws&lt;/code&gt; 절, 빈 메서드 본문)을 검사합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PointcutMethodStyleInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArgNamesErrorsInspection" defaultSeverity="ERROR" displayName="어드바이스 매개변수(argNames, returning, throwing) 일관성 검사" enabled="false" language="AOPTarget" pluginId="com.intellij.aop" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@AspectJ&lt;/code&gt; &lt;code&gt;argNames&lt;/code&gt; 속성 값이 실제 메서드 매개변수 이름과 일치하지 않는 경우를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ArgNamesErrorsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AroundAdviceStyleInspection" defaultSeverity="WARNING" displayName="어라운드 어드바이스 스타일 검사" enabled="false" language="AOPTarget" pluginId="com.intellij.aop" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@Around&lt;/code&gt; 어드바이스 사용 시 다음 두 가지를 기억하세요.
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;org.aspectj.lang.ProceedingJoinPoint#proceed&lt;/code&gt;를 호출해야 합니다. 그러지 않으면 호출이 대상에 도달하지 못합니다.&lt;/li&gt;
  &lt;li&gt;해당 호출의 결괏값(&lt;code&gt;java.lang.Object&lt;/code&gt; 타입)을 반환해야 합니다. 그러지 않으면 반환값이 원래 호출자에 도달하지 못합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;하지만 다음 두 조건은 거의 항상 코딩 오류를 나타냅니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;@Around&lt;/code&gt; 메서드의 시그니처가 &lt;code&gt;ProceedingJoinPoint&lt;/code&gt;를 첫 번째 인수로 갖지 않습니다. 이 경우 호출이 대상에 도달하지 못합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Around&lt;/code&gt; 메서드의 시그니처가 &lt;code&gt;Object&lt;/code&gt;를 반환 타입으로 갖지 않습니다. 이 경우 대상 메서드의 반환값이 항상 손실됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AroundAdviceStyleInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AopLanguageInspection" defaultSeverity="ERROR" displayName="포인트컷 표현 오류" enabled="false" language="PointcutExpression" pluginId="com.intellij.aop" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;AOP 포인트컷 식 내의 문제를 보고합니다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;미해결 참조&lt;/li&gt;
  &lt;li&gt;포인트컷에 호환되지 않는 개수의 인수&lt;/li&gt;
  &lt;li&gt;해결되지 않은 포인트컷&lt;/li&gt;
  &lt;li&gt;기타&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AopLanguageInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArgNamesWarningsInspection" defaultSeverity="WARNING" displayName="경고: argNames가 정의되지 않았습니다" enabled="false" language="AOPTarget" pluginId="com.intellij.aop" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@AspectJ&lt;/code&gt; 어노테이션에 &lt;code&gt;argNames&lt;/code&gt; 속성이 정의되지 않은 경우를 보고합니다.
&lt;p&gt;메서드 매개변수 이름은 런타임 시 사용 불가할 수 있으므로 &lt;code&gt;@AspectJ&lt;/code&gt; 어노테이션에 &lt;code&gt;argNames&lt;/code&gt; 속성을 정의하는 것이 좋습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ArgNamesWarningsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="메모리" path="Java"><inspection shortName="InnerClassMayBeStatic" defaultSeverity="WARNING" displayName="내부 클래스가 'static'이 될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;static&lt;/code&gt;이 될 수 있는 내부 클래스를 보고합니다.
&lt;p&gt;&lt;code&gt;static&lt;/code&gt; 내부 클래스는 둘러싸는 인스턴스에 대한 묵시적 참조를 유지하지 않습니다.
  Java 17 이전 버전을 사용하는 경우, 이를 통해 메모리 누수의 일반적 원인을 방지하고, 클래스의 인스턴스당 메모리 사용량을 줄일 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Outer {
    &lt;b&gt;class&lt;/b&gt; Inner { // not static
      &lt;b&gt;public void&lt;/b&gt; foo() {
        bar("x");
      }

      &lt;b&gt;private void&lt;/b&gt; bar(String string) {}
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Outer {
    &lt;b&gt;static class&lt;/b&gt; Inner {
      &lt;b&gt;public void&lt;/b&gt; foo() {
        bar("x");
      }

      &lt;b&gt;private void&lt;/b&gt; bar(String string) {}
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InnerClassMayBeStatic&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnOfInnerClass" defaultSeverity="WARNING" displayName="익명, 지역 또는 내부 클래스의 인스턴스 반환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
익명, 지역 또는 내부 클래스의 인스턴스를 반환하는 &lt;code&gt;return&lt;/code&gt; 문을 보고합니다.
그러한 인스턴스는 외부 인스턴스에 대한 묵시적 참조를 유지하여 외부 인스턴스가 가비지 수집을 하지 않도록 방지할 수 있습니다.
그러한 인스턴스를 반환하는 메서드의 호출자는 반환된 인스턴스를 계속 보유하고 있으므로 메모리 누수의 원인이 될 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 구성:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;비 public 메서드로부터의 반환 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;protected&lt;/code&gt; 또는 package-private 메서드로부터의 반환을 무시합니다.
    &lt;code&gt;private&lt;/code&gt; 메서드로부터의 반환은 항상 무시됩니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReturnOfInnerClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousInnerClassMayBeStatic" defaultSeverity="WARNING" displayName="익명 클래스가 이름 지정된 'static' 내부 클래스가 될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;static&lt;/code&gt; 내부 클래스로 안전하게 바꿀 수 있는 익명 클래스를 보고합니다.
익명 클래스는 주변 메서드의 로컬 클래스 또는 둘러싸는 인스턴스를 명시적으로 참조하지 않는 경우 &lt;code&gt;static&lt;/code&gt; 내부 클래스일 수 있습니다.
&lt;p&gt;
&lt;code&gt;static&lt;/code&gt; 내부 클래스는 둘러싸는 인스턴스에 대한 묵시적 참조를 유지하지 않습니다.
이를 통해 메모리 누수의 일반적 원인이 방지되며, 클래스 인스턴스당 메모리 사용량이 감소합니다.
&lt;/p&gt;
&lt;p&gt;
  Java 18부터 이 참조가 사용되지 않는 경우, 직렬화 가능한 익명 클래스만이 둘러싸는 인스턴스에 대한
묵시적 참조를 유지합니다. 따라서 모듈 언어 수준이 Java 18 이상인 경우, 이 검사는 직렬화 가능한 클래스만 보고합니다.
&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 익명 클래스를 명명된 &lt;code&gt;static&lt;/code&gt; 내부 클래스로 추출합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void sample() {
    Thread thread = new Thread(new Runnable() {
      @Override
      public void run() {
      }
    });
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void sample() {
    Thread thread = new Thread(new Task());
  }

  private static class Task implements Runnable {
    @Override
    public void run() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AnonymousInnerClassMayBeStatic&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryEmptyArrayUsage" defaultSeverity="WARNING" displayName="길이가 0인 배열의 불필요한 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열 요소 타입의 클래스에 상수가 있을 경우 알려진 길이가 0인 배열의 대입을 보고합니다.
길이가 0인 배열은 불변이므로 동일한 배열 인스턴스를 재사용하여 메모리를 절약할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Item {
    // 재사용 가능한 길이가 0인 배열의 Public 상수
    public static final Item[] EMPTY_ARRAY = new Item[0];
  }
  class EmptyNode {
    Item[] getChildren() {
      // 길이가 0인 배열의 불필요한 생성
      return new Item[0];
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EmptyNode {
    Item[] getChildren() {
      return Item.EMPTY_ARRAY;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryEmptyArrayUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringBufferField" defaultSeverity="WARNING" displayName="'StringBuilder' 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.StringBuffer&lt;/code&gt; 또는 &lt;code&gt;java.lang.StringBuilder&lt;/code&gt; 타입의 필드를 보고합니다.
그러한 필드는 제한 없이 확장될 수 있어 메모리 누수의 원인이 되는 경우가 많습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Example {
    private StringBuilder builder = new StringBuilder();

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringBufferField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ZeroLengthArrayInitialization" defaultSeverity="WARNING" displayName="제로 길이 배열 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
알려진 길이가 0인 배열의 할당을 보고합니다.
&lt;p&gt;
  Java 에서 배열 길이를 변경할 수 없으므로 새로운 배열을 반복적으로 할당하는 것보다 길이 0의 배열을 공유하는 것은 거의 항상 가능합니다. 이러한 공유는 프로그램 런타임 또는 점유 공간을 유용하게 최적화할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  이 검사는 static final 필드로 할당된 길이가 0인 배열을 보고하지 않습니다. 이 배열은 배열 공유를 구현하기 위해 사용되는 것으로 생각할 수 있기 때문입니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ZeroLengthArrayInitialization&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticCollection" defaultSeverity="WARNING" displayName="static 컬렉션" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Collection&lt;/code&gt; 타입의 static 필드를 보고합니다. 이것은 반드시 문제가 되지는 않지만 static 컬렉션은 메모리 누수의 원인이 되는 경우가 많아 일부 코드 표준에서 금지됩니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Example {
    static List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 구성:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;취약한 static 컬렉션 또는 맵 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;java.util.WeakHashMap&lt;/code&gt; 타입의 필드를 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StaticCollection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemGC" defaultSeverity="WARNING" displayName="'System.gc()' 또는 'Runtime.gc()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;System.gc()&lt;/code&gt; 또는 &lt;code&gt;Runtime.gc()&lt;/code&gt; 호출을 보고합니다.
테스트에서 유용한 경우도 있지만 명시적으로 &lt;code&gt;System.gc()&lt;/code&gt;를 사용한 명시적인 가비지 수집을 트리거하는 것은 프로덕션 코드에서 거의 권장되지 않으며 심각한 성능 문제를 유발할 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SystemGC&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="GitHub 액션" path=""><inspection shortName="MandatoryParamsAbsent" defaultSeverity="ERROR" displayName="잘못된 매개변수" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.github" pluginVersion="252.23892.515-IU" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  액션의 디폴트 값이 없는 필수 매개변수가 누락된 경우를 보고합니다. 또한, 빈 값으로 누락된 매개변수를 추가하는 빠른 수정을 제공합니다.
&lt;/p&gt;
&lt;p&gt;
  액션 매개변수에 관한 자세한 정보는 &lt;a href="https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#runsstepswith"&gt;GitHub 문서&lt;/a&gt;를 참조하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MandatoryParamsAbsent&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IllegalJobDependency" defaultSeverity="ERROR" displayName="정의되지 않은 잡 종속성" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.github" pluginVersion="252.23892.515-IU" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  GitHub 워크플로 YML 파일에서 정의되지 않은 잡의 종속성을 탐지합니다.
&lt;/p&gt;
&lt;p&gt;
  워크플로 구문에 관한 자세한 정보는 &lt;a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idneeds"&gt;GitHub Actions 문서&lt;/a&gt;를 참조하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IllegalJobDependency&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CyclicJobDependency" defaultSeverity="ERROR" displayName="순환 잡 종속성" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.github" pluginVersion="252.23892.515-IU" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  GitHub 워크플로 YML 파일 내 잡의 순환적 종속성을 탐지합니다.
&lt;/p&gt;
&lt;p&gt;
  워크플로 구문에 관한 자세한 정보는 &lt;a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idneeds"&gt;GitHub Actions 문서&lt;/a&gt;를 참조하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CyclicJobDependency&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GithubFunctionSignatureValidation" defaultSeverity="WARNING" displayName="표준 라이브러리 함수 검증" enabled="false" language="GithubExpressionLanguage" pluginId="org.jetbrains.plugins.github" pluginVersion="252.23892.515-IU" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  잘못된 GitHub Actions Expression 언어의 표준 라이브러리 함수 호출을 보고합니다
&lt;p&gt;
  GitHub Actions Expression 언어에 관한 자세한 정보는 &lt;a href="https://docs.github.com/en/actions/learn-github-actions/expressions"&gt;GitHub 문서&lt;/a&gt;를 참조하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GithubFunctionSignatureValidation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UndefinedParamsPresent" defaultSeverity="WARNING" displayName="정의되지 않은 매개변수" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.github" pluginVersion="252.23892.515-IU" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  액션에서 정의되지 않은 매개변수가 있는 경우를 보고합니다. 또한, 정의되지 않은 매개변수를 제거하는 빠른 수정을 제공합니다.
&lt;/p&gt;
&lt;p&gt;
  액션 매개변수에 관한 자세한 정보는 &lt;a href="https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#runsstepswith"&gt;GitHub 문서&lt;/a&gt;를 참조하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UndefinedParamsPresent&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UndefinedAction" defaultSeverity="WARNING" displayName="정의되지 않은 액션/파일 참조" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.github" pluginVersion="252.23892.515-IU" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  GitHub 액션 및 워크플로 파일에서 해결되지 않은 액션 참조를 탐지합니다.
&lt;/p&gt;
&lt;p&gt;
  액션 참조에 관한 자세한 정보는 &lt;a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsuses"&gt;GitHub 문서&lt;/a&gt;를 참조하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UndefinedAction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 15" path="Java/Java 언어 수준 마이그레이션 지원"><inspection shortName="TextBlockBackwardMigration" defaultSeverity="INFORMATION" displayName="텍스트 블록을 일반 문자열 리터럴로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
일반 문자열 리터럴로 대체 가능한 텍스트 블록을 보고합니다. 
이 검사는 이전 Java 버전과의 하위 호환성을 위해 다운그레이드하는 데 도움이 될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object obj = engine.eval("""
                           function hello() {
                             print('"Hello, world"');
                           }

                           hello();
                           """);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object obj = engine.eval("function hello() {\n" +
                           "  print('\"Hello, world\"');\n" +
                           "}\n" +
                           "\n" +
                           "hello();\n");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 15부터 사용할 수 있는 Java 기능 &amp;#39;텍스트 블록 리터럴&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TextBlockBackwardMigration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TextBlockMigration" defaultSeverity="WARNING" displayName="텍스트 블록 사용 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
텍스트 블록으로 대체하여 단순화할 수 있는 &lt;code&gt;String&lt;/code&gt; 연결을 보고합니다.
&lt;p&gt;요건:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;\n&lt;/code&gt;이 2번 이상 발생&lt;/li&gt;
  &lt;li&gt;텍스트 블록이 연결되지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;b&gt;단일 문자열 리터럴 보고&lt;/b&gt; 옵션을 사용하면 줄 바꿈이 포함된 단일 리터럴이 강조 표시됩니다.
옵션이 비활성화되어 있어도 빠른 수정은 사용할 수 있습니다.
&lt;p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String html = "&amp;lt;html&amp;gt;\n" +
                "    &amp;lt;body&amp;gt;\n" +
                "        &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt;\n" +
                "    &amp;lt;/body&amp;gt;\n" +
                "&amp;lt;/html&amp;gt;\n";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String html = """
                &amp;lt;html&amp;gt;
                    &amp;lt;body&amp;gt;
                        &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt;
                    &amp;lt;/body&amp;gt;
                &amp;lt;/html&amp;gt;
                """;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 15부터 사용할 수 있는 Java 기능 &amp;#39;텍스트 블록 리터럴&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TextBlockMigration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Dev Container" path=""><inspection shortName="DevcontainerFolder" defaultSeverity="ERROR" displayName="Dev Container 폴더 구조 문제" enabled="false" language="JSON" pluginId="org.jetbrains.plugins.docker.gateway" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
모호한 개발 컨테이너 컨텍스트를 포함하거나 상위 .devcontainer 폴더가 필요한데 누락된 .devcontainer 폴더를 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DevcontainerFolder&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DevContainerIdeSettings" defaultSeverity="ERROR" displayName="IDE 설정 검증" enabled="false" language="JSON" pluginId="org.jetbrains.plugins.docker.gateway" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
IDE 설정 이름 및 값을 검증합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DevContainerIdeSettings&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="가시성" path="Java"><inspection shortName="MethodOverridesStaticMethod" defaultSeverity="WARNING" displayName="메서드가 상위 클래스의 'static' 메서드를 재정의하려고 함" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상위 클래스의 &lt;code&gt;static&lt;/code&gt; 메서드와 시그니처가 동일한 &lt;code&gt;static&lt;/code&gt; 메서드를 보고합니다.
Java의 &lt;code&gt;static&lt;/code&gt; 메서드가 재정의될 수 없으므로 이와 같은 메서드가 실제로는 상위 클래스의 메서드를 숨긴 것이지만, 재정의처럼 보일 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    static void method(){}
  }

  class Example extends Parent {
    static void method(){} //경고
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MethodOverridesStaticMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalVariableHidingMemberVariable" defaultSeverity="WARNING" displayName="지역 변수가 필드를 숨김" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
주변 클래스와 이름이 동일하게 지정된 지역 변수를 보고합니다.
이와 같이 이름이 지정될 경우, 필드를 사용하려다가 동일한 이름의 변수를 실수로 사용할 수 있습니다.
&lt;p&gt;빠른 수정에서는 변수 이름을 변경하도록 제안합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {
    public Object foo;

    void bar() {
      Object o = new Object() {
        void baz() {
          Object foo; // 지역 변수 'foo'는 클래스의 필드 'Foo'를 숨깁니다
        }
      };
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 검사에서 다음 옵션을 구성할 수 있습니다.
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;액세스할 수 없는 필드 무시&lt;/strong&gt; - 표시되지 않는 상위 클래스 필드(예: private 필드)와 이름이 동일한 지역 변수를 무시합니다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비 static 필드를 숨기는 static 컨텍스트의 지역 변수 무시&lt;/strong&gt; - 
예를 들어 지역 변수가 static 메서드 내부에 있거나 static 내부 클래스의 메서드 내부에 있을 경우 무시합니다.
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LocalVariableHidingMemberVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeParameterHidesVisibleType" defaultSeverity="WARNING" displayName="타입 매개변수가 표시되는 타입을 숨김" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 현재 범위에서 보이는 타입과 동일한 타입 매개변수를 보고합니다. 그러한 매개변수 이름은 혼동될 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class MyList&amp;lt;T&amp;gt; extends AbstractList&amp;lt;T&amp;gt; {
    private List&amp;lt;T&amp;gt; elements;
    // 타입 매개변수 'T'가 타입 매개변수 'T'를 숨깁니다
    public &amp;lt;T&amp;gt; T[] toArray(T[] array) {
        return elements.toArray(array);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TypeParameterHidesVisibleType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PatternVariableHidesField" defaultSeverity="WARNING" displayName="패턴 변수가 필드를 숨김" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
주변 클래스와 이름이 동일하게 지정된 패턴 변수를 보고합니다.
이와 같이 이름이 지정될 경우, 필드를 사용하려다가 동일한 이름의 패턴 변수를 실수로 사용할 수 있습니다.
&lt;p&gt;
  빠른 수정에서는 변수 이름을 변경하도록 제안합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Pointless {
    Point p = new Point();

    public void test(Object a) {
      if (a instanceof Point p) {
        System.out.print("a is a point (" + p.x + ", " + p.y + ')');
      } else {
        System.out.print("p is a point (" + p.x + ", " + p.y + ')');
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PatternVariableHidesField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaParameterHidingMemberVariable" defaultSeverity="WARNING" displayName="람다 매개변수가 필드를 숨김" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
주변 클래스의 필드와 이름이 동일하게 지정된 람다 매개변수를 보고합니다.
이와 같이 이름이 지정될 경우 필드를 사용하려다가 동일한 이름의 람다 매개변수를 실수로 사용할 수 있습니다.
&lt;p&gt;빠른 수정은 람다 매개변수 이름을 변경하도록 제안합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class MyClass {
    public Object foo;

    void sort(List&amp;lt;Integer&amp;gt; list) {
      list.sort((foo, bar) -&gt; foo - bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  람다 식에서 표시되지 않는 필드를 무시할지 선택하는 옵션을 사용합니다.
  이러한 필드의 예로는 상위 클래스의 private 필드가 있습니다.
&lt;p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;람다 식&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LambdaParameterHidingMemberVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousClassVariableHidesContainingMethodVariable" defaultSeverity="WARNING" displayName="익명의 클래스 변수가 메서드 포함 시 변수를 숨김" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
포함하는 메서드 또는 람다 식의 매개변수나 지역 변수와 이름이 동일하게 지정된 익명 클래스의 필드를 보고합니다.
&lt;p&gt;
  이와 같이 이름이 지정될 경우, 포함하는 메서드의 변수 및 매개변수를 사용하려다가 익명 클래스의 이름이 동일한 필드를 실수로 사용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 필드 이름을 변경하도록 제안합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    public Test(String value) {
      Object foo = new Object() {
        private String value = "TEST";
        public void foo() {
          System.out.println(value); //매개변수가 아닌 필드에 액세스했습니다
        }
      };
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AnonymousClassVariableHidesContainingMethodVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InnerClassVariableHidesOuterClassVariable" defaultSeverity="WARNING" displayName="내부 클래스 필드가 외부 클래스 필드를 숨김" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
주변 클래스의 필드와 이름이 동일하게 지정된 내부 클래스 필드를 보고합니다.
이와 같이 이름이 지정될 경우, 주변 클래스의 필드를 사용하려다가 내부 클래스의 이름이 동일한 필드를 실수로 사용할 수 있습니다.
&lt;p&gt;빠른 수정은 내부 클래스 필드 이름을 변경하도록 제안합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
    private String name;

    class Inner {
      private String name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 검사가 모든 이름 충돌을 보고해야 하는지 혹은 내부 클래스에서 표시된 필드와 충돌만을 보고해야 하는지 선택하는 옵션을 사용합니다.
&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: InnerClassVariableHidesOuterClassVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodOverridesInaccessibleMethodOfSuper" defaultSeverity="WARNING" displayName="메서드가 상위 클래스의 메서드를 재정의" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상위 클래스의 액세스할 수 없는 메서드(예: 다른 패키지에 포함된 상위 클래스의 package-private 메서드)와 시그니처가 동일한 메서드를 보고합니다.
&lt;p&gt;
  이와 같은 메서드 이름은 하위 클래스의 메서드가 실제로는 상위 클래스의 액세스할 수 없는 메서드를 숨긴 것이지만, 재정의처럼 보일 수 있어 혼동될 수 있습니다.
  또한 추후 상위 클래스의 메서드 가시성이 변경될 경우 하위 클래스의 의미가 확인 없이 변경되거나 컴파일 오류가 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;빠른 수정은 메서드 이름을 변경하도록 제안합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Super {
    private void test() {
    }
  }

  public class Sub extends Super {
    void test() { // 'Super.test()'를 public으로 설정하면 컴파일 오류가 발생합니다
                  // 'Super.test()'를 package-private으로 설정하면 'Sub.test()'는 재정의가 됩니다
    }
  }&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MethodOverridesInaccessibleMethodOfSuper&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java9UndeclaredServiceUsage" defaultSeverity="WARNING" displayName="'module-info'에서 서비스의 사용위치가 선언되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
서비스가 &lt;code&gt;java.util.ServiceLoader&lt;/code&gt;로 로드되었지만 &lt;code&gt;module-info.java&lt;/code&gt; 파일에서 &lt;code&gt;uses&lt;/code&gt; 절로 선언되지 않은 경우를 보고하고 해당절의 삽입을 제안합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 9부터 사용할 수 있는 Java 기능 &amp;#39;모듈&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Java9UndeclaredServiceUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicConstructorInNonPublicClass" defaultSeverity="WARNING" displayName="비 public 클래스의 'public' 생성자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;public&lt;/code&gt;이 아닌 클래스 내 &lt;code&gt;public&lt;/code&gt; 생성자를 보고합니다.
&lt;p&gt;보통 낮은 액세스 수준을 가진 클래스에서 &lt;code&gt;public&lt;/code&gt; 생성자를 생성할 이유가 없습니다.
  단, 이 검사를 실행하면 일부 리플렉션 호출의 동작이 바뀔 수 있으니 유의하세요. 특히 &lt;code&gt;Class.getConstructor()&lt;/code&gt;는 업데이트된 생성자 찾을 수 없습니다(대신 &lt;code&gt;Class.getDeclaredConstructor()&lt;/code&gt;를 사용해야 함). 본인의 코드 또는 사용하는 프레임워크의 코드가 &lt;code&gt;getConstructor()&lt;/code&gt;를 통해서 생성자 접근성에 의존하는 경우 이 검사를 사용하면 안 됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class House {
    public House() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class House {
    House() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PublicConstructorInNonPublicClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterHidingMemberVariable" defaultSeverity="WARNING" displayName="매개변수가 필드를 숨김" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
주변 클래스의 필드와 이름이 동일하게 지정된 메서드 매개변수를 보고합니다.
이와 같이 이름이 지정될 경우, 필드를 사용하려다가 동일한 이름의 매개변수를 실수로 사용할 수 있습니다.
&lt;p&gt;빠른 수정은 매개변수 이름을 변경하도록 제안합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    private String value;

    public Main(String value) {
      value = value.toUpperCase();
    }
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 검사에서 다음 옵션을 구성할 수 있습니다.
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;strong&gt;프로퍼티 setter 무시&lt;/strong&gt; - 간단한 setter의 매개변수를 무시합니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;하위 클래스에서 표시되지 않는 상위 클래스 필드 무시&lt;/strong&gt; - 메서드에서 표시되지 않는 상위 클래스의 &lt;code&gt;private&lt;/code&gt;을 무시합니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;생성자 무시&lt;/strong&gt; - 생성자의 매개변수를 무시합니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;추상 메서드 무시&lt;/strong&gt; - 추상 메서드의 매개변수를 무시합니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;인스턴스 필드를 숨기는 static 메서드 매개변수 무시&lt;/strong&gt; - 인스턴스 필드를 숨기는 &lt;code&gt;static&lt;/code&gt; 메서드 매개변수를 무시하고 외부 클래스의 인스턴스 필드를 숨기는 static 내부 클래스의 인스턴스 메서드 매개변수를 무시합니다. 완전히 숨겨지는 것이 아니더라도 이러한 매개변수는 혼동될 수 있습니다.
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ParameterHidingMemberVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldHidesSuperclassField" defaultSeverity="WARNING" displayName="하위 클래스 필드가 상위 클래스 필드를 숨김" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상위 클래스의 필드와 이름이 동일하게 지정된 파생 클래스의 필드를 보고합니다.
Java 필드는 파생 클래스에서 재정의될 수 없으므로 파생 클래스의 필드가 상위 클래스에서 필드를 숨깁니다.
&lt;p&gt;
  이와 같이 이름이 지정될 경우, 기본 클래스의 필드를 사용하려다가 파생 클래스의 이름이 동일한 필드를 실수로 사용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 파생 클래스의 필드 이름을 변경하도록 제안합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Parent {
  Parent parent;
}
class Child extends Parent {
  Child parent;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 검사에서 다음 옵션을 구성할 수 있습니다.
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;strong&gt;액세스할 수 없는 필드 무시&lt;/strong&gt; - 이 검사가 모든 이름 충돌을 보고해야 하는지 혹은 하위 클래스에서 표시된 필드와 충돌만을 보고해야 하는지 지정합니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;static 필드를 숨기는 static 필드 무시&lt;/strong&gt; - 기본 클래스의 &lt;code&gt;static&lt;/code&gt; 필드를 숨기는 &lt;code&gt;static&lt;/code&gt; 필드를 무시합니다.
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: FieldHidesSuperclassField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodOverloadsParentMethod" defaultSeverity="WARNING" displayName="의도하지 않았을 수 있는 상위 클래스 메서드의 오버로드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상위 클래스의 메서드와 이름 및 매개변수 개수가 동일하지만 매개변수 중 하나 이상이 다르고 호환 불가능한 타입인 인스턴스 메서드를 보고합니다.
&lt;p&gt;
  이 경우 하위 클래스의 메서드는 해당 메서드를 오버로드하는 대신 상위 클래스의 메서드를 오버로드합니다. 의도되지 않은 경우 잠재적 버그를 초래할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {
    void foo(int x) {}
  }

  public class Bar extends Foo {
    void foo(Number x) {} // 재정의가 의도된 경우
                          // 'foo()' 메서드가 상위 클래스의 호환되는 메서드를 오버로드합니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 옵션을 사용하여 검사에서 매개변수 타입이 호환되지 않는 경우도 보고해야 하는지 선택합니다.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MethodOverloadsParentMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AmbiguousFieldAccess" defaultSeverity="WARNING" displayName="상속된 필드로의 액세스가 둘러싸는 코드의 요소로의 액세스처럼 보임" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스 주변 코드에서 이름이 동일한 지역 변수, 매개변수 또는 필드가 사용될 수 있는 익명, 내부 또는 지역 클래스의 상위 필드에 대한 액세스를 보고합니다.
실제로는 상위 클래스의 필드에 액세스한 경우에도, 주변 코드의 요소에 액세스한 것처럼 보일 수 있습니다.
&lt;p&gt;
  코드의 의도를 명확히 하려면 명시적 &lt;code&gt;super&lt;/code&gt; 한정자를 필드 액세스에 추가하는 것이 좋습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    class First {
      protected String ambiguous;
    }
    class Second {
      void foo(String ambiguous) {
        new First() {
          {
            System.out.println(ambiguous); // 매개변수가 아닌 필드에 액세스했습니다
          }
        };
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    class First {
      protected String ambiguous;
    }
    class Second {
      void foo(String ambiguous) {
        new First() {
          {
            System.out.println(super.ambiguous);
          }
        };
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AmbiguousFieldAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AmbiguousMethodCall" defaultSeverity="WARNING" displayName="상속된 메서드 호출이 지역 메서드 호출처럼 보임" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스 주변 코드에 동일한 시그니처를 가진 메서드가 있는 경우, 익명, 내부 또는 지역 클래스의 상위 메서드에 대한 호출을 보고합니다.
실제로는 상위 클래스의 메서드에 대한 호출인 경우에도, 주변 코드의 메서드가 호출된 것처럼 보일 수 있습니다.
&lt;p&gt;
  코드의 의도를 명확히 하려면 명시적 &lt;code&gt;super&lt;/code&gt; 한정자를 메서드 호출에 추가하는 것이 좋습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    void ambiguous(){}
  }

  class Example {
    void ambiguous(){}

    class Inner extends Parent {
      void example(){
        ambiguous(); //warning
      }
    }
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    void ambiguous(){}
  }

  class Example {
    void ambiguous(){}

    class Inner extends Parent {
      void example(){
        super.ambiguous();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AmbiguousMethodCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassEscapesItsScope" defaultSeverity="WARNING" displayName="클래스가 가시성 범위 외부에 노출됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
필드 시그니처 또는 메서드의 시그니처에 클래스가 사용되었으며 시그니처 내 클래스가 멤버 자체보다 가시성이 낮은 경우를 보고합니다.
Java에서는 유효하지만 이러한 멤버는 참조하는 클래스의 가시성 범위 밖에서 사용될 수 없습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Parent {
    public Child getChild() {
      return new Child();
    }

    private class Child {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
추가적으로, Java 9 이상에서 모듈은 클래스의 패키지를 내보내지 않는 방식으로 다른 모듈로부터 자신의 클래스를 숨길 수 있습니다.
그러나 내보낸 API의 일부인 멤버가 시그니처 내의 내보내지 않은 클래스를 참조하는 경우 그러한 멤버는 모듈 밖에서 사용될 수 없습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;내보내지 않은 클래스가 모듈 API 내에서 노출되면 보고(Java 9 이상)&lt;/b&gt; 옵션을 사용하면 내보내지 않은 클래스를 노출하는 모듈 API 멤버를 보고합니다.&lt;br&gt;프로젝트 또는 모듈의 언어 수준이 9 이상이어야 이 옵션을 사용할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;public API 내에 노출된 액세스가 불가능한 클래스 보고&lt;/b&gt; 옵션을 사용하면 가시성 범위가 더 작은 클래스를 노출하는 public 멤버를 보고합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;패키지 로컬 API 내에 노출된 private 클래스를 보고&lt;/b&gt; 옵션을 사용하면 &lt;code&gt;private&lt;/code&gt; 클래스를 노출하는 패키지 지역 멤버를 보고합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassEscapesItsScope&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaEmptyModuleInfoFile" defaultSeverity="WARNING" displayName="빈 'module-info.java' 파일" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;body&gt;
해결되지 않은 모듈 종속성이 있음을 의미하는 빈 &lt;code&gt;module-info.java&lt;/code&gt; 파일을 보고합니다. import 문을 검사하여 필요한 &lt;code&gt;requires&lt;/code&gt; 문을 자동으로 추가합니다.
경고를 억제하려면 모듈 구문 본문 내에 아래와 같은 주석을 작성할 수 있습니다.
&lt;pre&gt;&lt;code&gt;
module module.name {
    // 종속성 없음
}
&lt;/code&gt;&lt;/pre&gt;
&lt;b&gt;빠른 수정:&lt;/b&gt; &lt;i&gt;모듈 종속성 채우기&lt;/i&gt;는 소스 코드의 import 문을 기반으로 누락된 &lt;code&gt;requires&lt;/code&gt;를 채웁니다.
&lt;small&gt;2024.1의 새로운 기능&lt;/small&gt;
&lt;/body&gt;&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JavaEmptyModuleInfoFile&lt;/small&gt;&lt;/p&gt;</inspection><inspection shortName="Java9ModuleExportsPackageToItself" defaultSeverity="WARNING" displayName="모듈에서 패키지를 자신에게 내보내거나 자신에서 엽니다." enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
패키지가 정의되어 있는 동일한 Java 9 모듈로 내보내지거나 해당 모듈에서 연 패키지를 보고합니다.
빠른 수정은 &lt;code&gt;module-info.java&lt;/code&gt;에서 그러한 지시문을 제거합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  module com.mycomp {
    exports com.mycomp.main to com.mycomp;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  module main {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 9부터 사용할 수 있는 Java 기능 &amp;#39;모듈&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Java9ModuleExportsPackageToItself&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="비동기 코드 및 프로미스" path="JavaScript 및 TypeScript"><inspection shortName="ES6MissingAwait" defaultSeverity="WEAK WARNING" displayName="비동기 함수 호출을 위한 await 누락" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;async&lt;/code&gt; 함수 내부에 기대되는 &lt;code&gt;await&lt;/code&gt; 접두사가 없는 &lt;code&gt;async&lt;/code&gt; 함수 호출을 보고합니다.
그러한 호출은 &lt;code&gt;Promise&lt;/code&gt;를 반환하며 제어 흐름이 즉시 계속 진행됩니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
async function bar() { /* ... */ }
async function foo() {
    bar(); // 나쁨
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
빠른 수정은 적용된 후 &lt;code&gt;await&lt;/code&gt; 접두사가 추가됩니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
async function bar() { /* ... */ }
async function foo() {
    await bar(); // 좋음
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
'return 문의 프로미스 보고' 체크박스를 선택한 경우, return 문에 &lt;code&gt;await&lt;/code&gt;를 추가할 것을 제안합니다.&lt;br/&gt;
이는 일반적으로 필요하지 않지만 두 가지 주요 이점을 제공합니다.&lt;br/&gt;&lt;ul&gt;&lt;li&gt;
코드를 &lt;code&gt;try-catch&lt;/code&gt;로 둘러쌀 때 &lt;code&gt;await&lt;/code&gt;를 추가하는 것을 잊지 않게 됩니다.&lt;/li&gt;
&lt;li&gt;명시적 &lt;code&gt;await&lt;/code&gt;를 사용하면 V8 런타임이 &lt;a href="https://bit.ly/v8-zero-cost-async-stack-traces"&gt;비동기 스택 추적&lt;/a&gt;을 제공하는 데 도움이 됩니다.&lt;/li&gt;&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ES6MissingAwait&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6PossiblyAsyncFunction" defaultSeverity="WEAK WARNING" displayName="비동기가 아닌 함수 내 'await'" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
비동기가 의도되었을 가능성이 있으나 실제로 &lt;code&gt;async&lt;/code&gt; 제어자가 누락되어 있는 함수 내 &lt;code&gt;await&lt;/code&gt;의 사용 위치을 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;code&gt;await&lt;/code&gt;를 식별자로 사용할 수는 있지만 연산자로 사용하려고 의도했을 수 있기 때문에 그것을 포함한 함수를 &lt;code&gt;async&lt;/code&gt;로 만들어야 합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: ES6PossiblyAsyncFunction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6RedundantAwait" defaultSeverity="WEAK WARNING" displayName="중복 'await' 표현식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;await await&lt;/code&gt;처럼 &lt;code&gt;await&lt;/code&gt;의 불필요한 사용 또는 promise가 아닌 결과의 대기를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  'Report for promises'(promise 보고) 옵션을 선택하면, 해당하는 경우(&lt;code&gt;return&lt;/code&gt; 문에서, 그리고 &lt;code&gt;Promise.resolve/reject&lt;/code&gt;를 사용할 때) promise 앞의 &lt;code&gt;await&lt;/code&gt;를 제거하도록 제안합니다.
&lt;/p&gt;
&lt;p&gt;이러한 컨텍스트에서 &lt;code&gt;await&lt;/code&gt;를 제거하면 두 가지 문제가 발생합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;try-catch&lt;/code&gt;로 코드를 둘러싸고 &lt;code&gt;await&lt;/code&gt;를 추가하지 않으면 눈치채지 못하는 사이 코드 의미가 달라집니다.
  &lt;/li&gt;
  &lt;li&gt;
    명시적 &lt;code&gt;await&lt;/code&gt;를 사용하면 V8 런타임이 &lt;a href="http://bit.ly/v8-zero-cost-async-stack-traces"&gt;비동기 스택 추적&lt;/a&gt;을 제공하지 못할 수 있습니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ES6RedundantAwait&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSIgnoredPromiseFromCall" defaultSeverity="WEAK WARNING" displayName="프로미스를 반환 하는 메서드 호출의 결과는 무시됩니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
나중에 사용되지 않는 &lt;code&gt;Promise&lt;/code&gt;를 반환하는 함수 호출을 보고합니다.
그러한 호출은 보통 의도적이지 않으며 오류를 나타냅니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSIgnoredPromiseFromCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6TopLevelAwaitExpression" defaultSeverity="ERROR" displayName="최상위 'await' 표현식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
최상위 &lt;code&gt;await&lt;/code&gt; 표현식의 사용 위치를 보고합니다.
&lt;!-- tooltip end --&gt;
새로운 'top-level async' 제안이 도입될 예정이지만, async 함수 밖에서 &lt;code&gt;await&lt;/code&gt;를 사용하는 것은 허용되지 않습니다.
&lt;p&gt;&lt;small&gt;Inspection ID: ES6TopLevelAwaitExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="오류 처리" path="Java"><inspection shortName="NullThrown" defaultSeverity="WARNING" displayName="'null'이 던져짐" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;throw&lt;/code&gt; 문의 인수로 사용되는 &lt;code&gt;null&lt;/code&gt; 리터럴을 보고합니다.
&lt;p&gt;이러한 구문은 일반적으로 프로그램에서 던지면 안 되는 &lt;code&gt;java.lang.NullPointerException&lt;/code&gt;을 생성합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NullThrown&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowCaughtLocally" defaultSeverity="WARNING" displayName="'try' 문을 포함하여 'throw' 포착" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
포함된 &lt;code&gt;try&lt;/code&gt; 문에 의해 예외가 항상 포착되는 &lt;code&gt;throw&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;제어의 로컬 플로를 변경하기 위해 &lt;code&gt;throw&lt;/code&gt; 구문을 "goto" 로 사용하는 것은 혼란을 초래하며 성능이 저하됩니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    if (!Files.isDirectory(PROJECTS)) {
        throw new IllegalStateException("Directory not found."); // 경고: 포함하는 'try' 문에서 'throw'가 포착되었습니다
    }
    ...
  } catch (Exception e) {
      LOG.error("run failed");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;다시 발생하는 예외 무시&lt;/b&gt; 옵션을 사용하여 다시 발생하는 예외를 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThrowCaughtLocally&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceofCatchParameter" defaultSeverity="WARNING" displayName="'catch' 매개변수에 대한 'instanceof'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;instanceof&lt;/code&gt; 식이 &lt;code&gt;catch&lt;/code&gt; 블록의 매개변수 타입을 테스트하기 위해 사용되는 경우를 보고합니다.
&lt;p&gt;&lt;code&gt;catch&lt;/code&gt; 매개변수 타입 테스트는 &lt;code&gt;instanceof&lt;/code&gt;를 사용하는 대신에 별도의 &lt;code&gt;catch&lt;/code&gt; 블록을 사용하여 수행하는 것이 보통 더 좋습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Runnable runnable) {
    try {
        runnable.run();
    } catch (Throwable throwable) {
        if (throwable instanceof NoClassDefFoundError) { // 경고: 'catch' 매개변수 'throwable'의 'instanceof'
            System.out.println("Class not found!");
        }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InstanceofCatchParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowableSupplierOnlyThrowException" defaultSeverity="WARNING" displayName="Throwable 서플라이어가 값을 반환하지 않습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Optional.orElseThrow()&lt;/code&gt; 호출에서 예외를 반환하지 않고 던지는 &lt;code&gt;Supplier&lt;/code&gt; 람다를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
optional.orElseThrow(() -&gt; {
    throw new RuntimeException();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
optional.orElseThrow(() -&gt; new RuntimeException());
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2023.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThrowableSupplierOnlyThrowException&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinallyBlockCannotCompleteNormally" defaultSeverity="WARNING" displayName="정상적으로 완료되지 않는 'finally' 블록" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;finally&lt;/code&gt; 블록 내에서 사용되는 &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt; 및 &lt;code&gt;yield&lt;/code&gt; 문을 보고합니다.
이로 인해 &lt;code&gt;finally&lt;/code&gt; 블록이 정상적으로 완료되지 않고 갑자기 완료됩니다.
동일한 &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt; 문의 &lt;code&gt;try&lt;/code&gt; 및 &lt;code&gt;catch&lt;/code&gt; 블록에서 던져진 모든 예외는 억제됩니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void x() {
    &lt;b&gt;try&lt;/b&gt; {
      throw new RuntimeException();
    } &lt;b&gt;finally&lt;/b&gt; {
      // bar()가 true를 반환하는 경우 RuntimeException이 억제됩니다
      &lt;b&gt;if&lt;/b&gt; (bar()) &lt;b&gt;return&lt;/b&gt;;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: FinallyBlockCannotCompleteNormally&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalFieldOfException" defaultSeverity="WARNING" displayName="'Exception' 클래스의 비 final 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.Exception&lt;/code&gt;의 하위 클래스에서 &lt;code&gt;final&lt;/code&gt;로 선언되지 않은 필드를 보고합니다.
&lt;p&gt;예외 객체의 데이터는 수정해서는 안 됩니다. 수정하면 향후 디버그 및 기록을 위한 오류 컨텍스트가 손실될 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class EditorException extends Exception {
    private String message; // 경고: 예외 클래스의 비 final 필드 'message'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonFinalFieldOfException&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsThrowable" defaultSeverity="WARNING" displayName="클래스가 'Throwable'을 바로 확장" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.Throwable&lt;/code&gt;을 직접 확장하는 클래스를 보고합니다.
&lt;p&gt;&lt;code&gt;java.lang.Throwable&lt;/code&gt;을 직접 확장하는 것은 좋지 않은 사례로 일반적으로 간주됩니다.
  일반적으로 &lt;code&gt;java.lang.RuntimeException&lt;/code&gt;, &lt;code&gt;java.lang.Exception&lt;/code&gt; 또는 특별한 경우 &lt;code&gt;java.lang.Error&lt;/code&gt;를 확장하기만 해도 충분합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EnigmaThrowable extends Throwable {} // 경고: 클래스 'EnigmaThrowable'이 'java.lang.Throwable'을 직접 확장합니다.
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExtendsThrowable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnFromFinallyBlock" defaultSeverity="WARNING" displayName="'finally' 블록 내 'return'" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;finally&lt;/code&gt; 블록 내의 &lt;code&gt;return&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;의도한 경우도 있으나 이러한 &lt;code&gt;return&lt;/code&gt; 문은 던져진 예외를 가리고 디버그를 매우 복잡하게 만들 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    foo();
  } finally {
    if (bar()) return;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReturnFromFinallyBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExceptionFromCatchWhichDoesntWrap" defaultSeverity="WARNING" displayName="포착한 예외를 무시하는 'catch' 블록 내 'throw'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
포착된 예외를 '래핑'하지 않는 &lt;code&gt;catch&lt;/code&gt; 블록 내에서 던져지는 예외를 보고합니다.
&lt;p&gt;예외에 대한 대응으로 예외가 던져지는 경우, 초기 예외를 줄 바꿈하면 스택 프레임과 줄 번호 등 유용한 컨텍스트 정보 손실을
  방지할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ...
  catch (IOException e) {
    closeAllConnections();
    throw new ConnectException("Connection problem."); // 경고: 'catch' 블록 내의 'throw'는 포착된 예외 'e'를 무시합니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;예외 메서드 호출의 결과가 사용되는 경우 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;getMessage()&lt;/code&gt; 등 원래 예외에서 메서드 호출의 결과가
    인수인 예외를 이 검사가 무시하는지
    여부를 나타냅니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;던져진 예외가 예외를 줄 바꿈할 수 없는 경우 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;Throwable&lt;/code&gt; cause를 수락하는 생성자가 없는 예외를 던지는
    &lt;code&gt;throw&lt;/code&gt; 구문을 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExceptionFromCatchWhichDoesntWrap&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TooBroadThrows" defaultSeverity="WARNING" displayName="지나치게 넓은 'throw' 절" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드에서 실제로 발생하는 예외보다 더 일반적인 예외를 가진 &lt;code&gt;throws&lt;/code&gt; 절을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void createFile() throws Exception { // 경고: 'throws Exception'은 너무 광범위하고 'IOException' 예외를 숨깁니다
    File file = new File("pathToFile");
    file.createNewFile();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void createFile() throws IOException {
    File file = new File("pathToFile");
    file.createNewFile();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;지정된 것보다 많은 수의 다른 예외를 숨기려면 &lt;b&gt;경고할 숨겨진 예외의 최대 수&lt;/b&gt; 필드를 사용하여 예외를 무시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;RuntimeException, Exception, Error 또는 Throwable에 대해서만 경고&lt;/b&gt; 옵션을 사용하여 이 검사로 가장 일반적인 예외만 경고합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;라이브러리 메서드를 재정의하는 메서드에서 선언된 예외 무시&lt;/b&gt; 옵션을 사용하여 라이브러리 메서드를 재정의하는 메서드에서 너무 광범위한 &lt;code&gt;throws&lt;/code&gt; 절을 무시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;다른 예외를 숨기지만 자신은 던져지는 예외 무시&lt;/b&gt; 옵션을 사용하여 다른 예외를 숨기지만 여전히 메서드 본문에서 던져질 수 있어서 기술적으로 너무 광범위하지 않은 예외를 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TooBroadThrows&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowFromFinallyBlock" defaultSeverity="WARNING" displayName="'finally' 블록 내 'throw'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;finally&lt;/code&gt; 블록 내 &lt;code&gt;throw&lt;/code&gt; 문을 보고합니다. 
의도된 것일 수도 있으나 이러한 &lt;code&gt;throw&lt;/code&gt; 문은 &lt;code&gt;try&lt;/code&gt; 및 &lt;code&gt;catch&lt;/code&gt; 블록에서 던져진 예외를 숨길 수 있으므로 디버그 프로세스가 복잡해집니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Fascinating {
    void doTask(Task t) {
      try {
        t.activity();
      } finally {
        if (!t.finish()) {
          throw new IllegalStateException();
        }
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;예외를 선언하는 메서드에 대한 메서드 호출을 경고하려면, &lt;b&gt;선언된 예외가 던져질 수 있는 모든 경우에 경고&lt;/b&gt; 옵션을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThrowFromFinallyBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TooBroadCatch" defaultSeverity="WARNING" displayName="지나치게 넓은 'catch' 블록" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상응하는 &lt;code&gt;try&lt;/code&gt; 블록에서 던지는 예외보다 더 일반적인 매개변수를 가진 &lt;code&gt;catch&lt;/code&gt; 블록을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try  {
    File file = new File(pathToFile);
    return file.getAbsolutePath();
  } catch (Exception ex) { // warning: 'catch' of 'Exception' is too broad, masking exceptions 'RuntimeException'
    return defaultFilePath;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try  {
    File file = new File(pathToFile);
    return file.getAbsolutePath();
  } catch (RuntimeException ex) {
    return defaultFilePath;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;RuntimeException, Exception, Error 또는 Throwable에 대해서만 경고&lt;/b&gt; 옵션을 사용하여 이 검사로 가장 일반적인 예외에 대해서만 경고합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;다른 예외를 감추지만 자신은 던져지는 예외 무시&lt;/b&gt; 옵션을 사용하여 다른 예외를 감추지만 여전히 던져질 수 있어서 기술적으로 너무 광범위하지 않은 예외를 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TooBroadCatch&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CatchMayIgnoreException" defaultSeverity="WARNING" displayName="catch 블록이 예외를 무시할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
비어 있거나 예외를 무시할 수 있는 &lt;code&gt;catch&lt;/code&gt; 블록을 보고합니다.
&lt;p&gt;의도된 경우도 있으나 빈 &lt;code&gt;catch&lt;/code&gt; 블록은 디버그 작업을 복잡하게 만들 수 있습니다.
또한 &lt;code&gt;catch&lt;/code&gt; 매개변수를 무시하는 것은 잘못된 코드일 수 있습니다.
  마지막으로, 정적 코드 분석자는 &lt;code&gt;catch&lt;/code&gt; 블록이 &lt;code&gt;NullPointerException&lt;/code&gt;과 같은 중요한 VM 예외를 확인 없이 무시하는 것을 탐지하는 경우 보고합니다. 그러한 예외를 (기록하거나 다시 던지지 않고) 무시하면 버그가 숨겨집니다.&lt;/p&gt;

&lt;p&gt;
  이 검사는 &lt;code&gt;ignore&lt;/code&gt; 또는&lt;code&gt;ignored&lt;/code&gt;라는 이름의 &lt;code&gt;catch&lt;/code&gt; 매개변수를 보고하지 않습니다.
  반대로 이 검사는 &lt;code&gt;ignore&lt;/code&gt; 또는 &lt;code&gt;ignored&lt;/code&gt;라는 이름의 &lt;code&gt;catch&lt;/code&gt; 매개변수가 실제로 사용 중인 경우에 대해 경고합니다.
  또한 이 검사는 이름이 &lt;code&gt;expected&lt;/code&gt; 또는 &lt;code&gt;ok&lt;/code&gt;인 테스트 소스 내 &lt;code&gt;catch&lt;/code&gt; 매개변수를 보고하지 않습니다.
&lt;/p&gt;
&lt;p&gt;
  예외 이름을 &lt;code&gt;ignored&lt;/code&gt;로 변경하는 빠른 수정을 사용할 수 있습니다.
  빈 &lt;b&gt;catch&lt;/b&gt; 블록에 대해서는 &lt;b&gt;catch&lt;/b&gt; 본문을 생성하는 추가적인 빠른 수정이 제안됩니다.
  &lt;a href="settings://fileTemplates"&gt;설정 | 에디터 | 파일 및 코드 템플릿&lt;/a&gt;의 코드 탭에서 'Catch Statement Body' 템플릿을 수정할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    throwingMethod();
  } catch (IOException ex) {

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    System.out.println(System.in.read());
  } catch (IOException ignored) {

  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    주석이 있는 &lt;code&gt;catch&lt;/code&gt; 블록을 무시하려면 &lt;b&gt;'catch' 블록에 주석이 포함되어 있을 경우 경고 안 함&lt;/b&gt; 옵션을 사용하세요.
  &lt;/li&gt;
  &lt;li&gt;
    변수 자체가 사용되지 않으면서 구문 또는 주석을 내부에 포함하는 &lt;code&gt;catch&lt;/code&gt; 블록을 무시하려면 &lt;b&gt;'catch' 블록이 비어 있지 않을 경우 경고 안 함&lt;/b&gt; 옵션을 사용하세요.
  &lt;/li&gt;
  &lt;li&gt;
    이름이 &lt;code&gt;ignored&lt;/code&gt;인 사용 중인 변수를 무시하려면 &lt;b&gt;'ignore(d)'라는 예외가 실제로 무시되지 않은 경우 경고 안 함&lt;/b&gt;을 사용하세요.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;2018.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CatchMayIgnoreException&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryInitCause" defaultSeverity="WARNING" displayName="불필요한 'throwable.initCause()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
예외 생성자가 &lt;code&gt;Throwable cause&lt;/code&gt; 인수도 취하는 &lt;code&gt;Throwable.initCause()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;이 경우 &lt;code&gt;initCause()&lt;/code&gt; 호출이 제거되고, 예외의 생성자 호출에 그 인수가 추가될 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      process();
  }
  catch (RuntimeException ex) {
    RuntimeException wrapper = new RuntimeException("Error while processing");
    wrapper.initCause(ex); // 불필요한 'Throwable.initCause()' 호출
    throw wrapper;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;원인 인수를 생성자로 전달하는 빠른 수정을 사용할 수 있습니다. 빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      process();
  }
  catch (RuntimeException ex) {
    RuntimeException wrapper = new RuntimeException("Error while processing", ex);
    throw wrapper;
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryInitCause&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UncheckedExceptionClass" defaultSeverity="WARNING" displayName="검사되지 않은 'Exception' 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.RuntimeException&lt;/code&gt;의 하위 클래스를 보고합니다.
&lt;p&gt;일부 코드 표준에서는 모든 사용자 정의된 예외 클래스를 확인하도록 합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EnigmaException extends RuntimeException {} // 경고: 확인되지 않은 예외 클래스 'EnigmaException'
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UncheckedExceptionClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadDeathRethrown" defaultSeverity="WARNING" displayName="'ThreadDeath'가 다시 던져지지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.ThreadDeath&lt;/code&gt;를 포착하고 예외를 다시 던지지 않는 &lt;code&gt;try&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    executeInParallel(request);
  } catch (ThreadDeath ex) { // warning: ThreadDeath 'ex' not rethrown
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThreadDeathRethrown&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyTryBlock" defaultSeverity="WARNING" displayName="빈 'try' 블록" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
 try-with-resources 구문을 포함하여 빈 &lt;code&gt;try&lt;/code&gt; 블록을 보고합니다.
&lt;p&gt;주석이 있는 &lt;code&gt;try&lt;/code&gt; 블록은 빈 상태로 간주합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
이 검사는 JSP 파일에서 찾을 수 있는 빈 &lt;code&gt;try&lt;/code&gt; 블록을 보고하지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EmptyTryBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedTryStatement" defaultSeverity="WARNING" displayName="중첩된 'try' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
중첩된 &lt;code&gt;try&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;중첩된 &lt;code&gt;try&lt;/code&gt; 문은 불명확한 코드를 생성할 수 있으며 병합된 &lt;code&gt;catch&lt;/code&gt; 및 &lt;code&gt;finally&lt;/code&gt; 섹션이 있을 수도 있습니다.
  &lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NestedTryStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueOrBreakFromFinallyBlock" defaultSeverity="WARNING" displayName="'finally' 블록 내 'continue' 또는 'break'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;finally&lt;/code&gt; 블록 내부의 &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;의도된 경우도 있으나 이러한 구문은 혼란을 일으키며, 던져진 예외를 가리고 디버그를 복잡하게 만들 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    while (true) {
        try {
          throwingMethod();
        } finally {
            continue;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ContinueOrBreakFromFinallyBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BadExceptionDeclared" defaultSeverity="WARNING" displayName="금지된 예외 선언" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;throws&lt;/code&gt; 절에서 적절하지 않은 예외를 선언하는 메서드를 보고합니다.
예를 들어, &lt;code&gt;java.lang.Exception&lt;/code&gt; 또는 &lt;code&gt;java.lang.Throwable&lt;/code&gt;과 같이 지나치게 일반적인 예외는 적절하지 않을 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void describeModule(String module) throws Exception {} // 경고: 금지된 예외 'Exception'이 선언되었습니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;금지된 예외&lt;/b&gt; 목록을 사용하여 보고 예외 대상을 지정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;라이브러리 메서드를 재정의하는 메서드에 선언된 예외 무시&lt;/b&gt; 옵션을 사용하여 라이브러리 메서드를 재정의하는 메서드에서 선언한 예외를 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BadExceptionDeclared&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ErrorRethrown" defaultSeverity="WARNING" displayName="'Error'가 다시 던져지지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.Error&lt;/code&gt; 또는 해당 하위 클래스를 포착하고, 오류를 다시 던지지 않는 &lt;code&gt;try&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;&lt;code&gt;java.lang.ThreadDeath&lt;/code&gt;를 포착하는 구문은
  보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    executeTests(request);
  }
  catch (OutOfMemoryError ex) { // 경고: 'ex' 오류를 다시 던졌습니다
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ErrorRethrown&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CaughtExceptionImmediatelyRethrown" defaultSeverity="WARNING" displayName="포착된 예외가 즉시 다시 던져짐" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
포착된 예외에 대한 액션을 수행하지 않고 해당 예외를 즉시 다시 던지는 &lt;code&gt;catch&lt;/code&gt; 블록을 보고합니다.
그러한 &lt;code&gt;catch&lt;/code&gt; 블록은 불필요하며 오류를 처리하지 않습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
        try {
            new FileInputStream("");
        } catch (FileNotFoundException e) {
            throw e;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: CaughtExceptionImmediatelyRethrown&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckedExceptionClass" defaultSeverity="WARNING" displayName="검사된 예외 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
검사된 예외 클래스(즉, &lt;code&gt;java.lang.RuntimeException&lt;/code&gt;의 하위 클래스가 아닌 &lt;code&gt;java.lang.Exception&lt;/code&gt;의 하위 클래스)를 보고합니다.
&lt;p&gt;일부 코딩 표준은 검사된 사용자 정의 예외 클래스를 억제합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class IllegalMoveException extends Exception {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CheckedExceptionClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BadExceptionCaught" defaultSeverity="WARNING" displayName="금지된 'Exception' 포착" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
부적절한 예외를 포착하는 &lt;code&gt;catch&lt;/code&gt; 절을 보고합니다.
&lt;p&gt;예를 들어, &lt;code&gt;java.lang.NullPointerException&lt;/code&gt; 또는 &lt;code&gt;java.lang.IllegalMonitorStateException&lt;/code&gt; 같은 일부 예외는 프로그래밍 오류를 나타내므로 프로덕션 코드에서 거의 확실하게 포착되어서는 안 됩니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    return component.getMousePosition(true) != null;
  } catch (NullPointerException e) { // warning: Prohibited exception 'NullPointerException' caught
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;금지된 예외&lt;/b&gt; 목록을 사용하여 보고 예외 대상을 지정합니다.&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BadExceptionCaught&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyFinallyBlock" defaultSeverity="WARNING" displayName="빈 'finally' 블록" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
빈 &lt;code&gt;finally&lt;/code&gt; 블록을 보고합니다.
&lt;p&gt;일반적으로 빈 &lt;code&gt;finally&lt;/code&gt; 블록은 코딩 오류를 의미합니다. 이러한 블록은 코드 리팩터링 후에도 남을 수 있으며 안전하게 제거할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이 검사는 JSP 파일의 빈 &lt;code&gt;finally&lt;/code&gt; 블록을 보고하지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    Files.readString(Paths.get("in.txt"));
  } catch (IOException e) {
    throw new RuntimeException(e);
  } finally {

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:
&lt;pre&gt;&lt;code&gt;
  try {
    Files.readString(Paths.get("in.txt"));
  } catch (IOException e) {
    throw new RuntimeException(e);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EmptyFinallyBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowsRuntimeException" defaultSeverity="WARNING" displayName="검사되지 않은 예외가 'throws' 절에서 선언됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드의 &lt;code&gt;throws&lt;/code&gt; 절에서 확인되지 않은 예외(&lt;code&gt;java.lang.RuntimeException&lt;/code&gt; 또는 하위 클래스 중 하나)의 선언을 보고합니다.
&lt;p&gt;확인되지 않은 예외의 선언은 필요하지 않으며 삭제하거나 Javadoc의 &lt;code&gt;@throws&lt;/code&gt; 태그로 이동할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class InvalidDataException extends RuntimeException {}

  class TextEditor {
    void readSettings() throws InvalidDataException {} // 경고: 'throws' 절에서 선언된 확인되지 않은 예외 'InvalidDataException'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThrowsRuntimeException&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BadExceptionThrown" defaultSeverity="WARNING" displayName="금지된 예외가 던져짐" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
부적절한 예외를 던지는 &lt;code&gt;throw&lt;/code&gt; 문을 보고합니다.
예를 들어, &lt;code&gt;java.lang.Exception&lt;/code&gt; 또는 &lt;code&gt;java.io.IOException&lt;/code&gt;과 같이 지나치게 일반적인 예외는 적절하지 않을 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void setup(Mode mode) {
      if (mode == null)
          throw new RuntimeException("Problem during setup"); // 경고: 금지된 예외 'RuntimeException'을 던졌습니다
      ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;금지된 예외&lt;/b&gt; 목록을 사용하여 보고 예외 대상을 지정합니다.&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BadExceptionThrown&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NewExceptionWithoutArguments" defaultSeverity="WARNING" displayName="인수 없이 예외 생성자 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지정된 인수가 없는 예외 인스턴스 생성을 보고합니다.
&lt;p&gt;인수 없이 예외가 생성된 경우, 발생한 문제에 대한 정보가 포함되지 않기 때문에 디버그가 불필요하게 어려워집니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  throw new IOException(); // 경고: 인수가 없는 예외
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NewExceptionWithoutArguments&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JSON 및 JSON5" path=""><inspection shortName="JsonSchemaRefReference" defaultSeverity="WARNING" displayName="해결되지 않은 '$ref' 및 '$schema' 참조" enabled="false" language="JSON" pluginId="com.intellij.modules.json" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JSON 스키마 내 해결되지 않은 &lt;code&gt;$ref&lt;/code&gt; 또는 &lt;code&gt;$schema&lt;/code&gt; 경로를 보고합니다.&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JsonSchemaRefReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonSchemaDeprecation" defaultSeverity="WEAK WARNING" displayName="곧 사용할 수 없게 될 JSON 프로퍼티" enabled="false" language="JSON" pluginId="com.intellij.modules.json" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JSON 파일 내 사용이 중단된 프로퍼티를 보고합니다.&lt;br&gt;
사용 중단 메커니즘은 JSON 스키마 사양에 아직 정의되어 있지 않으며
이 검사는 비 표준 확장인 'deprecationMessage'을 사용합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JsonSchemaDeprecation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonStandardCompliance" defaultSeverity="ERROR" displayName="JSON 표준 준수" enabled="false" language="JSON" pluginId="com.intellij.modules.json" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JSON 파일 내 &lt;a href="https://tools.ietf.org/html/rfc7159"&gt;언어 사양&lt;/a&gt;과의 다음 차이를 보고합니다:
&lt;ul&gt;
  &lt;li&gt;줄 또는 블록 주석(구성 가능).&lt;/li&gt;
  &lt;li&gt;여러 최상위 값(JSON Lines 파일 제외, 그 외 파일 구성 가능)&lt;/li&gt;
  &lt;li&gt;객체 또는 배열 내 후행 쉼표(구성 가능).&lt;/li&gt;
  &lt;li&gt;작은따옴표가 붙은 문자열.&lt;/li&gt;
  &lt;li&gt;프로퍼티 키가 큰 따옴표가 붙은 문자열이 아닙니다.&lt;/li&gt;
  &lt;li&gt;NaN 또는 부동 소수점 리터럴로서의 Infinity/-Infinity 숫자 값(구성 가능).&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JsonStandardCompliance&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MongoDBJsonDuplicatePropertyKeys" defaultSeverity="WARNING" displayName="객체 리터럴 내 중복 키" enabled="false" language="MongoDB-JSON" pluginId="com.intellij.persistence" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
객체 리터럴 내 중복 키를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MongoDBJsonDuplicatePropertyKeys&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonSchemaCompliance" defaultSeverity="WARNING" displayName="JSON 스키마 준수" enabled="false" language="JSON" pluginId="com.intellij.modules.json" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JSON 파일과 해당 파일에 할당된 &lt;a href="https://json-schema.org"&gt;JSON 스키마&lt;/a&gt; 사이의 불일치를 보고합니다.&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JsonSchemaCompliance&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonDuplicatePropertyKeys" defaultSeverity="WARNING" displayName="객체 리터럴 내 중복 키" enabled="false" language="JSON" pluginId="com.intellij.modules.json" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
객체 리터럴 내 중복 키를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JsonDuplicatePropertyKeys&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Json5StandardCompliance" defaultSeverity="ERROR" displayName="JSON5 표준 준수" enabled="false" language="JSON5" pluginId="com.intellij.modules.json" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JSON5 파일 내 &lt;a href="http://json5.org"&gt;언어 사양&lt;/a&gt;의 불일치를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Json5StandardCompliance&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="접근성" path="HTML"><inspection shortName="HtmlRequiredLangAttribute" defaultSeverity="WARNING" displayName="필요한 'lang' 속성 누락" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;html&lt;/code&gt; 태그 내 누락된 &lt;code&gt;lang&lt;/code&gt;(또는&lt;code&gt;xml:lang&lt;/code&gt;) 속성을 보고합니다. 문서의 디폴트 언어를 명시하는 필수 속성을 추가할 것을 제안합니다. WCAG 2.0 &lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H57.html"&gt;H57&lt;/a&gt;에 기반합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlRequiredLangAttribute&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlRequiredTitleElement" defaultSeverity="WARNING" displayName="필요한 'title' 요소 누락" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;head&lt;/code&gt; 섹션 내부의 누락된 &lt;code&gt;title&lt;/code&gt; 요소를 보고합니다. &lt;code&gt;title&lt;/code&gt; 요소를 추가할 것을 제안합니다. 제목은 문서를 설명해야 합니다. WCAG 2.0 &lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H25.html"&gt;H25&lt;/a&gt;에 기반합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlRequiredTitleElement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlRequiredAltAttribute" defaultSeverity="WARNING" displayName="필요한 'alt' 속성 누락" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;img&lt;/code&gt; 또는 &lt;code&gt;applet&lt;/code&gt; 태그 내 혹은 이미지 맵의 &lt;code&gt;area&lt;/code&gt; 요소 내 누락된 &lt;code&gt;alt&lt;/code&gt; 속성을 보고합니다. 태그 콘텐츠의 대체 텍스트를 포함하는 필수 속성을 추가할 것을 제안합니다. WCAG 2.0 &lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H24.html"&gt;H24&lt;/a&gt;, &lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H35.html"&gt;H35&lt;/a&gt;, &lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H36.html"&gt;H36&lt;/a&gt;, &lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H37.html"&gt;H37&lt;/a&gt;에 기반합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlRequiredAltAttribute&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlRequiredTitleAttribute" defaultSeverity="INFORMATION" displayName="필요한 'title' 속성 누락" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;frame&lt;/code&gt;, &lt;code&gt;iframe&lt;/code&gt;, &lt;code&gt;dl&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; 태그 내 누락된 title 속성을 보고합니다. title 속성을 추가할 것을 제안합니다. WCAG 2.0 &lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H33.html"&gt;H33&lt;/a&gt;, &lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H40.html"&gt;H40&lt;/a&gt;, &lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H64.html"&gt;H64&lt;/a&gt;에 기반합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlRequiredTitleAttribute&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlRequiredSummaryAttribute" defaultSeverity="INFORMATION" displayName="필요한 'summary' 속성 누락" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;table&lt;/code&gt; 태그 내 누락된 &lt;code&gt;summary&lt;/code&gt; 속성을 보고합니다. &lt;code&gt;summary&lt;/code&gt; 속성을 추가할 것을 제안합니다. WCAG 2.0 &lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H73.html"&gt;H73&lt;/a&gt;에 기반합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlRequiredSummaryAttribute&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlFormInputWithoutLabel" defaultSeverity="WARNING" displayName="관련된 라벨 누락" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
관련 라벨이 없는 form 요소(&lt;code&gt;input&lt;/code&gt;, &lt;code&gt;textarea&lt;/code&gt;, 또는 &lt;code&gt;select&lt;/code&gt;)를 보고합니다. 새 라벨을 생성할 것을 제안합니다. WCAG 2.0 &lt;a href="https://www.w3.org/TR/WCAG20-TECHS/H44.html"&gt;H44&lt;/a&gt;에 기반합니다.&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlFormInputWithoutLabel&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="패턴 유효성 검사" path=""><inspection shortName="PatternValidation" defaultSeverity="WARNING" displayName="어노테이션 추가된 패턴의 유효성 검사" enabled="false" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지정된 패턴과 일치하지 않고 &lt;code&gt;@Pattern&lt;/code&gt; 어노테이션이 추가된 메서드에서 반환되었으며, &lt;code&gt;@Pattern&lt;/code&gt; 매개변수에 대한 인수로 전달된 표현식을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Pattern("\\d\\d-\\d\\d\\d") String getId() {
    &lt;b&gt;return&lt;/b&gt; "1";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;b&gt;비 컴파일타임 상수 표현식 플래그 표시&lt;/b&gt; 옵션을 사용하여 알 수 없는 값이 있는 표현식을 검사에서
  보고하도록 하고 대체(&lt;code&gt;@Subst&lt;/code&gt;) 어노테이션 추가를 제안하도록 합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PatternValidation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PatternOverriddenByNonAnnotatedMethod" defaultSeverity="WARNING" displayName="어노테이션이 없는 메서드가 @Pattern 메서드를 재정의" enabled="false" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@Pattern&lt;/code&gt; 어노테이션이 추가되지 않은 메서드가 &lt;code&gt;@Pattern&lt;/code&gt; 어노테이션이 추가된 메서드를 재정의하는 경우 보고합니다.
이렇게 해도 에디터 내부의 오류 강조 표시가 방지되지는 않지만 런타임에 재정의 메서드를 검사하지 않습니다.
&lt;p&gt;
슈퍼클래스 메서드의 어노테이션과 일치하는 &lt;code&gt;@Pattern&lt;/code&gt; 어노테이션을 추가하기 위해 빠른 수정이 제공됩니다. 이렇게 하면
런타임 검사 계측이 올바르게 작동합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Parent {
    abstract @Pattern("\\d\\d-\\d\\d\\d") String getId();
  }
  class Child extends Parent {
    @Override String getId() { // 여기서 경고
      return "12-345";
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PatternOverriddenByNonAnnotatedMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PatternNotApplicable" defaultSeverity="ERROR" displayName="패턴 어노테이션 적용 불가" enabled="false" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;String&lt;/code&gt; 이외의 타입이 있는 요소에 &lt;code&gt;@Pattern&lt;/code&gt; 어노테이션이 적용되는 경우 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Pattern("\\d\\d") &lt;b&gt;int&lt;/b&gt; i;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PatternNotApplicable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="JUnit" path="Java"><inspection shortName="MetaAnnotationWithoutRuntimeRetention" defaultSeverity="WARNING" displayName="'@Retention(RUNTIME)' 어노테이션 없이 어노테이션 테스트" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JUnit 5에서 사용되어야 하는 &lt;code&gt;SOURCE&lt;/code&gt; 또는 &lt;code&gt;CLASS&lt;/code&gt; 보존 정책을 사용하는 어노테이션을 보고합니다.
그러한 어노테이션은 런타임 시 사용할 수 없으며 보존 정책은 리플렉션을 통해 액세스 가능하도록 수정되어야 합니다.
&lt;p&gt;보존 정책이 지정되어 있지 않은 경우 디폴트 보존 정책인 &lt;code&gt;CLASS&lt;/code&gt;가 사용됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Testable
  public @interface UnitTest {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Retention(RetentionPolicy.RUNTIME)
  @Testable
  public @interface UnitTest {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;!--&lt;p&gt;&lt;small&gt;Inspection ID: MetaAnnotationWithoutRuntimeRetention&lt;/small&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;&lt;/p&gt;--&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 5" path="Java/Java 언어 수준 마이그레이션 지원"><inspection shortName="MethodCanBeVariableArityMethod" defaultSeverity="INFORMATION" displayName="메서드는 varargs 매개변수를 가질 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
가변 인자 메서드로 변환할 수 있는 메서드를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process(String name, Object[] objects);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process(String name, Object... objects);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;가변 arity 메서드&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MethodCanBeVariableArityMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryUnboxing" defaultSeverity="WARNING" displayName="불필요한 언박싱" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
래핑된 기본 값의 명시적 언래핑인 언박싱을 보고합니다.
&lt;p&gt;Java 5 이상 버전에서 언박싱은 불필요하며 안전하게 제거할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Integer i = Integer.valueOf(42).intValue();&lt;/code&gt; &amp;rarr; &lt;code&gt;Integer i = Integer.valueOf(42);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;int k = Integer.valueOf(42).intValue();&lt;/code&gt; &amp;rarr; &lt;code&gt;int k = Integer.valueOf(42);&lt;/code&gt;
    &lt;p&gt;(&lt;b&gt;정말 불필요하게 언박싱된 표현식만 보고&lt;/b&gt; 옵션이 검사되지 않은 경우에만 보고합니다)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;정말 불필요하게 언박싱된 표현식만 보고&lt;/b&gt; 옵션을 사용하여 언박싱된 값이 즉시 묵시적 또는 명시적으로 박싱되는 정말 불필요한 언박싱만을 보고합니다.
  이 경우 언박싱-박싱 단계 전체를 제거할 수 있습니다. 이 검사는 간단한 명시적 언박싱을 보고하지 않습니다.&lt;/p&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 5 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryUnboxing&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForCanBeForeach" defaultSeverity="WARNING" displayName="'for' 루프를 향상된 루프로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
컬렉션 또는 배열을 반복하며 개선된 &lt;code&gt;for&lt;/code&gt; 루프(foreach 반복 구문)로 자동 대체 가능한 루프를 보고합니다.
&lt;!--  'foreach' still used in this description so that the inspection continues to be found using this keyword --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Iterator&amp;lt;String&amp;gt; iterator = list.iterator(); iterator.hasNext(); ) {
    String item = iterator.next();
    System.out.println(item);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String item : list) {
    System.out.println(item);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;색인 생성된 'java.util.List' 루프 보고&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;list.get(index)&lt;/code&gt; 호출을 포함한 루프를 찾습니다.
  프로세스의 기준이 되는 목록을 변경하지 않는 한(예: &lt;code&gt;list.remove(index)&lt;/code&gt;를 호출하여 변경), 일반적으로 이 루프는 강화된 &lt;code&gt;for&lt;/code&gt; 루프와 교체될 수 있습니다.
  후자의 경우 강화된 &lt;code&gt;for&lt;/code&gt; 루프는 &lt;code&gt;ConcurrentModificationException&lt;/code&gt;을 던질 가능성이 있습니다.
  또한 경우에 따라 &lt;code&gt;list.get(index)&lt;/code&gt; 루프가 약간 빠르게 작동할 수 있습니다.&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;타입이 지정되지 않은 컬렉션의 반복을 보고하지 않음&lt;/b&gt; 옵션을 사용하여 타입 매개변수가 없는 컬렉션을 무시합니다.
  이와 같은 방법으로 &lt;code&gt;java.lang.Object&lt;/code&gt; 타입의 강화된 &lt;code&gt;for&lt;/code&gt; 루프 변수의 생성과 이 루프 변수가 사용되는 형 변환의 삽입을 방지합니다.&lt;/p&gt;
&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;For-each 루프&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ForCanBeForeach&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IndexOfReplaceableByContains" defaultSeverity="WARNING" displayName="'String.indexOf()' 식을 'contains()'로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;String.contains()&lt;/code&gt; 메서드 호출로 바꿀 수 있는 &lt;code&gt;String.indexOf()&lt;/code&gt; 호출과의 비교를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; b = "abcd".indexOf('e') &gt;= 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; b = "abcd".contains('e');
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 5 이상인 경우에만 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: IndexOfReplaceableByContains&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CollectionsFieldAccessReplaceableByMethodCall" defaultSeverity="WARNING" displayName="빈 컬렉션 필드 참조를 메서드 호출로 바꿀 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음과 같은 &lt;code&gt;java.util.Collections&lt;/code&gt; 필드의 사용 위치를 보고합니다. &lt;code&gt;EMPTY_LIST&lt;/code&gt;, &lt;code&gt;EMPTY_MAP&lt;/code&gt; 또는 &lt;code&gt;EMPTY_SET&lt;/code&gt; 이러한 필드 사용 위치는 다음 메서드 호출로 바꿀 수 있습니다. &lt;code&gt;emptyList()&lt;/code&gt;, &lt;code&gt;emptyMap()&lt;/code&gt; 또는 &lt;code&gt;emptySet()&lt;/code&gt;
그러한 메서드 호출은 타입 매개변수를 추측할 수 있기 때문에 컴파일러에 의한 확인되지 않은 경고를 방지합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; emptyList = Collections.EMPTY_LIST;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; emptyList = Collections.emptyList();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 5 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CollectionsFieldAccessReplaceableByMethodCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WhileCanBeForeach" defaultSeverity="WARNING" displayName="'while' 루프를 향상된 'for' 루프로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
컬렉션을 반복하며 개선된 &lt;code&gt;for&lt;/code&gt; 루프(foreach 반복 구문)로 대체 가능한 &lt;code&gt;while&lt;/code&gt; 루프를 보고합니다.
&lt;!--  'foreach' still used in this description so that the inspection continues to be found using this keyword --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Iterator it = c.iterator();
  while(it.hasNext()) {
    Object obj = it.next();
    System.out.println(obj);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음으로 대체 가능:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Object obj : c) {
    System.out.println(obj);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;For-each 루프&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: WhileCanBeForeach&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryBoxing" defaultSeverity="WARNING" displayName="불필요한 박싱" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
객체에서 기본 값의 래핑인 명시적 박싱을 보고합니다.
&lt;p&gt;Java 5 이상 버전에서 명시적 수동 박싱은 불필요하며 안전하게 제거될 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Integer i = new Integer(1);&lt;/code&gt; &amp;rarr; &lt;code&gt;Integer i = Integer.valueOf(1);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;int i = Integer.valueOf(1);&lt;/code&gt; &amp;rarr; &lt;code&gt;int i = 1;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;b&gt;정말 불필요하게 박싱된 표현식만 보고&lt;/b&gt; 옵션을 사용하여 박싱된 값이 즉시 묵시적 또는 명시적으로 언박싱되어 정말 불필요한 박싱만을 보고합니다.
이 경우 박싱-언박싱 단계 전체를 제거할 수 있습니다. 이 검사는 간단한 명시적 박싱을 보고하지 않습니다.
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 5 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryBoxing&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringBufferReplaceableByStringBuilder" defaultSeverity="WARNING" displayName="'StringBuffer'가 'StringBuilder'가 될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;StringBuffer&lt;/code&gt;로 선언된 변수를 보고하고 &lt;code&gt;StringBuilder&lt;/code&gt;로 대체하도록 제안합니다.
&lt;code&gt;StringBuilder&lt;/code&gt;는 &lt;code&gt;StringBuffer&lt;/code&gt;의 비 스레드 안전 대체 항목입니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 5 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringBufferReplaceableByStringBuilder&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RawUseOfParameterizedType" defaultSeverity="WARNING" displayName="매개변수화된 클래스의 원시 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
타입 매개변수가 생략된 제네릭 클래스를 보고합니다. 그러한 제네릭 &lt;i&gt;원시&lt;/i&gt; 타입의 사용은 Java에서 유효하지만 타입 매개변수의 목적을 무효화하며 버그를 가릴 수 있습니다. 이 검사는 &lt;code&gt;javac&lt;/code&gt;의 &lt;code&gt;rawtypes&lt;/code&gt; 경고와 같이 동작합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
//경고: 매개변수화된 클래스 'List'의 원시 사용
List list = new ArrayList&amp;lt;String&amp;gt;();
//문자열 목록이 생성되었지만, 정수도 허용됩니다.
list.add(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
//배열 생성 중에 타입 인수를 제공하는 것이 불가능하므로 경고 없음
IntFunction&amp;lt;List&amp;lt;?&amp;gt;[]&gt; fun = List[]::new;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;객체 생성에 사용된 원시 타입을 무시하려면 &lt;b&gt;새 객체 생성 무시&lt;/b&gt; 옵션을 사용하세요.&lt;/li&gt;
  &lt;li&gt;형 변환에 사용된 원시 타입을 무시하려면 &lt;b&gt;형 변환 무시&lt;/b&gt; 옵션을 사용하세요.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;타입 매개변수가 컴파일되지 않는 위치 무시&lt;/b&gt; 옵션을 사용하여 타입 매개변수가 컴파일되지 않는 경우를 무시합니다(예: 배열 생성 또는 라이브러리 메서드 재정의 시).&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;재정의하는 메서드의 매개변수 타입 무시&lt;/b&gt; 옵션을 사용하여 재정의된 메서드의 매개변수에서 사용된 타입 매개변수를 무시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;자동 빠른 수정을 사용할 수 없는 경우 무시&lt;/b&gt; 옵션을 사용하여 빠른 수정이 지원되지 않는 경우를 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;제네릭&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RawUseOfParameterizedType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BigDecimalLegacyMethod" defaultSeverity="WARNING" displayName="'BigDecimal' 기존 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
정수 상수를 사용하여 반올림 모드를 지정하는 &lt;code&gt;BigDecimal.divide()&lt;/code&gt; 또는 &lt;code&gt;BigDecimal.setScale()&lt;/code&gt; 호출을 보고합니다.
JDK 1.5 이후부터 &lt;code&gt;RoundingMode&lt;/code&gt;를 취하는 메서드를 사용해 보세요.  
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new BigDecimal("42").setScale(2, BigDecimal.ROUND_FLOOR);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new BigDecimal("42").setScale(2, RoundingMode.FLOOR);&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BigDecimalLegacyMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="CSS" path=""><inspection shortName="CssBrowserCompatibilityForProperties" defaultSeverity="WARNING" displayName="프로퍼티가 선택한 브라우저와 호환되지 않습니다" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
특정 브라우저에서 지원하지 않는 CSS 프로퍼티를 보고합니다.
&lt;a href="https://github.com/mdn/browser-compat-data"&gt;MDN 호환성 데이터&lt;/a&gt;에 기반합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssBrowserCompatibilityForProperties&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssReplaceWithShorthandSafely" defaultSeverity="WEAK WARNING" displayName="프로퍼티를 축약으로 안전하게 바꿀 수 있습니다" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본디 프로퍼티 집합을 보고합니다. 완전한 본디 CSS 프로퍼티 집합을 동등한 단축 양식으로 바꿀 것을 제안합니다.
&lt;p&gt;
  예를 들어, 4개의 프로퍼티 &lt;code&gt;padding-top&lt;/code&gt;, &lt;code&gt;padding-right&lt;/code&gt;, &lt;code&gt;padding-bottom&lt;/code&gt;, &lt;code&gt;padding-left&lt;/code&gt;를 하나의 &lt;code&gt;padding&lt;/code&gt; 프로퍼티로 안전하게 바꿀 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  짧은 프로퍼티로 전환하면 결과가 달라질 수 있으므로 긴 프로퍼티 집합이 불완전할 경우 이 검사는 나타나지 않습니다(예: 규칙 집합의 3개뿐인 &lt;code&gt;padding-xxx&lt;/code&gt; 프로퍼티).
  그러한 경우, 'Properties may probably be replaced with a shorthand'(프로퍼티를 짧은 프로퍼티로 안전하게 대체 가능) 검사를 고려해보세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssReplaceWithShorthandSafely&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssConvertColorToHexInspection" defaultSeverity="WARNING" displayName="색상을 #-hex로 바꿀 수 있습니다" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;rgb()&lt;/code&gt;, &lt;code&gt;hsl()&lt;/code&gt;, 또는 기타 색상 함수를 보고합니다.
&lt;p&gt;색상 함수를 동등한 16진수 표기로 교체할 것을 제안합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rgb(12, 15, 255)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#0c0fff&lt;/code&gt;.&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssConvertColorToHexInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssConvertColorToRgbInspection" defaultSeverity="WARNING" displayName="색상을 rgb()로 바꿀 수 있습니다" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;hsl()&lt;/code&gt; 및 &lt;code&gt;hwb()&lt;/code&gt; 색상 함수 또는 16진수 색상 표기를 보고합니다.
&lt;p&gt;그러한 색상 값을 동등한 &lt;code&gt;rgb()&lt;/code&gt; 또는 &lt;code&gt;rgba()&lt;/code&gt; 색상 함수로 바꿀 것을 제안합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#0c0fff&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rgb(12, 15, 255)&lt;/code&gt;.&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssConvertColorToRgbInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssDeprecatedValue" defaultSeverity="ERROR" displayName="지원 중단된 값" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지원 중단된 CSS 값을 보고합니다. 지원 중단된 값을 유효하며 동등한 값으로 바꾸도록 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssDeprecatedValue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssOverwrittenProperties" defaultSeverity="WARNING" displayName="덮어쓰기 한 프로퍼티" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
규칙 집합 내 중복된 CSS 프로퍼티를 보고합니다. 단축 프로퍼티를 따릅니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
.foo {
  margin-bottom: 1px;
  margin-bottom: 1px; /* duplicates margin-bottom */
  margin: 0; /* overrides margin-bottom */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssOverwrittenProperties&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssUnusedSymbol" defaultSeverity="WARNING" displayName="사용되지 않는 선택자" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
선택자에 표시되나 HTML에서 사용되지 않는 CSS 클래스 또는 요소 ID를 보고합니다.
&lt;p&gt;
  단, &lt;b&gt;Code(코드) | Inspect Code(코드 검사)&lt;/b&gt; 또는 &lt;b&gt;Code(코드) | Analyze Code(코드 분석) | Run Inspection by Name(이름별로 검사 실행)&lt;/b&gt;을 통해 실행한 경우에만 완전한 검사 결과가 제공됩니다.
  성능상의 이유로 스타일시트 파일이 즉각적으로 검사되지 않습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssUnusedSymbol&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssReplaceWithShorthandUnsafely" defaultSeverity="INFORMATION" displayName="프로퍼티를 축약으로 바꿀 수 있습니다" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
긴 CSS 프로퍼티 집합을 보고하고 불완전한 긴 CSS 프로퍼티 집합을 짧은 형식으로 바꿀 것을 제안합니다(단, 두 형식은 100% 동등하지 않음).
&lt;p&gt;
  예를 들어, 2개의 프로퍼티 &lt;code&gt;outline-color&lt;/code&gt; 및 &lt;code&gt;outline-style&lt;/code&gt;을 하나의 &lt;code&gt;outline&lt;/code&gt;으로 바꿀 수 있습니다.
  단축 양식은 모든 누락된 하위 값을 초기 상태로 재설정하므로 그러한 교체는 100% 동등하지 않습니다.
  이 예시에서 &lt;code&gt;outline&lt;/code&gt;이라는 짧은 형식으로 바꾸면 &lt;code&gt;outline-width&lt;/code&gt; 역시 초기 값인 &lt;code&gt;medium&lt;/code&gt;으로 재설정됩니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 검사는 긴 프로퍼티의 전체 집합을 다루지 않습니다(짧은 형식으로 바꾸면 100% 안전할 경우).
  그러한 경우, '프로퍼티를 안전하게 단축 속성으로 바꿀수 있습니다' 검사를 고려하십시오.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssReplaceWithShorthandUnsafely&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Qodana" path=""><inspection shortName="CyclomaticComplexityInspection" defaultSeverity="WARNING" displayName="코드 메트릭" enabled="false" language="" pluginId="org.intellij.qodana" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
순환 복잡도를 계산합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CyclomaticComplexityInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="XSLT" path=""><inspection shortName="XsltUnusedDeclaration" defaultSeverity="WARNING" displayName="사용되지 않은 변수 또는 매개변수" enabled="false" language="XML" pluginId="XPathView" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
전혀 사용되지 않는 지역 변수 및 매개변수를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XsltUnusedDeclaration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XsltTemplateInvocation" defaultSeverity="ERROR" displayName="잘못된 템플릿 호출" enabled="false" language="XML" pluginId="XPathView" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명명된 XSLT 템플릿 호출에서 인수가 누락되거나 선언되지 않은 인수가 전달되거나 매개변수에 인수를 두 번 이상 전달하는 경우를 보고합니다.

&lt;p&gt;
디폴트 값으로 선언된 매개변수는 선택 항목이며 따라서 누락으로 보고하지 않습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XsltTemplateInvocation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XsltVariableShadowing" defaultSeverity="WARNING" displayName="가려진 변수" enabled="false" language="XML" pluginId="XPathView" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
가려진 XSLT 변수를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XsltVariableShadowing&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XsltDeclarations" defaultSeverity="ERROR" displayName="잘못된 선언" enabled="false" language="XML" pluginId="XPathView" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
XSLT 변수, 매개변수 및 이름이 있는 템플릿의 중복된 선언 및 잘못된 식별자를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XsltDeclarations&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 16" path="Java/Java 언어 수준 마이그레이션 지원"><inspection shortName="ClassCanBeRecord" defaultSeverity="WEAK WARNING" displayName="클래스가 레코드 클래스일 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
레코드 클래스로 변환될 수 있는 클래스를 보고합니다.
&lt;p&gt;레코드 클래스는 확장 가능한 동작보다는 불변 데이터를 모델링하는 데 주안점을 둡니다.
&lt;code&gt;equals()&lt;/code&gt; 및 접근자와 같이 데이터 기반 메서드의 묵시적 자동 구현은 상용구 코드를 줄이는 데 유용합니다.&lt;/p&gt;
&lt;p&gt;
  단, 모든 클래스가 레코드 클래스가 될 수 있는 것은 아닙니다. 다음 몇 가지 제한 사항입니다:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;클래스에 하위 클래스가 없어야 합니다.&lt;/li&gt;
  &lt;li&gt;클래스 내 모든 비 static 필드는 final이어야 합니다.&lt;/li&gt;
  &lt;li&gt;이니셜라이저, 제네릭 생성자 및 네이티브 메서드가 있어서는 안됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;레코드 클래스에 대한 자세한 설명은 &lt;a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10"&gt;Java 언어 사양&lt;/a&gt;을 참조하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Point {
    private final double x;
    private final double y;

    Point(double x, double y) {
      this.x = x;
      this.y = y;
    }

    double getX() {
      return x;
    }

    double getY() {
      return y;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record Point(int x, int y) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;getX()&lt;/code&gt;/&lt;code&gt;isX()&lt;/code&gt; 접근자 이름을 &lt;code&gt;x()&lt;/code&gt;로 자동 변경하려면, &lt;b&gt;접근자 이름 변경 제안&lt;/b&gt; 옵션을 활성화하세요.&lt;/p&gt;
&lt;p&gt;
  변환으로 인해 멤버의 접근성이 약화될 수 있는 클래스를 제외하려면 &lt;b&gt;멤버의 접근성이 향상되면 강조 표시 비활성화&lt;/b&gt; 옵션을 사용하세요.
  빠른 수정은 인텐션으로 여전히 사용 가능하며, 이를 트리거하면 영향을 받는 멤버가 표시되고 확인이 요청됩니다.
  배치 모드에서는 변환이 제안되지 않습니다.
&lt;/p&gt;
&lt;p&gt;지정된 패턴과 일치하는 어노테이션이 추가된 경우, 변환에서 클래스를 제외하려면 &lt;b&gt;Suppress conversion if class is annotated by(클래스에 다음 어노테이션이 추가된 경우 변환 억제)&lt;/b&gt; 목록을 사용하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 16부터 사용할 수 있는 Java 기능 &amp;#39;기록&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ClassCanBeRecord&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PatternVariableCanBeUsed" defaultSeverity="WARNING" displayName="패턴 변수 사용 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
일반적으로 더 간결한 변수인 패턴 변수로 대체 가능한 지역 변수 선언을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (obj instanceof String) {
    String str = (String) obj;
    System.out.println(str);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음으로 대체 가능:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (obj instanceof String str) {
    System.out.println(str);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 16부터 사용할 수 있는 Java 기능 &amp;#39;&amp;#39;instanceof&amp;#39; 내 패턴&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PatternVariableCanBeUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring Cloud" path="Spring"><inspection shortName="SpringBootBootstrapConfigurationInspection" defaultSeverity="WEAK WARNING" displayName="애플리케이션 컨텍스트에 포함된 부트스트랩 구성" enabled="false" language="UAST" pluginId="com.intellij.spring.cloud" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;불필요할 수 있는 구성 요소 스캔을 통해 Spring Boot 애플리케이션 컨텍스트에 포함된 &lt;code&gt;BootstrapConfiguration&lt;/code&gt;을 보고합니다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#customizing-the-bootstrap-configuration"&gt;Spring Cloud Commons 문서&lt;/a&gt;를 참조하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SpringBootBootstrapConfigurationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="일반" path=""><inspection shortName="RedundantSuppression" defaultSeverity="WARNING" displayName="불필요한 억제" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
영향을 미치는 검사가 이 컨텍스트에서 더 이상 적용되지 않으므로 안전하게 제거할 수 있는 다음 요소의 사용 위치를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;@SuppressWarning&lt;/code&gt; 어노테이션, 또는&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;// noinspection&lt;/code&gt; 줄 주석, 또는&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;/** noinspection */&lt;/code&gt; JavaDoc 주석&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
public class C {
 // 심볼이 이미 private이지만,
 // 여전히 어노테이션으로 감싸져 있습니다
  @SuppressWarnings({"WeakerAccess"})
 private boolean CONST = true;
 void f() {
    CONST = false;
  }
}
&lt;/code&gt;&lt;/pre&gt;


&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantSuppression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InjectedReferences" defaultSeverity="ERROR" displayName="삽입된 참조" enabled="false" language="" pluginId="org.intellij.intelliLang" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://www.jetbrains.com/help/idea/using-language-injections.html"&gt;언어 삽입&lt;/a&gt;에 의해 삽입된 해결되지 않은 참조를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
    @Language("file-reference")
    String fileName = "/home/user/nonexistent.file"; // 파일이 없을 때 강조 표시됨
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: InjectedReferences&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LongLine" defaultSeverity="WARNING" displayName="줄이 코드 스타일에서 허용된 길이보다 깁니다" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="settings://preferences.sourceCode?Hard%20wrap%20at"&gt;Settings(설정) | Editor(에디터) | Code Style(코드 스타일) | General(일반)&lt;/a&gt;에서 지정된 &lt;b&gt;Hard wrap at(다음 길이에서 하드 랩)&lt;/b&gt;의 매개변수보다 긴 줄을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LongLine&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="QodanaJavaSanity" defaultSeverity="ERROR" displayName="Java 온전성" enabled="false" language="JAVA" pluginId="org.intellij.qodana" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Java 코드에서 해결되지 않은 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: QodanaJavaSanity&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Annotator" defaultSeverity="ERROR" displayName="어노테이터" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
배치 코드 검사가 실행된 결과에서 파일 내 중요한 문제(예: 구문 오류)를 보고합니다.
이러한 문제는 에디터에서 항상 강조 표시되며 검사와 달리 구성할 수 없습니다.
해당 옵션은 이 검사가 수행하는 확인의 범위를 제어합니다.
&lt;ul&gt;
  &lt;li&gt;'&lt;b&gt;구문 오류 보고&lt;/b&gt;' 옵션: 파서 관련 문제를 보고합니다.&lt;/li&gt;
  &lt;li&gt;'&lt;b&gt;특정 언어의 어노테이터에서 발생한 문제 보고&lt;/b&gt;' 옵션: 관련 언어에 구성된 어노테이터에서 발견된 문제를 보고합니다.
    자세한 내용은 &lt;a href="https://plugins.jetbrains.com/docs/intellij/annotator.html"&gt;사용자 지정 언어 지원: 어노테이터&lt;/a&gt;를 참조하세요.&lt;/li&gt;
  &lt;li&gt;'&lt;b&gt;기타 강조 표시 문제 보고&lt;/b&gt;' 옵션: 현재 파일의 언어에 한정된 문제를 보고합니다(예: 타입 불일치 또는 보고되지 않은 예외).
    자세한 내용은 &lt;a href="https://plugins.jetbrains.com/docs/intellij/syntax-highlighting-and-error-highlighting.html#semantic-highlighting"&gt;사용자 지정 언어 지원: 강조 표시&lt;/a&gt;를 참조하세요.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Annotator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicatedCode" defaultSeverity="WEAK WARNING" displayName="중복 코드 조각" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">Reports duplicated blocks of code from the selected scope: the same file, same module, dependent modules or the entire project.&lt;!-- tooltip end --&gt; &lt;p&gt;The inspection features quick-fixes that help you to set the size of detected duplicates, navigate to repetitive code fragments, and compare them in a tool window.When possible, the inspection provides a quick-fix to extract a method from the duplicated code.&lt;p&gt;The inspection options allow you to select the scope of the reported duplicated fragments and set the initial size for the duplicated language constructs.&lt;p&gt;You can also configure the constructs that you want to anonymize in &lt;a href="settings://duplicates.index"&gt; 파일 | 설정 | Editor | Duplicates&lt;/a&gt;.</inspection><inspection shortName="EmptyDirectory" defaultSeverity="WARNING" displayName="빈 디렉터리" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
빈 디렉터리를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;보고된 소스 루트의 디렉터리만 보고하려면 &lt;b&gt;소스 폴더에 있는 빈 디렉터리만 보고&lt;/b&gt; 옵션을 사용합니다.&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EmptyDirectory&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncorrectFormatting" defaultSeverity="WEAK WARNING" displayName="올바르지 않은 서식" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  코드가 프로젝트의 코드 스타일 설정을 따르지 않을 경우 나타나는 서식 지정 문제를 보고합니다.
&lt;/p&gt;
&lt;p&gt;
  이 검사는 코드 서식 지정을 위해 타사 서식 지정 도구가 필요한 언어(예: CLangFormat이 활성화된 Go 또는 C)와 호환되지 않습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IncorrectFormatting&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="QodanaKotlinSanity" defaultSeverity="ERROR" displayName="Kotlin 온전성" enabled="false" language="kotlin" pluginId="org.intellij.qodana" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kotlin 코드에서 해결되지 않은 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: QodanaKotlinSanity&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InconsistentLineSeparators" defaultSeverity="WARNING" displayName="일관되지 않은 줄 구분 기호" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
프로젝트 설정에 지정된 줄 구분 기호와 다른 기호가 있는 파일을 보고합니다.
&lt;p&gt;예를 들어, &lt;a href="settings://preferences.sourceCode?Line%20separator"&gt;Settings(설정) | Editor(에디터) | Code Style(코드 스타일) | Line separator(줄 구분 기호)&lt;/a&gt;에서 줄 구분 기호를 &lt;code&gt;\n&lt;/code&gt;으로 설정했으나 편집 중인 파일은 줄 구분 기호로 &lt;code&gt;\r\n&lt;/code&gt;을 사용하는 경우 검사가 트리거됩니다.&lt;/p&gt;

&lt;p&gt;검사에서는 파일 내의 혼합 줄 구분 기호에 대해서도 경고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: InconsistentLineSeparators&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReassignedToPlainText" defaultSeverity="WARNING" displayName="평문으로 재할당됨" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명시적으로 일반 텍스트 파일 타입으로 재할당된 파일을 보고합니다.
플랫폼이 텍스트 파일을 내용으로 자동 탐지하기 때문에 이러한 연결은 불필요합니다.

&lt;p&gt;이 경고는 &lt;b&gt;설정 | 에디터 | 파일 타입 | 텍스트&lt;/b&gt;에서 파일 타입 연결을 제거하여 해제할 수 있습니다.&lt;/p&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReassignedToPlainText&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaAnnotator" defaultSeverity="ERROR" displayName="Java 어노테이터" enabled="false" language="JAVA" pluginId="org.intellij.qodana" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Java 어노테이터가 보고한 문제(예: 컴파일링 문제, IDE에서 해결되지 않은 참조 등)를 볼 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JavaAnnotator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TodoComment" defaultSeverity="WARNING" displayName="TODO 주석" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
코드 내 &lt;b&gt;TODO&lt;/b&gt; 주석을 보고합니다.
&lt;p&gt;&lt;a href="settings://preferences.toDoOptions"&gt;Settings(설정) | Editor(에디터) | TODO&lt;/a&gt;에서 &lt;b&gt;TODO&lt;/b&gt; 주석의 서식을 구성할 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;세부 정보가 없는 TODO 주석만 경고&lt;/b&gt; 옵션을 활성화하면, 수행해야 할 작업에 관한 설명이 없이 비어 있는 TODO 주석만 경고합니다. 모든 TODO 주석을 보고하려면 비활성화하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TodoComment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProblematicWhitespace" defaultSeverity="WARNING" displayName="문제가 있는 공백" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음 문제를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;코드 스타일이 공백만 사용하도록 구성된 경우 들여쓰기에 사용되는 탭입니다.&lt;/li&gt;
  &lt;li&gt;코드 스타일이 공백만 사용하도록 구성된 경우 들여쓰기에 사용되는 공백입니다.&lt;/li&gt;
  &lt;li&gt;코드 스타일이 스마트 탭을 사용하도록 구성된 경우 들여쓰기 및 맞추기 탭에 사용되는 공백입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ProblematicWhitespace&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="DotEnv" path=""><inspection shortName="EmptyNestedVariableInspection" defaultSeverity="WARNING" displayName="변수 참조가 비어 있습니다" enabled="false" language="DotEnv" pluginId="ru.adelf.idea.dotenv" pluginVersion="252.23892.201" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
`.env` 파일 내에서 중첩 변수가 정의되었지만 비어 있거나 빈칸으로 남아 있는 경우를 강조 표시합니다. 개발자가 문제를 일으킬 수 있거나 온전하지 않은 구성을 식별할 때 유용합니다.
&lt;p&gt;
    이 검사는 특히 환경 변수 파일이 올바르고 완전한지 확인할 때 유용합니다. 빈 중첩 함수를 탐지하면 잘못된 구성으로 인한 런타임 문제를 피할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EmptyNestedVariableInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DotEnvTrailingWhitespaceInspection" defaultSeverity="WARNING" displayName="값에 후행 공백이 있음" enabled="false" language="DotEnv" pluginId="ru.adelf.idea.dotenv" pluginVersion="252.23892.201" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
후행 공백을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DotEnvTrailingWhitespaceInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DotEnvLowercaseKeyInspection" defaultSeverity="WARNING" displayName="키가 소문자를 사용" enabled="false" language="DotEnv" pluginId="ru.adelf.idea.dotenv" pluginVersion="252.23892.201" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
소문자를 사용하는 키를 보고합니다. 키는 대문자로 작성되어야 합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DotEnvLowercaseKeyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DotEnvExtraBlankLineInspection" defaultSeverity="WARNING" displayName="불필요한 빈 줄" enabled="false" language="DotEnv" pluginId="ru.adelf.idea.dotenv" pluginVersion="252.23892.201" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
.env 파일 내에서 불필요한 빈 줄을 보고합니다
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DotEnvExtraBlankLineInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DotEnvIncorrectDelimiterInspection" defaultSeverity="WARNING" displayName="잘못된 구분 기호" enabled="false" language="DotEnv" pluginId="ru.adelf.idea.dotenv" pluginVersion="252.23892.201" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
.env 파일 내에서 잘못된 구분자('-' 대신 '_')를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DotEnvIncorrectDelimiterInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedVariableOutsideDoubleQuotesInspection" defaultSeverity="WARNING" displayName="중첩 변수는 큰따옴표 밖에서 사용할 수 없습니다" enabled="false" language="DotEnv" pluginId="ru.adelf.idea.dotenv" pluginVersion="252.23892.201" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
중첩 변수가 `.env` 파일 내의 쌍따옴표 밖에서 사용되어 올바르게 분석되지 않을 수 있는 경우를 탐지합니다. 이 검사는 구성 문제를 피하기 위해 중첩 변수가 적절하게 닫혀 있는지 확인합니다.
&lt;p&gt;
    이 검사는 중첩 변수에 쌍따옴표 사용을 강제하여 `.env` 파일 내의 문법을 올바르게 유지하고 변수 평가 중에 예기치 않은 동작을 방지합니다.
&lt;/p&gt;
&lt;p&gt;빠른 수정: 검사가 자동으로 중첩 변수를 쌍따옴표 안에 포함시키는 빠른 수정을 제공합니다. 제공된 빠른 수정을 클릭하여 문제를 자동으로 해결하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NestedVariableOutsideDoubleQuotesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DotEnvSpaceInsideNonQuotedInspection" defaultSeverity="WARNING" displayName="따옴표로 묶이지 않은 값 내의 공백" enabled="false" language="DotEnv" pluginId="ru.adelf.idea.dotenv" pluginVersion="252.23892.201" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
따옴표로 묶이지 않은 값 내의 공백을 보고합니다. 일부 .env 라이브러리는 첫 번째 공백 이후의 모든 내용을 무시합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DotEnvSpaceInsideNonQuotedInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DotEnvSpaceAroundSeparatorInspection" defaultSeverity="WARNING" displayName="'=' 주위의 불필요한 여백" enabled="false" language="DotEnv" pluginId="ru.adelf.idea.dotenv" pluginVersion="252.23892.201" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구분 기호를 둘러싸는 공백을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DotEnvSpaceAroundSeparatorInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UndefinedNestedVariableInspection" defaultSeverity="WARNING" displayName="중첩 변수 ''{0}''의 참조가 정의되지 않았습니다" enabled="false" language="DotEnv" pluginId="ru.adelf.idea.dotenv" pluginVersion="252.23892.201" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
`.env` 파일 내의 중첩 변수가 프로젝트 범위 내의 다른 곳에서 정의 혹은 초기화되지 않은 상태로 액세스되는 경우를 탐지합니다. 잘못된 구성이나 런타임 오류를 방지하기 위해 정의되지 않은 중첩 변수가 적절하게 처리됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UndefinedNestedVariableInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DotEnvLeadingCharacterInspection" defaultSeverity="WARNING" displayName="잘못된 선행 문자" enabled="false" language="DotEnv" pluginId="ru.adelf.idea.dotenv" pluginVersion="252.23892.201" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
.env 파일 내에서 잘못된 선행 문자를 포함한 키를 보고합니다. 키의 첫 번째 문자로는 A-Z 및 '_'만 사용할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DotEnvLeadingCharacterInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DotEnvDuplicateKeyInspection" defaultSeverity="WARNING" displayName="중복 키" enabled="false" language="DotEnv" pluginId="ru.adelf.idea.dotenv" pluginVersion="252.23892.201" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
.env 파일의 중복 키를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DotEnvDuplicateKeyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="컴파일러 문제" path="Java"><inspection shortName="PreviewFeature" defaultSeverity="WARNING" displayName="테스트 버전 기능 경고" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
테스트 버전 API, 즉 &lt;code&gt;@PreviewFeature&lt;/code&gt; 어노테이션이 추가된 &lt;code&gt;java.*&lt;/code&gt; 혹은 &lt;code&gt;javax.*&lt;/code&gt; 네임스페이스 내의 모듈, 패키지, 클래스, 인터페이스, 메서드, 생성자, 필드 혹은 열거형 상수의 사용을 보고합니다.
&lt;p&gt;
  미리보기 기능은 지정과 구현이 완료된 Java 언어, Java 가상머신, 또는 Java SE API의 새로운 기능이지만 아직 정식으로 도입되지 않았습니다. 미리보기 기능의 개념은 &lt;a href="https://openjdk.org/jeps/12"&gt;JEP 12&lt;/a&gt;에서 정의됩니다.
&lt;/p&gt;
&lt;p&gt;
  코드의 일부가 테스트 버전 API에 의존하는 경우 API의 기능이 변경되거나 제거되면 향후 JDK 버전에서 컴파일되지 않을 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 &lt;b&gt;테스트 버전&lt;/b&gt; 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2021.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PreviewFeature&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UNCHECKED_WARNING" defaultSeverity="WARNING" displayName="확인되지 않은 경고" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
javac 컴파일러에서 확인되지 않은 경고가 발생하는 코드를 보고합니다.
모든 확인되지 않은 경고는 런타임 시 잠재적으로 &lt;code&gt;ClassCastException&lt;/code&gt; 을 발생시킬 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List items = Arrays.asList("string", "string");
  List&amp;lt;Integer&amp;gt; numbers = Collections.unmodifiableList(items); // 확인되지 않은 대입
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UNCHECKED_WARNING&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizeOnValueBasedClass" defaultSeverity="WARNING" displayName="값 기준 경고" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Java 16부터 컴파일 경고와 런타임 예외가 발생하는 값 기반 클래스의 인스턴스에 대한 동기화 시도를 보고합니다.
&lt;p&gt;
  예를 들어 &lt;code&gt;java.lang.Double&lt;/code&gt;에는 &lt;code&gt;jdk.internal.ValueBased&lt;/code&gt; 어노테이션이 추가되어, 다음 코드에서 컴파일 타임 경고가 발생합니다.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Double d = 20.0;
synchronized (d) { ... } // javac 경고
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SynchronizeOnValueBasedClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavacQuirks" defaultSeverity="WARNING" displayName="Javac 문제" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
알려진 Javac 이슈, 성능 문제 및 비호환성을 보고합니다.
예를 들어, 타입 추론은 많은 중첩 호출을 처리해야 할 경우 느려질 수 있습니다.
&lt;p&gt;vararg 메서드 호출에 50여 개의 많은 인수가 있으므로, 다음 코드는 경고를 트리거합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Arrays.asList(
      Arrays.asList("a1", "b1"),
      Arrays.asList("a2", "b2"),
      ...
      Arrays.asList("a100", "b100"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정은 명시적 타입 인수를 추가하여 컴파일 및 처리를 더 빠르게 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  //noinspection RedundantTypeArguments
  Arrays.&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;asList(
      Arrays.asList("a1", "b1"),
      Arrays.asList("a2", "b2"),
      ...
      Arrays.asList("a100", "b100"));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JavacQuirks&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="메서드" path="Java/이름 생성 규칙"><inspection shortName="BooleanMethodNameMustStartWithQuestion" defaultSeverity="WARNING" displayName="부울 메서드 이름은 질문 단어로 시작해야 함" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 의문사로 시작하지 않는 부울 메서드를 보고합니다.
&lt;p&gt;라이브러리 메서드를 재정의하는 부울 메서드는 이 검사에서 무시됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;boolean empty(List&amp;lt;String&amp;gt; list) {
  return list.isEmpty();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러한 메서드의 이름을 변경하는 빠른 수정은 에디터에서만 사용할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;부울 메서드 이름을 시작하는 허용 가능한 의문사를 지정하려면 &lt;b&gt;부울 메서드 이름 접두사&lt;/b&gt; 목록을 사용하세요.&lt;/li&gt;
  &lt;li&gt;반환 타입이 &lt;code&gt;java.lang.Boolean&lt;/code&gt;인 메서드를 무시하려면 &lt;b&gt;반환 타입이 'java.lang.Boolean'인 메서드 무시&lt;/b&gt; 옵션을 사용하세요. &lt;/li&gt;
  &lt;li&gt;어노테이션 타입(&lt;code&gt;@interface&lt;/code&gt;)의 부울 메서드를 무시하려면 &lt;b&gt;@interface의 부울 메서드 무시&lt;/b&gt; 옵션을 사용하세요.&lt;/li&gt;
  &lt;li&gt;상위 메서드가 있는 메서드를 무시하려면 &lt;b&gt;상위 메서드를 재정의/구현하는 메서드 무시&lt;/b&gt; 옵션을 사용하세요.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BooleanMethodNameMustStartWithQuestion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MisspelledMethodName" defaultSeverity="WARNING" displayName="대/소문자만 다른 메서드 이름" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스의 여러 메서드의 이름이 대/소문자 표기만 다른 경우를 보고합니다. 그러한 이름은 매우 혼동될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  public int hashcode() { // 보고됩니다. hashCode여야 하지 않을까요?
    return 0;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러한 메서드의 이름을 변경하는 빠른 수정은 에디터에서만 사용할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;상위 클래스의 메서드를 재정의하거나 구현하는 메서드를 무시하려면 &lt;b&gt;상위 메서드를 재정의/구현하는 메서드 무시(&amp;O)&lt;/b&gt; 옵션을 사용하세요.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: MisspelledMethodName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverloadedMethodsWithSameNumberOfParameters" defaultSeverity="WARNING" displayName="매개변수 수가 동일한 오버로드된 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동일한 클래스에서 선언되고 동일한 이름과 동일한 수의 매개변수를 가진 메서드를 보고합니다.
그러한 오버로드는 어떤 오버로드가 호출되었는지 확실하지 않아 매우 혼동될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public static void execute(Runnable r) {}
    public static &amp;lt;T&amp;gt; void execute(RunnableFuture&amp;lt;T&amp;gt; c) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  옵션을 사용하여 매개변수 타입이 확실히 호환되지 않는 오버로드된 메서드를 무시합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: OverloadedMethodsWithSameNumberOfParameters&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaUnfriendlyMethodOverload" defaultSeverity="WARNING" displayName="람다 친화적이지 않은 메서드 오버로드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
충돌하는 추상 메서드 시그니처를 가지는 함수형 인터페이스를 사용하는 오버로드된 메서드를 보고합니다.
&lt;p&gt;그러한 오버로드는 모호함을 불러오며 호출자가 람다를 특정 타입으로 변환하거나 람다 매개변수 타입을 명시적으로 지정할 것을 요구합니다.
  모호함을 제거하기 위해 오버로드된 메서드에 다른 이름을 부여하는 것이 좋습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface MyExecutor {
    void execute(Supplier&amp;lt;?&amp;gt; supplier);
    void execute(Callable&amp;lt;?&amp;gt; callable);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
여기서 &lt;code&gt;Supplier&lt;/code&gt; 및 &lt;code&gt;Callable&lt;/code&gt;는 매개변수를 취하지 않고 void가 아닌 값을 반환하는 단일 추상 메서드를 포함하는 함수형 인터페이스입니다.
그 결과, 명시적인 형 변환이 사용되지 않는 한 람다의 타입을 호출 지점에서 추측할 수 없습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LambdaUnfriendlyMethodOverload&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NewMethodNamingConvention" defaultSeverity="WARNING" displayName="메서드 이름 지정 규칙" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길거나 지정된 정규 표현식 패턴을 따르지 않는 메서드를 보고합니다.
&lt;p&gt;라이브러리 메서드 및 생성자를 재정의하는 인스턴스 메서드는 이 검사에서 무시됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt; 이 검사가 static 메서드에 대해 활성화되어 있으며 메서드 이름의 길이가 최소 4(디폴트)로 지정되어 있는 경우, 다음 static 메서드는 이름 길이가 4보다 작은 3이므로 경고가 발생합니다. &lt;code&gt;public static int max(int a, int b)&lt;/code&gt;
&lt;p&gt;그러한 메서드의 이름을 변경하는 빠른 수정은 에디터에서만 사용할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;&lt;b&gt;옵션&lt;/b&gt; 섹션의 목록을 사용하여 확인해야 하는 메서드를 지정합니다. 검사를 건너뛰려는 메서드 타입의 체크박스를 선택 해제하세요. 관련된 검사를 건너뛰려면 길이 필드에 &lt;b&gt;0&lt;/b&gt;을 지정하세요.&lt;/p&gt;
&lt;p&gt;정규 표현식은 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식으로 지정되어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NewMethodNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodNameSameAsParentName" defaultSeverity="WARNING" displayName="상위 클래스 이름과 동일한 메서드 이름" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상위 클래스와 이름이 같은 메서드를 보고합니다. 그러한 메서드 이름은 혼란을 일으킬 수 있습니다.
&lt;p&gt;이 검사는 계층 구조의 깊은 곳에 위치한 인터페이스 또는 상위 클래스를 검사하지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {}
  class Child extends Parent {
     public Parent Parent() {
       return null;
     }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러한 메서드의 이름을 변경하는 빠른 수정은 에디터에서만 사용할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: MethodNameSameAsParentName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonBooleanMethodNameMayNotStartWithQuestion" defaultSeverity="WARNING" displayName="부울이 아닌 메서드 이름은 질문 단어로 시작하면 안 됩니다." enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 의문사로 시작하는 부울이 아닌 메서드를 보고합니다. 그러한 메서드 이름은 혼동될 수 있습니다.
&lt;p&gt;라이브러리 메서드를 재정의하는 부울이 아닌 메서드는 이 검사에서 무시됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  public void hasName(String name) {
    assert names.contains(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러한 메서드의 이름을 변경하는 빠른 수정은 에디터에서만 사용할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;부울 메서드 이름 접두사&lt;/b&gt; 목록을 사용하여 부울 메서드에만 사용되어야 하는 의문사를 지정합니다.&lt;/li&gt;
  &lt;li&gt;반환 타입이 &lt;code&gt;java.lang.Boolean&lt;/code&gt;인 메서드를 무시하려면 &lt;b&gt;반환 타입이 'java.lang.Boolean'인 메서드 무시&lt;/b&gt; 옵션을 사용합니다.&lt;/li&gt;
  &lt;li&gt;상위 메서드가 있는 메서드를 무시하려면 &lt;b&gt;상위 메서드를 재정의/구현하는 메서드 무시&lt;/b&gt; 옵션을 사용합니다. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonBooleanMethodNameMayNotStartWithQuestion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverloadedVarargsMethod" defaultSeverity="WARNING" displayName="오버로드된 vararg 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스 또는 상위 클래스의 다른 메서드와 이름이 같은 vararg 메서드를 보고합니다.
가변 인수 수를 취하는 오버로드 메서드는 어떤 오버로드가 호출되었는지 확실하지 않은 경우가 많아 매우 혼동될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    public void execute(Runnable... r) {} // 경고
    public void execute(Runnable r1, Runnable r2) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  옵션을 사용하여 매개변수 타입이 확실히 호환되지 않는 오버로드된 메서드를 무시합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: OverloadedVarargsMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodNameSameAsClassName" defaultSeverity="WARNING" displayName="클래스 이름과 동일한 메서드 이름" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스와 이름이 동일하게 지정된 메서드를 보고합니다.
Java 언어에서 이와 같은 이름 지정이 허용되기는 하지만 일반적으로 생성자 정의에만 사용됩니다.
클래스와 동일한 이름을 메서드에 사용하는 것은 실수이거나 좋지 않은 방법일 가능성이 높습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    int val;

    // 포함하는 클래스와 이름이 동일하게 지정된 MyClass 메서드
    // 'void'도 실수로 추가되었을 수 있습니다
    void MyClass(int val) {
      this.val = val;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;적절한 경우 빠른 수정에서는 메서드를 생성자로 변환합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    int val;

    MyClass(int val) {
      this.val = val;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;메서드 이름을 변경하는 다른 빠른 수정도 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MethodNameSameAsClassName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="동시성 어노테이션 문제" path="Java"><inspection shortName="InstanceGuardedByStatic" defaultSeverity="WARNING" displayName="static 필드로 보호되는 인스턴스 멤버" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
가드가 &lt;code&gt;static&lt;/code&gt; 필드인 인스턴스 필드 또는 메서드의 &lt;code&gt;@GuardedBy&lt;/code&gt; 어노테이션을 보고합니다. static이 아닌 인스턴스 필드 또는 메서드의 가드가 static인 경우 과도한 잠금 경합을 초래할 수 있습니다. 객체 인스턴스의 각 잠긴 필드에 액세스하면 모든 객체 인스턴스의 해당 필드에 대한 동시 액세스가 차단되기 때문입니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private static ReadWriteLock lock = new ReentrantReadWriteLock(); //static guarding field
    private Object state;

    @GuardedBy("lock")
    public void bar() {
        state = new Object();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;지원되는 &lt;code&gt;@GuardedBy&lt;/code&gt; 어노테이션:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InstanceGuardedByStatic&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalGuard" defaultSeverity="WARNING" displayName="final이 아닌 '@GuardedBy' 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
보호하는 필드가 &lt;code&gt;final&lt;/code&gt;이 아닌 &lt;code&gt;@GuardedBy&lt;/code&gt; 어노테이션을 보고합니다.
&lt;p&gt;final이 아닌 필드를 보호할 경우 필드 자체(변경 가능)가 아닌 필드 값이 잠금되므로 예기치 않은 경합 상태가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private ReadWriteLock lock = new ReentrantReadWriteLock(); // final이 아닌 보호하는 필드
    private Object state;

    @GuardedBy("lock")
    public void bar() {
        state = new Object();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;지원되는 &lt;code&gt;@GuardedBy&lt;/code&gt; 어노테이션:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonFinalGuard&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldAccessNotGuarded" defaultSeverity="WARNING" displayName="보호되지 않는 필드 액세스 또는 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
적절한 동기화 구조로 보호되지 않으며 &lt;code&gt;@GuardedBy&lt;/code&gt;로 선언되는 필드 액세스를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    @GuardedBy("this")
    void x() {
        notify();
    }
    void y() {
        x(); // unguarded method call
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;지원되는 &lt;code&gt;@GuardedBy&lt;/code&gt; 어노테이션:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FieldAccessNotGuarded&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalFieldInImmutable" defaultSeverity="WARNING" displayName="@Immutable 클래스 내 비 final 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스에서 &lt;code&gt;@Immutable&lt;/code&gt; 어노테이션이 추가된 비 final 필드를 보고합니다.
이는 &lt;code&gt;@Immutable&lt;/code&gt; 어노테이션 컨트랙트에 위배됩니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import javax.annotation.concurrent.Immutable;
  @Immutable
  class Foo {
    String bar = "foo";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;지원되는 &lt;code&gt;@GuardedBy&lt;/code&gt; 어노테이션:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonFinalFieldInImmutable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnknownGuard" defaultSeverity="WARNING" displayName="알 수 없는 '@GuardedBy' 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지정된 보호 필드를 알 수 없는 &lt;code&gt;@GuardedBy&lt;/code&gt; 어노테이션을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private Object state;

    @GuardedBy("lock") //알 수 없는 가드 참조
    public void bar() {
        state = new Object();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;지원되는 &lt;code&gt;@GuardedBy&lt;/code&gt; 어노테이션:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnknownGuard&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticGuardedByInstance" defaultSeverity="WARNING" displayName="인스턴스 필드 또는 this로 보호되는 static 멤버" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
가드가 static이 아닌 필드이거나 &lt;code&gt;this&lt;/code&gt;인 &lt;code&gt;static&lt;/code&gt; 필드 또는 메서드의 &lt;code&gt;@GuardedBy&lt;/code&gt; 어노테이션을 보고합니다.
&lt;p&gt;static 요소를 static이 아닌 요소로 보호하면 과도한 동시성이 발생할 수 있으며, 서로 다른 객체 컨텍스트를 잠가, 가드된 필드에 여러 스레드가 동시에 액세스할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private ReadWriteLock lock = new ReentrantReadWriteLock();

    @GuardedBy("lock")
    public static void bar() {
        // ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;지원되는 &lt;code&gt;@GuardedBy&lt;/code&gt; 어노테이션:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StaticGuardedByInstance&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="발생할 수 있는 버그" path="CSS"><inspection shortName="CssMissingComma" defaultSeverity="WARNING" displayName="선택자 목록에 쉼표가 없습니다" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
여러 줄 선택자를 보고합니다. 이는 보통 여러 개의 한 줄 선택자를 사용하려 했으나 1개 이상의 줄 끝에 쉼표가 누락되었음을 가리킵니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
input /* comma has probably been forgotten */
.button {
  margin: 1px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssMissingComma&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssNoGenericFontName" defaultSeverity="WARNING" displayName="제네릭 글꼴 집합 이름 누락" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-family"&gt;font-family&lt;/a&gt;&lt;/code&gt; 프로퍼티가 폴백 대체 글꼴로 일반 글꼴 집합 이름을 포함하는지 확인합니다.
&lt;p&gt;
  일반 글꼴 집합 이름은 &lt;code&gt;serif&lt;/code&gt;, &lt;code&gt;sans-serif&lt;/code&gt;, &lt;code&gt;cursive&lt;/code&gt;, &lt;code&gt;fantasy&lt;/code&gt;, &lt;code&gt;monospace&lt;/code&gt;입니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssNoGenericFontName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssNonIntegerLengthInPixels" defaultSeverity="WEAK WARNING" displayName="픽셀 길이가 정수가 아닙니다" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
정수가 아닌 픽셀 길이를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 너비: 3.14px&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssNonIntegerLengthInPixels&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="애플리케이션 서버" path=""><inspection shortName="JBoss" defaultSeverity="ERROR" displayName="JBoss/WildFly" enabled="false" language="XML" pluginId="JBoss" pluginVersion="252.23892.409" isGlobalTool="false">&lt;!-- Copyright (c) 2004 - 2009 by Fuhrer Engineering AG, CH-2504 Biel/Bienne, Switzerland --&gt;
&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 JBoss용 XML 배포 설명자를 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;jboss-web.xml&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;jboss-app.xml&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;jboss.xml&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;몇 가지 보고된 문제는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인스턴스화할 수 없는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;필수 클래스를 확장하지 않는 클래스 참조&lt;/li&gt;
  &lt;li&gt;빈 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 하위 태그 또는 속성을 포함하지 않는 태그&lt;/li&gt;
  &lt;li&gt;이름이 중복된 객체를 정의하는 태그&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JBoss&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Lombok" path="Java"><inspection shortName="LombokFlagUsage" defaultSeverity="WARNING" displayName="Lombok flag usages" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;IntelliJ Lombok flagUsage 검사&lt;/h1&gt;

&lt;p&gt;
  이 검사는 &lt;code&gt;lombok.config&lt;/code&gt; 파일에 지정된 모든 &lt;code&gt;flagUsage&lt;/code&gt; 구성을 지원합니다. IntelliJ 내에서 플래그 지정하도록 구성된 Lombok 기능이 사용되면 경고 또는 오류를 발생시킵니다. 이러한 사전 예방적 피드백은 코드 표준을 준수하고 승인을 받은 Lombok 기능만 사용되도록 보장합니다.
&lt;/p&gt;

&lt;h2&gt;지원되는 flagUsage 구성&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
  &lt;tr&gt;
    &lt;th&gt;구성 키&lt;/th&gt;
    &lt;th&gt;설명&lt;/th&gt;
  &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.anyConstructor.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;XxxArgsConstructor&lt;/code&gt; 어노테이션이 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.allArgsConstructor.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@AllArgsConstructor&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.noArgsConstructor.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@NoArgsConstructor&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.requiredArgsConstructor.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@RequiredArgsConstructor&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.data.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Data&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.value.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Value&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.getter.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Getter&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.getter.lazy.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Getter(lazy=true)&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.setter.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Setter&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.equalsAndHashCode.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@EqualsAndHashCode&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.toString.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@ToString&lt;/code&gt;이 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.builder.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Builder&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.cleanup.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Cleanup&lt;/code&gt;이 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.delegate.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Delegate&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.nonNull.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@NonNull&lt;/code&gt;이 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.sneakyThrows.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@SneakyThrows&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.synchronized.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Synchronized&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.val.flagUsage&lt;/td&gt;
    &lt;td&gt;언어 키워드 &lt;code&gt;val&lt;/code&gt;이 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.var.flagUsage&lt;/td&gt;
    &lt;td&gt;언어 키워드 &lt;code&gt;var&lt;/code&gt;이 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.with.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@With&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.log.flagUsage&lt;/td&gt;
    &lt;td&gt;어떤 로그 어노테이션이든 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.log.apacheCommons.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@CommonsLog&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.log.javaUtilLogging.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Log&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.log.log4j.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Log4j&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.log.log4j2.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Log4j2&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.log.slf4j.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Slf4j&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.log.xslf4j.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@XSlf4j&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.log.jbosslog.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@JBossLog&lt;/code&gt;이 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.log.flogger.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Flogger&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.log.custom.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@CustomLog&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.experimental.flagUsage&lt;/td&gt;
    &lt;td&gt;실험적인 기능이 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.accessors.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Accessors&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.extensionMethod.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@ExtensionMethod&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.fieldDefaults.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@FieldDefaults&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.helper.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Helper&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.locked.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Locked&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.onX.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;onX&lt;/code&gt; 플래그가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.utilityClass.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@UtilityClass&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.fieldNameConstants.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@FieldNameConstants&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.superBuilder.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@SuperBuilder&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.withBy.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@WithBy&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.jacksonized.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@Jacksonized&lt;/code&gt;가 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;lombok.standardException.flagUsage&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;@StandardException&lt;/code&gt;이 사용되면 경고 또는 오류를 발생시킵니다.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LombokFlagUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DeprecatedLombok" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 Lombok 어노테이션" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
곧 사용할 수 없게 될 Lombok 어노테이션을 보고하고 해당 어노테이션을 main 패키지로 승격된 어노테이션으로 바꾸는 빠른 수정을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DeprecatedLombok&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringQualifierCopyableLombok" defaultSeverity="WARNING" displayName="Lombok으로 복사할 수 없는 @Qualifier" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해당 Lombok &lt;code&gt;@RequiredArgsConstructor&lt;/code&gt; 및 &lt;code&gt;@AllArgsConstructor&lt;/code&gt; 어노테이션에서 무시되는, 클래스 필드에 대한 Spring &lt;code&gt;@Qualifier&lt;/code&gt; 어노테이션을 보고합니다.
생성된 생성자는 &lt;code&gt;lombok.config&lt;/code&gt; 파일 내 &lt;code&gt;lombok.copyableAnnotations&lt;/code&gt; 정의가 없이는 &lt;code&gt;@Qualifier&lt;/code&gt; 어노테이션을 받지 않습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringQualifierCopyableLombok&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="Lombok" defaultSeverity="WARNING" displayName="Lombok 어노테이션" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Lombok 어노테이션에 대한 일반 검사를 제공합니다.
&lt;p&gt;
이 검토에서 보고된 경고와 오류는 Lombok 어노테이션 프로세서에서 컴파일 타임에 보고한 경고와 오류와 1:1로 일치하도록 설정되었습니다. 예를 들면 다음과 같습니다.
&lt;ul&gt;
  &lt;li&gt;
    불필요하게 적용된 어노테이션(경고로 보고됨)
    &lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;
      @ToString
      class Person {
        final String name;
        final int age;

        @Override
        public String toString() {
            return "Person{name='" + name + "', age=" + age + '}';
        }
      }
    &lt;/code&gt;&lt;/pre&gt;
    빠른 수정에서는 불필요한 어노테이션을 제거합니다.
  &lt;/li&gt;
  &lt;li&gt;
    잘못 적용된 어노테이션(오류로 보고됨)
    &lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;
      @Value
      record Person(String name, int age) {}
    &lt;/code&gt;&lt;/pre&gt;
    빠른 수정에서는 잘못된 어노테이션을 제거합니다.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Lombok&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StaticMethodImportLombok" defaultSeverity="WARNING" displayName="Lombok으로 생성된 메서드에는 static import 문 사용" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Lombok의 생성된 메서드에 사용되는 static import 문의 사용 위치를 보고합니다.&lt;br&gt;
&lt;p&gt;
  이는 javac으로 컴파일링할 때 실패합니다. lombok 어노테이션 프로세서가 개입하기 전에 static 메서드가 해결되기 때문입니다.
  현재 javac은 어노테이션 프로세서가 생성한 코드보다 원본 코드를 먼저 사용합니다. 그런 다음 누락된 심볼(생성된 메서드)을 보고합니다.
&lt;/p&gt;
자세한 내용은 &lt;a href="https://github.com/projectlombok/lombok/issues/2044"&gt;여기&lt;/a&gt;를 참조하세요
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: StaticMethodImportLombok&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Liquibase" path=""><inspection shortName="DuplicateChangesetId" defaultSeverity="ERROR" displayName="`author`가 같은 하나의 파일 내에 변경 집합의 `id` 속성이 중복됩니다. 변경 집합의 `author` 또는 `id` 값을 조정하세요." enabled="false" language="XML" pluginId="com.intellij.liquibase" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
하나의 파일에 있는 중복된 변경 세트 &lt;pre&gt;&lt;code&gt;id&lt;/code&gt;&lt;/pre&gt; 속성을 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DuplicateChangesetId&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LiquibaseXmlUnresolvedProperty" defaultSeverity="ERROR" displayName="해결되지 않은 Liquibase 프로퍼티" enabled="false" language="XML" pluginId="com.intellij.liquibase" pluginVersion="252.23892.409" isGlobalTool="false">&lt;!DOCTYPE html&gt;
&lt;html lang="ko"&gt;
&lt;body&gt;
해결되지 않은 Liquibase 프로퍼티의 사용을 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LiquibaseXmlUnresolvedProperty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="RELAX NG" path=""><inspection shortName="UnusedDefine" defaultSeverity="WARNING" displayName="사용되지 않는 정의" enabled="false" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
RELAX-NG 파일(XML 또는 Compact 구문) 내 사용되지 않는 명명된 패턴(&lt;code&gt;define&lt;/code&gt;)을 보고합니다.
다른 파일의 include에서 사용된 &lt;code&gt;define&lt;/code&gt; 요소는 무시됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnusedDefine&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnresolvedReference" defaultSeverity="ERROR" displayName="해결되지 않은 참조" enabled="false" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
XML 구문을 사용하는 RELAX-NG 파일 내 명명된 패턴(&lt;code&gt;define&lt;/code&gt;)으로의 해결되지 않은 참조를 를 보고합니다.
참조된 &lt;code&gt;define&lt;/code&gt; 요소를 생성할 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnresolvedReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 21" path="Java/Java 언어 수준 마이그레이션 지원"><inspection shortName="ImplicitToExplicitClassBackwardMigration" defaultSeverity="INFORMATION" displayName="묵시적으로 선언된 클래스는 일반 클래스로 변환될 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
묵시적으로 선언된 클래스를 보고하며 정규 클래스로 대체하도록 제안합니다.
&lt;p&gt;&lt;b&gt;예시(Sample.java 파일 내):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public static void main() {
      System.out.println("Hello, world!");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Sample {
    public static void main() {
        System.out.println("Hello, world!");
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 검사는 이전 Java 버전과의 하위 호환성을 위해 다운그레이드하는 데 도움이 될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2024.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 21-preview부터 사용할 수 있는 Java 기능 &amp;#39;묵시적으로 선언된 클래스&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ImplicitToExplicitClassBackwardMigration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SequencedCollectionMethodCanBeUsed" defaultSeverity="WARNING" displayName="SequencedCollection 메서드 사용 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;SequencedCollection&lt;/code&gt; 메서드를 사용해서 단순화할 수 있는 모든 컬렉션 API 메서드 호출을 보고합니다.
&lt;p&gt;다음의 변환이 지원됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;list.add(0, element)&lt;/code&gt; &amp;rarr; &lt;code&gt;list.addFirst(element);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;list.get(0)&lt;/code&gt; &amp;rarr; &lt;code&gt;list.getFirst();&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;list.get(list.size() - 1)&lt;/code&gt; &amp;rarr; &lt;code&gt;list.getLast();&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;list.remove(0)&lt;/code&gt; &amp;rarr; &lt;code&gt;list.removeFirst();&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;list.remove(list.size() - 1)&lt;/code&gt; &amp;rarr; &lt;code&gt;list.removeLast();&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;collection.iterator().next()&lt;/code&gt; &amp;rarr; &lt;code&gt;collection.getFirst();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2023.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 21부터 사용할 수 있는 Java 기능 &amp;#39;시퀀스가 설정된 컬렉션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SequencedCollectionMethodCanBeUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeconstructionCanBeUsed" defaultSeverity="WARNING" displayName="레코드 패턴 사용 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
레코드 패턴으로 바꿀 수 있는 패턴을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record Point(int x, int y) {
    static void printSum(Object obj) {
      if (obj instanceof Point p) {
        int x = p.x();
        int y = p.y();
        System.out.println(x + y);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record Point(int x, int y) {
    static void printSum(Object obj) {
      if (obj instanceof Point(int x, int y)) {
        System.out.println(x + y);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2023.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 21부터 사용할 수 있는 Java 기능 &amp;#39;패턴 가드 및 레코드 패턴&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DeconstructionCanBeUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExplicitToImplicitClassMigration" defaultSeverity="WARNING" displayName="묵시적 클래스 선언은 묵시적으로 선언된 클래스로 변환될 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
묵시적으로 선언된 클래스로 변환될 수 있는 일반적인 클래스를 보고합니다
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Sample {
      public static void main(String[] args) {
          System.out.println("Hello, world!");
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public static void main(String[] args) {
      System.out.println("Hello, world!");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2024.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 21-preview부터 사용할 수 있는 Java 기능 &amp;#39;묵시적으로 선언된 클래스&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ExplicitToImplicitClassMigration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringTemplateReverseMigration" defaultSeverity="INFORMATION" displayName="문자열 템플릿을 연결된 문자열일 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;STR&lt;/code&gt; 처리기를 사용하여 문자열 템플릿 표현식을 보고하며 일반 문자열 연결로 다시 마이그레이션하는 빠른 제안을 제공합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String name = "Bob";
  String greeting = STR."Hello, \{name}. 당신은 29살입니다.";
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String name = "Bob";
  String greeting = "Hello, " + name + ". 당신은 29살입니다.";
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;2024.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringTemplateReverseMigration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringTemplateMigration" defaultSeverity="WARNING" displayName="문자열 템플릿을 사용할 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자열 템플릿으로 대체하여 단순화할 수 있는 &lt;code&gt;String&lt;/code&gt; 연결을 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String name = "Bob";
  String greeting = "Hello, " + name + ". 당신은 " + 29 + "살입니다.";
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String name = "Bob";
  String greeting = STR."Hello, \{name}. 당신은 29살입니다.";
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;2023.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 21-preview부터 사용할 수 있는 Java 기능 &amp;#39;문자열 템플릿&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: StringTemplateMigration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="리플렉티브 액세스" path="Java"><inspection shortName="JavaLangInvokeHandleSignature" defaultSeverity="WARNING" displayName="MethodHandle/VarHandle 타입 불일치" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
어떠한 메서드 또는 필드와도 일치하지 않는 &lt;code&gt;MethodHandle&lt;/code&gt; 및 &lt;code&gt;VarHandle&lt;/code&gt; factory 메서드 호출을 보고합니다.
&lt;p&gt;또한 &lt;code&gt;MethodHandle&lt;/code&gt; 시그니처와 일치하지 않는 &lt;code&gt;MethodHandle.invoke()&lt;/code&gt; 및 비슷한 메서드의 인수, 그리고 &lt;code&gt;VarHandle&lt;/code&gt; 타입과 일치하지 않는 &lt;code&gt;VarHandle.set()&lt;/code&gt;의 인수를 보고합니다.
  &lt;!-- tooltip end --&gt;

&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;
  MethodHandle mh = MethodHandles.lookup().findVirtual(
      MyClass.class, "foo", MethodType.methodType(void.class, int.class));
  &lt;i&gt;// 인수는 &lt;b&gt;int&lt;/b&gt; 값이어야 합니다&lt;/i&gt;
  mh.invoke(myObj, "&lt;b&gt;abc&lt;/b&gt;");
&lt;/pre&gt;
&lt;br&gt;
&lt;pre&gt;
  &lt;i&gt;// 인수는 &lt;b&gt;String&lt;/b&gt;.class여야 합니다&lt;/i&gt;
  VarHandle vh = MethodHandles.lookup().findVarHandle(
      MyClass.class, "text", &lt;b&gt;int&lt;/b&gt;.class);
&lt;/pre&gt;
&lt;br&gt;
&lt;pre&gt;
  VarHandle vh = MethodHandles.lookup().findVarHandle(
      MyClass.class, "text", String.class);
  &lt;i&gt;//인수는 &lt;b&gt;String&lt;/b&gt; 값이어야 합니다&lt;/i&gt;
  vh.set(myObj, &lt;b&gt;42&lt;/b&gt;);
&lt;/pre&gt;
&lt;p&gt;
  &lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavaLangInvokeHandleSignature&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaReflectionInvocation" defaultSeverity="WARNING" displayName="리플렉티브 호출 인수 불일치" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Method.invoke()&lt;/code&gt; 및 &lt;code&gt;Constructor.newInstance()&lt;/code&gt;에 제공된 인수가 &lt;code&gt;Class.getMethod()&lt;/code&gt; 및 &lt;code&gt;Class.getConstructor()&lt;/code&gt;에 지정된 시그니처와 일치하지 않는 경우를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Method m = myObj.getClass().getMethod("myMethod", &lt;b&gt;int&lt;/b&gt;.class);
  &lt;i&gt;// 인수는 &lt;b&gt;int&lt;/b&gt; 값이어야 합니다&lt;/i&gt;
  m.invoke(myObj, "&lt;b&gt;abc&lt;/b&gt;");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavaReflectionInvocation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaReflectionMemberAccess" defaultSeverity="WARNING" displayName="없거나 보이지 않는 클래스 멤버에 대한 리플렉티브 액세스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
존재하지 않거나 표시되지 않는 필드와 메서드에 대한 리플렉티브 액세스를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Field stringHashField() throws NoSuchFieldException {
    return String.class.getField("hash");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Field stringHashField() throws NoSuchFieldException {
    return String.class.getDeclaredField("hash");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;final&lt;/code&gt; 클래스를 사용하면 클래스에 지정된 이름을 가진 필드 또는 메서드가 있는지 명확히 알 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;final&lt;/code&gt;이 아닌 클래스를 사용하면 하위 클래스에 해당 이름을 가진 필드 또는 메서드가 있을 수 있으므로 거짓 양성 오류가 발생할 수 있습니다.
  검사 설정을 사용하여 전체 또는 특정 클래스의 거짓 양성 오류를 제거합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavaReflectionMemberAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java9ReflectionClassVisibility" defaultSeverity="WARNING" displayName="모듈 문제 전체에 리플렉티브 액세스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Java 9 모듈 접근성 규칙에 따라 현재 범위에 표시되지 않는 클래스에 액세스하려는 &lt;code&gt;Class.forName()&lt;/code&gt; 및 &lt;code&gt;ClassLoader.loadClass()&lt;/code&gt; 호출을 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 9부터 사용할 수 있는 Java 기능 &amp;#39;모듈&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Java9ReflectionClassVisibility&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 8" path="Java/Java 언어 수준 마이그레이션 지원"><inspection shortName="CodeBlock2Expr" defaultSeverity="WARNING" displayName="람다 구문은 람다 표현식으로 바꿀수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
표현식 스타일의 본문이 대신 사용될 수 있는 경우 코드 블록 본문이 포함된 람다 식을 보고합니다.
변환 후 결과는 더욱 간결하고 명확합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Comparable&amp;lt;String&amp;gt; c = o -&gt; {return 0;};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Comparable&amp;lt;String&amp;gt; c = o -&gt; 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;람다 식&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CodeBlock2Expr&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaCanBeMethodCall" defaultSeverity="INFORMATION" displayName="람다를 메서드 호출로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JDK 메서드 호출로 대체 가능한 람다 식을 보고합니다.
&lt;p&gt;예: &lt;code&gt;Function&amp;lt;T, T&amp;gt;&lt;/code&gt; 타입의 표현식 &lt;code&gt;x -&amp;gt; x&lt;/code&gt;는 &lt;code&gt;Function.identity()&lt;/code&gt; 호출로 대체할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;람다 식&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LambdaCanBeMethodCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparatorCombinators" defaultSeverity="WARNING" displayName="'Comparator' 결합자를 사용할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Comparator.comparing()&lt;/code&gt; 호출을 사용하여 표현할 수 있는 람다 식으로 정의된 &lt;code&gt;Comparator&lt;/code&gt; 인스턴스를 보고합니다.
&lt;code&gt;Comparator.thenComparing()&lt;/code&gt; 식으로 바꿀 수 있는 체인 비교 또한 보고됩니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  myList.sort((person1, person2) -&gt; person1.getName().compareTo(person2.getName()));

  myList2.sort((person1, person2) -&gt; {
      int res = person1.first().compareTo(person2.first());
      if(res == 0) res = person1.second().compareTo(person2.second());
      if(res == 0) res = person1.third() - person2.third();
      return res;
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  myList.sort(Comparator.comparing(Person::getName));

  myList2.sort(Comparator.comparing(Person::first)
                         .thenComparing(Person::second)
                         .thenComparingInt(Person::third));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;람다 식&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ComparatorCombinators&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java8MapForEach" defaultSeverity="WARNING" displayName="Map.forEach() 사용 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;for(Entry&amp;lt;?,?&amp;gt; entry : map.entrySet()) {...}&lt;/code&gt; 또는 &lt;code&gt;map.entrySet().forEach(entry -&amp;gt; ...)&lt;/code&gt;를 &lt;code&gt;map.forEach((key, value) -&gt; ...)&lt;/code&gt;로 대체하도록 제안합니다.
&lt;p&gt;예시&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Map&amp;lt;String, Integer&amp;gt; map) {
    map.entrySet().forEach(entry -&gt; {
      String str = entry.getKey();
      System.out.println(str + ":" + entry.getValue());
    });
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Map&amp;lt;String, Integer&amp;gt; map) {
    map.forEach((str, value) -&gt; System.out.println(str + ":" + value));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;루프를 보고하지 않음&lt;/b&gt; 옵션이 활성화된 경우 &lt;code&gt;entrySet().forEach()&lt;/code&gt; 사례만 보고됩니다.
  &lt;code&gt;for&lt;/code&gt; 루프에도 빠른 수정 액션이 지원됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;컬렉션 내 람다 메서드&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Java8MapForEach&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FoldExpressionIntoStream" defaultSeverity="INFORMATION" displayName="표현식을 Stream 체인으로 접을 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;i&gt;Stream API&lt;/i&gt; 또는 &lt;code&gt;String.join()&lt;/code&gt; 호출로 대체 가능한 반복 패턴이 포함된 표현식을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean allStartWith(String a, String b, String c, String d, String prefix) {
    return a.startsWith(prefix) &amp;&amp; b.startsWith(prefix) &amp;&amp; c.startsWith(prefix) &amp;&amp; d.startsWith(prefix);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean foo(String a, String b, String c, String d, String prefix) {
    return Stream.of(a, b, c, d).allMatch(s -&gt; s.startsWith(prefix));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String joinAll(String a, String b, String c, String d) {
    return a + "," + b + "," + c + "," + d;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String joinAll(String a, String b, String c, String d) {
    return String.join(",", a, b, c, d);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FoldExpressionIntoStream&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java8CollectionRemoveIf" defaultSeverity="WARNING" displayName="루프를 'Collection.removeIf()'로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단일 &lt;code&gt;Collection.removeIf()&lt;/code&gt; 호출로 축소 가능한 루프를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Iterator&amp;lt;String&amp;gt; it = collection.iterator(); it.hasNext(); ) {
    String aValue = it.next();
    if(shouldBeRemoved(aValue)) {
      it.remove();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  collection.removeIf(aValue -&gt; shouldBeRemoved(aValue));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;컬렉션 내 람다 메서드&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Java8CollectionRemoveIf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java8ListReplaceAll" defaultSeverity="WARNING" displayName="루프는 'List.replaceAll()'로 대체될 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단일 &lt;code&gt;List.replaceAll()&lt;/code&gt; 호출로 축소 가능한 루프를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i = 0; i &amp;lt; strings.size(); i++) {
    String str = strings.get(i).toLowerCase();
    strings.set(i, str);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  strings.replaceAll(String::toLowerCase);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;컬렉션 내 람다 메서드&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Java8ListReplaceAll&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java8MapApi" defaultSeverity="WARNING" displayName="단순화 가능한 'Map' 작업" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Map&lt;/code&gt;의 일반적인 사용 패턴을 보고하고 다음으로 대체하도록 제안합니다.
&lt;code&gt;getOrDefault()&lt;/code&gt;, &lt;code&gt;computeIfAbsent()&lt;/code&gt;, &lt;code&gt;putIfAbsent()&lt;/code&gt;, &lt;code&gt;merge()&lt;/code&gt; 또는 &lt;code&gt;replaceAll()&lt;/code&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.containsKey(key) ? map.get(key) : "default";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.getOrDefault(key, "default");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = map.get(key);
  if (list == null) {
    list = new ArrayList&amp;lt;&amp;gt;();
    map.put(key, list);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.computeIfAbsent(key, localKey -&gt; new ArrayList&amp;lt;&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer val = map.get(key);
  if (val == null) map.put(key, 1);
  else map.put(key, val + 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.merge(key, 1, (localKey, localValue) -&gt; localValue + 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Map.Entry&amp;lt;String, String&amp;gt; entry : map.entrySet()) {
    map.put(entry.getKey(), transform(entry.getValue()));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.replaceAll((localKey, localValue) -&gt; transform(localValue));
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;람다 식으로 추출된 코드가 동일한 &lt;code&gt;Map&lt;/code&gt;을 수정하는 경우, 일부 &lt;code&gt;Map&lt;/code&gt; 구현에서 &lt;code&gt;computeIfAbsent()&lt;/code&gt; 또는 &lt;code&gt;merge()&lt;/code&gt;로 올바르게 대체되지 않을 수 있습니다. 기본적으로 이 코드에 부수 효과가 있으면 경고가 표시되지 않습니다. 필요한 경우 &lt;b&gt;람다에 부수 효과가 있더라도 대체 제안&lt;/b&gt; 옵션을 사용하여 경고를 항상 표시하세요.&lt;/p&gt;
&lt;p&gt;또한 &lt;code&gt;put()&lt;/code&gt;과 같은 기존 메서드와 &lt;code&gt;computeIfAbsent()&lt;/code&gt; 또는 &lt;code&gt;merge()&lt;/code&gt;와 같은 최신 메서드에서 &lt;code&gt;null&lt;/code&gt; 값이 다르게 처리되므로, 지정된 &lt;code&gt;Map&lt;/code&gt;에 &lt;code&gt;null&lt;/code&gt; 값을 저장하는 것이 중요한 경우 의미가 변경될 수 있습니다. 해당 값이 정적으로 null 가능한 값으로 알려진 경우 검사에서 대체를 제안하지 않지만 알려지지 않은 null 값 가능성이 있는 값에는 대체가 제안됩니다. 이 경우 경고를 억제하고 주석 설명을 추가하는 것이 좋습니다.
&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;컬렉션 내 람다 메서드&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Java8MapApi&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Convert2MethodRef" defaultSeverity="WARNING" displayName="람다를 메서드 참조로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 참조로 바꿀 수 있는 람다를 보고합니다. 취향의 차이인 경우가 많지만 람다보다 메서드 참조가 더 명확하고 가독성이 좋습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Runnable r = () -&gt; System.out.println();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Runnable r = System.out::println;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사는 람다가 메서드를 호출하지 않는 경우에도 메서드 참조를 제안할 수 있습니다(예: &lt;code&gt;obj -&gt; obj != null&lt;/code&gt;을 &lt;code&gt;Objects::nonNull&lt;/code&gt;로 대체). 
  &lt;a href="settings://preferences.sourceCode.Java?Lambda%20Body"&gt;Settings(설정) | Editor(에디터) | Code Style(코드 스타일) | Java | Code Generation(코드 생성)&lt;/a&gt; 설정을 통해 특수 메서드 참조를 구성합니다.
&lt;/p&gt;
&lt;p&gt;이 검사는 다음 Java 기능에 의존합니다.&lt;ul&gt;&lt;li&gt;람다 식&lt;/li&gt;&lt;li&gt;메서드 참조&lt;/li&gt;&lt;/ul&gt;이러한 기능은 Java 8부터 사용할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Convert2MethodRef&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifyForEach" defaultSeverity="INFORMATION" displayName="단순화 가능한 forEach() 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
더 간결한 메서드로 대체 가능하거나 중간 단계를 제거할 수 있는 &lt;code&gt;forEach()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; findNStrings(List&amp;lt;String&amp;gt; list, int n) {
    List&amp;lt;String&amp;gt; other = new ArrayList&amp;lt;&gt;();
    list.forEach(s -&gt; {
      if(s.length() &gt; n) other.add(s);
    });
    return other;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; findNStrings(List&amp;lt;String&amp;gt; list, int n) {
    List&amp;lt;String&amp;gt; other = list.stream()
      .filter(s -&gt; s.length() &gt; n)
      .collect(Collectors.toList());
    return other;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;컬렉션 내 람다 메서드&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SimplifyForEach&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Convert2Lambda" defaultSeverity="WARNING" displayName="익명 타입을 람다로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
람다 식으로 대체 가능한 익명 클래스를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Thread(new Runnable() {
    @Override
    public void run() {
      // run thread
    }
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Thread(() -&gt; {
    // run thread
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
익명 클래스가 무상태 람다로 변환되는 경우, 
후속 호출 중 Java 런타임에서 동일 람다 객체를 다시 사용할 수 있습니다. 반면 익명 클래스를 사용하면
 매번 별도의 객체가 생성됩니다. 따라서 빠른 수정 적용 시 드물게 의미가 변경될 수 있습니다.
예: 익명 클래스 인스턴스가 &lt;code&gt;HashMap&lt;/code&gt; 키로 사용되는 경우.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;b&gt;인터페이스에 @FunctionalInterface로 어노테이션이 추가되지 않은 경우 보고&lt;/b&gt; 옵션을 사용하여 익명 클래스가 &lt;code&gt;@FunctionalInterface&lt;/code&gt; 어노테이션이 없는 인터페이스를 구현한 경우를 무시합니다.
&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;람다 식&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Convert2Lambda&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StaticPseudoFunctionalStyleMethod" defaultSeverity="WARNING" displayName="Guava 의사 함수 호출을 Stream API 호출로 변환 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Java Stream API&lt;/code&gt;를 이용할 수 있는 경우 Guava 의사 함수 코드가 사용된 경우를 보고합니다.
&lt;p&gt;&lt;code&gt;Guava Iterable API&lt;/code&gt;는 &lt;code&gt;Java Streams API&lt;/code&gt;와 유사한 기능을 제공하지만 약간의 차이점이 있으며 일부 기능이 누락될 수 있습니다.
  특히 &lt;code&gt;IntStream&lt;/code&gt;과 같이 기본 타입에 특화된 스트림 항목은 제네릭 항목보다 성능 면에서 더욱 뛰어납니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
List&amp;lt;String&amp;gt; transformedIterable = Iterables.transform(someList, someTransformFunction);//경고: 의사 함수 스타일 코드
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; transformedIterable = someList.stream().map(someTransformFunction).collect(Collectors.toList());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;b&gt;참고:&lt;/b&gt; 코드 의미가 변경될 수 있습니다. 예를 들어, Guava의 &lt;code&gt;terable.transform&lt;/code&gt;은 지연 평가된 이터러블을 생성하지만 대체 시 즉시 평가된 이터러블이 생성됩니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: StaticPseudoFunctionalStyleMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseHashCodeMethodInspection" defaultSeverity="WARNING" displayName="표준 'hashCode()' 메서드를 사용할 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Long.hashCode&lt;/code&gt; 또는 &lt;code&gt;Double.hashCode()&lt;/code&gt; 메서드에 대한 호출로 바꿀 수 있는 비트 단위 연산을 보고합니다.
이 검사는 &lt;code&gt;x&lt;/code&gt;가 &lt;code&gt;long&lt;/code&gt; 타입의 변수거나 이전 &lt;code&gt;Double.doubleToLongBits()&lt;/code&gt; 호출의 결과인 생성자 &lt;code&gt;(int)(x ^ (x &gt;&gt;&gt; 32))&lt;/code&gt;를 탐지합니다. 이렇게 대체하면 코드가 단축되어 가독성이 높아집니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int result = (int)(var ^ (var &gt;&gt;&gt; 32));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int result = Long.hashCode(var);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 8 이상인 경우에만 보고합니다.
&lt;p&gt;&lt;small&gt;2024.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UseHashCodeMethodInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Convert2streamapi" defaultSeverity="INFORMATION" displayName="Stream API를 사용하면 루프를 접을 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
람다 식을 사용해 스트림 API로 대체 가능한 루프를 보고합니다.
&lt;p&gt;이렇게 대체하면 코드 스타일이 명령형에서 함수형으로 변경되며, 코드도 더욱 간결해집니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; check(List&amp;lt;String&gt; data) {
    &lt;b&gt;for&lt;/b&gt; (String e : data) {
      String trimmed = e.trim();
      &lt;b&gt;if&lt;/b&gt; (!trimmed.startsWith("xyz")) {
        &lt;b&gt;return&lt;/b&gt; false;
      }
    }
    return true;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; check(List&amp;lt;String&gt; data) {
    &lt;b&gt;return&lt;/b&gt; data.stream().map(String::trim).allMatch(trimmed -&gt; trimmed.startsWith("xyz"));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Convert2streamapi&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java8ListSort" defaultSeverity="WARNING" displayName="'Collections.sort()'를 'List.sort()'로 바꿀수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;list.sort(comparator)&lt;/code&gt;로 대체 가능한 &lt;code&gt;Collections.sort(list, comparator)&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;&lt;code&gt;Collections.sort&lt;/code&gt;는 래퍼에 불과하므로 인스턴스 메서드를 직접 사용하는 것이 좋습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;컬렉션 내 람다 메서드&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Java8ListSort&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousHasLambdaAlternative" defaultSeverity="WARNING" displayName="익명 타입에 더 짧은 람다 대체 항목이 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
생성자 또는 람다 식 인수를 사용하는 factory 메서드 호출로 변환 가능한 익명 클래스를 보고합니다
&lt;p&gt;이 검사를 통해 다음 클래스가 보고됩니다.
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;initialValue()&lt;/code&gt; 메서드가 포함된 &lt;code&gt;ThreadLocal&lt;/code&gt;을 확장하는 익명 클래스(&lt;code&gt;ThreadLocal.withInitial&lt;/code&gt;로 대체 가능)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;run()&lt;/code&gt; 메서드가 포함된 &lt;code&gt;Thread&lt;/code&gt;를 확장하는 익명 클래스(&lt;code&gt;new Thread(Runnable)&lt;/code&gt;로 대체 가능)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;new&lt;/b&gt; Thread() {
    @Override
    &lt;b&gt;public void&lt;/b&gt; run() {
      System.out.println("Hello from thread!");
    }
  }.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;new&lt;/b&gt; Thread(() -&gt; {
    System.out.println("Hello from thread!");
  }).start();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;ThreadLocal.withInitial()&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AnonymousHasLambdaAlternative&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Anonymous2MethodRef" defaultSeverity="WARNING" displayName="익명 타입을 메서드 참조로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 참조로 대체할 수 있는 익명 타입을 보고합니다.
&lt;p&gt;
  익명 클래스가 바인딩되지 않은 메서드 참조로 변환되는 경우, 
후속 호출 중 Java 런타임에서 동일 메서드 참조 객체를 다시 사용할 수 있습니다. 반면 익명 클래스를 사용하면
  매번 별도의 객체가 생성됩니다. 따라서 빠른 수정 적용 시 드물게 의미가 변경될 수 있습니다.
예: 익명 클래스 인스턴스가 &lt;code&gt;HashMap&lt;/code&gt; 키로 사용되는 경우.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Runnable r = new Runnable() {
    @Override
    public void run() {
      System.out.println();
    }
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Runnable r = System.out::println;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;인터페이스에 @FunctionalInterface 어노테이션이 추가되지 않은 경우 보고&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;@FunctionalInterface&lt;/code&gt; 어노테이션이 추가되지 않은 인터페이스에 대한 검사를 활성화합니다.&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;메서드 참조&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Anonymous2MethodRef&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Guava" defaultSeverity="WARNING" displayName="Guava의 함수 프리미티브 타입을 Java로 바꿀 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
표준 Java API 호출로 마이그레이션할 수 있는 Guava의 함수 기본 타입의 사용을 보고합니다.
&lt;p&gt;예를 들어, &lt;code&gt;FluentIterable&lt;/code&gt;, &lt;code&gt;Optional&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;,
  &lt;code&gt;Predicate&lt;/code&gt; 또는 &lt;code&gt;Supplier&lt;/code&gt; 등의 클래스 및 인터페이스 사용 위치가 검사를 통해 보고됩니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ImmutableList&amp;lt;String&amp;gt; results = FluentIterable.from(List.of(1, 2, 3)).transform(Object::toString).toList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; results = List.of(1, 2, 3).stream().map(Object::toString).collect(Collectors.toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
빠른 수정으로 의미가 달라질 수 있습니다. 지연 평가된 일부 Guava iterable이 즉시 평가되도록 변환될 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Guava&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Hibernate" path=""><inspection shortName="HibernateMappingDomInspection" defaultSeverity="ERROR" displayName="잘못된 Hibernate XML 매핑" enabled="false" language="XML" pluginId="com.intellij.hibernate" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;다음과 같은 Hibernate XML 구성 매핑 오류를 보고합니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;인스턴스화할 수 없는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;필수 클래스를 확장하지 않는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;부적절한 범위를 가진 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;빈 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 패턴(예: Java 식별자)과 일치하지 않는 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 하위 태그 또는 속성을 포함하지 않는 태그&lt;/li&gt;
  &lt;li&gt;이름이 중복된 객체를 정의하는 태그&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HibernateMappingDomInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HibernateFindAnnotationInspection" defaultSeverity="ERROR" displayName="@Find 어노테이션의 잘못된 사용" enabled="false" language="UAST" pluginId="com.intellij.hibernate" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Hibernate @Find 어노테이션 오류를 보고합니다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;어노테이션 추가된 메서드의 반환 타입은 엔티티 타입 &lt;b&gt;E&lt;/b&gt;이거나 다음 중 하나의 타입이어야 합니다.
    &lt;ul&gt;
      &lt;li&gt;java.util.List&amp;lt;E&amp;gt;&lt;/li&gt;
      &lt;li&gt;org.hibernate.query.Query&amp;lt;E&amp;gt;&lt;/li&gt;
      &lt;li&gt;org.hibernate.query.SelectionQuery&amp;lt;E&amp;gt;&lt;/li&gt;
      &lt;li&gt;jakarta.persistence.Query&amp;lt;E&amp;gt;&lt;/li&gt;
      &lt;li&gt;jakarta.persistence.TypedQuery&amp;lt;E&amp;gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;finder 메서드에 있는 매개변수의 이름과 타입은 finder 메서드가 반환하는 엔티티 타입의 영구 필드의 이름 및 타입과 정확히 일치해야 합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HibernateFindAnnotationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HibernateMappingDatasourceDomInspection" defaultSeverity="ERROR" displayName="잘못된 Hibernate DB 관련 XML 매핑" enabled="false" language="XML" pluginId="com.intellij.hibernate" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;다음과 같은 Hibernate XML 구성 DB 관련 매핑 오류를 보고합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;인식되지 않는 카탈로그/스키마/테이블에 대한 참조&lt;/li&gt;
  &lt;li&gt;인식되지 않는 열 참조&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HibernateMappingDatasourceDomInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HibernateConfigDomInspection" defaultSeverity="ERROR" displayName="잘못된 Hibernate XML 구성" enabled="false" language="XML" pluginId="com.intellij.hibernate" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;다음과 같은 Hibernate XML 구성 오류를 보고합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;인스턴스화할 수 없는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;필수 클래스를 확장하지 않는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;부적절한 범위를 가진 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;빈 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 패턴(예: Java 식별자)과 일치하지 않는 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 하위 태그 또는 속성을 포함하지 않는 태그&lt;/li&gt;
  &lt;li&gt;이름이 중복된 객체를 정의하는 태그&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HibernateConfigDomInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CriteriaApiResolveInspection" defaultSeverity="ERROR" displayName="Hibernate Criteria API로 인식되지 않는 프로퍼티" enabled="false" language="JAVA" pluginId="com.intellij.hibernate" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Hibernate Criteria API 사용 위치 내 인식되지 않는 프로퍼티를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CriteriaApiResolveInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HibernateConfigDomFacetInspection" defaultSeverity="WARNING" displayName="Hibernate 구성 XML이 패싯에 추가되지 않습니다" enabled="false" language="XML" pluginId="com.intellij.hibernate" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;누락된 Hibernate XML 구성 파일을 보고합니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 필요한 경우 패싯을 생성하고 해당 패싯에 구성 파일을 추가합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HibernateConfigDomFacetInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="유효성 문제" path="Gradle"><inspection shortName="DeprecatedConfigurations" defaultSeverity="WARNING" displayName="지원 중단된 구성" enabled="false" language="UAST" pluginId="org.jetbrains.plugins.gradle" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;지원 중단된 구성 메서드의 사용 위치를 탐지합니다.&lt;/p&gt;

  구성 메서드는 두 가지 이유로 지원 중단될 수 있습니다.
  &lt;ul&gt;
  &lt;li&gt;Gradle API가 개선되었습니다. 따라서 예전 메서드는 선택을 지양해야 합니다.&lt;/li&gt;
  &lt;li&gt;일부 플러그인은 더는 사용되지 않는 구성 메서드의 개선된 버전을 제공합니다.&lt;/li&gt;
  &lt;/ul&gt;
  지원 중단된 대부분의 메서드는 대안이 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="groovy"&gt;
plugins {
  id 'java'
}

dependencies {
  archive 'org.gradle.api:gradle:1.0' // reports 'archive'
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DeprecatedConfigurations&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncorrectPluginDslStructure" defaultSeverity="ERROR" displayName="플러그인 DSL 구조" enabled="false" language="UAST" pluginId="org.jetbrains.plugins.gradle" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;'plugins {}' 블록 앞에 허용되지 않는 구문을 탐지합니다 &lt;/p&gt;
Gradle Plugin DSL의 제한 때문에 '&lt;code&gt;plugins {}&lt;/code&gt;' 블록 앞에 제한된 Groovy 구문 집합만 사용할 수 있습니다. 유일한 옵션은 '&lt;code&gt;buildscript {}&lt;/code&gt;', '&lt;code&gt;pluginManagement {}&lt;/code&gt;' 및 기타 '&lt;code&gt;plugins {}&lt;/code&gt;'입니다. &lt;br&gt;
  &lt;a href="https://docs.gradle.org/current/userguide/plugins.html#plugins_dsl_limitations"&gt;Gradle 문서 참조&lt;/a&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="groovy"&gt;
import foo.bar.Baz
plugins {} // 'plugins'를 보고
plugins {
  foo() // 'foo'를 보고
  id 'java'
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IncorrectPluginDslStructure&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="스타일" path="Groovy"><inspection shortName="GrUnnecessaryAlias" defaultSeverity="WEAK WARNING" displayName="불필요한 import 별칭" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;불필요한 import 별칭을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import com.foo.Bar as Bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import com.foo.Bar
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrUnnecessaryAlias&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ChangeToOperator" defaultSeverity="WEAK WARNING" displayName="메서드 호출을 연산자 호출로 바꿀수 있음" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
연산자 호출로 바꿀 수 있는 메서드 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a.plus(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a + b
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ChangeToOperator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessaryPublicModifier" defaultSeverity="WARNING" displayName="불필요한 'public'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Groovy 클래스 및 메서드는 기본적으로 &lt;code&gt;public&lt;/code&gt;이므로 불필요한 &lt;code&gt;public&lt;/code&gt; 제어자를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo{
      public void bar(){
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo{
      void bar(){
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrUnnecessaryPublicModifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaStylePropertiesInvocation" defaultSeverity="INFORMATION" displayName="Java 스타일 프로퍼티 액세스" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;메서드 호출을 통해 액세스된 속성을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      int foo
  }

  def bar = new Foo()
  print(&lt;b&gt;bar.getFoo()&lt;/b&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      int foo
  }

  def bar = new Foo()
  print(&lt;b&gt;bar.foo&lt;/b&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JavaStylePropertiesInvocation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessaryDefModifier" defaultSeverity="WARNING" displayName="불필요한 'def'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;명시적 유형 선언과 함께 사용할 때 불필요한 &lt;code&gt;def&lt;/code&gt; 제어자를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;def&lt;/b&gt; boolean foo() {} // 제어자가 불필요합니다
  &lt;b&gt;def&lt;/b&gt; Object bar // 제어자가 불필요합니다

  // 제어자가 필요하므로 강조 표시되지 않습니다
  &lt;b&gt;def&lt;/b&gt; (int a, String b) = []
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrUnnecessaryDefModifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ChangeToMethod" defaultSeverity="INFORMATION" displayName="연산자 호출을 메서드 호출로 바꿀 수 있음" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 호출로 바꿀 수 있는 연산자 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a + b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a.plus(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ChangeToMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrStringStyleViolation" defaultSeverity="WEAK WARNING" displayName="문자열 스타일 위반" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;코드 스타일과 일치하지 않는 따옴표를 포함하는 문자열을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def hw = "Hello, world!"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def hw = 'Hello, world!'
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;다양한 종류의 문자열에서 코드 스타일을 지정하려면 아래 제공한 필드를 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GrStringStyleViolation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConditional" defaultSeverity="WARNING" displayName="삼항식" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
삼항식을 보고합니다.
&lt;p&gt;일부 코딩 표준에서는 조건 연산자의 사용을 금지하며 대신 &lt;code&gt;if&lt;/code&gt; 문을 권장합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyConditional&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessarySealedModifier" defaultSeverity="WARNING" displayName="불필요한 'sealed' 제어자" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;메서드, 필드 또는 변수에 사용되는 불필요한 &lt;code&gt;sealed&lt;/code&gt; 제어자를 보고합니다.&lt;/p&gt;
&lt;p&gt;이 제어자는 클래스, 인터페이스 및 특성에서만 효과가 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;sealed&lt;/b&gt; boolean foo() {} // 제어자가 불필요합니다
  &lt;b&gt;sealed&lt;/b&gt; Object bar // 제어자가 불필요합니다

  // 제어자가 필요하므로 강조 표시되지 않습니다
  &lt;b&gt;sealed&lt;/b&gt; class A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrUnnecessarySealedModifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessarySemicolon" defaultSeverity="WARNING" displayName="불필요한 세미콜론" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;불필요한 세미콜론을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  print 2; print 3 // 세미콜론이 필요합니다
  print 2; // 세미콜론이 불필요합니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrUnnecessarySemicolon&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessaryNonSealedModifier" defaultSeverity="WARNING" displayName="불필요한 'non-sealed' 제어자" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;메서드, 필드 또는 변수에 사용되는 불필요한 &lt;code&gt;non-sealed&lt;/code&gt; 제어자를 보고합니다.&lt;/p&gt;
&lt;p&gt;이 제어자는 클래스, 인터페이스 및 특성에서만 효과가 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;non-sealed&lt;/b&gt; boolean foo() {} // 제어자가 불필요합니다
  &lt;b&gt;non-sealed&lt;/b&gt; Object bar // 제어자가 불필요합니다

  // 제어자가 필요하므로 강조 표시되지 않습니다
  &lt;b&gt;non-sealed&lt;/b&gt; class A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrUnnecessaryNonSealedModifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessaryFinalModifier" defaultSeverity="WARNING" displayName="불필요한 'final'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;레코드 정의와 함께 사용할 때 불필요한 &lt;code&gt;final&lt;/code&gt; 제어자를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;final&lt;/b&gt; record R(int a) {} // 제어자는 필요하지 않습니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrUnnecessaryFinalModifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="클래스" path="Java/이름 생성 규칙"><inspection shortName="NonExceptionNameEndsWithException" defaultSeverity="WARNING" displayName="비예외 클래스 이름이 'Exception'으로 끝남" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 &lt;code&gt;Exception&lt;/code&gt;으로 끝나는 비 &lt;code&gt;exception&lt;/code&gt; 클래스를 보고합니다.
&lt;p&gt;이러한 클래스는 일반적인 이름 지정 규칙을 위반하여 혼동을 일으킬 수 있으며 &lt;code&gt;extends Exception&lt;/code&gt; 절이 누락되었음을 나타내는 경우가 많습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;
  &lt;pre&gt;&lt;code&gt;public class NotStartedException {}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러한 클래스의 이름을 변경하는 빠른 수정은 에디터에서만 사용할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonExceptionNameEndsWithException&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassNamePrefixedWithPackageName" defaultSeverity="WARNING" displayName="패키지 이름 앞에 붙어 있는 클래스 이름" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
패키지 이름이 접두사로 사용된 클래스를 대/소문자 구분을 무시하여 보고합니다.
&lt;p&gt;그러한 이름을 갖는 것이 합리적인 경우도 있으나 좋지 않은 명명 규칙에 따라 사용되어 불필요하고 번거로울 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;
  &lt;pre&gt;&lt;code&gt;
  package byteCode;
  class ByteCodeAnalyzer {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러한 클래스의 이름을 변경하는 빠른 수정은 에디터에서만 사용할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ClassNamePrefixedWithPackageName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExceptionNameDoesntEndWithException" defaultSeverity="WARNING" displayName="예외 클래스 이름이 'Exception'으로 끝나지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 &lt;code&gt;Exception&lt;/code&gt;으로 끝나지 않는 예외 클래스를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt; &lt;code&gt;class NotStartedEx extends Exception {}&lt;/code&gt;
&lt;p&gt;그러한 클래스의 이름을 변경하는 빠른 수정은 에디터에서만 사용할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ExceptionNameDoesntEndWithException&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NewClassNamingConvention" defaultSeverity="WARNING" displayName="클래스 이름 지정 규칙" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길거나 지정된 정규 표현식 패턴을 따르지 않는 클래스를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt; 검사가 테스트에 대해 활성화되어 있으며 클래스 이름의 최소 길이가 8(디폴트)로 지정되어 있는 경우, 다음 테스트 클래스는 이름 길이가 8보다 작은 6이므로 경고가 발생합니다. &lt;code&gt;public class MyTest{}&lt;/code&gt;
&lt;p&gt;그러한 클래스의 이름을 변경하는 빠른 수정은 에디터에서만 사용할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;옵션&lt;/b&gt; 섹션의 목록을 사용하여 검사되어야 하는 클래스를 지정하세요. 검사를 건너뛰려는 클래스의 체크박스를 선택 해제하세요.&lt;/p&gt;
&lt;p&gt;각 클래스 타입에 대해 제공된 입력 필드를 사용하여 최소 길이, 최대 길이, 클래스 이름에 필요한 정규 표현식을 지정하세요. 대응하는 검사를 건너뛰려면 length 필드에 &lt;b&gt;0&lt;/b&gt;을 지정하세요.&lt;/p&gt;
&lt;p&gt;정규 표현식은 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식으로 지정되어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NewClassNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassNameSameAsAncestorName" defaultSeverity="WARNING" displayName="조상의 이름과 동일한 클래스 이름" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상위 클래스 중 하나와 이름이 같지만 정규화된 이름은 다른 클래스를 보고합니다.
그러한 클래스 이름은 혼동될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;
  package util;
  abstract class Iterable&amp;lt;T&amp;gt; implements java.lang.Iterable&amp;lt;T&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러한 클래스의 이름을 변경하는 빠른 수정은 에디터에서만 사용할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ClassNameSameAsAncestorName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="모범 사례" path="Gradle"><inspection shortName="ConfigurationAvoidance" defaultSeverity="WARNING" displayName="구성 회피" enabled="false" language="UAST" pluginId="org.jetbrains.plugins.gradle" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;(Gradle 4.9+) 작업과 즉시 상호작용하는 API의 사용을 탐지합니다.&lt;/p&gt;
&lt;p&gt;작업과 즉시 상호작용하면 여러 문제가 발생할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;작업 간 모든 종속성을 사용자가 수동으로 설정해야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:build_phases"&gt;구성 단계&lt;/a&gt;에서 즉시 작동하는 API로 액세스된 모든 작업은 추후에 실행되지 않더라도 구성된 상태가 됩니다.
    이에 따라 성능 저하가 발생합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;추후 즉시 작동하는 API는 지원 중단되고 지연되어 작동하는 API로 대체될 예정입니다.&lt;/p&gt;
&lt;p&gt;마이그레이션 가이드는
  &lt;a href="https://docs.gradle.org/current/userguide/task_configuration_avoidance.html"&gt;Gradle 문서&lt;/a&gt;를 참조하세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;task foo { // 'task'를 경고하고 'task.register'로 바꾸도록 제안합니다
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ConfigurationAvoidance&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring Data" path=""><inspection shortName="SpringDataJdbcAssociatedDbElementsInspection" defaultSeverity="ERROR" displayName="Spring Data JDBC와 연결된 DB 요소" enabled="false" language="UAST" pluginId="com.intellij.spring.data" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음 Spring Data JDBC 어노테이션 내부의 참조가 구성된 데이터 소스 안에서 해결될 수 없는 경우를 보고합니다.&lt;br/&gt;
&lt;ul&gt;
  &lt;li&gt; @Table(name, schema)&lt;/li&gt;
  &lt;li&gt; @Column(name)&lt;/li&gt;
  &lt;li&gt; @MappedCollection(idColumn, keyColumn)&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;참고:&lt;/b&gt; '데이터 소스 할당' 액션 또는 엔티티 클래스에 해당하는 여백 아이콘을 통해 데이터 소스를 구성할 수 있습니다
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SpringDataJdbcAssociatedDbElementsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Android Lint: Performance" path=""><inspection shortName="AndroidLintUnusedIds" defaultSeverity="WARNING" displayName="Unused id" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unused id&lt;br&gt;&lt;br&gt;This resource id definition appears not to be needed since it is not referenced from anywhere. Having id definitions, even if unused, is not necessarily a bad idea since they make working on layouts and menus easier, so there is not a strong reason to delete these.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
The unused resource check can ignore tests. If you want to include resources that are only referenced from tests, consider packaging them in a test source set instead.&lt;br/&gt;
&lt;br/&gt;
You can include test sources in the unused resource check by setting the system property lint.unused-resources.include-tests =true, and to exclude them (usually for performance reasons), use lint.unused-resources.exclude-tests =true.&lt;br/&gt;
&lt;br&gt;&lt;br&gt;Issue id: UnusedIds&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHandlerLeak" defaultSeverity="WARNING" displayName="Handler reference leaks" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Handler reference leaks&lt;br&gt;&lt;br&gt;Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a &lt;code&gt;Looper&lt;/code&gt; or &lt;code&gt;MessageQueue&lt;/code&gt; for a thread other than the main thread, then there is no issue. If the &lt;code&gt;Handler&lt;/code&gt; is using the &lt;code&gt;Looper&lt;/code&gt; or &lt;code&gt;MessageQueue&lt;/code&gt; of the main thread, you need to fix your &lt;code&gt;Handler&lt;/code&gt; declaration, as follows: Declare the &lt;code&gt;Handler&lt;/code&gt; as a static class; In the outer class, instantiate a &lt;code&gt;WeakReference&lt;/code&gt; to the outer class and pass this object to your &lt;code&gt;Handler&lt;/code&gt; when you instantiate the &lt;code&gt;Handler&lt;/code&gt;; Make all references to members of the outer class using the &lt;code&gt;WeakReference&lt;/code&gt; object.&lt;br&gt;&lt;br&gt;Issue id: HandlerLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotificationTrampoline" defaultSeverity="ERROR" displayName="Notification Trampolines" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notification Trampolines&lt;br&gt;&lt;br&gt;Activities should not be launched indirectly from a notification via an intermediate &lt;code&gt;BroadcastReceiver&lt;/code&gt; or &lt;code&gt;Service&lt;/code&gt;. This can lead to significant lags in some scenarios, and is forbidden if &lt;code&gt;targetSdkVersion&lt;/code&gt; is set to the API level for Android 12 or higher.&lt;br/&gt;
&lt;br/&gt;
To fix this, launch the &lt;code&gt;Activity&lt;/code&gt; directly from the notification.&lt;br&gt;&lt;br&gt;Issue id: NotificationTrampoline&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDevModeObsolete" defaultSeverity="WARNING" displayName="Dev Mode Obsolete" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Dev Mode Obsolete&lt;br&gt;&lt;br&gt;In the past, our documentation recommended creating a &lt;code&gt;dev&lt;/code&gt; product flavor with has a minSdkVersion of 21, in order to enable multidexing to speed up builds significantly during development.&lt;br/&gt;
&lt;br/&gt;
That workaround is no longer necessary, and it has some serious downsides, such as breaking API access checking (since the true &lt;code&gt;minSdkVersion&lt;/code&gt; is no longer known).&lt;br/&gt;
&lt;br/&gt;
In recent versions of the IDE and the Gradle plugin, the IDE automatically passes the API level of the connected device used for deployment, and if that device is at least API 21, then multidexing is automatically turned on, meaning that you get the same speed benefits as the &lt;code&gt;dev&lt;/code&gt; product flavor but without the downsides.&lt;br&gt;&lt;br&gt;Issue id: DevModeObsolete&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintObsoleteLayoutParam" defaultSeverity="WARNING" displayName="Obsolete layout params" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete layout params&lt;br&gt;&lt;br&gt;The given layout_param is not defined for the given layout, meaning it has no effect. This usually happens when you change the parent layout or move view code around without updating the layout params. This will cause useless attribute processing at runtime, and is misleading for others reading the layout so the parameter should be removed.&lt;br&gt;&lt;br&gt;Issue id: ObsoleteLayoutParam&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUselessParent" defaultSeverity="WARNING" displayName="Unnecessary parent layout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unnecessary parent layout&lt;br&gt;&lt;br&gt;A layout with children that has no siblings, is not a scrollview or a root layout, and does not have a background, can be removed and have its children moved directly into the parent for a flatter and more efficient layout hierarchy.&lt;br&gt;&lt;br&gt;Issue id: UselessParent&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDisableBaselineAlignment" defaultSeverity="WARNING" displayName="Missing baselineAligned attribute" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;baselineAligned&lt;/code&gt; attribute&lt;br&gt;&lt;br&gt;When a &lt;code&gt;LinearLayout&lt;/code&gt; is used to distribute the space proportionally between nested layouts, the baseline alignment property should be turned off to make the layout computation faster.&lt;br&gt;&lt;br&gt;Issue id: DisableBaselineAlignment&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateDivider" defaultSeverity="WARNING" displayName="Unnecessary Divider Copy" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unnecessary Divider Copy&lt;br&gt;&lt;br&gt;Older versions of the RecyclerView library did not include a divider decorator, but one was provided as a sample in the support demos. This divider class has been widely copy/pasted into various projects.&lt;br/&gt;
&lt;br/&gt;
In recent versions of the support library, the divider decorator is now included, so you can replace custom copies with the "built-in" version, &lt;code&gt;android.support.v7.widget.DividerItemDecoration&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: DuplicateDivider&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLaunchActivityFromNotification" defaultSeverity="WARNING" displayName="Notification Launches Services or BroadcastReceivers" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notification Launches Services or BroadcastReceivers&lt;br&gt;&lt;br&gt;Notifications should only launch activities -- that's what users expect (and has been the guidance in both the Android SDK and Material Design documentation for a while).&lt;br/&gt;
&lt;br/&gt;
A &lt;code&gt;Service&lt;/code&gt; or a &lt;code&gt;BroadcastReceiver&lt;/code&gt; should not be used as an intermediate, because this can lead to significant performance problems, and as a result, this will not be allowed in Android 12.&lt;br&gt;&lt;br&gt;Issue id: LaunchActivityFromNotification&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/notifiers/notifications?hl=en#Actions"&gt;https://developer.android.com/guide/topics/ui/notifiers/notifications?hl=en#Actions&lt;/a&gt;&lt;br&gt;&lt;a href="https://d.android.com/r/studio-ui/designer/material/notifications-behavior"&gt;https://d.android.com/r/studio-ui/designer/material/notifications-behavior&lt;/a&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/notifiers/notifications?hl=en"&gt;https://developer.android.com/guide/topics/ui/notifiers/notifications?hl=en&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseCompoundDrawables" defaultSeverity="WARNING" displayName="Node can be replaced by a TextView with compound drawables" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Node can be replaced by a &lt;code&gt;TextView&lt;/code&gt; with compound drawables&lt;br&gt;&lt;br&gt;A &lt;code&gt;LinearLayout&lt;/code&gt; which contains an &lt;code&gt;ImageView&lt;/code&gt; and a &lt;code&gt;TextView&lt;/code&gt; can be more efficiently handled as a compound drawable (a single TextView, using the &lt;code&gt;drawableTop&lt;/code&gt;, &lt;code&gt;drawableLeft&lt;/code&gt;, &lt;code&gt;drawableRight&lt;/code&gt; and/or &lt;code&gt;drawableBottom&lt;/code&gt; attributes to draw one or more images adjacent to the text).&lt;br/&gt;
&lt;br/&gt;
If the two widgets are offset from each other with margins, this can be replaced with a &lt;code&gt;drawablePadding&lt;/code&gt; attribute.&lt;br/&gt;
&lt;br/&gt;
There's a lint quickfix to perform this conversion in the Eclipse plugin.&lt;br&gt;&lt;br&gt;Issue id: UseCompoundDrawables&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedResources" defaultSeverity="WARNING" displayName="Unused resources" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unused resources&lt;br&gt;&lt;br&gt;Unused resources make applications larger and slow down builds.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
The unused resource check can ignore tests. If you want to include resources that are only referenced from tests, consider packaging them in a test source set instead.&lt;br/&gt;
&lt;br/&gt;
You can include test sources in the unused resource check by setting the system property lint.unused-resources.include-tests =true, and to exclude them (usually for performance reasons), use lint.unused-resources.exclude-tests =true.&lt;br/&gt;
,&lt;br&gt;&lt;br&gt;Issue id: UnusedResources&lt;br&gt;&lt;br&gt;Available options:&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;skip-libraries&lt;/b&gt; (default is true):&lt;br/&gt;
Whether the unused resource check should skip reporting unused resources in libraries.&lt;br/&gt;
&lt;br/&gt;
Many libraries will declare resources that are part of the library surface; other modules depending on the library will also reference the resources. To avoid reporting all these resources as unused (in the context of a library), the unused resource check normally skips reporting unused resources in libraries. Instead, run the unused resource check on the consuming app module (along with &lt;code&gt;checkDependencies=true&lt;/code&gt;).&lt;br/&gt;
&lt;br/&gt;
However, there are cases where you want to check that all the resources declared in a library are used; in that case, you can disable the skip option.&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="UnusedResources"&gt;
        &amp;lt;option name="skip-libraries" value="true" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLogConditional" defaultSeverity="WARNING" displayName="Unconditional Logging Calls" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unconditional Logging Calls&lt;br&gt;&lt;br&gt;The &lt;code&gt;BuildConfig&lt;/code&gt; class provides a constant, &lt;code&gt;DEBUG&lt;/code&gt;, which indicates whether the code is being built in release mode or in debug mode. In release mode, you typically want to strip out all the logging calls. Since the compiler will automatically remove all code which is inside a &lt;code&gt;if (false)&lt;/code&gt; check, surrounding your logging calls with a check for &lt;code&gt;BuildConfig.DEBUG&lt;/code&gt; is a good idea.&lt;br/&gt;
&lt;br/&gt;
If you &lt;b&gt;really&lt;/b&gt; intend for the logging to be present in release mode, you can suppress this warning with a &lt;code&gt;@SuppressLint&lt;/code&gt; annotation for the intentional logging calls.&lt;br&gt;&lt;br&gt;Issue id: LogConditional&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseOfBundledGooglePlayServices" defaultSeverity="WARNING" displayName="Use of bundled version of Google Play services" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use of bundled version of Google Play services&lt;br&gt;&lt;br&gt;Google Play services SDK's can be selectively included, which enables a smaller APK size. Consider declaring dependencies on individual Google Play services SDK's. If you are using Firebase API's (&lt;a href="https://firebase.google.com/docs/android/setup"&gt;https://firebase.google.com/docs/android/setup&lt;/a&gt;), Android Studio's Tools &amp;#8594; Firebase assistant window can automatically add just the dependencies needed for each feature.&lt;br&gt;&lt;br&gt;Issue id: UseOfBundledGooglePlayServices&lt;br&gt;&lt;br&gt;&lt;a href="https://developers.google.com/android/guides/setup#split"&gt;https://developers.google.com/android/guides/setup#split&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAssertionSideEffect" defaultSeverity="WARNING" displayName="Assertions with Side Effects" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Assertions with Side Effects&lt;br&gt;&lt;br&gt;Assertion conditions can have side effects. This is risky because the behavior depends on whether assertions are on or off. This is usually not intentional, and can lead to bugs where the production version differs from the version tested during development.&lt;br/&gt;
&lt;br/&gt;
Generally, you'll want to perform the operation with the side effect before the assertion, and then assert that the result was what you expected.&lt;br&gt;&lt;br&gt;Issue id: AssertionSideEffect&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUselessLeaf" defaultSeverity="WARNING" displayName="Unnecessary leaf layout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unnecessary leaf layout&lt;br&gt;&lt;br&gt;A layout that has no children or no background can often be removed (since it is invisible) for a flatter and more efficient layout hierarchy.&lt;br&gt;&lt;br&gt;Issue id: UselessLeaf&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintObsoleteSdkInt" defaultSeverity="WARNING" displayName="Obsolete SDK_INT Version Check" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete SDK_INT Version Check&lt;br&gt;&lt;br&gt;This check flags version checks that are not necessary, because the &lt;code&gt;minSdkVersion&lt;/code&gt; (or surrounding known API level) is already at least as high as the version checked for.&lt;br/&gt;
&lt;br/&gt;
Similarly, it also looks for resources in &lt;code&gt;-vNN&lt;/code&gt; folders, such as &lt;code&gt;values-v14&lt;/code&gt; where the version qualifier is less than or equal to the &lt;code&gt;minSdkVersion&lt;/code&gt;, where the contents should be merged into the best folder.&lt;br&gt;&lt;br&gt;Issue id: ObsoleteSdkInt&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAnnotationProcessorOnCompilePath" defaultSeverity="WARNING" displayName="Annotation Processor on Compile Classpath" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Annotation Processor on Compile Classpath&lt;br&gt;&lt;br&gt;This dependency is identified as an annotation processor. Consider adding it to the processor path using &lt;code&gt;annotationProcessor&lt;/code&gt; instead of including it to the compile path.&lt;br&gt;&lt;br&gt;Issue id: AnnotationProcessorOnCompilePath&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExpensiveAssertion" defaultSeverity="WARNING" displayName="Expensive Assertions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Expensive Assertions&lt;br&gt;&lt;br&gt;In Kotlin, assertions are not handled the same way as from the Java programming language. In particular, they're just implemented as a library call, and inside the library call the error is only thrown if assertions are enabled.&lt;br/&gt;
&lt;br/&gt;
This means that the arguments to the &lt;code&gt;assert&lt;/code&gt; call will &lt;b&gt;always&lt;/b&gt; be evaluated. If you're doing any computation in the expression being asserted, that computation will unconditionally be performed whether or not assertions are turned on. This typically turns into wasted work in release builds.&lt;br/&gt;
&lt;br/&gt;
This check looks for cases where the assertion condition is nontrivial, e.g. it is performing method calls or doing more work than simple comparisons on local variables or fields.&lt;br/&gt;
&lt;br/&gt;
You can work around this by writing your own inline assert method instead:&lt;br/&gt;

&lt;pre&gt;
@Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER")
inline fun assert(condition: () -&gt; Boolean) {
    if (_Assertions.ENABLED &amp;amp;&amp;amp; !condition()) {
        throw AssertionError()
    }
}
&lt;/pre&gt;
&lt;br/&gt;
In Android, because assertions are not enforced at runtime, instead use this:&lt;br/&gt;

&lt;pre&gt;
inline fun assert(condition: () -&gt; Boolean) {
    if (BuildConfig.DEBUG &amp;amp;&amp;amp; !condition()) {
        throw AssertionError()
    }
}
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;Issue id: ExpensiveAssertion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLifecycleAnnotationProcessorWithJava8" defaultSeverity="WARNING" displayName="Lifecycle Annotation Processor with Java 8 Compile Option" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Lifecycle Annotation Processor with Java 8 Compile Option&lt;br&gt;&lt;br&gt;For faster incremental build, switch to the Lifecycle Java 8 API with these steps:&lt;br/&gt;
&lt;br/&gt;
First replace
&lt;pre&gt;
annotationProcessor "androidx.lifecycle:lifecycle-compiler:*version*"
kapt "androidx.lifecycle:lifecycle-compiler:*version*"
&lt;/pre&gt;
with
&lt;pre&gt;
implementation "androidx.lifecycle:lifecycle-common-java8:*version*"
&lt;/pre&gt;
Then remove any &lt;code&gt;OnLifecycleEvent&lt;/code&gt; annotations from &lt;code&gt;Observer&lt;/code&gt; classes and make them implement the &lt;code&gt;DefaultLifecycleObserver&lt;/code&gt; interface.&lt;br&gt;&lt;br&gt;Issue id: LifecycleAnnotationProcessorWithJava8&lt;br&gt;&lt;br&gt;&lt;a href="https://d.android.com/r/studio-ui/lifecycle-release-notes"&gt;https://d.android.com/r/studio-ui/lifecycle-release-notes&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearableBindListener" defaultSeverity="ERROR" displayName="Usage of Android Wear BIND_LISTENER is deprecated" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Usage of Android Wear BIND_LISTENER is deprecated&lt;br&gt;&lt;br&gt;BIND_LISTENER receives all Android Wear events whether the application needs them or not. This can be inefficient and cause applications to wake up unnecessarily. With Google Play Services 8.2.0 or later it is recommended to use a more efficient combination of manifest listeners and api-based live listeners filtered by action, path and/or path prefix.&lt;br&gt;&lt;br&gt;Issue id: WearableBindListener&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2016/04/deprecation-of-bindlistener.html"&gt;https://android-developers.googleblog.com/2016/04/deprecation-of-bindlistener.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWakelockTimeout" defaultSeverity="WARNING" displayName="Using wakeLock without timeout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using wakeLock without timeout&lt;br&gt;&lt;br&gt;Wakelocks have two acquire methods: one with a timeout, and one without. You should generally always use the one with a timeout. A typical timeout is 10 minutes. If the task takes longer than it is critical that it happens (i.e. can't use &lt;code&gt;JobScheduler&lt;/code&gt;) then maybe they should consider a foreground service instead (which is a stronger run guarantee and lets the user know something long/important is happening).&lt;br&gt;&lt;br&gt;Issue id: WakelockTimeout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseSparseArrays" defaultSeverity="WARNING" displayName="HashMap can be replaced with SparseArray" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;HashMap can be replaced with SparseArray&lt;br&gt;&lt;br&gt;For maps where the keys are of type integer, it's typically more efficient to use the Android &lt;code&gt;SparseArray&lt;/code&gt; API. This check identifies scenarios where you might want to consider using &lt;code&gt;SparseArray&lt;/code&gt; instead of &lt;code&gt;HashMap&lt;/code&gt; for better performance.&lt;br/&gt;
&lt;br/&gt;
This is &lt;b&gt;particularly&lt;/b&gt; useful when the value types are primitives like ints, where you can use &lt;code&gt;SparseIntArray&lt;/code&gt; and avoid auto-boxing the values from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;Integer&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If you need to construct a &lt;code&gt;HashMap&lt;/code&gt; because you need to call an API outside of your control which requires a &lt;code&gt;Map&lt;/code&gt;, you can suppress this warning using for example the &lt;code&gt;@SuppressLint&lt;/code&gt; annotation.&lt;br&gt;&lt;br&gt;Issue id: UseSparseArrays&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseValueOf" defaultSeverity="WARNING" displayName="Should use valueOf instead of new" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Should use &lt;code&gt;valueOf&lt;/code&gt; instead of &lt;code&gt;new&lt;/code&gt;&lt;br&gt;&lt;br&gt;You should not call the constructor for wrapper classes directly, such as`new Integer(42)`. Instead, call the &lt;code&gt;valueOf&lt;/code&gt; factory method, such as &lt;code&gt;Integer.valueOf(42)&lt;/code&gt;. This will typically use less memory because common integers such as 0 and 1 will share a single instance.&lt;br&gt;&lt;br&gt;Issue id: UseValueOf&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAnimatorKeep" defaultSeverity="WARNING" displayName="Missing @Keep for Animated Properties" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing @Keep for Animated Properties&lt;br&gt;&lt;br&gt;When you use property animators, properties can be accessed via reflection. Those methods should be annotated with @Keep to ensure that during release builds, the methods are not potentially treated as unused and removed, or treated as internal only and get renamed to something shorter.&lt;br/&gt;
&lt;br/&gt;
This check will also flag other potential reflection problems it encounters, such as a missing property, wrong argument types, etc.&lt;br&gt;&lt;br&gt;Issue id: AnimatorKeep&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMergeRootFrame" defaultSeverity="WARNING" displayName="FrameLayout can be replaced with &lt;merge&gt; tag" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;FrameLayout can be replaced with &lt;code&gt;&amp;lt;merge&gt;&lt;/code&gt; tag&lt;br&gt;&lt;br&gt;If a &lt;code&gt;&amp;lt;FrameLayout&gt;&lt;/code&gt; is the root of a layout and does not provide background or padding etc, it can often be replaced with a &lt;code&gt;&amp;lt;merge&gt;&lt;/code&gt; tag which is slightly more efficient. Note that this depends on context, so make sure you understand how the &lt;code&gt;&amp;lt;merge&gt;&lt;/code&gt; tag works before proceeding.&lt;br&gt;&lt;br&gt;Issue id: MergeRootFrame&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2009/03/android-layout-tricks-3-optimize-by.html"&gt;https://android-developers.googleblog.com/2009/03/android-layout-tricks-3-optimize-by.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintViewHolder" defaultSeverity="WARNING" displayName="View Holder Candidates" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;View Holder Candidates&lt;br&gt;&lt;br&gt;When implementing a view Adapter, you should avoid unconditionally inflating a new layout; if an available item is passed in for reuse, you should try to use that one instead. This helps make for example &lt;code&gt;ListView&lt;/code&gt; scrolling much smoother.&lt;br&gt;&lt;br&gt;Issue id: ViewHolder&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/layout/recyclerview#ViewHolder"&gt;https://developer.android.com/guide/topics/ui/layout/recyclerview#ViewHolder&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateStrings" defaultSeverity="WARNING" displayName="Duplicate Strings" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate Strings&lt;br&gt;&lt;br&gt;Duplicate strings can make applications larger unnecessarily.&lt;br/&gt;
&lt;br/&gt;
This lint check looks for duplicate strings, including differences for strings where the only difference is in capitalization. Title casing and all uppercase can all be adjusted in the layout or in code.&lt;br&gt;&lt;br&gt;Issue id: DuplicateStrings&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/widget/TextView.html#attr_android:inputType"&gt;https://developer.android.com/reference/android/widget/TextView.html#attr_android:inputType&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSyntheticAccessor" defaultSeverity="WARNING" displayName="Synthetic Accessor" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Synthetic Accessor&lt;br&gt;&lt;br&gt;A private inner class which is accessed from the outer class will force the compiler to insert a synthetic accessor; this means that you are causing extra overhead. This is not important in small projects, but is important for large apps running up against the 64K method handle limit, and especially for &lt;b&gt;libraries&lt;/b&gt; where you want to make sure your library is as small as possible for the cases where your library is used in an app running up against the 64K limit.&lt;br&gt;&lt;br&gt;Issue id: SyntheticAccessor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTooDeepLayout" defaultSeverity="WARNING" displayName="Layout hierarchy is too deep" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Layout hierarchy is too deep&lt;br&gt;&lt;br&gt;Layouts with too much nesting is bad for performance. Consider using a flatter layout (such as &lt;code&gt;RelativeLayout&lt;/code&gt; or &lt;code&gt;GridLayout&lt;/code&gt;).The default maximum depth is 10 but can be configured with the environment variable &lt;code&gt;ANDROID_LINT_MAX_DEPTH&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: TooDeepLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintKaptUsageInsteadOfKsp" defaultSeverity="WARNING" displayName="Kapt usage should be replaced with KSP" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Kapt usage should be replaced with KSP&lt;br&gt;&lt;br&gt;KSP is a more efficient replacement for kapt. For libraries that support both, KSP should be used to improve build times.&lt;br&gt;&lt;br&gt;Issue id: KaptUsageInsteadOfKsp&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/studio/build/migrate-to-ksp"&gt;https://developer.android.com/studio/build/migrate-to-ksp&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWakelock" defaultSeverity="WARNING" displayName="Incorrect WakeLock usage" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect &lt;code&gt;WakeLock&lt;/code&gt; usage&lt;br&gt;&lt;br&gt;Failing to release a wakelock properly can keep the Android device in a high power mode, which reduces battery life. There are several causes of this, such as releasing the wake lock in &lt;code&gt;onDestroy()&lt;/code&gt; instead of in &lt;code&gt;onPause()&lt;/code&gt;, failing to call &lt;code&gt;release()&lt;/code&gt; in all possible code paths after an &lt;code&gt;acquire()&lt;/code&gt;, and so on.&lt;br/&gt;
&lt;br/&gt;
NOTE: If you are using the lock just to keep the screen on, you should strongly consider using &lt;code&gt;FLAG_KEEP_SCREEN_ON&lt;/code&gt; instead. This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. See &lt;a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_KEEP_SCREEN_ON"&gt;https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_KEEP_SCREEN_ON&lt;/a&gt;.&lt;br&gt;&lt;br&gt;Issue id: Wakelock&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNestedWeights" defaultSeverity="WARNING" displayName="Nested layout weights" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Nested layout weights&lt;br&gt;&lt;br&gt;Layout weights require a widget to be measured twice. When a &lt;code&gt;LinearLayout&lt;/code&gt; with non-zero weights is nested inside another &lt;code&gt;LinearLayout&lt;/code&gt; with non-zero weights, then the number of measurements increase exponentially.&lt;br&gt;&lt;br&gt;Issue id: NestedWeights&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRecycle" defaultSeverity="WARNING" displayName="Missing recycle() calls" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;recycle()&lt;/code&gt; calls&lt;br&gt;&lt;br&gt;Many resources, such as TypedArrays, VelocityTrackers, etc., should be recycled (with a &lt;code&gt;recycle()&lt;/code&gt; call) after use. This lint check looks for missing &lt;code&gt;recycle()&lt;/code&gt; calls.&lt;br&gt;&lt;br&gt;Issue id: Recycle&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRedundantNamespace" defaultSeverity="WARNING" displayName="Redundant namespace" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Redundant namespace&lt;br&gt;&lt;br&gt;In Android XML documents, only specify the namespace on the root/document element. Namespace declarations elsewhere in the document are typically accidental leftovers from copy/pasting XML from other files or documentation.&lt;br&gt;&lt;br&gt;Issue id: RedundantNamespace&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotifyDataSetChanged" defaultSeverity="WARNING" displayName="Invalidating All RecyclerView Data" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalidating All RecyclerView Data&lt;br&gt;&lt;br&gt;The &lt;code&gt;RecyclerView&lt;/code&gt; adapter's &lt;code&gt;onNotifyDataSetChanged&lt;/code&gt; method does not specify what about the data set has changed, forcing any observers to assume that all existing items and structure may no longer be valid. `LayoutManager`s will be forced to fully rebind and relayout all visible views.&lt;br&gt;&lt;br&gt;Issue id: NotifyDataSetChanged&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInefficientWeight" defaultSeverity="WARNING" displayName="Inefficient layout weight" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Inefficient layout weight&lt;br&gt;&lt;br&gt;When only a single widget in a &lt;code&gt;LinearLayout&lt;/code&gt; defines a weight, it is more efficient to assign a width/height of &lt;code&gt;0dp&lt;/code&gt; to it since it will absorb all the remaining space anyway. With a declared width/height of &lt;code&gt;0dp&lt;/code&gt; it does not have to measure its own size first.&lt;br&gt;&lt;br&gt;Issue id: InefficientWeight&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOverdraw" defaultSeverity="WARNING" displayName="Overdraw: Painting regions more than once" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Overdraw: Painting regions more than once&lt;br&gt;&lt;br&gt;If you set a background drawable on a root view, then you should use a custom theme where the theme background is null. Otherwise, the theme background will be painted first, only to have your custom background completely cover it; this is called "overdraw".&lt;br/&gt;
&lt;br/&gt;
NOTE: This detector relies on figuring out which layouts are associated with which activities based on scanning the Java code, and it's currently doing that using an inexact pattern matching algorithm. Therefore, it can incorrectly conclude which activity the layout is associated with and then wrongly complain that a background-theme is hidden.&lt;br/&gt;
&lt;br/&gt;
If you want your custom background on multiple pages, then you should consider making a custom theme with your custom background and just using that theme instead of a root element background.&lt;br/&gt;
&lt;br/&gt;
Of course it's possible that your custom drawable is translucent and you want it to be mixed with the background. However, you will get better performance if you pre-mix the background with your drawable and use that resulting image or color as a custom theme background instead.&lt;br&gt;&lt;br&gt;Issue id: Overdraw&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringFormatTrivial" defaultSeverity="WARNING" displayName="String.format string only contains trivial conversions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;String.format&lt;/code&gt; string only contains trivial conversions&lt;br&gt;&lt;br&gt;Every call to &lt;code&gt;String.format&lt;/code&gt; creates a new &lt;code&gt;Formatter&lt;/code&gt; instance, which will decrease the performance of your app. &lt;code&gt;String.format&lt;/code&gt; should only be used when necessary--if the formatted string contains only trivial conversions (e.g. &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;) and there are no translation concerns, it will be more efficient to replace them and concatenate with &lt;code&gt;+&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: StringFormatTrivial&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUsableSpace" defaultSeverity="WARNING" displayName="Using getUsableSpace()" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using getUsableSpace()&lt;br&gt;&lt;br&gt;When you need to allocate disk space for large files, consider using the new &lt;code&gt;allocateBytes(FileDescriptor, long)&lt;/code&gt; API, which will automatically clear cached files belonging to other apps (as needed) to meet your request.&lt;br/&gt;
&lt;br/&gt;
When deciding if the device has enough disk space to hold your new data, call &lt;code&gt;getAllocatableBytes(UUID)&lt;/code&gt; instead of using &lt;code&gt;getUsableSpace()&lt;/code&gt;, since the former will consider any cached data that the system is willing to clear on your behalf.&lt;br/&gt;
&lt;br/&gt;
Note that these methods require API level 26. If your app is running on older devices, you will probably need to use both APIs, conditionally switching on &lt;code&gt;Build.VERSION.SDK_INT&lt;/code&gt;. Lint only looks in the same compilation unit to see if you are already using both APIs, so if it warns even though you are already using the new API, consider moving the calls to the same file or suppressing the warning.&lt;br&gt;&lt;br&gt;Issue id: UsableSpace&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintVectorPath" defaultSeverity="WARNING" displayName="Long vector paths" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Long vector paths&lt;br&gt;&lt;br&gt;Using long vector paths is bad for performance. There are several ways to make the &lt;code&gt;pathData&lt;/code&gt; shorter:&lt;br/&gt;
* Using less precision&lt;br/&gt;
* Removing some minor details&lt;br/&gt;
* Using the Android Studio vector conversion tool&lt;br/&gt;
* Rasterizing the image (converting to PNG)&lt;br&gt;&lt;br&gt;Issue id: VectorPath&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnnecessaryArrayInit" defaultSeverity="WEAK WARNING" displayName="Unnecessary array initialization" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unnecessary array initialization&lt;br&gt;&lt;br&gt;When constructing an array in Kotlin, you don't need to pass a lambda to set the initial value if it's identical to the default or if you're going to overwrite all the values without reading them anyway.&lt;br&gt;&lt;br&gt;Issue id: UnnecessaryArrayInit&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStaticFieldLeak" defaultSeverity="WARNING" displayName="Static Field Leaks" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Static Field Leaks&lt;br&gt;&lt;br&gt;A static field will leak contexts.&lt;br/&gt;
&lt;br/&gt;
Non-static inner classes have an implicit reference to their outer class. If that outer class is for example a &lt;code&gt;Fragment&lt;/code&gt; or &lt;code&gt;Activity&lt;/code&gt;, then this reference means that the long-running handler/loader/task will hold a reference to the activity which prevents it from getting garbage collected.&lt;br/&gt;
&lt;br/&gt;
Similarly, direct field references to activities and fragments from these longer running instances can cause leaks.&lt;br/&gt;
&lt;br/&gt;
ViewModel classes should never point to Views or non-application Contexts.&lt;br&gt;&lt;br&gt;Issue id: StaticFieldLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTooManyViews" defaultSeverity="WARNING" displayName="Layout has too many views" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Layout has too many views&lt;br&gt;&lt;br&gt;Using too many views in a single layout is bad for performance. Consider using compound drawables or other tricks for reducing the number of views in this layout.&lt;br/&gt;
&lt;br/&gt;
The maximum view count defaults to 80 but can be configured with the environment variable &lt;code&gt;ANDROID_LINT_MAX_VIEW_COUNT&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: TooManyViews&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDrawAllocation" defaultSeverity="WARNING" displayName="Memory allocations within drawing code" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Memory allocations within drawing code&lt;br&gt;&lt;br&gt;You should avoid allocating objects during a drawing or layout operation. These are called frequently, so a smooth UI can be interrupted by garbage collection pauses caused by the object allocations.&lt;br/&gt;
&lt;br/&gt;
The way this is generally handled is to allocate the needed objects up front and to reuse them for each drawing operation.&lt;br/&gt;
&lt;br/&gt;
Some methods allocate memory on your behalf (such as &lt;code&gt;Bitmap.create&lt;/code&gt;), and these should be handled in the same way.&lt;br&gt;&lt;br&gt;Issue id: DrawAllocation&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="JSP" path=""><inspection shortName="ELMethodSignatureInspection" defaultSeverity="WARNING" displayName="EL 메서드 시그니처 검사" enabled="false" language="EL" pluginId="com.intellij.jsp" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
TLD 파일의 &lt;code&gt;method-signature&lt;/code&gt; 제약과 일치하지 않는 EL의 메서드 호출을 보고합니다.

&lt;p&gt;&lt;b&gt;Java 클래스 예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
public class ExampleAction {
  public void goodAction() { ... }
  public void badAction(String str) { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;JSP 파일 예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code lang="jsp"&gt;
&amp;lt;jsp:useBean id="example" scope="request" type="org.example.ExampleAction"/&amp;gt;
&amp;lt;f:view&amp;gt;
  &amp;lt;h:commandButton action="#{example.goodAction}"/&amp;gt; // 좋음: 메서드가 0개의 매개변수를 허용하고 'void'를 반환합니다
  &amp;lt;h:commandButton action="#{example.badAction}"/&amp;gt; // 오류: 메서드 'void badAction(String)'이 'void'가 아닌 'java.lang.String' 타입을 반환합니다
&amp;lt;/f:view&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ELMethodSignatureInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnhandledExceptionInJSP" defaultSeverity="WARNING" displayName="JSP 내 처리되지 않은 예외" enabled="false" pluginId="com.intellij.jsp" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
최상위 JSP 스크립트릿에서 던져진 예외를 보고합니다.&lt;br/&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="jsp"&gt;
  &amp;lt;%!
  String getFormattedDate() {
    ...
    throw new IllegalArgumentException(...); // 오류
  }
  %&amp;gt;
  &amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&amp;gt;
    &amp;lt;title&amp;gt;Hello, JSP!&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;i&amp;gt;Today is &amp;lt;%= getFormattedDate() %&amp;gt;&amp;lt;/i&amp;gt;
  &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;참고:&lt;/b&gt; 서블릿 컨테이너가 모든 JSP 코드를 &lt;b&gt;try {} catch() {}&lt;/b&gt; 블록으로 래핑하기 때문에 그러한 JSP 페이지는 컴파일되지만 서버에 배포 시 런타임 예외가 발생합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnhandledExceptionInJSP&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReferencesToClassesFromDefaultPackagesInJSPFile" defaultSeverity="ERROR" displayName="JSP 파일 내 디폴트 패키지의 클래스 참조" enabled="false" language="JAVA" pluginId="com.intellij.jsp" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JSP 파일 내 디폴트 패키지의 클래스에 대한 모든 참조를 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="jsp"&gt;
  &amp;lt;%!
  Integer countSomeUsefulStuff() {
    ...
    new ClassFromDefaultPackage(...); // 오류
    new com.example.GoodClass(...); // 좋음
  }
  %&amp;gt;
  &amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
      &amp;lt;title&amp;gt;Hello, JSP!&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
  &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;참고:&lt;/b&gt; JSP의 컴파일된 클래스는 보통 디폴트가 아닌 패키지(예: Tomcat 사용 시 'org.apache.jsp', WebSphere 사용 시 'com.ibm._jsp')에 있고, 디폴트 패키지에서 가져오기는 Java에서 허용되지 않기 때문에 그러한 참조는 JSP 컴파일 도중에 해결되지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReferencesToClassesFromDefaultPackagesInJSPFile&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ELDeferredExpressionsInspection" defaultSeverity="WARNING" displayName="EL 지연된 표현식 검사" enabled="false" language="EL" pluginId="com.intellij.jsp" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지연 표현식이 필요한 곳에 사용된 동적 표현식 또는 그 반대의 경우를 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;jsp:useBean id="exampleBean" scope="request" type="java.util.Date"/&amp;gt;

&amp;lt;h:outputText id="${exampleBean.day}" value="#{exampleBean.day}" /&amp;gt; // 좋음
&amp;lt;h:outputText id="#{exampleBean.day}" value="${exampleBean.day}" /&amp;gt; // 오류: 'id' 속성에는 동적 표현식이, 'value'에는 지연 표현식이 필요합니다 
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ELDeferredExpressionsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ELSpecValidationInJSP" defaultSeverity="WARNING" displayName="JSP EL 사양 유효성 검사" enabled="false" language="EL" pluginId="com.intellij.jsp" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
비표준 EL 확장에 의해 발생했을 가능성이 있는 문제(속성 외부의 JSF EL 표현식, 비표준 EL 표현식 등)를 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;f:view&amp;gt;
  &amp;lt;h:form&amp;gt;
    &amp;lt;f:loadBundle var="example"/&amp;gt;
    &amp;lt;h:commandButton action="${example.size()}"/&amp;gt; // 경고: 메서드 호출이 비표준 확장입니다
  &amp;lt;/h:form&amp;gt;
&amp;lt;/f:view&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ELSpecValidationInJSP&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JspUnescapedEl" defaultSeverity="WARNING" displayName="이스케이프되지 않은 EL 표현식" enabled="false" language="EL" pluginId="com.intellij.jsp" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JSP 페이지 내의 이스케이프되지 않은 EL 표현식의 안전하지 않은 데이터를 보고합니다. 이러한 경우는 &lt;a href="https://en.wikipedia.org/wiki/Cross-site_scripting"&gt;크로스 사이트 스크립팅(XSS)&lt;/a&gt; 취약점을 일으킬 수 있습니다.
&lt;p&gt;
  아래의 설명에서 &lt;b&gt;untainted&lt;/b&gt; 데이터라는 용어는 안전하고 신뢰할 수 있는 데이터를 의미하며 &lt;b&gt;tainted&lt;/b&gt;(안전하지 않고 신뢰할 수 없음)의 반의어입니다. 자세한 정보는 &lt;a href="https://en.wikipedia.org/wiki/Taint_checking"&gt;taint 검사&lt;/a&gt;를 참조하세요.
&lt;/p&gt;
&lt;p&gt;
  안전한(untainted) 객체:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기본 데이터 타입(&lt;code&gt;char&lt;/code&gt; 제외)&lt;/li&gt;
  &lt;li&gt;untainted로 표시된 메서드가 호출된 결과&lt;/li&gt;
  &lt;li&gt;이스케이프하는 함수 호출의 결과&lt;/li&gt;
  &lt;li&gt;untainted로 표시된 필드&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
JSP 페이지는 제공된 데이터에 따라 다른 컨텍스트를 가질 수 있으며 한 컨텍스트에서 데이터가 안전하더라도 다른 컨텍스트에서는 안전하지 않을 수 있습니다.
&lt;a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#output-encoding"&gt;크로스 사이트 스크립트 방지 족보&lt;/a&gt;에서 예시를 살펴보세요. 이 검사는 &lt;b&gt;모든&lt;/b&gt; 컨텍스트에서 untainted(안전함)로 표시된 데이터를 건너뜁니다.
&lt;/p&gt;
&lt;p&gt;
  이 검사는 다음의 옵션을 사용하여 메서드와 필드를 안전한 것으로 표시합니다.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;구성 가능한 untainted 어노테이션 목록에 있는 어노테이션을 사용&lt;/li&gt;
  &lt;li&gt;안전한 메서드와 필드의 목록을 구성&lt;/li&gt;
  &lt;li&gt;모든 static final 필드는 'untainted 메서드 및 필드' 탭의 'static final 필드를 untainted로 간주' 옵션을 사용하여 untainted로 표시되어야 합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  이 검사는 안전하지 않은 데이터가 JSP 페이지 내의 안전한 태그에 도달하는 경우를 강조 표시하지 않습니다.
  예를 들어 JSTL taglib의 &lt;code&gt;out&lt;/code&gt; 태그는 기본적으로 주어진 값을 이스케이프하므로 안전합니다.
  안전한 태그의 목록을 구성할 수 있습니다(전체 범위를 정의하려면 &lt;code&gt;tag&lt;/code&gt; 또는 &lt;code&gt;attribute&lt;/code&gt;를 생략하세요).
&lt;/p&gt;
&lt;p&gt;&amp;quot;JSTL &amp;lt;out&amp;gt; 태그로 래핑&amp;quot; 빠른 수정이 EL 식을 JSTL &lt;code&gt;&amp;lt;out&amp;gt;&lt;/code&gt; 태그로 래핑합니다.&lt;/p&gt;
&lt;p&gt;전:&lt;/p&gt;
&lt;pre&gt;
  &lt;code&gt;
    ${foo}
  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;후:&lt;/p&gt;
&lt;pre&gt;
  &lt;code&gt;
  &amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
&amp;lt;c:out value=&amp;quot;${foo}&amp;quot;/&amp;gt;
  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&amp;quot;JSTL escapeXml() 함수로 래핑&amp;quot;은 안전하지 않은 값을 &lt;code&gt;escapeXml&lt;/code&gt; 이스케이프 함수로 래핑합니다.&lt;/p&gt;
&lt;p&gt;전:&lt;/p&gt;
&lt;pre&gt;
  &lt;code&gt;
  &amp;lt;%@ taglib prefix=&amp;quot;custom&amp;quot; uri=&amp;quot;WEB_INF/custom.tld&amp;quot; %&amp;gt;
  &amp;lt;custom:tag value=&amp;quot;${foo}&amp;quot;/&amp;gt;
  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;후:&lt;/p&gt;
&lt;pre&gt;
  &lt;code&gt;
    &amp;lt;%@ taglib prefix=&amp;quot;custom&amp;quot; uri=&amp;quot;WEB_INF/custom.tld&amp;quot; %&amp;gt;
    &amp;lt;%@ taglib prefix=&amp;quot;fn&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/functions&amp;quot; %&amp;gt;
    &amp;lt;custom:tag value=&amp;quot;${fn:escapeXml(foo)}&amp;quot;/&amp;gt;
  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;이 외에도 선택된 태그를 안전한 태그에 추가하거나 관련 메서드 또는 필드에 untainted 어노테이션을 추가할 수 있는 빠른 수정이 더 있습니다.&lt;/p&gt;
&lt;p&gt;
  사용자 지정 이스케이프 함수를 추가할 수 있습니다('이스케이프 함수' 탭 참조).
  이제 안전한 값을 반환하는 JSTL의 함수가 포함됩니다(예: 잘 알려진 &lt;code&gt;escapeXml&lt;/code&gt; 함수).
  네임스페이스 URI가 다른 JSTL 함수를 정의할 필요가 없습니다.
  'http://java.sun.com/jsp/jstl/functions' 또는 'http://java.sun.com/jstl/functions'가 사용 중인 경우 나머지도 확인합니다. 이스케이프 함수를 이름으로 어디에서든 건너뛸 수 있습니다.
  이를 위해서는 네임스페이스 URI 필드를 비워두세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JspUnescapedEl&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SelfIncludingJspFiles" defaultSeverity="ERROR" displayName="자체 포함 JSP 파일" enabled="false" language="XML" pluginId="com.intellij.jsp" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
포함하는 JSP 파일을 참조하는 JSP 파일 내 include 지시문을 보고합니다.&lt;br/&gt;

&lt;p&gt;&lt;b&gt;이름이 main.jsp인 JSP 파일 예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;jsp:include page="./main.jsp" /&amp;gt; // 오류: 포함된 파일을 포함하려고 시도합니다
  ...
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;참고:&lt;/b&gt; 그러한 자기 포함은 무한한 재귀로 이어지므로 JSP 파일이 컴파일되지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SelfIncludingJspFiles&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;

</inspection><inspection shortName="JspDirectiveInspection" defaultSeverity="ERROR" displayName="Jsp 지시문 검사" enabled="false" language="XML" pluginId="com.intellij.jsp" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
URI 또는 tagdir 속성이 없는 JSP import 지시문을 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;%@ taglib prefix="html"%&amp;gt; // 오류: 'uri' 또는 'tagdir' 속성 중 하나가 지정되어야 합니다
    ...
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JspDirectiveInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FunctionELReferenceInspection" defaultSeverity="ERROR" displayName="EL 메서드 함수 매개변수 개수" enabled="false" language="EL" pluginId="com.intellij.jsp" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
EL 함수 호출에서 형식 및 실제 매개변수의 개수가 다른 경우를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FunctionELReferenceInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JspAbsolutePathInspection" defaultSeverity="WARNING" displayName="절대 경로" enabled="false" language="XML" pluginId="com.intellij.jsp" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JSP 파일 내 절대 경로를 보고합니다.
&lt;p&gt;절대 경로는 애플리케이션 컨텍스트가 비어 있지 않은 경우 해결되지 않으므로 JSP에서 금지됩니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 경로에 동적 접두사를 추가합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;%@page contentType=&amp;quot;text/html; ISO-8859-1&amp;quot; %&amp;gt;

  &amp;lt;a href=&amp;quot;/hey.jsp&amp;quot;&amp;gt;hey&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;%@page contentType=&amp;quot;text/html; ISO-8859-1&amp;quot; %&amp;gt;

  &amp;lt;a href=&amp;quot;${pageContext.request.contextPath}/hey.jsp&amp;quot;&amp;gt;hey&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JspAbsolutePathInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JspPropertiesInspection" defaultSeverity="ERROR" displayName="Jsp 프로퍼티 검사" enabled="false" language="XML" pluginId="com.intellij.jsp" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;*.properties&lt;/code&gt; 파일에서 해결되지 않은 프로퍼티를 보고합니다.

&lt;p&gt;&lt;b&gt;JSP 파일 예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&amp;gt;
&amp;lt;%@ taglib uri="/tags/fmt" prefix="fmt" %&amp;gt;

&amp;lt;fmt:message bundle="bundle.properties" key="unknown.property"/&amp;gt; // 오류: 참조 파일 내에 해당 프로퍼티가 없습니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JspPropertiesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JspTagBodyContent" defaultSeverity="WARNING" displayName="태그 본문 내용 타입" enabled="false" language="XML" pluginId="com.intellij.jsp" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
TLD 본문 내용의 사양을 준수하지 않는 JSP 태그 본문 내용을 보고합니다.
&lt;p&gt;빈 본문 내용이 지정된 경우 태그의 본문을 비어 있어야 합니다.&lt;/p&gt;
&lt;p&gt;본문 내용이 스크립트리스로 지정되어 있는 경우 태그 본문은 JSP 스크립트릿을 포함할 수 없습니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 빈 콘텐츠 타입의 경우 태그의 본문을 제거하며, 스크립트리스 콘텐츠 타입이 지정된 경우 스크립트릿을 제거합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;s:empty&amp;gt;body not allowed here&amp;lt;/s:empty&amp;gt;
&amp;lt;s:scriptless&amp;gt;say: &amp;lt;% System.out.println(&amp;quot;hey&amp;quot;); %&amp;gt;&amp;lt;/s:scriptless&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;s:empty/&amp;gt;
&amp;lt;s:scriptless&amp;gt;say: &amp;lt;/s:scriptless&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JspTagBodyContent&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TaglibDomModelInspection" defaultSeverity="ERROR" displayName="태그 라이브러리 설명자 검사" enabled="false" language="XML" pluginId="com.intellij.jsp" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JSP TLD 파일 내 문제를 보고합니다.
&lt;p&gt;TLD 파일은 JSP 태그 라이브러리 스키마를 준수해야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TaglibDomModelInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Dockerfile" path=""><inspection shortName="DockerFileRunCommandMissingContinuation" defaultSeverity="ERROR" displayName="'RUN' 명령어의 연속 문자 누락" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;RUN&lt;/code&gt; 명령어 내 누락된 연속 문자를 보고합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;i&gt;셸&lt;/i&gt; 형식의 &lt;code&gt;RUN&lt;/code&gt; 명령어에서는 하나의 &lt;code&gt;RUN&lt;/code&gt; 지시를 다음 줄에서 계속하려면  '\'(백슬래시)를 사용해야 합니다.
  그러지 않으면 Docker 빌드가 실패합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  # the command below will fail
  RUN /bin/bash -c 'source $HOME/.bashrc;
      echo $HOME'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  RUN /bin/bash -c 'source $HOME/.bashrc; \
      echo $HOME'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DockerFileRunCommandMissingContinuation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DockerFileArgumentCount" defaultSeverity="ERROR" displayName="잘못된 인수 개수" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Dockerfile 명령어의 잘못된 인수 개수를 보고합니다.&lt;/p&gt;
&lt;p&gt;
  인수 개수가 잘못된 명령에 도달하면 Docker 빌드는 실패합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DockerFileArgumentCount&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DockerJsonFormStringLiterals" defaultSeverity="WARNING" displayName="JSON 배열 형식으로 된 작은따옴표로 묶인 문자열" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  JSON 배열 양식에서 작은따옴표로 둘러싸인 문자열을 보고합니다.
&lt;/p&gt;
&lt;p&gt;
  JSON 배열 양식은 반드시 작은따옴표(')가 아닌 큰따옴표(")로 단어를 둘러싸야 합니다. 그러지 않으면 Docker 빌드가 실패합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  # 아래 명령어는 모두 실패합니다
  RUN ['/bin/bash', '-c', 'echo hello']
  ADD ['binaryA.jar', 'binary2.jar', 'destination/']
  COPY ['binaryA.jar', 'binary2.jar', 'destination/']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  RUN ["/bin/bash", "-c", "echo hello"]
  ADD ["binaryA.jar", "binary2.jar", "destination/"]
  COPY ["binaryA.jar", "binary2.jar", "destination/"]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DockerJsonFormStringLiterals&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DockerFileAddOrCopyPaths" defaultSeverity="WARNING" displayName="'ADD'/'COPY' 명령어의 잘못된 대상" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;ADD&lt;/code&gt; 및 &lt;code&gt;COPY&lt;/code&gt; 명령어 내 잘못된 대상 디렉터리를 보고합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a href="https://docs.docker.com/engine/reference/builder/#add"&gt;Dockerfile 사양&lt;/a&gt;에 따르면 여러 개의 소스가 지정된 경우 대상은 디렉터리여야 하며 슬래시 '/'로 끝나야 합니다.
  그러지 않으면 Docker 빌드가 실패합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  # 아래 명령어 모두 실패함
  ADD textA.txt textB.txt relativeDir
  ADD ["binaryA.jar", "binary2.jar", "destination"]
  COPY text3.txt text4.txt /absolute/path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ADD textA.txt textB.txt relativeDir/
  ADD ["binaryA.jar", "binary2.jar", "destination/"]
  COPY text3.txt text4.txt /absolute/path/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DockerFileAddOrCopyPaths&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DockerFileDuplicatedStageName" defaultSeverity="ERROR" displayName="중복된 스테이지 이름" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;FROM 내에서 중복된 스테이지 이름을 보고합니다... AS stage-name&lt;/code&gt; 명령어.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  # 아래의 명령어는 실패합니다
  FROM ubuntu:latest AS stage1
  FROM ubuntu:latest AS stage1
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DockerFileDuplicatedStageName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DockerFileAssignments" defaultSeverity="ERROR" displayName="'key=value' 쌍 내 올바르지 않은 공백" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;ARG&lt;/code&gt;, &lt;code&gt;ENV&lt;/code&gt;, &lt;code&gt;LABEL&lt;/code&gt; 명령어의 키-값 쌍에 사용된 잘못된 공백을 보고합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a href="https://docs.docker.com/engine/reference/builder/#arg"&gt;Dockerfile 사양&lt;/a&gt;에 명시적으로 지정되어 있지 않지만 키-값 쌍의 몇 가지 공백 조합은 허용되지 않습니다.
  문제가 되는 명령에 도달하면 Docker 빌드는 실패합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ARG&lt;/code&gt; 명령어는 '=' 주위에 어떠한 공백도 허용하지 않습니다&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ENV&lt;/code&gt; 및 &lt;code&gt;LABEL&lt;/code&gt;은 '=' 뒤에 공백을 허용하지 않습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
  # 아래의 모든 명령어는 실패합니다
  ARG answer = 42
  ARG version= "1.0.0"
  LABEL "maintained.by"= someone@gmail.com
  ENV JAVA_HOME= "/docker-java-home"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ARG answer=2
  ARG version="1.0.0"
  LABEL "maintained.by"=someone@gmail.com
  ENV JAVA_HOME="/docker-java-home"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DockerFileAssignments&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DockerFileEntrypointWithoutExec" defaultSeverity="WARNING" displayName="진입점 셸 서식에 'exec' 누락" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;ENTRYPOINT 명령어의 셸 서식에서 누락된 &lt;code&gt;exec&lt;/code&gt;을 보고합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;docker stop&lt;/code&gt;이 오래 실행되는 ENTRYPOINT 실행 파일에 대해 올바르게 신호를 보내려면&lt;code&gt;exec&lt;/code&gt;으로 시작해야 합니다.
&lt;/p&gt;
&lt;p&gt;
  자세한 정보는 &lt;a href="https://docs.docker.com/reference/dockerfile/#shell-form-entrypoint-example"&gt;Dockerfile 참조&lt;/a&gt;를 확인하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DockerFileEntrypointWithoutExec&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DockerFileCopyHeredoc" defaultSeverity="ERROR" displayName="ADD/COPY의 마지막 인수(대상)로 지정된 heredoc" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  ADD/COPY 명령어의 마지막 인수(대상)로 사용된 heredoc을 보고합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
이 코드는 잘못된 대상을 정의합니다.
&lt;pre&gt;&lt;code&gt;
  COPY foo &amp;lt;&amp;lt;EOF1 bar &amp;lt;&amp;lt;EOF2
  file content 1
  EOF1
  file content 2
  EOF2
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DockerFileCopyHeredoc&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DockerFileHeredocDelimiters" defaultSeverity="ERROR" displayName="닫히지 않은 heredoc 구분자" enabled="false" language="Dockerfile" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  파일 끝의 닫히지 않은 heredoc 구분 기호를 보고합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
이 코드는 누락된 FILE2 및 FILE3 구분 기호를 보고합니다.
&lt;pre&gt;&lt;code&gt;
  RUN &amp;lt;&amp;lt;FILE1 cat &amp;gt; file1 &amp;&amp; &amp;lt;&amp;lt;FILE2 cat &amp;gt; file2 &amp;&amp; &amp;lt;&amp;lt;FILE3 cat &amp;gt; file3
  mkdir -p foo/bar
  FILE1
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DockerFileHeredocDelimiters&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="함수 메트릭" path="JavaScript 및 TypeScript"><inspection shortName="ParametersPerFunctionJS" defaultSeverity="WARNING" displayName="매개변수가 너무 많은 함수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
매개변수가 너무 많은 함수를 보고합니다.
그러한 함수는 보통 디자인 문제를 나타냅니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 필드를 사용해 함수에 허용 가능한 매개변수의 최대 개수를 지정하세요.

&lt;p&gt;&lt;small&gt;Inspection ID: ParametersPerFunctionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CyclomaticComplexityJS" defaultSeverity="WARNING" displayName="지나치게 복잡한 함수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
함수 내 분기점이 너무 많은 함수를 보고합니다(너무 높은 순환 복잡도). 그러한 함수는
혼란을 일으킬 수 있으며 검사하기 어렵습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 제공된 필드를 사용해 함수에 허용 가능한 최대 순환 복잡도를 지정하십시오.

&lt;p&gt;&lt;small&gt;Inspection ID: CyclomaticComplexityJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionWithMultipleReturnPointsJS" defaultSeverity="WARNING" displayName="여러 반환점이 있는 함수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
여러 반환점이 있는 함수을 보고합니다.
그러한 함수는 이해하기 어렵고 유지 관리하기 힘듭니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FunctionWithMultipleReturnPointsJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionWithMultipleLoopsJS" defaultSeverity="WARNING" displayName="여러 루프가 있는 함수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
여러 루프 구문을 포함하는 함수를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FunctionWithMultipleLoopsJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestingDepthJS" defaultSeverity="WARNING" displayName="지나치게 중첩된 함수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 구문 내부에 너무 깊이 중첩된 구문이 본문에 포함된 함수를 보고합니다.
그러한 함수는 혼란을 일으킬 수 있으며 리팩토링이 필요함을 나타냅니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 제공된 필드를 사용해 함수에 허용 가능한 중첩 깊이를 지정하십시오.
&lt;p&gt;&lt;small&gt;Inspection ID: NestingDepthJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreeNegationsPerFunctionJS" defaultSeverity="WARNING" displayName="3개 이상의 부정이 있는 함수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
세 개 이상의 부정 연산(&lt;code&gt;!&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt;)을 포함하는 함수를 보고합니다.
그러한 함수는 불필요한 혼란을 일으킬 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ThreeNegationsPerFunctionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StatementsPerFunctionJS" defaultSeverity="WARNING" displayName="지나치게 긴 함수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지나치게 긴 함수를 보고합니다.
함수 내 비어 있지 않은 구문의 개수를 세어 함수 길이를 계산합니다.
너무 긴 함수는 오류가 발생하기 쉽고 검사하기 어렵습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 필드를 사용하여 함수에 사용 가능한 최대 구문 개수를 지정하십시오.

&lt;p&gt;&lt;small&gt;Inspection ID: StatementsPerFunctionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="SQL 서버" path=""><inspection shortName="MsOrderByInspection" defaultSeverity="ERROR" displayName="쿼리 내 ORDER BY" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;ORDER BY&lt;/code&gt; 절이 뷰, 인라인 함수, 파생 테이블, 하위 쿼리, 공통 테이블 표현식에서 &lt;code&gt;TOP&lt;/code&gt;, &lt;code&gt;OFFSET&lt;/code&gt;, 또는 &lt;code&gt;FOR XML&lt;/code&gt; 없이 사용된 위치를 보고합니다.
&lt;p&gt;&lt;code&gt;ORDER BY&lt;/code&gt; 사용에 관한 더 자세한 내용은 &lt;a
    href="https://docs.microsoft.com/en-us/sql/t-sql/queries/select-order-by-clause-transact-sql"&gt;docs.microsoft.com에서 SELECT - ORDER BY 절(Transact-SQL)&lt;/a&gt;를 참고하세요.&lt;/p&gt;
&lt;p&gt;예(Microsoft SQL 서버):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE foo (a INT NOT NULL, b  INT NOT NULL);

SELECT *
FROM (SELECT a, b
FROM foo A
WHERE a &amp;lt; 89
ORDER BY b) ALIAS;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하위 쿼리에서 ORDER BY는 오류로 강조 표시됩니다. TOP, OFFSET, FOR XML를 하위 쿼리에 추가할 수 있습니다.
  아니면 &lt;b&gt;요소 삭제&lt;/b&gt; 빠른 수정을 사용하여 ORDER BY 섹션을 삭제하세요.&lt;/p&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT *
FROM (SELECT a, b
FROM foo A
WHERE a &amp;lt; 89) ALIAS;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MsOrderByInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MsBuiltinInspection" defaultSeverity="WARNING" displayName="기본 제공 함수" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
ISNULL 함수 내 문자열 인수 자르기를 보고합니다.

&lt;p&gt;ISNULL 구문은 &lt;code&gt;ISNULL(check_expression, replacement_value)&lt;/code&gt;입니다.
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/sql/t-sql/functions/isnull-transact-sql" target="_blank"&gt;docs.microsoft.com의 ISNULL&lt;/a&gt;에 따르면 &lt;code&gt;replacement_value&lt;/code&gt;이 &lt;code&gt;check_expression&lt;/code&gt;보다 긴 경우 &lt;code&gt;replacement_value&lt;/code&gt;이 잘립니다.
&lt;/p&gt;

&lt;p&gt;예시(Microsoft SQL 서버):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE @name1 VARCHAR(2) = NULL;
DECLARE @name2 VARCHAR(10) = 'Example';
DECLARE @name3 VARCHAR(2) = 'Hi';

  -- '@name2'은 VARCHAR(10)이므로 잘립니다
SELECT ISNULL(@name1, @name2);

  -- '@name3'은 '@name1'와 같이 VARCHAR(2)이므로 잘리지 않습니다
SELECT ISNULL(@name1, @name3);&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MsBuiltinInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="MongoJS" path=""><inspection shortName="MongoJSExtDeprecationInspection" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 요소" enabled="false" language="MongoJSExt" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
MongoDB 및 JavaScript 코드 내 지원 중지된 메서드가 사용된 경우를 보고합니다.
&lt;p&gt;빠른 수정에서는 지원 중지된 메서드를 권장 대체 메서드로 바꿉니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  db.my_collection.insert()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  db.my_collection.insertOne()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MongoJSExtDeprecationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MongoJSExtSideEffectsInspection" defaultSeverity="WARNING" displayName="부수 효과가 있는 구문" enabled="false" language="MongoJSExt" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
데이터 소스가 읽기 전용 모드인 동안 부작용을 초래할 수 있는 구문을 보고합니다.
&lt;p&gt;빠른 수정은 각각의 데이터 소스의 읽기 전용 모드를 끕니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
db.my_collection.insertOne()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MongoJSExtSideEffectsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MongoJSExtResolveInspection" defaultSeverity="WARNING" displayName="확인 문제" enabled="false" language="MongoJSExt" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
MongoDB 및 JavaScript 코드에서 해결되지 않은 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MongoJSExtResolveInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MongoJSDeprecationInspection" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 요소" enabled="false" language="MongoJS" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
MongoDB 및 JavaScript 코드 내 지원 중지된 메서드가 사용된 경우를 보고합니다.
&lt;p&gt;빠른 수정에서는 지원 중지된 메서드를 권장 대체 메서드로 바꿉니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;db.my_collection.insert()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;db.my_collection.insertOne()&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MongoJSDeprecationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MongoJSResolveInspection" defaultSeverity="WARNING" displayName="확인 문제" enabled="false" language="MongoJS" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
MongoDB 및 JavaScript 코드에서 해결되지 않은 참조를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;db
use foo
  -- 존재하지 않는 컬렉션 참조
db.non_existing_collection
db['non_existing_collection']
db['non_existing_collection'].find().hasNext()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;non_existing_collection&lt;/code&gt; 컬렉션은 데이터베이스에 존재하지 않으므로 보고됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MongoJSResolveInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MongoJSSideEffectsInspection" defaultSeverity="WARNING" displayName="부수 효과가 있는 구문" enabled="false" language="MongoJS" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
데이터 소스가 읽기 전용 모드인 동안 부작용을 초래할 수 있는 구문을 보고합니다.
&lt;p&gt;읽기 전용 모드 활성화에 관한 더 자세한 내용은 &lt;a href="https://www.jetbrains.com/help/datagrip/configuring-database-connections.html#enable-read-only-mode-for-a-connection"&gt;IDE 문서 내 연결 읽기 전용 모드 활성화&lt;/a&gt;를 참고하세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;읽기 전용 모드 비활성화&lt;/b&gt; 빠른 수정은 각각의 데이터 소스의 읽기 전용 모드를 끕니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
db.my_collection.insertOne()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MongoJSSideEffectsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="매니페스트" path=""><inspection shortName="MissingFinalNewline" defaultSeverity="ERROR" displayName="마지막 줄 바꿈 누락" enabled="false" language="Manifest" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JAR 파일 사양에서 요구된 바와 같이 매니페스트 파일이 마지막 새 줄로 끝나지 않는 경우를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MissingFinalNewline&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MisspelledHeader" defaultSeverity="WEAK WARNING" displayName="알 수 없거나 철자가 잘못된 헤더 이름" enabled="false" language="Manifest" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  알 수 없으며 철자가 잘못되었을 수 있는 헤더 이름을 보고하고 가능한 다른 이름을 제공합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MisspelledHeader&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 10" path="Java/Java 언어 수준 마이그레이션 지원"><inspection shortName="RedundantExplicitVariableType" defaultSeverity="INFORMATION" displayName="지역 변수 타입은 생략 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 지역 변수 타입을 보고합니다.
&lt;p&gt;해당 타입은 컨텍스트에서 추론되므로 &lt;code&gt;var&lt;/code&gt;로 대체할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(InputStream s) {
    try (InputStream in = s) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(InputStream s) {
    try (var in = s) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;이 검사는 Java 10부터 사용할 수 있는 Java 기능 &amp;#39;지역 변수 타입 추론&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantExplicitVariableType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VariableTypeCanBeExplicit" defaultSeverity="INFORMATION" displayName="변수 타입이 명시적일 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명시적 타입으로 대체할 수 있는 &lt;code&gt;var&lt;/code&gt; 타입의 지역 변수를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var str = "Hello";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String str = "Hello";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 10부터 사용할 수 있는 Java 기능 &amp;#39;지역 변수 타입 추론&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VariableTypeCanBeExplicit&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 7" path="Java/Java 언어 수준 마이그레이션 지원"><inspection shortName="TryFinallyCanBeTryWithResources" defaultSeverity="WARNING" displayName="'try finally'를 리소스가 있는 'try'로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
오류 발생 가능성이 낮은 Java 7 Automatic Resource Management를 사용할 수 있는 &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;finally&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;&lt;code&gt;try&lt;/code&gt;-&lt;code&gt;finally&lt;/code&gt; 문을 &lt;code&gt;try&lt;/code&gt;-with-resources 문으로 변환하는 빠른 수정을 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  PrintStream printStream = new PrintStream(fileName);
  try {
    printStream.print(true);
  } finally {
    printStream.close();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;원인을 생성자로 전달하는 빠른 수정이 제공됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try (PrintStream printStream = new PrintStream(fileName)) {
    printStream.print(true);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 7부터 사용할 수 있는 Java 기능 &amp;#39;Try-with-resources&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TryFinallyCanBeTryWithResources&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TryWithIdenticalCatches" defaultSeverity="WARNING" displayName="'try' 문의 동일한 'catch' 브랜치" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단일 &lt;code&gt;try&lt;/code&gt; 문 내 동일한 &lt;code&gt;catch&lt;/code&gt; 섹션을 보고합니다.
&lt;p&gt;해당 섹션을 하나의 &lt;i&gt;multi-catch&lt;/i&gt; 블록으로 접으면, 코드 중복을 줄일 수 있을 뿐만 아니라 &lt;code&gt;catch&lt;/code&gt; 섹션 하나는 업데이트되고 다른 하나는 업데이트되지 않는 상황을 방지할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    try {
        doSmth();
    }
    catch (IOException e) {
        LOG.error(e);
    }
    catch (URISyntaxException e) {
        LOG.error(e);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드를 더 간결하게 바꾸는 빠른 수정을 이용할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    try {
        doSmth();
    }
    catch (IOException | URISyntaxException e) {
        LOG.error(e);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 7부터 사용할 수 있는 Java 기능 &amp;#39;여러 catch&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TryWithIdenticalCatches&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SafeVarargsDetector" defaultSeverity="WARNING" displayName="매개변수화된 vararg 타입의 잠재적 힙 오염" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
가변 인자가 있는 메서드 중 &lt;code&gt;@SafeVarargs&lt;/code&gt; 어노테이션을 추가할 수 있는 메서드를 모두 보고합니다.
&lt;code&gt;@SafeVarargs&lt;/code&gt; 어노테이션은 호출 사이트에서 매개변수화된 배열 생성에 관한 확인되지 않은 경고를 억제합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo&amp;lt;T&amp;gt; {
    private List&amp;lt;T&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    public final void safeVarargs(T... elements) {
      Collections.addAll(list, elements);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo&amp;lt;T&amp;gt; {
    private List&amp;lt;T&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    @SafeVarargs
    public final void safeVarargs(T... elements) {
      Collections.addAll(list, elements);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  이 어노테이션은 Java 1.6 이전 버전의 JVM에서 지원되지 않습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SafeVarargsDetector&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsReplaceableByObjectsCall" defaultSeverity="WEAK WARNING" displayName="'equals()' 식을 'Objects.equals()' 식으로 바꾸기 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Objects#equals&lt;/code&gt; 호출로 대체 가능한 표현식을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(Object a, Object b) {
    boolean result = a != null &amp;&amp; a.equals(b);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(Object a, Object b) {
    boolean result = Objects.equals(a, b);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;a != null &amp;&amp; a.equals(b)&lt;/code&gt;와 같은 표현식을 &lt;code&gt;Objects.equals(a, b)&lt;/code&gt;로 대체할 경우 의미가 약간 변경됩니다. 이 동작을 활성화 또는 비활성화하려면 &lt;b&gt;'a != null &amp;&amp; a.equals(b)'와 같은 표현식을 강조 표시&lt;/b&gt; 옵션을 사용합니다.
&lt;/p&gt;
&lt;p&gt;이 검사는 Java 7부터 사용할 수 있는 Java 기능 &amp;#39;java.util.Objects API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EqualsReplaceableByObjectsCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Convert2Diamond" defaultSeverity="WARNING" displayName="명시적 타입을 '&lt;&gt;'로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다이아몬드 모양의 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;로 대체 가능한 타입 인수가 포함된 &lt;code&gt;new&lt;/code&gt; 식을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); // 배열 목록 타입 인수를 보고합니다
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;이 검사는 Java 7부터 사용할 수 있는 Java 기능 &amp;#39;Diamond 타입&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Convert2Diamond&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Spring Data" path="Spring"><inspection shortName="SpringDataPageableParameterMissing" defaultSeverity="WARNING" displayName="Page를 반환하는 쿼리는 Pageable 매개변수가 있어야 합니다." enabled="false" language="UAST" pluginId="com.intellij.spring.data" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
 &lt;pre&gt;&lt;code&gt;Pageable&lt;/code&gt;&lt;/pre&gt; 매개변수가 다음을 반환하는 쿼리에 있는지 확인합니다. &lt;pre&gt;&lt;code&gt;Page&lt;/code&gt;&lt;/pre&gt;.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringDataPageableParameterMissing&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringDataMethodInconsistencyInspection" defaultSeverity="WARNING" displayName="Spring Data 저장소 메서드 오류" enabled="false" language="UAST" pluginId="com.intellij.spring.data" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  &lt;a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation"&gt;Spring Data Query&lt;/a&gt; 빌더가 해당하는 쿼리를 생성할 수 없는 Spring Data CRUD 저장소 메서드를 보고합니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
interface PersonRepository extends Repository&amp;lt;Person, Long&amp;gt; {
  List&amp;lt;Person&amp;gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);
  List&amp;lt;Person&amp;gt; findByEmail&lt;strong&gt;Unknown&lt;/strong&gt;AndLastname(EmailAddress emailAddress, String lastname); // 프로퍼티 'Unknown'을 해결할 수 없습니다
  List&amp;lt;Person&amp;gt; &lt;strong&gt;findByAndLastname&lt;/strong&gt;(EmailAddress emailAddress, String lastname); // 프로퍼티 이름 누락

  List&amp;lt;Person&amp;gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
  List&amp;lt;Person&amp;gt; findPeopleDistinctBy&lt;strong&gt;Unknown&lt;/strong&gt;OrFirstname(String lastname, String firstname); // 프로퍼티 'Unknown'을 해결할 수 없습니다

  List&amp;lt;Person&amp;gt; findByLastnameOrderByFirstnameAsc(String lastname);
  List&amp;lt;Person&amp;gt; findByLastnameOrderBy&lt;strong&gt;Unknown&lt;/strong&gt;Desc(String lastname);  // 프로퍼티 'Unknown'을 해결할 수 없습니다
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringDataMethodInconsistencyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringDataRepositoryMethodReturnTypeInspection" defaultSeverity="WARNING" displayName="Spring Data 저장소 메서드 반환 타입 오류" enabled="false" language="UAST" pluginId="com.intellij.spring.data" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;반환 타입이 잘못된 Spring Data CRUD 저장소 메서드를 보고합니다.&lt;/p&gt;
&lt;p&gt;지원되는 반환 타입은 다음과 같습니다.&lt;/p&gt;
&lt;list&gt;
  &lt;li&gt;&lt;code&gt;void&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;기본 타입&lt;/li&gt;
  &lt;li&gt;래퍼 타입&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;T&lt;/code&gt;: 쿼리 메서드가 최대 1개의 결과만을 반환해야 할 경우. 결과가 없는 경우 &lt;code&gt;null&lt;/code&gt;을 반환하고 결과가 2개 이상인 경우&lt;code&gt;IncorrectResultSizeDataAccessException&lt;/code&gt;을 던집니다.
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.List&lt;/code&gt; 또는 일반적인 &lt;code&gt;Iterable&lt;/code&gt; 타입&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.stream.Stream&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Optional&lt;/code&gt; 또는 &lt;code&gt;scala.Option&lt;/code&gt;: 쿼리 메서드가 최대 1개의 결과만을 반환해야 할 경우. 결과가 없는 경우 &lt;code&gt;Optional.empty()&lt;/code&gt; 또는 &lt;code&gt;Optional.absent()&lt;/code&gt;를 반환하고 결과가 2개 이상인 경우&lt;code&gt;IncorrectResultSizeDataAccessException&lt;/code&gt;을 던집니다.
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.data.model.Page&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.data.model.Slice&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.concurrent.Future&lt;/code&gt;, &lt;code&gt;java.util.concurrent.CompletableFuture&lt;/code&gt; 또는 &lt;code&gt;ListenableFuture&lt;/code&gt;: 메서드에 &lt;code&gt;@Async&lt;/code&gt; 어노테이션이 추가되었으며 Spring 비동기 메서드 실행이 활성화된 경우
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;GeoResults&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;GeoResult&amp;lt;T&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;GeoPage&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/list&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringDataRepositoryMethodReturnTypeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringDataRepositoryMethodParametersInspection" defaultSeverity="WARNING" displayName="Spring Data 저장소 메서드 매개변수 오류" enabled="false" language="UAST" pluginId="com.intellij.spring.data" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;타입이 잘못된 Spring Data CRUD 저장소 메서드 매개변수를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class Person {
    private int id;
    private String lastname;
    private Address address;
  }

  public class Address {
    private int zipCode;
  }

  public interface CustomerRepository extends CrudRepository&amp;lt;Person, Integer&amp;gt; {
    List&amp;lt;Person&amp;gt; &lt;strong&gt;findByAddress&lt;/strong&gt;(String lastname);  // 'Address' 타입이 필요합니다
    List&amp;lt;Person&amp;gt; &lt;strong&gt;findByAddressZipCode&lt;/strong&gt;(String str);   // 'int' 타입이 필요합니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringDataRepositoryMethodParametersInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringDataMongoDBJsonFieldInspection" defaultSeverity="ERROR" displayName="Spring Data MongoDB JSON 미해결 필드" enabled="false" language="Spring-MongoDB-JSON" pluginId="com.intellij.spring.data" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  &lt;code&gt;org.springframework.data.mongodb.repository.Query&lt;/code&gt; 어노테이션 내에 지정된 미해결 문서 필드를 보고합니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
@Document
class User {
  @Field
  String name;
}

interface UserRepository extends Repository&amp;lt;User, Long&amp;gt; {
  @Query("{ age: { $gt: ?0 } }") // 'age'가 미해결로 강조 표시됩니다
  List&amp;lt;User&amp;gt; findUsersOlderThan(Integer age);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringDataMongoDBJsonFieldInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringDataModifyingAnnotationMissing" defaultSeverity="WARNING" displayName="Update/Delete 쿼리는 @Modifying 어노테이션을 추가해야 하며, 그러지 않으면 InvalidDataAccessApiUsageException이 발생합니다." enabled="false" language="UAST" pluginId="com.intellij.spring.data" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
삭제/업데이트 쿼리에 &lt;pre&gt;&lt;code&gt;@Modifying&lt;/code&gt;&lt;/pre&gt; 어노테이션이 추가되었는지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringDataModifyingAnnotationMissing&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Wear 타일 미리보기" path=""><inspection shortName="WearTilePreviewDeviceSpec" defaultSeverity="ERROR" displayName="Preview의 기기 매개변수가 유효해야 합니다" enabled="false" language="UAST" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="WearTilePreviewNotSupportedInUnitTestFiles" defaultSeverity="ERROR" displayName="미리보기는 유닛 테스트 파일에서 지원되지 않습니다" enabled="false" language="UAST" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="WearTilePreviewComposableAnnotationIsNotSupported" defaultSeverity="ERROR" displayName="@Composable 어노테이션은 타일 미리보기에서 지원되지 않습니다" enabled="false" language="UAST" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="WearTilePreviewMethodIsAnnotatedWithTilePreviewAnnotation" defaultSeverity="ERROR" displayName="타일을 미리 보려면 Preview 어노테이션의 출처가 androidx.wear.tiles.tooling.preview여야 합니다" enabled="false" language="UAST" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="WearTilePreviewShouldBeTopLevelFunction" defaultSeverity="ERROR" displayName="Preview가 최상위 선언이거나 디폴트 생성자가 있는 최상위 클래스에 있어야 합니다" enabled="false" language="UAST" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="WearTilePreviewContextComesFromParameter" defaultSeverity="ERROR" displayName="Context는 출처가 Preview 메서드 매개변수여야 합니다" enabled="false" language="UAST" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="WearTilePreviewHasValidMethodSignature" defaultSeverity="ERROR" displayName="Preview 메서드는 androidx.wear.tiles.tooling.preview.TilePreviewData를 반환해야 하고 선택적인 android.content.Context 매개변수를 하나만 가질 수 있습니다" enabled="false" language="UAST" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection></group><group name="로깅" path="JVM 언어"><inspection shortName="LoggingPlaceholderCountMatchesArgumentCount" defaultSeverity="WARNING" displayName="자리표시자 수가 로깅 호출의 인수 수와 일치하지 않음" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
로거 메시지의 &lt;code&gt;{}&lt;/code&gt; 자리표시자 숫자가 로깅 호출에 대한 다른 인수의 숫자와 일치하지 않는 &lt;code&gt;logger.info("{}: {}", key)&lt;/code&gt;와 같은 SLF4J, Log4j2 및 akka.event.LoggingAdapter 로깅 호출을 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 옵션을 사용하여 SLF4J가 사용하는 구현을 지정합니다.
  &lt;strong&gt;자동 확인&lt;/strong&gt;을 선택하면 클래스 경로에서 &lt;code&gt;org.apache.logging.slf4j.Log4jLogger&lt;/code&gt;가 검색됩니다.
  이 파일을 찾거나 &lt;strong&gt;예&lt;/strong&gt;를 선택하였고, 예외 타입이 있는 마지막 매개변수에 자리표시자가 있는 경우, SLFJ4 API가 보고되지 않습니다.&lt;br/&gt;
예시:
&lt;pre&gt;&lt;code lang="java"&gt;
//이 경우 '예' 옵션이 선택되면 보고되지 않습니다
log.error("For id {}: {}", "1", new RuntimeException());
&lt;/code&gt;&lt;/pre&gt;
이 경우 'toString()'을 사용하여 'new RuntimeException()'이 출력됩니다(스택 추적은 출력되지 않습니다).
&lt;pre&gt;&lt;code lang="text"&gt;
For id 1: java.lang.RuntimeException
&lt;/code&gt;&lt;/pre&gt;

그렇지 않은 경우 마지막 자리표시자가 사용되지 않으므로 강조 표시됩니다.
&lt;pre&gt;&lt;code lang="text"&gt;
For id 1: {}
java.lang.RuntimeException: null
&lt;/code&gt;&lt;/pre&gt;

&lt;strong&gt;아니요&lt;/strong&gt; 옵션을 사용하면 &lt;code&gt;org.apache.logging.slf4j.Log4jLogger&lt;/code&gt;가 백엔드로 사용되더라도 자리표시자가 예외로 사용되는 경우 항상 강조 표시됩니다.&lt;br/&gt;

이 옵션은 SLF4J만 지원합니다.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LoggingPlaceholderCountMatchesArgumentCount&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoggingGuardedByCondition" defaultSeverity="INFORMATION" displayName="로그 조건으로 로그 호출에 가드가 적용됨" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
가드 조건으로 둘러싸인 로깅 호출을 보고합니다.
이 검사는 사용자 지정 코드 스타일로 조정하기 위해 사용될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class TestObject {
    void test(Object object) {
      if(LOG.isDebugEnabled()){
        LOG.debug("some logging " + expensiveCalculation(1));
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class TestObject {
    void test(Object object) {
      LOG.debug("some logging " + expensiveCalculation(1));
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 검사는 &lt;em&gt;Log4j2&lt;/em&gt;와 &lt;em&gt;SLF4J&lt;/em&gt; 로깅 프레임워크(빌더 제외)를 지원합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2024.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LoggingGuardedByCondition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoggingStringTemplateAsArgument" defaultSeverity="WARNING" displayName="문자열 템플릿을 로깅 호출에 인수로 전달" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;b&gt;SLF4J&lt;/b&gt; 및 &lt;b&gt;Log4j 2&lt;/b&gt; 로깅 메서드에 대한 인수로 사용되는 문자열 템플릿을 보고합니다.
&lt;code&gt;org.apache.logging.log4j.Logger.log()&lt;/code&gt; 메서드 및 오버로드는 &lt;b&gt;모든 로그 수준&lt;/b&gt; 옵션에만 지원됩니다.
문자열 템플릿은 로깅 메시지가 기록되지 않는 경우에도 런타임에 평가됩니다. 이 과정은 성능에 부정적인 영향을 줍니다.
대신에 매개변수화된 로그 메시지를 사용하는 것이 좋습니다. 이 메시지는 로깅이 비활성화되면 평가되지 않습니다.
&lt;p&gt;&lt;b&gt;예(Kotlin):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="kotlin"&gt;
      val variable1 = getVariable()
      logger.info("variable1: $variable1")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;빠른 수정 적용 후(Kotlin):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="kotlin"&gt;
      val variable1 = getVariable()
      logger.info("variable1: {}", variable1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  제안된 대체 항목은 예를 들어 문자열 템플릿에 메서드 호출이나 대입식이 포함된 경우 원래의 코드와 동일하지 않을 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;b&gt;경고 대상&lt;/b&gt; 목록을 사용하여 특정한 상위 로깅 수준을 무시합니다. 상위 로깅 수준은 항상 활성화할 수 있으며, 인수는 항상 평가됩니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;b&gt;기본 타입, 래퍼 또는 문자열이 있는 표현식만 포함된 경우 경고 안 함&lt;/b&gt; 옵션을 사용하여 기본 타입, 래퍼 또는 문자열이 있는 표현식만 포함된 문자열 템플릿을 무시합니다.
    이는 예를 들어, 컬렉션의 지연 로드를 방지하는 데 도움이 될 수 있습니다.
    단, 기본 타입, 래퍼 또는 문자열이 있는 표현식만 포함하는 문자열을 런타임에 생성하더라도 성능에 부정적인 영향을 미칠 수 있습니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;b&gt;메시지 인수 뒤의 인수로서의 예외만 포함하는 호출은 경고 안 함&lt;/b&gt; 옵션을 사용하면, 메시지 인수 뒤에 오는 인수로서의 예외만 포함하는 호출을 무시합니다.
    예를 들어, 이는 사용자 지정 코드 스타일로 검사의 동작을 조정할 때 유용합니다.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;2023.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LoggingStringTemplateAsArgument&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LogStatementNotGuardedByLogCondition" defaultSeverity="INFORMATION" displayName="로그 조건으로 로그 호출에 가드가 적용되지 않음" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
가드 조건으로 둘러싸여 있지 않은 로깅 호출을 보고합니다.
호출의 인수를 평가하려면 리소스 소비가 클 수 있습니다.
로깅 구문이 사용하는 수준에 대해 로깅이 비활성화된 경우 guard 절을 사용하여 로깅 호출을 둘러싸면 이 비용을 피할 수 있습니다. 이는 가장 덜 심각한 수준(trace, debug, finest)의 로깅 호출에 특히 유용합니다. 이러한 호출은 프로덕션 환경에서 매우 자주 비활성화되기 때문입니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class TestObject {
    void test(Object object) {
      LOG.debug("some logging " + expensiveCalculation(1));
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class TestObject {
    void test(Object object) {
      if(LOG.isDebugEnabled()){
        LOG.debug("some logging " + expensiveCalculation(1));
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 검사는 &lt;em&gt;Log4j2&lt;/em&gt;와 &lt;em&gt;SLF4J&lt;/em&gt; 로깅 프레임워크(빌더 제외)를 지원합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2024.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LogStatementNotGuardedByLogCondition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoggingConditionDisagreesWithLogLevelStatement" defaultSeverity="WARNING" displayName="로그 조건이 로깅 호출과 일치하지 않음" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
포함된 로깅 호출의 로그 수준과 일치하지 않는 &lt;code&gt;if&lt;/code&gt; 문의 &lt;em&gt;is log enabled for&lt;/em&gt; 조건을 보고합니다.
&lt;p&gt;
예:
&lt;pre&gt;&lt;code lang="java"&gt;
  if (LOG.isTraceEnabled()) {
    // 디버그 수준이 기록되었지만 추적 수준이 확인되었습니다
    LOG.debug("some log message");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 &lt;em&gt;java.util.logging&lt;/em&gt;, &lt;em&gt;Log4j&lt;/em&gt;, &lt;em&gt;Log4j2&lt;/em&gt;, &lt;em&gt;Apache Commons Logging&lt;/em&gt; 및 &lt;em&gt;SLF4J&lt;/em&gt; 로깅 프레임워크를 이해합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: LoggingConditionDisagreesWithLogLevelStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoggingSimilarMessage" defaultSeverity="WEAK WARNING" displayName="구분할 수 없는 로그 호출" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
유사한 로그 메시지를 가지며 &lt;code&gt;logger.info("message: {}", key)&lt;/code&gt;와 같은 SLF4J, Log4j2 로깅 호출이 한 클래스에 있는 경우를 보고합니다.
이러한 호출은 서로 분간할 수 없고, 특정 로그 메시지의 출처가 어디인지 파악하기 어려울 수 있습니다.
&lt;p&gt;&lt;b&gt;예시(Java):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  private static void request1(String text) {
      log.info("Message: {}", text); //유사한 호출
      doSomething1();
  }

  private static void request2(int i) {
      log.info("Message: {}", i); //유사한 호출
      doSomething2();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;b&gt;유사한 시퀀스의 최소 길이&lt;/b&gt; 옵션을 사용하여 호출이 보고되는 유사 시퀀스의 최소 길이를 지정합니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;b&gt;'error' 로그 수준의 호출은 보고 안 함&lt;/b&gt; 옵션을 사용하여 메시지에 `error` 로그 수준이거나 예외가 있는 경우 메시지를 무시합니다.
    호출 위치는 여전히 스택 추적으로 찾을 수 있기 때문에 경고를 숨기는 데 유용합니다.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;2024.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LoggingSimilarMessage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="이름 생성 규칙" path="Kotlin"><inspection shortName="TestFunctionName" defaultSeverity="WEAK WARNING" displayName="Test 함수 이름 지정 규칙" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#names-for-test-methods"&gt;권장 이름 생성 규칙&lt;/a&gt;을 따르지 않는 테스트 함수 이름을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TestFunctionName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageName" defaultSeverity="WEAK WARNING" displayName="패키지 이름 지정 규칙" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
이름 생성 규칙을 따르지 않는 패키지 이름을 보고합니다.
&lt;p&gt;요구된 패턴을 검사 옵션에서 지정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;권장 이름 생성 규칙&lt;/a&gt;: 패키지 이름은 항상 소문자이며 밑줄을 포함하지 않아야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;code&gt;org.example.project&lt;/code&gt;
&lt;p&gt;여러 단어로 구성된 이름을 사용하는 것은 일반적으로 권장하지 않지만 그러한 이름을 사용해야 한다면 그냥 각 단어를 연결하거나 낙타 표기법을 사용할 수 있습니다&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;code&gt;org.example.myProject&lt;/code&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PackageName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalVariableName" defaultSeverity="WEAK WARNING" displayName="지역 변수 이름 지정 규칙" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름 생성 규칙을 따르지 않는 지역 변수를 보고합니다.
&lt;p&gt;요구된 패턴을 검사 옵션에서 지정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#function-names"&gt;권장 이름 생성 규칙&lt;/a&gt;: 소문자로 시작해야 하고, 낙타 표기법을 사용해야 하며, 밑줄을 사용하지 않아야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun fibonacciNumber(index: Int): Long = when(index) {
      0 -&gt; 0
      else -&gt; {
          // 이름 생성 규칙을 따르지 않음: 밑줄('_') 포함
          var number_one: Long = 0
          // 이름 생성 규칙을 따르지 않음: 대문자로 시작
          var NUMBER_TWO: Long = 1
          // 이름 생성 규칙 준수: 소문자로 시작, 낙타 표기법 사용, 밑줄 사용 안 함
          var numberThree: Long = number_one + NUMBER_TWO

          for(currentIndex in 2..index) {
              numberThree = number_one + NUMBER_TWO
              number_one = NUMBER_TWO
              NUMBER_TWO = numberThree
          }
          numberThree
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LocalVariableName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstPropertyName" defaultSeverity="WEAK WARNING" displayName="Const 프로퍼티 이름 지정 규칙" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
권장하는 이름 생성 규칙을 따르지 않는 &lt;code&gt;const&lt;/code&gt; 프로퍼티 이름을 보고합니다.
&lt;p&gt;
    이름을 생성할 때 일관성을 유지하면 코드를 읽고 이해하기 쉽습니다.
    &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#property-names"&gt;Kotlin 공식 스타일 가이드&lt;/a&gt;에 따르면 &lt;code&gt;const&lt;/code&gt; 프로퍼티는 대문자를 사용해야 하며 이름을 밑줄로 구분해야 합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  const val Planck: Double = 6.62607015E-34
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 프로퍼티의 이름을 변경합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  const val PLANCK: Double = 6.62607015E-34
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConstPropertyName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InconsistentCommentForJavaParameter" defaultSeverity="WARNING" displayName="Java 매개변수에 대한 일관되지 않은 주석" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
주석 블록에 지정된 &lt;b&gt;Java&lt;/b&gt; 메서드 호출의 일관되지 않은 매개변수 이름을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Java
  public class JavaService {
      public void invoke(String command) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
  // Kotlin
  fun main() {
      JavaService().invoke(/* name = */ "fix")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 주석 블록 내 매개변수 이름을 수정합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      JavaService().invoke(/* command = */ "fix")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: InconsistentCommentForJavaParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectPropertyName" defaultSeverity="WEAK WARNING" displayName="Object 프로퍼티 이름 지정 규칙" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름 생성 규칙을 따르지 않는 프로퍼티를 보고합니다.
&lt;p&gt;다음과 같은 프로퍼티가 보고됩니다.&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;최상위 프로퍼티&lt;/li&gt;
    &lt;li&gt;객체 및 컴패니언 객체의 프로퍼티&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;요구된 패턴을 검사 옵션에서 지정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;권장 이름 생성 규칙&lt;/a&gt;: 대문자로 시작해야 하고, 낙타 표기법을 사용해야 하며, 밑줄을 사용하지 않아야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 최상위 프로퍼티
  val USER_NAME_FIELD = "UserName"
  // 싱글턴 객체에 대한 참조를 유지한 최상위 프로퍼티
  val PersonComparator: Comparator&amp;lt;Person&amp;gt; = /*...*/

  class Person {
    companion object {
      // 컴패니언 객체의 프로퍼티
      val NO_NAME = Person()
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ObjectPropertyName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionName" defaultSeverity="WEAK WARNING" displayName="함수 이름 지정 규칙" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
권장되는 이름 생성 규칙을 따르지 않는 함수 이름을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Foo() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;문제를 해결하려면 권장되는 이름 생성 규칙에 부합하도록 함수의 이름을 변경합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FunctionName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectPrivatePropertyName" defaultSeverity="WEAK WARNING" displayName="객체 private 프로퍼티 이름 지정 규칙" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름 생성 규칙을 따르지 않는 프로퍼티를 보고합니다.
&lt;p&gt;다음과 같은 프로퍼티가 보고됩니다.&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;객체 및 컴패니언 객체의 private 프로퍼티&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;요구된 패턴을 검사 옵션에서 지정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;권장 이름 생성 규칙&lt;/a&gt;: 밑줄 또는 대문자로 시작해야 하고, 낙타 표기법을 사용해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    companion object {
      // 컴패니언 객체 내 프로퍼티
      private val NO_NAME = Person()
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ObjectPrivatePropertyName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnumEntryName" defaultSeverity="WEAK WARNING" displayName="열거형 항목 이름 지정 규칙" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
권장되는 이름 생성 규칙을 따르지 않는 열거형 항목 이름을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum class Foo {
    _Foo,
    foo
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;문제를 해결하려면 권장되는 이름 생성 규칙에 부합하도록 열거형 항목의 이름을 변경합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EnumEntryName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassName" defaultSeverity="WEAK WARNING" displayName="클래스 이름 지정 규칙" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
권장하는 이름 생성 규칙을 따르지 않는 클래스 이름을 보고합니다.
&lt;p&gt;
    이름을 생성할 때 일관성을 유지하면 코드를 읽고 이해하기 쉽습니다.
    &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;Kotlin 공식 스타일 가이드&lt;/a&gt;에 따르면 클래스 이름은 대문자로 시작해야 하고 낙타 표기법을 사용해야 합니다.
&lt;/p&gt;
&lt;p&gt;'Pattern' 정규 표현식을 변경하면 다른 이름 생성 규칙도 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class user(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 Kotlin 이름 생성 규칙에 따라 이름을 변경합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PrivatePropertyName" defaultSeverity="WEAK WARNING" displayName="Private 프로퍼티 이름 지정 규칙" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;권장되는 이름 생성 규칙을 따르지 않는 private 프로퍼티 이름을 보고합니다.&lt;/p&gt;
&lt;p&gt;
    이름을 생성할 때 일관성을 유지하면 코드를 읽고 이해하기 쉽습니다.
    &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;Kotlin 공식 스타일 가이드&lt;/a&gt;에 따르면 private 프로퍼티 이름은 소문자로 시작해야 하고 낙타 표기법을 사용해야 합니다.
    밑줄 접두사를 사용하는 옵션도 있지만 &lt;b&gt;private&lt;/b&gt; 프로퍼티에만 가능합니다.
&lt;/p&gt;
&lt;p&gt;'Pattern' 정규 표현식을 변경하면 다른 이름 생성 규칙도 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val _My_Cool_Property = ""
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 Kotlin 이름 생성 규칙에 따라 이름을 변경합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val _myCoolProperty = ""
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PrivatePropertyName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PropertyName" defaultSeverity="WEAK WARNING" displayName="프로퍼티 이름 지정 규칙" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;권장되는 이름 생성 규칙을 따르지 않는 프로퍼티 이름을 보고합니다.&lt;/p&gt;
&lt;p&gt;
    이름을 생성할 때 일관성을 유지하면 코드를 읽고 이해하기 쉽습니다.
    &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;Kotlin 공식 스타일 가이드&lt;/a&gt;에 따르면 프로퍼티 이름은 소문자로 시작해야 하고 낙타 표기법을 사용해야 합니다.
&lt;/p&gt;
&lt;p&gt;'Pattern' 정규 표현식을 변경하면 다른 이름 생성 규칙도 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val My_Cool_Property = ""
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 Kotlin 이름 생성 규칙에 따라 이름을 변경합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val myCoolProperty = ""
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PropertyName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="비트 연산 이슈" path="Java"><inspection shortName="PointlessBitwiseExpression" defaultSeverity="WARNING" displayName="무의미한 비트 표현식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
무의미한 비트 표현식을 보고합니다.
&lt;p&gt;
  그 예시로는 제공된 타입의 최댓값에 &lt;code&gt;&amp;&lt;/code&gt; 연산자를 적용하는 표현식, &lt;code&gt;or&lt;/code&gt; 연산자를 0에 적용하는 표현식 및 0만큼 이동하는 표현식 등이 있습니다. 이러한 표현식은 코드 완성이 수반되지 않은 자동 리팩터링의 결과일 수 있으며 애초에 의도된 것이 아닐 가능성이 높습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 경고: 연산은 무의미하며 'flags'로 대체 가능합니다
  // 0xFFFF_FFFF는 정수의 최댓값이며 두 리터럴 모두
  // 32비트 정수 리터럴로 취급됩니다
  int bits = flags &amp; 0xFFFF_FFFF;

  // 경고: 연산은 무의미하며 'bits'로 대체 가능합니다
  // OR을 0에 적용하는 경우 항상 다른 피연산자가 출력됩니다
  int or = bits | 0x0;

  // 경고: 연산 결과는 항상 0이므로 연산이 무의미합니다
  int xor = or ^ or;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PointlessBitwiseExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ShiftOutOfRange" defaultSeverity="WARNING" displayName="부적절한 상수에의한 시프트 연산" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
시프트 값이 적정 범위 외부의 상수인 시프트 연산을 보고합니다.
&lt;p&gt;&lt;code&gt;0..31&lt;/code&gt; 범위를 벗어난 정수 시프트 연산 및 &lt;code&gt;0..63&lt;/code&gt; 범위를 벗어난 long 시프트 연산이 보고됩니다. 음수 또는 지나치게 큰 값으로 시프트하는 것은 거의 명백한 코딩 오류입니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int shiftSize = 32;
  // 경고: 32비트 시프트는 0비트 시프트와 동등하므로 시프트가 없습니다.
  int mask = (1 &amp;lt;&amp;lt; shiftSize) - 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ShiftOutOfRange&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncompatibleMask" defaultSeverity="WARNING" displayName="호환되지 않는 비트 마스크 연산" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
반드시 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt;로 평가되는 
비트 마스크 식을 보고합니다.
&lt;p&gt;
  이 검사는 &lt;code&gt;constant1&lt;/code&gt; 및 &lt;code&gt;constant2&lt;/code&gt;가 호환되지 않는 
비트 마스크 상수인 &lt;code&gt;(var &amp; constant1) == constant2&lt;/code&gt; 
또는 &lt;code&gt;(var | constant1) == constant2&lt;/code&gt; 형식의 표현식을 검사합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  // 호환되지 않는 마스크: 마스크가 00으로 끝나므로,
  // 결과가 0x1200는 될 수 있으나 0x1234는 될 수 없습니다
  if ((mask &amp; 0xFF00) == 0x1234) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IncompatibleMask&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Quarkus" path=""><inspection shortName="QsProperties" defaultSeverity="WARNING" displayName="잘못된 Quarkus application.properties 구성" enabled="false" language="Properties" pluginId="com.intellij.quarkus" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  Quarkus &lt;code&gt;.properties&lt;/code&gt; 구성 파일의 구문 오류, 타입 오류, 지원이 중단되거나 해결되지 않은 키와 값을 보고합니다.
&lt;/p&gt;
&lt;p&gt;
  또한 구문 및 타입 오류가 강조 표시됩니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: QsProperties&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SmallRyeConfigMappingMissingPrefixInspection" defaultSeverity="WARNING" displayName="'@ConfigMapping' 어노테이션 내 누락되거나 빈 'prefix' 속성 값" enabled="false" language="UAST" pluginId="com.intellij.quarkus" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;@io.smallrye.config.ConfigMapping&lt;/code&gt; 어노테이션 내 누락되거나 빈 &lt;code&gt;prefix&lt;/code&gt; 속성 값을 보고합니다.&lt;/p&gt;
&lt;p&gt;IDE가 구성 프로퍼티를 검색하려면 접두사가 올바르게 지정되어야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SmallRyeConfigMappingMissingPrefixInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="QsYaml" defaultSeverity="WARNING" displayName="잘못된 Quarkus YAML 구성" enabled="false" language="yaml" pluginId="com.intellij.quarkus" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Quarkus 애플리케이션 YAML 구성 파일에서 지원이 중단되거나 확인되지 않은 키와 값을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: QsYaml&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="QsUndeclaredPathMimeTypesInspection" defaultSeverity="WEAK WARNING" displayName="'@Path'의 선언되지 않은 '@Produces' / '@Consumes' MIME 타입" enabled="false" language="UAST" pluginId="com.intellij.quarkus" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  &lt;code&gt;@Produces&lt;/code&gt; 또는 &lt;code&gt;@Consumes&lt;/code&gt; 어노테이션이 없는 엔드포인트 메서드를 보고합니다.
&lt;/p&gt;
&lt;p&gt;
  Quarkus는 해당 어노테이션을 분석하여 기본 실행 파일에 포함된 JAX-RS 공급자 수를 애플리케이션에 필요한 최소 수준으로 제한합니다. 이를 통해 기본 실행 파일의 크기가 감소합니다.
&lt;/p&gt;
&lt;p&gt;
  메서드 또는 전체 클래스에 &lt;code&gt;@Produces&lt;/code&gt; 또는 &lt;code&gt;@Consumes&lt;/code&gt; 어노테이션을 추가하고(HTTP 메서드에서 지원되는 경우) 대상 MIME 타입을 지정합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: QsUndeclaredPathMimeTypesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="QsPrivateBeanMembersInspection" defaultSeverity="WARNING" displayName="CDI 어노테이션이 추가된 Bean 멤버의 잘못된 액세스 제어자" enabled="false" language="UAST" pluginId="com.intellij.quarkus" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  삽입된 필드, observer ​메서드, private 액세스 권한이 있는 Bean 생성자를 보고합니다.
&lt;/p&gt;
&lt;p&gt;
  CDI 멤버의 액세스 수준이 private일 경우 Bean 설정에 필요한 리플렉션 조작이 증가합니다.
  Package-private 또는 protected 액세스 수준을 대신 사용하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: QsPrivateBeanMembersInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Micronaut Data" path="Micronaut"><inspection shortName="MicronautDataMethodInconsistency" defaultSeverity="ERROR" displayName="잘못된 저장소 메서드 선언" enabled="false" language="UAST" pluginId="com.intellij.micronaut" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://micronaut-projects.github.io/micronaut-data/latest/guide/#criteria"&gt;쿼리 패턴 기준&lt;/a&gt;에 부합하지 않는 Micronaut Data 저장소 메서드를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MicronautDataMethodInconsistency&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MicronautDataRepositoryMethodParameters" defaultSeverity="WARNING" displayName="잘못된 저장소 메서드 매개변수" enabled="false" language="UAST" pluginId="com.intellij.micronaut" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 Micronaut Data 저장소 메서드 매개변수 타입을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class Person {
    private int id;
    private String lastname;
    private Address address;
  }

  public class Address {
    private int zipCode;
  }

  public interface CustomerRepository extends CrudRepository&amp;lt;Person, Integer&amp;gt; {
    List&amp;lt;Person&amp;gt; &lt;strong&gt;findByAddress&lt;/strong&gt;(String lastname);  // 'Address' 타입이 필요합니다
    List&amp;lt;Person&amp;gt; &lt;strong&gt;findByAddressZipCode&lt;/strong&gt;(String str);   // 'int' 타입이 필요합니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MicronautDataRepositoryMethodParameters&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MicronautDataRepositoryMethodReturnType" defaultSeverity="WARNING" displayName="잘못된 저장소 메서드 반환 타입" enabled="false" language="UAST" pluginId="com.intellij.micronaut" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 Micronaut 데이터 &lt;a href="https://micronaut-projects.github.io/micronaut-data/latest/guide/#querying"&gt;저장소 메서드 반환 타입&lt;/a&gt;을 보고합니다.&lt;/p&gt;
&lt;p&gt;지원되는 반환 타입은 다음과 같습니다.&lt;/p&gt;
&lt;list&gt;
  &lt;li&gt;void&lt;/li&gt;
  &lt;li&gt;기본 타입&lt;/li&gt;
  &lt;li&gt;단순 타입&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.List&lt;/code&gt; 또는 일반적인 &lt;code&gt;Iterable&lt;/code&gt; 타입&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.stream.Stream&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Optional&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.data.model.Page&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.data.model.Slice&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.concurrent.Future&lt;/code&gt; 또는 &lt;code&gt;java.util.concurrent.CompletableFuture&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Reactive Streams 호환 타입(예: &lt;code&gt;Publisher&lt;/code&gt;, &lt;code&gt;Single&lt;/code&gt;, &lt;code&gt;Maybe&lt;/code&gt;, &lt;code&gt;Flux&lt;/code&gt;, &lt;code&gt;Mono&lt;/code&gt; 등)
  &lt;/li&gt;
&lt;/list&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MicronautDataRepositoryMethodReturnType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="이름 생성 규칙" path="JavaScript 및 TypeScript"><inspection shortName="FunctionNamingConventionJS" defaultSeverity="WARNING" displayName="함수 이름 지정 규칙" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길어나 지정된 정규 표현식 패턴을 따르지 않는 함수를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 아래 제공된 필드를 사용하여 함수 이름을 위한
최소 길이, 최대 길이 및 정규 표현식을 지정하십시오. 정규 표현식에 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식을 사용하십시오.
&lt;p&gt;&lt;small&gt;Inspection ID: FunctionNamingConventionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSClassNamingConvention" defaultSeverity="WARNING" displayName="클래스 이름 지정 규칙" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길거나 지정된 정규 표현 패턴을 따르지 않는 JSDoc &lt;code&gt;@constructor&lt;/code&gt; 또는 &lt;code&gt;@class&lt;/code&gt; 태그로 어노테이션이 추가된 클래스 또는 함수를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 제공된 필드를 사용하여 클래스 이름으로 기대되는 최소 길이, 최대 길이 및 정규 표현식을 지정하십시오. 정규 표현식에 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식을 사용하십시오.
&lt;p&gt;&lt;small&gt;Inspection ID: JSClassNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalVariableNamingConventionJS" defaultSeverity="WARNING" displayName="지역 변수 이름 지정 규칙" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길거나 지정된 정규 표현식 패턴을 따르지 않는 지역 변수를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 제공된 필드를 사용하여 최소 길이, 최대 길이 및 지역 변수 이름으로 기대되는 정규 표현식을 지정하세요. 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식의 정규 표현식을 사용하세요.
&lt;p&gt;&lt;small&gt;Inspection ID: LocalVariableNamingConventionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterNamingConventionJS" defaultSeverity="WARNING" displayName="함수 매개변수 이름 지정 규칙" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길어나 지정된 정규 표현식 패턴을 따르지 않는 함수 매개변수를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 제공된 필드를 사용하여 지역 변수 이름으로 기대되는 최소 길이, 최대 길이 및 정규 표현식을 지정하십시오. 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식의 정규 표현식을 사용하세요.
&lt;p&gt;&lt;small&gt;Inspection ID: ParameterNamingConventionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSNonASCIINames" defaultSeverity="WARNING" displayName="비 ASCII 심볼이 있는 식별자" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름에 사용된 ASCII가 아닌 기호를 보고합니다.&lt;br/&gt;&lt;br/&gt;
'Allow only ASCII names'(ASCII 이름만 허용) 옵션을 선택하면, ASCII가 아닌 기호를 포함하는 모든 이름이 보고됩니다.&lt;br/&gt;
그렇지 않으면 ASCII 기호와 ASCII가 아닌 기호를 포함하는 모든 이름을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSNonASCIINames&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="코드 스타일 이슈" path="Java"><inspection shortName="PatternVariablesCanBeReplacedWithCast" defaultSeverity="INFORMATION" displayName="패턴을 포함하여 'instanceof'를 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
패턴이 있는 &lt;code&gt;instanceof&lt;/code&gt;를 보고하며, 형 변환이 있는 일반 &lt;code&gt;instanceof&lt;/code&gt;로 변환하는 것이 좋습니다.
&lt;p&gt;이 검사는 빠른 수정을 적용해 이전 Java 버전을 사용하는 패턴이 있는 &lt;code&gt;instanceof&lt;/code&gt;를 코드 베이스로 이동할 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;instanceof&lt;/code&gt; 앞에 복잡한 표현식을 사용하는 경우 결과는 패턴이 있는 원래 &lt;code&gt;instanceof&lt;/code&gt;와 완전히 동등하지 않을 수 있습니다. 이러한 경우 이 표현식이 다시 계산됩니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (object instanceof String txt &amp;&amp; txt.length() == 1) {
      System.out.println(txt);
  } else {
      return;
  }
  System.out.println(txt);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (object instanceof String &amp;&amp; ((String) object).length() ==1) {
      String txt = (String) object;
      System.out.println(txt);
  } else {
      return;
  }
  String txt = (String) object;
  System.out.println(txt);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2023.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PatternVariablesCanBeReplacedWithCast&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CharsetObjectCanBeUsed" defaultSeverity="WARNING" displayName="표준 'Charset' 객체 사용 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자형 상수 집합 &lt;code&gt;String&lt;/code&gt; 리터럴 (예를 들어, &lt;code&gt;"UTF-8"&lt;/code&gt;) 을 사전 정의된 &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt; 코드로 바꿀 수 있는 메서드 및 생성자를 보고합니다.
&lt;p&gt;문자 집합 조회가 불필요해지므로 수정 후 코드가 빨라질 수 있습니다.
  또한, &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;을 catch할 필요가 없어질 수 있습니다. 이 경우 catch 블록은 자동으로 제거됩니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    byte[] bytes = "str".getBytes("UTF-8");
  } catch (UnsupportedEncodingException e) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  byte[] bytes = "str".getBytes(StandardCharsets.UTF_8);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 7 이상에서 사용 가능합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2018.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CharsetObjectCanBeUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FuseStreamOperations" defaultSeverity="WARNING" displayName="후속 단계를 Stream API 체인으로 결합 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Stream API 체인에 통합할 수 있는 Stream API 체인 외부의 변환을 감지합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = stream.collect(Collectors.toList());
  list.sort(null);
  return list.toArray(new String[list.size()]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;변환 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return stream.sorted().toArray(String[]::new);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  변환된 스트림 체인이 명시적 &lt;code&gt;ArrayList&lt;/code&gt;를 &lt;code&gt;Collectors.toList()&lt;/code&gt;로 대체하거나 명시적 &lt;code&gt;HashSet&lt;/code&gt;을 &lt;code&gt;Collectors.toSet()&lt;/code&gt;으로 대체하는 경우가 때때로 있습니다. 현재 라이브러리 구현은 이러한 컬렉션을 내부적으로 사용합니다. 그러나 이 방법은 그다지 신뢰할 수 없으며 코드의 의미가 향후에 변경될 수 있습니다.&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;이에 대해 염려가 되는 경우 &lt;b&gt;'toList()' 또는 'toSet()' 컬렉터를 제안하지 않음&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;toList&lt;/code&gt; 및 &lt;code&gt;toSet&lt;/code&gt; 컬렉터 대신 &lt;code&gt;Collectors.toCollection()&lt;/code&gt;을 제안하세요.
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FuseStreamOperations&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnThis" defaultSeverity="WARNING" displayName="'this' 반환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;this&lt;/code&gt;를 반환하는 메서드를 보고합니다.
&lt;p&gt;
  그러한 반환은 유효하지만 거의 필요하지 않으며, 보통 메서드가 유사한 메서드 호출 체인(예: &lt;code&gt;buffer.append("foo").append("bar").append("baz")&lt;/code&gt;)의 일부로 사용되도록 의도했음을 나타냅니다.
  이러한 체인은 다양한 코드 표준에서 인정되지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public Builder append(String str) {
    // [...]
    return this;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReturnThis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableEqualsExpression" defaultSeverity="WARNING" displayName="'equals()' 호출 전 불필요한 'null' 검사" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상수 인수를 사용한 &lt;code&gt;equals()&lt;/code&gt;의 호출에 선행하는 &lt;code&gt;null&lt;/code&gt; 비교를 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (s != null &amp;&amp; s.equals("literal")) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if ("literal".equals(s)) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
    검사 설정을 사용하여, &lt;code&gt;equals()&lt;/code&gt;의 인수가 &lt;code&gt;null&lt;/code&gt;이 되지 않는 것이 확실한 경우 비 상수의 인수를 사용하는 &lt;code&gt;equals()&lt;/code&gt;의 호출을 보고합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SimplifiableEqualsExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ChainedEquality" defaultSeverity="WARNING" displayName="체인 상등 비교" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
체인 상등 비교를 보고합니다.
&lt;p&gt;이러한 비교는 혼란스러울 수 있습니다: &lt;code&gt;a == b == c&lt;/code&gt;는 &lt;code&gt;(a == b) == c&lt;/code&gt;를 의미하지만, &lt;code&gt;a == b &amp;&amp; a == c&lt;/code&gt;를 의도할 가능성이 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean chainedEquality(boolean a, boolean b, boolean c) {
    return a == b == c;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;비교의 혼란을 방지하기 위해 괄호를 사용할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean chainedEquality(boolean a, boolean b, boolean c) {
    return (a == b) == c;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ChainedEquality&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnqualifiedInnerClassAccess" defaultSeverity="WARNING" displayName="정규화되지 않은 내부 클래스 액세스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
감싸는 클래스의 이름으로 한정되지 않는 내부 클래스의 참조를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import foo.Foo.Bar;

  class Foo {
    class Bar {}
  }

  class Baz {
    void f(Bar bar) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    class Bar {}
  }

  class Baz {
    void f(Foo.Bar bar) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 설정을 사용하여 동일한 클래스 내에서 내부의 클래스를 무시합니다. 이 경우 import 문이 필요하지 않습니다.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnqualifiedInnerClassAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryCallToStringValueOf" defaultSeverity="WARNING" displayName="'문자열'로 불필요한 변환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;String.valueOf()&lt;/code&gt; 또는 &lt;code&gt;Integer.toString()&lt;/code&gt;과 같이 매개변수를 문자열로 변환하는 불필요한 static 메서드 호출을 보고합니다.
문자열 연결 시에 이러한 호출은 불필요합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println("Number: " + Integer.toString(count));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println("Number: " + count);
&lt;/code&gt;&lt;/pre&gt;
추가적으로 이러한 호출은 자체적으로 문자열을 변환하는 라이브러리 메서드의 인수로 사용될 때도 불필요합니다.
다음은 문자열을 자체적으로 변환하는 라이브러리 메서드의 예시입니다.
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;java.io.PrintWriter&lt;/code&gt;, &lt;code&gt;java.io.PrintStream&lt;/code&gt; 클래스
    &lt;ul&gt;&lt;li&gt;&lt;code&gt;print()&lt;/code&gt;, &lt;code&gt;println()&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;java.lang.StringBuilder&lt;/code&gt;, &lt;code&gt;java.lang.StringBuffer&lt;/code&gt; 클래스
    &lt;ul&gt;&lt;li&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
  &lt;/li&gt;

  &lt;li&gt;
    &lt;code&gt;org.slf4j.Logger&lt;/code&gt; 클래스
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;trace()&lt;/code&gt;, &lt;code&gt;debug()&lt;/code&gt;, &lt;code&gt;info()&lt;/code&gt;, &lt;code&gt;warn()&lt;/code&gt;, &lt;code&gt;error()&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;빈 문자열 연결로 대체될 수 있는 호출을 보고&lt;/b&gt; 옵션을 사용하면 &lt;code&gt;String.valueOf()&lt;/code&gt; 호출 대신 빈 문자열 연결이 대신 사용될 수 있는 경우를 보고합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryCallToStringValueOf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableAnnotation" defaultSeverity="WARNING" displayName="단순화 가능한 어노테이션" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단일 요소 또는 마커 줄임 양식으로 단순화할 수 있는 어노테이션을 보고합니다.
&lt;p&gt;
보고된 문제:
&lt;ul&gt;
  &lt;li&gt;이름-값 페어 내의 불필요한 &lt;code&gt;value=&lt;/code&gt;
  &lt;li&gt;값이 하나 뿐인 배열 값 주위의 불필요한 중괄호
  &lt;li&gt;@ 기호와 어노테이션 이름 사이의 불필요한 공백
  &lt;li&gt;어노테이션 이름 및 매개변수 목록 간의 불필요한 공백
  &lt;li&gt;매개변수가 없는 어노테이션 내의 불필요한 소괄호
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @interface Foo { String[] value(); }

  @ Foo({"foo"})
  public String name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @interface Foo { String[] value(); }

  @Foo("foo")
  public String name;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SimplifiableAnnotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarySuperConstructor" defaultSeverity="WARNING" displayName="불필요한 'super()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인수가 없는 상위 클래스 생성자가 객체 생성 중에 호출되는 것을 보고합니다.
&lt;p&gt;이러한 호출은 필요하지 않으며 삭제할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {
      super();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessarySuperConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayCanBeReplacedWithEnumValues" defaultSeverity="INFORMATION" displayName="배열을 열거형 값으로 바꿀수 있습니다." enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;EnumType.values()&lt;/code&gt; 호출로 바꿀 수 있는 열거형 상수 배열을 보고합니다.
&lt;p&gt;일반적으로 이러한 열거형을 업데이트할 때 배열도 업데이트해야 합니다. 그러나 &lt;code&gt;EnumType.values()&lt;/code&gt;을 사용하면 수정이 필요하지 않습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum States {
     NOT_RUN, IN_PROGRESS, FINISHED;
  }
  
  handleStates(new States[] {NOT_RUN, IN_PROGRESS, FINISHED});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  handleStates(States.values());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;2019.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ArrayCanBeReplacedWithEnumValues&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LiteralAsArgToStringEquals" defaultSeverity="WARNING" displayName="문자열 리터럴은 'equals()' 한정자일 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자열 리터럴 인수를 사용하는 &lt;code&gt;String.equals()&lt;/code&gt; 또는 &lt;code&gt;String.equalsIgnoreCase()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;일부 코딩 표준은 문자열 리터럴을 인수가 아니라 &lt;code&gt;equals()&lt;/code&gt;의 한정자로 사용하여 &lt;code&gt;NullPointerException&lt;/code&gt;를 최소화해야 한다고 지정합니다.&lt;/p&gt;
&lt;p&gt;리터럴 및 표현식을 바꾸는 빠른 수정을 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean isFoo(String value) {
    return value.equals("foo");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean isFoo(String value) {
    return "foo".equals(value);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LiteralAsArgToStringEquals&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodRefCanBeReplacedWithLambda" defaultSeverity="INFORMATION" displayName="메서드 참조를 람다로 바꾸기 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;MyClass::myMethod&lt;/code&gt; 및 &lt;code&gt;myObject::myMethod&lt;/code&gt;와 같은 메서드 참조를 보고하고, 이를 동등한 람다 식으로 바꿀 것을 제안합니다.
&lt;p&gt;람다 식이 메서드 참조보다 수정이 용이할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out::println
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  s -&amp;gt; System.out.println(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;디폴트로, 이 검사는 에디터 내 코드를 강조 표시하지 않으며, 빠른 수정만을 제공합니다.&lt;/p&gt;
&lt;p&gt;이 검사는 다음 Java 기능에 의존합니다.&lt;ul&gt;&lt;li&gt;람다 식&lt;/li&gt;&lt;li&gt;메서드 참조&lt;/li&gt;&lt;/ul&gt;이러한 기능은 Java 8부터 사용할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MethodRefCanBeReplacedWithLambda&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldMayBeFinal" defaultSeverity="WARNING" displayName="필드가 'final'이 될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전하게 &lt;code&gt;final&lt;/code&gt;로 만들 수 있는 필드를 보고합니다.
모든 &lt;code&gt;final&lt;/code&gt; 필드에는 값이 있으며 이 값은 변경되지 않으므로 코드를 더 쉽게 추론할 수 있습니다.
&lt;p&gt;분석에 과도한 비용이 드는 것을 피하기 위해, 이 검사는 필드에 &lt;code&gt;private&lt;/code&gt; 제어자가 있거나 이 필드가 로컬 또는 익명 클래스에서 정의된 경우만 보고합니다.
  다음과 같은 경우 필드가 &lt;code&gt;final&lt;/code&gt;일 수 있습니다.
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;static&lt;/code&gt;이며 해당 선언 또는 하나의 &lt;code&gt;static&lt;/code&gt; 이니셜라이저에서 한 번 초기화된 경우.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;static&lt;/code&gt;이 아니며 해당 선언 또는 하나의 인스턴스 이니셜라이저 또는 모든 생성자에서 한 번 초기화되었으며&lt;/li&gt;
&lt;/ul&gt;
어디서도 수정되지 않은 경우.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Person {
    private String name; // final일 수 있음

    Person(String name) {
      this.name = name;
    }

    public String getName() {
      return name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Person {
    private final String name;

    Person(String name) {
      this.name = name;
    }

    public String getName() {
      return name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  '어노테이션' 버튼을 사용하여 묵시적 필드 쓰기를 가정하는 어노테이션의 목록을 수정하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FieldMayBeFinal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertMessageNotString" defaultSeverity="WARNING" displayName="'assert' 메시지가 문자열이 아님" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.String&lt;/code&gt; 타입이 아닌 &lt;code&gt;assert&lt;/code&gt; 메시지를 보고합니다.
&lt;p&gt;문자열을 사용하면 실패 또는 어설션 이유를 진단하는 데 더 많은 정보가 제공됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(List&amp;lt;Integer&amp;gt; myList) {
    assert myList.isEmpty() : false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;code&gt;assert&lt;/code&gt; 메시지 타입이 &lt;code&gt;boolean&lt;/code&gt; 또는 &lt;code&gt;java.lang.Boolean&lt;/code&gt;인 경우에만 경고하려면 &lt;b&gt;&lt;code&gt;assert&lt;/code&gt; 메시지 타입이 'boolean' 또는 'java.lang.Boolean'인 경우에만 경고&lt;/b&gt; 옵션을 사용하세요.
&lt;code&gt;boolean&lt;/code&gt; 상세 메시지는 어설션 실패에 관한 추가 정보를 제공할 가능성이 낮으며 실수로 &lt;code&gt;&amp;&lt;/code&gt; 대신 &lt;code&gt;:&lt;/code&gt;를 입력할 수 있습니다.
&lt;p&gt;이 검사는 Java 1.4부터 사용할 수 있는 Java 기능 &amp;#39;어설션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AssertMessageNotString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnnecessaryQualifierForThis" defaultSeverity="WARNING" displayName="'this' 또는 'super'에 불필요한 한정자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;super&lt;/code&gt;의 불필요한 한정을 보고합니다.
&lt;p&gt;
  코드 참조의 모호함을 없애기 위해 &lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;super&lt;/code&gt;에 한정자를 사용하면 자동 리팩터링 수행 시 불필요해지기 쉬우므로 명확함을 위해 삭제해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void foo() {}
  }

  class Bar extends Foo {
    void bar() {
      Bar.super.foo();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void foo() {}
  }

  class Bar extends Foo {
    void bar() {
      super.foo();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryQualifierForThis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DiamondCanBeReplacedWithExplicitTypeArguments" defaultSeverity="INFORMATION" displayName="다이아몬드를 명시적 타입 인수로 바꾸기 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
타입 매개변수 대신 &lt;b&gt;&amp;lt;&amp;gt;&lt;/b&gt; 심볼 (다이아몬드) 이 사용된 제네릭 클래스의 인스턴스화를 보고합니다.

&lt;p&gt;빠른 수정은 &lt;b&gt;&amp;lt;&amp;gt;&lt;/b&gt; (다이아몬드) 를 명시적 타입 매개변수로 바꿉니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;Diamond operation&lt;/i&gt;은 Java 7에 등장했습니다.
  이 검사는 이전 Java 버전과의 하위 호환성을 위해 다운그레이드하는 데 도움이 될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DiamondCanBeReplacedWithExplicitTypeArguments&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ListIndexOfReplaceableByContains" defaultSeverity="WARNING" displayName="'List.indexOf()' 식을 'contains()'로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;List.contains()&lt;/code&gt; 메서드로 바꿀 수 있는 모든 &lt;code&gt;List.indexOf()&lt;/code&gt; 표현을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean hasEmptyString(List&amp;lt;String&amp;gt; list) {
    // 경고: 단순화될 수 있습니다
    return list.indexOf("") &amp;gt;= 0;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;제공된 빠른 수정은 &lt;code&gt; indexOf&lt;/code&gt; 호출을 &lt;code&gt;contains&lt;/code&gt; 호출로 바꿉니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean hasEmptyString(List&amp;lt;String&amp;gt; list) {
    // 빠른 수정이 적용되었습니다
    return list.contains("");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ListIndexOfReplaceableByContains&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayCreationWithoutNewKeyword" defaultSeverity="INFORMATION" displayName="'new' 식이 없는 배열 생성" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;new&lt;/code&gt; 배열 표현식이 없는 배열 이니셜라이저를 보고하고 표현식을 추가하도록 제안합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int[] a = {42}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int[] a = new int[]{42}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ArrayCreationWithoutNewKeyword&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EqualsCalledOnEnumConstant" defaultSeverity="WARNING" displayName="열거 값에서 'equals()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
열거형 상수의 &lt;code&gt;equals()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;두 열거형 상수는 동일한 ID를 가지고 있는 경우에만 동일하기 때문에 그러한 호출은 ID 비교(&lt;code&gt;==&lt;/code&gt;)로 바꿀 수 있습니다.&lt;/p&gt;
&lt;p&gt;호출을 비교로 변경하는 빠른 수정을 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean foo(MyEnum value) {
    return value.equals(MyEnum.FOO);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean foo(MyEnum value) {
    return value == MyEnum.FOO;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EqualsCalledOnEnumConstant&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConfusingOctalEscape" defaultSeverity="WARNING" displayName="혼동되는 8진 이스케이프 시퀀스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
8진수 이스케이프 시퀀스 바로 다음에 숫자가 나오는 문자열 리터럴을 보고합니다.
&lt;p&gt;이러한 문자열은 혼란스러울 수 있으며, 종종 이스케이프 코드 작성에서 발생한 오류의 결과입니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println("\1234"); // 8진 이스케이프 시퀀스 '\123'의 바로 뒤에 숫자가 옵니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConfusingOctalEscape&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchLabeledRuleCanBeCodeBlock" defaultSeverity="INFORMATION" displayName="라벨 지정된 switch 식 규칙에 코드 블록 포함 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
표현식 본문을 포함하는 &lt;code&gt;switch&lt;/code&gt; 식 또는 향상된 &lt;code&gt;switch&lt;/code&gt; 문의 규칙을 보고합니다.
이는 코드 블록으로 변환할 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String message = switch (errorCode) {
    case 404 -&gt; "Not found!";
    ...
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String message = switch (errorCode) {
    case 404 -&gt; {
                yield "Not found!";
            }
    ...
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 14부터 사용할 수 있는 Java 기능 &amp;#39;향상된 &amp;#39;switch&amp;#39; 블록&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SwitchLabeledRuleCanBeCodeBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryToStringCall" defaultSeverity="WARNING" displayName="불필요한 'toString()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음 경우에서 호출된 &lt;code&gt;toString()&lt;/code&gt; 호출을 보고합니다:
&lt;ul&gt;
  &lt;li&gt;문자열 연결에서&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.lang.StringBuilder#append()&lt;/code&gt; 또는 &lt;code&gt;java.lang.StringBuffer#append()&lt;/code&gt; 메서드에서&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.io.PrintWriter&lt;/code&gt; 또는 &lt;code&gt;java.io.PrintStream&lt;/code&gt; 에서&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.slf4j.Logger&lt;/code&gt; 에서&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 경우, 문자열로의 변환은 기본 라이브러리 메서드에 의해 처리되며, 명시적으로 &lt;code&gt;toString()&lt;/code&gt;을 호출할 필요가 없습니다.
  불필요한 &lt;code&gt;toString()&lt;/code&gt; 호출을 제거하면 종종 성능이 개선되고 객체 할당이 줄어듭니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(this.toString())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(this)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  참고로 &lt;code&gt;toString()&lt;/code&gt; 호출이 없으면 코드 의미가 다를 수 있습니다: 만약 표현식이 null 이면, &lt;code&gt;NullPointerException&lt;/code&gt;을 던지는 대신 &lt;code&gt;null&lt;/code&gt; 문자열이 사용됩니다.&lt;/p&gt;
  &lt;p&gt;잠재적으로 null이 될 수 있는 값에 대한 경고를 피하려면 &lt;b&gt;한정자가 null이 아닐 경우에만 보고&lt;/b&gt; 옵션을 사용하세요.
  이러한 경우에 명시적 &lt;code&gt;toString()&lt;/code&gt;을 제거하면 런타임 의미가 &lt;code&gt;NullPointException&lt;/code&gt;을 던지는 것에서 &lt;code&gt;null&lt;/code&gt;일 때 확인 없이 값을 취하는 것으로 바뀝니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryToStringCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultiCatchCanBeSplit" defaultSeverity="INFORMATION" displayName="여러 catch를 개별 catch 블록으로 분할할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
여러 개의 &lt;code&gt;catch&lt;/code&gt; 섹션을 보고하고 각각의 &lt;code&gt;catch&lt;/code&gt; 블록으로 분리할 것을 제안합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    int i = getIndex();
  } catch (NullPointerException|IndexOutOfBoundsException e) {
    e.printStackTrace();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    int i = getIndex();
  } catch (NullPointerException e) {
    e.printStackTrace();
  } catch (IndexOutOfBoundsException e) {
    e.printStackTrace();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 7부터 사용할 수 있는 Java 기능 &amp;#39;여러 catch&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MultiCatchCanBeSplit&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NestedMethodCall" defaultSeverity="WARNING" displayName="중첩된 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 메서드 호출에 대한 매개변수로 사용되는 메서드 호출을 보고합니다.
&lt;p&gt;빠른 수정에서는 변수를 삽입하여 코드를 단순화하고 디버그를 용이하게 합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int y() { return 1; }
  public int f(int x) { return 2 * x; }

  public void foo() {
      int x = f(y());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int y() { return 1; }
  public int f(int x) { return 2 * x; }

  public void foo() {
      int y = y();
      int x = f(y);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
보고 대상을 전환하려면 검사 옵션을 사용하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;필드 이니셜라이저의 메서드 호출&lt;/li&gt;
  &lt;li&gt;static 메서드 호출&lt;/li&gt;
  &lt;li&gt;간단한 getter 호출&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: NestedMethodCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RecordCanBeClass" defaultSeverity="INFORMATION" displayName="레코드를 클래스로 변환할 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
레코드 클래스를 보고하고 이를 일반 클래스로 변환하도록 제안합니다.
&lt;p&gt;이 검사는 이 레코드에 빠른 수정을 적용하여 Java 레코드를 이전 Java 버전을 사용하는 코드 베이스로 이동 가능하게 합니다.&lt;/p&gt;
&lt;p&gt;
  참고로, 결과로 얻어진 클래스는 기존 레코드와 완전히 똑같지는 않습니다.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;결과로 얻어진 클래스는 더이상 &lt;code&gt;java.lang.Record&lt;/code&gt;를 확장하지 않으므로,  &lt;code&gt;instanceof Record&lt;/code&gt;는 &lt;code&gt;false&lt;/code&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Class.isRecord()&lt;/code&gt; 및 &lt;code&gt;Class.getRecordComponents()&lt;/code&gt;와 같은 리플렉션 메서드가 다른 결과를 생성합니다.&lt;/li&gt;
  &lt;li&gt;생성된 &lt;code&gt;hashCode()&lt;/code&gt; 구현은 다른 결과를 생성할 수 있습니다. 왜냐하면 레코드의 &lt;code&gt;hashCode&lt;/code&gt;를 계산하는 식이 의도적으로 지정되지 않았기 때문입니다.&lt;/li&gt;
  &lt;li&gt;일반 클래스와 레코드 직렬화 메커니즘이 다릅니다.
    자세한 내용은 &lt;i&gt;Java Object Serialization Specification&lt;/i&gt; 을 참고하세요.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record Point(int x, int y) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final class Point {
    private final int x;
    private final int y;

    Point(int x, int y) {
      this.x = x;
      this.y = y;
    }

    public int x() { return x; }

    public int y() { return y; }

    @Override
    public boolean equals(Object obj) {
      if (obj == this) return true;
      if (obj == null || obj.getClass() != this.getClass()) return false;
      var that = (Point)obj;
      return this.x == that.x &amp;&amp;
             this.y == that.y;
    }

    @Override
    public int hashCode() {
      return Objects.hash(x, y);
    }

    @Override
    public String toString() {
      return "Point[" +
             "x=" + x + ", " +
             "y=" + y + ']';
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;2020.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 16부터 사용할 수 있는 Java 기능 &amp;#39;기록&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RecordCanBeClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarilyQualifiedStaticUsage" defaultSeverity="WARNING" displayName="정적 액세스가 불필요하게 정규화되었습니다." enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스 이름으로 불필요하게 정규화된 static 멤버가 사용된 경우를 보고합니다.
&lt;p&gt;
감싸는 클래스에서, 또는 감싸는 클래스의 상위 클래스에서 static 멤버를 사용할 수 있는 경우, 클래스로 정규화하는 것은 불필요합니다. 그러한 정규화는 안전하게 제거될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      Foo.foo();
      System.out.println(Foo.x);
    }

    static void baz() { Foo.foo(); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      foo();
      System.out.println(x);
    }

    static void baz() { foo(); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  보고 대상을 전환하려면 검사 옵션을 사용하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;static 필드 액세스:&lt;br&gt;&lt;code&gt;void bar() { System.out.println(Foo.x); }&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;static 메서드 호출:&lt;br&gt;&lt;code&gt;void bar() { Foo.foo(); }&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  또한 정적 컨텍스트에서 정적 멤버의 사용을 보고하기 위해 검사를 구성할 수 있습니다. 이 경우 &lt;code&gt;static void baz() { Foo.foo(); }&lt;/code&gt;만 보고됩니다.
&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessarilyQualifiedStaticUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantExpression" defaultSeverity="INFORMATION" displayName="상수식을 평가할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
값을 정적으로 평가할 수 있는 상수 식을 보고하며 실제 값으로 바꾸도록 제안합니다.
  예를 들어 &lt;code&gt;2 + 2&lt;/code&gt;를 &lt;code&gt;4&lt;/code&gt;로 바꾸거나 &lt;code&gt;Math.sqrt(9.0)&lt;/code&gt;를 &lt;code&gt;3.0&lt;/code&gt;으로 바꾸도록 제안합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConstantExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantOnWrongSideOfComparison" defaultSeverity="WARNING" displayName="비교 시 잘못된 쪽에 있는 상수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
잘못된 쪽에 상수 값이 있는 비교 연산을 보고합니다.
&lt;p&gt;일부 코딩 규칙에서는 비교의 특정한 쪽(왼쪽 또는 오른쪽)에 상수를 배치해야 한다고 지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean compare(int x) {
    return 1 &amp;gt; x; // 비교 왼쪽에 상수 '1'이 있습니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean compare(int x) {
    return x &amp;lt; 1;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  비교할 상수의 위치를 선택하고, &lt;code&gt;null&lt;/code&gt; 리터럴이 잘못된 위치에 있으면 경고할지 여부를 선택하려면 검사 설정을 사용합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2019.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConstantOnWrongSideOfComparison&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectsEqualsCanBeSimplified" defaultSeverity="INFORMATION" displayName="'objects.equals()'를 'equals()'로 바꿀수 있습니다." enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
첫 번째 인수가 정적으로 null이 아닌 것으로 알려진 &lt;code&gt;Objects.equals(a, b)&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;인수 모두가 기본 타입인 경우 이러한 호출은 &lt;code&gt;a.equals(b)&lt;/code&gt; 또는 &lt;code&gt;a == b&lt;/code&gt;로 안전하게 바꿀 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String defaultName = "default";
  boolean isDefault = Objects.equals(defaultName, name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String defaultName = "default";
  boolean isDefault = defaultName.equals(name);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 7부터 사용할 수 있는 Java 기능 &amp;#39;java.util.Objects API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ObjectsEqualsCanBeSimplified&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarilyQualifiedStaticallyImportedElement" defaultSeverity="WARNING" displayName="정적으로 가져온 요소가 불필요하게 정규화됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
포함된 클래스 이름으로 한정된 정적으로 가져온 멤버의 사용을 보고합니다.
&lt;p&gt;정적으로 가져온 멤버는 멤버 이름으로 바로 액세스할 수 있기 때문에 그러한 한정은 불필요하며 삭제할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import static foo.Test.WIDTH;

  class Bar {
    void bar() {
      System.out.println(Test.WIDTH);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import static foo.Test.WIDTH;

  class Bar {
    void bar() {
      System.out.println(WIDTH);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessarilyQualifiedStaticallyImportedElement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryParentheses" defaultSeverity="INFORMATION" displayName="불필요한 소괄호" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 소괄호가 사용된 모든 사례를 보고합니다.
&lt;p&gt;소괄호가 제거된 후에도 표현식의 평가 순서가 변하지 않을 경우, 소괄호는 불필요한 것으로 간주됩니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = 3 + (9 * 8);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = 3 + 9 * 8;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이항식을 명확히 하는 데 도움이 되는 소괄호를 무시하려면 &lt;b&gt;소괄호 명확화 무시&lt;/b&gt; 옵션을 사용하세요. &lt;code&gt;instanceof&lt;/code&gt; 식이 더 큰 표현식의 일부이거나 상위 표현식과는 다른 연산자를 가진 경우 이 식에 사용된 소괄호는 이를 명확하게 합니다.&lt;/li&gt;
  &lt;li&gt;조건식에서 조건을 둘러싸는 모든 소괄호를 무시하려면 &lt;b&gt;조건식에서 조건을 둘러싸는 소괄호 무시&lt;/b&gt; 옵션을 사용하에요. 일부 코딩 표준은 이러한 모든 조건들을 반드시 소괄호로 묶어야합니다.&lt;/li&gt;
  &lt;li&gt;
    람다 식 내 한 개의 람다 매개변수를 둘러싼 소괄호를 무시하려면 &lt;b&gt;형식이 없는 단일 유형 람다 매개변수를 둘러싼 소괄호 무시&lt;/b&gt; 옵션을 사용하세요.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryParentheses&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryBlockStatement" defaultSeverity="INFORMATION" displayName="불필요한 코드 블록" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
프로그램의 의미상 불필요하며 해당 블록의 본문으로 대체될 수 있는 코드 블록을 보고합니다.
&lt;p&gt;&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, 또는 &lt;code&gt;for&lt;/code&gt; 구문의 본문인 코드 블록은 이 검사에서 보고하지 않습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo() {
    { // 불필요함
      int result = call();
      analyze(result);
    } // 불필요함
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;
switch 구문 분기에 사용된 코드 블록을 무시하려면 &lt;b&gt;'switch' 문의 분기 무시&lt;/b&gt; 옵션을 사용하세요.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryBlockStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryModifier" defaultSeverity="WARNING" displayName="불필요한 제어자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 제어자를 보고하고 제거를 제안합니다.
그 결과 코드는 더 간단해지지만 동작 및 의미는 변하지 않습니다.
&lt;p&gt;&lt;b&gt;예시 1:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Java 17 이상에서 모든 코드는 묵시적으로 strictfp입니다
  strictfp class X {

    // 내부 열거형은 묵시적으로 static입니다
    static enum Inner {
        A, B, C
    }

    // 내부 레코드는 묵시적으로 static입니다
    static record R() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;예시 2:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final record R() {
    // 모든 레코드는 묵시적으로 final입니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;예시 3:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 모든 인터페이스는 묵시적으로 추상적입니다
  abstract interface Printer {

    // 모든 인터페이스 멤버는 묵시적으로 public입니다
    public int size();

    // 인터페이스의 모든 내부 클래스는 묵시적으로 static입니다
    static class Inner {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryModifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalIsPresent" defaultSeverity="WARNING" displayName="함수형 스타일이 아닌 'Optional.isPresent()' 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;if&lt;/code&gt; 식 또는 조건식의 조건으로 사용되고 함수 형태로 다시 작성될 수 있는&lt;code&gt;Optional&lt;/code&gt; 식을 보고합니다.
이러면 결과가 더 짧고 읽기 쉬워지는 경우가 많습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (str.isPresent()) str.get().trim();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  str.ifPresent(String::trim);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: OptionalIsPresent&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitCallToSuper" defaultSeverity="WARNING" displayName="'super()'를 묵시적으로 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
'super' 생성자 또는 동일한 클래스의 또 다른 생성자 호출로 시작하지 않는 생성자를 보고합니다.
&lt;p&gt;이러한 생성자는 묵시적으로 &lt;code&gt;super()&lt;/code&gt; 호출로 시작된다고 생각할 수 있습니다. 일부 코딩 표준에서는 이러한 &lt;code&gt;super()&lt;/code&gt; 호출을 명시적으로 지정하는 것을 선호합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {
      super();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 옵션을 사용하여 &lt;code&gt;Object&lt;/code&gt;에서 직접 확장되는 클래스를 무시합니다.
  예:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {} // 보고 안 함
  }

  class Bar extends Foo {
    Bar() {} // 'super()'에 대한 묵시적 호출
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ImplicitCallToSuper&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EscapedSpace" defaultSeverity="WARNING" displayName="'\s' 이스케이프 시퀀스의 터미널 외 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
텍스트 블록 줄의 끝이나 이스케이프 공백이 연속되는 위치를 제외한 모든 곳의 &lt;code&gt;\s&lt;/code&gt; 이스케이프 시퀀스를 보고합니다.
해당 문자열이 일반적인 표현식으로 해석되는 경우 이러한 사용 위치는 명확하지 않거나 실수일 수 있습니다.
&lt;code&gt;\s&lt;/code&gt; 이스케이프 시퀀스는 일반 공백이 잘리는 텍스트 블록 줄의 끝에서 공백을 인코딩하기 위해 사용됩니다.
일반 문자열 또는 char 리터럴을 포함한 다른 위치에서 &lt;code&gt;\s&lt;/code&gt;는 일반 공백 문자(&lt;code&gt;"&amp;nbsp;"&lt;/code&gt;)와 동일합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (str.matches("\s+")) {...}
&lt;/code&gt;&lt;/pre&gt;
원래의 의도는 &lt;code&gt;"\\s+"&lt;/code&gt;였을 수도 있습니다(공백 문자와 일치시키기 위해). 그렇지 않은 경우 &lt;code&gt;str.matches("&amp;nbsp;+")&lt;/code&gt;를 사용하면 더 명확해집니다.
&lt;p&gt;
  &lt;code&gt;\s&lt;/code&gt; 이스케이프를 공백 문자로 대체하는 빠른 수정이 제공됩니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 15부터 사용할 수 있는 Java 기능 &amp;#39;&amp;#39;\s&amp;#39; 이스케이프 시퀀스&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EscapedSpace&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrailingWhitespacesInTextBlock" defaultSeverity="WARNING" displayName="텍스트 블록 내 후행 공백" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
후행 공백 문자가 있는 텍스트 블록을 보고합니다.
후행 공백은 부수적인 것으로 간주되며 Java 컴파일러가 이를 제거합니다.
&lt;p&gt;&lt;b&gt;예(점으로 공백 표시):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
..String.count.=."""
....one
....two....
....three
....""";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;두 개의 빠른 수정이 제공됩니다.
  하나는 마지막 공백을 제거하고, 다른 하나는 마지막 공백이 컴파일러에 의해 제거되지 않도록 해당 공백을 이스케이프 처리합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
..String.count.=."""
....one
....two...\s
....three
....""";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 15부터 사용할 수 있는 Java 기능 &amp;#39;텍스트 블록 리터럴&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TrailingWhitespacesInTextBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalCanBeFinal" defaultSeverity="WARNING" displayName="지역 변수 또는 매개변수는 'final'이 될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
매개변수 혹은 지역 변수 중 선언에 &lt;code&gt;final&lt;/code&gt; 제어자가 추가될 수 있는 항목을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList();
  fill(list);
  return list;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList();
  fill(list);
  return list;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 옵션을 사용하여 매개변수 또는 지역 변수가 보고되어야 하는지 정의합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LocalCanBeFinal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LambdaParameterTypeCanBeSpecified" defaultSeverity="INFORMATION" displayName="람다 매개변수 타입을 지정할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
타입이 지정되지 않은 람다 매개변수를 보고하고 누락된 타입 선언을 추가할 것을 제안합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Function&amp;lt;String, Integer&amp;gt; length = a -&amp;gt; a.length();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Function&amp;lt;String, Integer&amp;gt; length = (String a) -&amp;gt; a.length();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;람다 식&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LambdaParameterTypeCanBeSpecified&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MoveFieldAssignmentToInitializer" defaultSeverity="INFORMATION" displayName="필드 대입을 이니셜라이저로 이동할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대입을 사용하는 필드 초기화를 필드 선언 내 초기화로 바꿀 것을 제안합니다
&lt;p&gt;필드 대입이 인스턴스나 static 이니셜라이저에 있고 이 대입을 필드 선언과 결합하는 것이 안전한 경우에만 보고합니다.
  다른 경우(예: 생성자 내에 대입이 있는 경우) 수정으로 의미가 바뀔 수 있으므로, 빠른 수정이 강조 표시 없이 제공됩니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    static final int intConstant;
    
    static {
      intConstant = 10;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
빠른 수정은 대입된 값을 필드 이니셜라이저로 이동하고, 가능한 경우 클래스 이니셜라이저를 제거합니다.
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    static final int intConstant = 10;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;small&gt;2017.2부터 적용&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MoveFieldAssignmentToInitializer&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnqualifiedMethodAccess" defaultSeverity="WARNING" displayName="인스턴스 메서드 호출이 'this'로 정규화되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;this&lt;/code&gt;로 한정되지 않는 동일한 인스턴스에 대한 비 &lt;code&gt;static&lt;/code&gt; 메서드 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void bar() {}

    void foo() {
      bar();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void bar() {}

    void foo() {
      this.bar();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnqualifiedMethodAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnqualifiedFieldAccess" defaultSeverity="WARNING" displayName="인스턴스 필드 액세스가 'this'로 정규화되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;this&lt;/code&gt; 또는 다른 한정자로 한정되지 않는 필드 액세스 연산을 보고합니다.
&lt;p&gt;
  일부 코드 스타일에서는 지역 변수 또는 매개변수 액세스와 혼동을 방지하기 위해 모든 필드 액세스 연산을 반드시 한정하도록 합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo;

    void bar() {
      foo += 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo;

    void bar() {
      this.foo += 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnqualifiedFieldAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SizeReplaceableByIsEmpty" defaultSeverity="WARNING" displayName="'size() == 0'을 'isEmpty()'로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;.isEmpty()&lt;/code&gt; 호출로 바꿀 수 있는 &lt;code&gt;0&lt;/code&gt; 리터럴과의 &lt;code&gt;.size()&lt;/code&gt; 또는 &lt;code&gt;.length()&lt;/code&gt; 비교를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean emptyList = list.size() == 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean emptyList = list.isEmpty();
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;무시된 클래스&lt;/b&gt; 테이블을 사용하여 &lt;code&gt;.size()&lt;/code&gt; 또는 &lt;code&gt;.length()&lt;/code&gt; 비교를 바꿔서는 안 되는 클래스를 추가하세요.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;!isEmpty()&lt;/code&gt;로 바꿀 수 있는 모든 표현식을 무시하려면 &lt;b&gt;&lt;code&gt;!isEmpty()&lt;/code&gt;로 바꿀 수 있는 표현식 무시&lt;/b&gt; 옵션을 사용하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SizeReplaceableByIsEmpty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ControlFlowStatementWithoutBraces" defaultSeverity="INFORMATION" displayName="중괄호가 없는 제어 흐름 구문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
중괄호가 없는 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt; 또는 &lt;code&gt;for&lt;/code&gt; 문을 보고합니다.
&lt;a href="https://google.github.io/styleguide/javaguide.html"&gt;Google Java 스타일 가이드&lt;/a&gt; 같은 일부 코드 스타일의 경우, 모든 제어문에 중괄호가 필요합니다.
&lt;p&gt;
  중괄호가 없는 제어문에 구문을 추가하려면 중괄호를 잊지 말고 추가해야 합니다.
  코드 한 줄을 주석 처리할 때 중괄호를 사용하지 않는 경우, 다음 구문을 제어 흐름 구문의 일부로 만들지 않도록 더욱 주의를 기울여야 합니다.
  항상 중괄호를 사용하면 안전하게 코드를 삽입하거나 주석 처리할 수 있습니다.
&lt;p&gt;
  중괄호가 항상 사용되는 코드 스타일이었다면, &lt;a href="https://www.imperialviolet.org/2014/02/22/applebug.html"&gt;goto fail 취약점&lt;/a&gt;은 발생하지 않았을 가능성이 높습니다.
  중괄호가 있는 제어문은 잠재적으로 올바르지 않을 수도 있는 들여쓰기에 의존하지 않고도 손쉽게 제어 흐름을 볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Strange {
    void x(boolean one, boolean two) {
      if(one)
        if(two)
          foo();
      else
        bar();
    }

    void foo() {}
    void bar() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정은 구문 본문을 중괄호로 둘러쌉니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Strange {
    void x(boolean one, boolean two) {
      if(one) {
        if(two) {
          foo();
        } else {
          bar();
        }
      }
    }

    void foo() {}
    void bar() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ControlFlowStatementWithoutBraces&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalCanBeOptional" defaultSeverity="INFORMATION" displayName="조건을 Optional로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
null 검사 조건을 보고하고 이를 &lt;code&gt;Optional&lt;/code&gt; 체인으로 바꿀 것을 제안합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return str == null ? "" : str.trim();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return Optional.ofNullable(str).map(String::trim).orElse("");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;변경 후 코드가 항상 더 짧은 것은 아니지만 향후 리팩터링에 유용할 수 있습니다 (예를 들어, 메서드 반환 값을  &lt;code&gt;Optional&lt;/code&gt;로 변경하는 경우).&lt;/p&gt;
&lt;p&gt;조건의 null이 아닌 분기가 null을 반환하는 경우, 해당 매핑 단계 실행은 의미를 바꿀 가능성이 있는 빈 &lt;code&gt;Optional&lt;/code&gt;을 생성합니다. 의미 보존을 정적으로 증명할 수 없는 경우 빠른 수정 액션 이름에 '(의미가 변경될 수 있음)'이라는 알림이 포함되며 검사의 강조 표시가 비활성화됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ConditionalCanBeOptional&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ChainedMethodCall" defaultSeverity="WARNING" displayName="체인 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대상이 다른 메서드 호출인 메서드 호출을 보고합니다.
빠른 수정에서는 지역 변수를 삽입할 것을 제안합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
    int foo(File f) {
      return f.getName().length();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
    int foo(File f) {
      final String name = f.getName();
      return name.length();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 옵션을 사용하여 다음 경우에 대한 경고를 전환합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;
      필드 이니셜라이저 내 체인 메서드 호출(예: &lt;code&gt;private final int i = new Random().nextInt();&lt;/code&gt;)
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      동일한 타입에서 작동되는 체인 메서드 호출(예: &lt;code&gt;new StringBuilder().append("x: ").append(new X()).append("y: ").append(new Y()).toString();&lt;/code&gt;).
    &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ChainedMethodCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FillPermitsList" defaultSeverity="INFORMATION" displayName="봉인된 클래스의 permits 절에서 동일한 파일 하위 클래스가 누락되었습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명시적인 &lt;code&gt;permits&lt;/code&gt; 목록이 없는 &lt;code&gt;sealed&lt;/code&gt; 클래스를 보고합니다.
하위 클래스가 같은 파일에만 있는 sealed 클래스는 명시적인 &lt;code&gt;permits&lt;/code&gt; 목록이 필요하지 않습니다.
기본적으로 이 검사는 에디터에서 강조 표시하지 않으며, 수정만을 제공합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class A {}
  final class B extends A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class A permits B {}
  final class B extends A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 17부터 사용할 수 있는 Java 기능 &amp;#39;봉인된 클래스&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FillPermitsList&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsObject" defaultSeverity="WARNING" displayName="클래스가 'Object'를 명시적으로 확장" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명시적으로 &lt;code&gt;java.lang.Object&lt;/code&gt;를 상속받도록 선언된 모든 클래스를 보고합니다.
&lt;p&gt;이러한 선언은 불필요하며 안전하게 생략할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass extends Object {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정은 불필요한 &lt;code&gt;extends Object&lt;/code&gt; 절을 제거합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExtendsObject&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarySemicolon" defaultSeverity="WARNING" displayName="불필요한 세미콜론" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 세미콜론 및 클래스 멤버 사이, 블록 구문 내부, 또는 클래스 정의 다음에 사용된 세미콜론을 보고합니다.
&lt;p&gt;이러한 세미콜론은 Java에서 유효하지만, 불필요하며 제거될 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    ;
    void m() throws Exception {
        try (AutoCloseable r1 = createAutoCloseable();) {
          ;
        }
    }
    ;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    void m() throws Exception {
      try (AutoCloseable r1 = createAutoCloseable()) {
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessarySemicolon&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryFullyQualifiedName" defaultSeverity="INFORMATION" displayName="불필요한 정규화된 이름" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
축약될 수 있는 정규화된 클래스 이름을 보고합니다.
&lt;p&gt;빠른 수정은 정규화된 이름을 축약하고 필요한 경우 import 문을 추가합니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class ListWrapper {
    java.util.List&amp;lt;Integer&amp;gt; l;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.List;
  class ListWrapper {
    List&amp;lt;Integer&amp;gt; l;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;

&lt;p&gt;
  Java 9 &lt;code&gt;provides&lt;/code&gt; 및 &lt;code&gt;uses&lt;/code&gt; 모듈 구문 내에서 정규화된 이름을 무시하려면 &lt;b&gt;Java 9 모듈 구문 무시&lt;/b&gt; 옵션을 사용하세요.
&lt;p&gt;
  검사를 구성하려면 &lt;a href="settings://preferences.sourceCode.Java?JavaDoc%20Inner"&gt;설정 | 에디터 | 코드 스타일 | Java | import 문&lt;/a&gt;에서 다음 옵션을 사용하세요.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;내부 클래스에 대한 참조가 외부 클래스와 정규화되어야 하는 경우 &lt;b&gt;내부 클래스에 대한 import 문 삽입&lt;/b&gt; 옵션을 사용하세요.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;JavaDoc에서 정규화된 클래스 이름 사용&lt;/b&gt; 옵션을 사용하여 Javadoc에서 정규화된 이름을 허용하세요.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryFullyQualifiedName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnSeparatedFromComputation" defaultSeverity="INFORMATION" displayName="결과 계산에서 분리된 'return'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
같은 메서드 내부의 다른 어딘가에서 변숫값이 계산되는 지역 변수를 반환하는 &lt;code&gt;return&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;빠른 수정은 반환 구문을 변수 값이 계산되는 지점으로 옮겨서 반환된 변수를 인라인화합니다.
  반환된 &lt;code&gt;return&lt;/code&gt; 값이 &lt;0&gt;return&lt;/0&gt; 구문으로 인라인화될 수 없는 경우 빠른 수정은 반환 구문을 반환 값이 계산되는 위치에 되도록 가까운 위치로 옮깁니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = -1;
  for (int i = 0; i &amp;lt; a.length; i++) {
    if (a[i] == b) {
      n = i;
      break;
    }
  }
  return n;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = -1;
  for (int i = 0; i &amp;lt; a.length; i++) {
    if (a[i] == b) {
      return i;
    }
  }
  return n;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReturnSeparatedFromComputation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToStringConcatCanBeReplacedByOperator" defaultSeverity="WARNING" displayName="'String.concat()' 호출을 '+'로 바꿀수 있습니다." enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.String.concat()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  메서드가 상수 인수로 상수에서 호출된 경우 명확성과 성능 개선 가능성을 위해 해당 호출을 &lt;code&gt;+&lt;/code&gt; 연산자로 바꿀 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String foo(String name) {
    return name.concat("foo");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String foo(String name) {
    return name + "foo";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CallToStringConcatCanBeReplacedByOperator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaBodyCanBeCodeBlock" defaultSeverity="INFORMATION" displayName="람다 본문이 코드 블록이 될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 한 개의 표현식인 람다를 보고하고 표현식 본문을 코드 블록으로 변환할 것을 제안합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  n&amp;nbsp;-&amp;gt;&amp;nbsp;n&amp;nbsp;+&amp;nbsp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n -&amp;gt; {
  return n + 1;
}&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;람다 식&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LambdaBodyCanBeCodeBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryConstructor" defaultSeverity="WARNING" displayName="중복 비인수 생성자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 생성자를 보고합니다.
&lt;p&gt;
  해당 생성자가 클래스의 유일한 생성자이고, 매개변수가 없고, 포함된 클래스와 동일한 접근 제어자를 가지며, 명시적 또는 묵시적으로 상위 클래스 생성자를 호출하는 것을 제외하고 인수 없이 어떠한 초기화도 수행하지 않는 경우, 불필요합니다.
  생성자는 지정되지 않은 경우에도 컴파일러로 생성되므로 안전하게 제거할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {
    public Foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
검사 설정을 사용하여 어노테이션이 포함된 불필요한 생성자를 무시합니다.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarySuperQualifier" defaultSeverity="WARNING" displayName="불필요한 'super' 한정자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 호출과 필드 참조에서 불필요한 &lt;code&gt;super&lt;/code&gt; 한정자를 보고합니다.
&lt;p&gt;
  호출 클래스에서 슈퍼클래스의 필드 또는 메서드가 표시 및 재정의되지 않는 경우 &lt;code&gt;super&lt;/code&gt; 한정자는 필요하지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void foo() {}
  }

  class Bar extends Foo {
    void bar() {
      super.foo();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void foo() {}
  }

  class Bar extends Foo {
    void bar() {
      foo();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 설정을 사용하여 외부 클래스 멤버와 이름이 동일한 상위 클래스 멤버의 액세스를 구분하는 한정자를 무시합니다.
&lt;p&gt;
&lt;p&gt;
  다음의 검사도 참조하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;i&gt;Java | 가시성 | 상속된 필드에 대한 액세스가 주변 코드의 요소에 대한 액세스로 보임&lt;/i&gt;&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Java | 가시성 | 상속된 메서드 호출이 지역 메서드 호출처럼 보임&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessarySuperQualifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TryStatementWithMultipleResources" defaultSeverity="INFORMATION" displayName="여러 리소스가 있는 'try' 문을 분할할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
여러 개의 try-with-resources 문으로 자동으로 분할될 수 있는 여러 리소스를 사용하는 &lt;code&gt;try&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;이러한 변환은 향후 리팩터링 (예를 들어, 중첩된 &lt;code&gt;try&lt;/code&gt; 문을 여러 개의 메서드로 추출할 경우) 에 유용합니다. &lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try (FileInputStream in = new FileInputStream("in.txt");
     FileOutputStream out = new FileOutputStream("out.txt")) {
     /*읽기 및 쓰기*/
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try (FileInputStream in = new FileInputStream("in.txt")) {
    try (FileOutputStream out = new FileOutputStream("out.txt")) {
      /*읽기 및 쓰기*/
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TryStatementWithMultipleResources&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MultipleVariablesInDeclaration" defaultSeverity="INFORMATION" displayName="하나의 선언 내 여러 변수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
한 개의 선언에 선언된 여러 개의 변수를 보고하고 각 변수에 대한 별도의 선언을 생성할 것을 제안합니다.
&lt;p&gt;일부 코딩 표준은 이러한 선언을 금지합니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x = 1, y = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x = 1;
  int y = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;'for' 루프 구문 초기화에 선언된 여러 개의 변수를 무시하려면 &lt;b&gt;'for' 루프 선언 무시&lt;/b&gt; 옵션을 사용하세요. 예:
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;for&lt;/b&gt; (int i = 0, max = list.size(); i &amp;gt; max; i++) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;하나의 선언에서 서로 다른 배열 크기를 가진 변수들에 대해서만 경고를 표시하려면 &lt;b&gt;단일 선언에서 서로 다른 배열 크기에 대해서만 경고&lt;/b&gt; 옵션을 사용하세요. 예:
&lt;pre&gt;&lt;code&gt;
  String s = "", array[];
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;2019.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MultipleVariablesInDeclaration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StreamToLoop" defaultSeverity="INFORMATION" displayName="Stream API 호출 체인을 루프로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
일반적인 루프로 자동 변환되는 Stream API 체인, &lt;code&gt;Iterable.forEach()&lt;/code&gt; 및 &lt;code&gt;Map.forEach()&lt;/code&gt; 호출을 보고합니다.
이 검사는 이전 Java 버전과의 하위 호환성을 위해 다운그레이드하는 데 도움이 될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String joinNonEmpty(List&amp;lt;String&amp;gt; list) {
    return list.stream() // 스트림을 루프로 변환할 수 있습니다
      .filter(s -&gt; !s.isEmpty())
      .map(String::trim)
      .collect(Collectors.joining(", "));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String joinNonEmpty(List&amp;lt;String&amp;gt; list) {
    StringJoiner joiner = new StringJoiner(", ");
    for (String s : list) {
      if (!s.isEmpty()) {
        String trim = s.trim();
        joiner.add(trim);
      }
    }
    return joiner.toString();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  때때로 이 검사로 인해 약간의 의미 변경이 있을 수 있습니다.
  스트림이 쇼트 서킷될 때 실제로 얼마나 많은 요소를 읽을 지 지정되지 않았으므로 쇼트 서킷과 관련하여 특별한 주의를 기울여야 합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;인식되지 않은 소스를 사용하는 스트림에 대한 변환을 제안하려면 &lt;b&gt;Stream.iterator()를 통해 알 수 없는 Stream 소스 반복&lt;/b&gt; 옵션을 사용하세요.
  이 경우 반복자는 스트림으로부터 생성됩니다.
  예를 들어, 체크박스가 선택되면, 제안된 변환이 여기에 표시됩니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;ProcessHandle&amp;gt; handles = ProcessHandle.allProcesses().collect(Collectors.toList());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경우 결과는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;ProcessHandle&amp;gt; handles = new ArrayList&amp;lt;&amp;gt;();
  for (Iterator&amp;lt;ProcessHandle&amp;gt; it = ProcessHandle.allProcesses().iterator(); it.hasNext(); ) {
    ProcessHandle allProcess = it.next();
    handles.add(allProcess);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: StreamToLoop&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryThis" defaultSeverity="WARNING" displayName="불필요한 'this' 한정자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 &lt;code&gt;this&lt;/code&gt; 한정자를 보고합니다.
&lt;p&gt;
  코드 참조의 모호함을 없애기 위해 &lt;code&gt;this&lt;/code&gt;를 사용하는 것은 다양한 코드 스타일에서 지양되며 자동 리팩터링 수행 시 불필요해지기 쉽습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int x;
    void foo() {
      this.x = 2;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int x;
    void foo() {
      x = 2;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 설정을 사용하여 필드 대입을 무시합니다.
  예를 들면 &lt;code&gt;this.x = 2;&lt;/code&gt;는 보고되지 않지만 &lt;code&gt;int y = this.x;&lt;/code&gt;는 보고됩니다.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryThis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableIfStatement" defaultSeverity="INFORMATION" displayName="'if' 문을 조건 또는 부울 표현식으로 바꾸기 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;&amp;&amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt; 또는 &lt;code&gt;?:&lt;/code&gt; 연산자를 사용하는 조건으로 바꿀 수 있는 &lt;code&gt;if&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;얻어진 결과는 일반적으로 더 짧지만, 항상 더 명확하지는 않으므로, 모든 경우에 적용하는 것은 권장하지 않습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (condition) return true; else return foo;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return condition || foo;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
  &lt;b&gt;'?:' 연산자를 제안 안 함&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;?:&lt;/code&gt; 연산자가 제안되는 경우 경고를 끄세요. 이 경우, &lt;code&gt;&amp;&amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 제안만 강조 표시됩니다. 에디터에서 빠른 수정을 계속 사용할 수 있습니다.
&lt;/li&gt;
&lt;li&gt;
  &lt;b&gt;체인 'if' 문 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;if-else&lt;/code&gt; 체인에 대한 경고를 끌 수 있습니다. 에디터에서 빠른 수정을 계속 사용할 수 있습니다.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;2018.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SimplifiableIfStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryFinalOnLocalVariableOrParameter" defaultSeverity="WARNING" displayName="지역 변수 또는 매개변수의 불필요한 'final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 &lt;code&gt;final&lt;/code&gt; 선언이 포함된 변수 또는 매개변수를 보고합니다.
&lt;p&gt;일부 코드 표준에서는 코드를 간결하게 하기 위한 목적으로 변수의 &lt;code&gt;final&lt;/code&gt; 선언을 인정하지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo(Object o) {}

    void bar(final Object o) {
      new Foo(o);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo(Object o) {}

    void bar(Object o) {
      new Foo(o);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  보고 대상을 전환하려면 검사 옵션을 사용하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    지역 변수
  &lt;/li&gt;
  &lt;li&gt;
    매개변수(&lt;code&gt;catch&lt;/code&gt; 블록과 확장된 &lt;code&gt;for&lt;/code&gt; 구문의 매개변수 포함)
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  또한 &lt;code&gt;abstract&lt;/code&gt; 또는 인터페이스 메서드의 &lt;code&gt;final&lt;/code&gt; 매개변수를 보고하기 위해 검사를 구성할 수 있으며, 이와 같은 표시는 메서드의 구현에 영향을 주지 않으므로 특히 불필요한 것으로 간주될 수 있습니다.
&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryFinalOnLocalVariableOrParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalToIf" defaultSeverity="INFORMATION" displayName="'Optional'을 'if' 문 시퀀스로 바꿀 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
일련의 &lt;code&gt;if&lt;/code&gt;문으로 바꿀 수 있는 &lt;code&gt;Optional&lt;/code&gt; 호출 체인을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return Optional.ofNullable(name)
    .map(this::extractInitials)
    .map(initials -&gt; initials.toUpperCase(Locale.ENGLISH))
    .orElseGet(this::getDefault);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (name != null) {
    String initials = extractInitials(name);
    if (initials != null) return initials.toUpperCase(Locale.ENGLISH);
  }
  return getDefault();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 검사는 이전 Java 버전과의 하위 호환성을 위해 다운그레이드하는 데 도움이 될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: OptionalToIf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnclearBinaryExpression" defaultSeverity="INFORMATION" displayName="우선 순위가 다른 여러 연산자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
소괄호 없이 서로 다른 연산자로 구성된 2진, 조건 또는 &lt;code&gt;instanceof&lt;/code&gt; 표현식을 보고합니다. 이러한 표현식은 연산자의 각기 다른 우선 순위 규칙 때문에 가독성이 떨어집니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = 3 + 9 * 8 + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = 3 + (9 * 8) + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnclearBinaryExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeParameterExtendsObject" defaultSeverity="WARNING" displayName="타입 매개변수가 명시적으로 'Object'를 확장" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.Object&lt;/code&gt;를 확장하도록 명시적으로 선언되어 있는 타입 매개변수 및 와일드카드 타입 인수를 보고합니다.
&lt;p&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;는 모든 클래스의 상위 타입이므로 그러한 'extends' 절은 불필요합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class ClassA&amp;lt;T extends Object&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  어노테이션 때문에 'extends Object' 절을 유지해야 한다면, &lt;b&gt;Ignore when java.lang.Object에 어노테이션이 추가된 경우 무시&lt;/b&gt; 옵션을 비활성화하세요.
  이 옵션은 예를 들어 nullness 분석기를 사용하며 'extends Object' 절이 &lt;code&gt;@Nullable&lt;/code&gt;/&lt;code&gt;@NotNull&lt;/code&gt; 어노테이션을 포함하는 경우에 유용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class MyClass&amp;lt;T extends @NotNull Object&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: TypeParameterExtendsObject&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryConstantArrayCreationExpression" defaultSeverity="WARNING" displayName="상수 배열 생성 시의 중복 'new' 표현식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열 이니셜라이저로 바꿀 수 있는 불변의 new 배열 표현식을 보고합니다. 배열 이니셜라이저는 대입의 왼쪽에 이미 지정되어 타입을 생략할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int[] foo = new int[] {42};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int[] foo = {42};
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryConstantArrayCreationExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalContainsCollection" defaultSeverity="WARNING" displayName="'Optional'에 배열 또는 컬렉션이 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열 또는 컬렉션 타입 매개변수를 가지는 &lt;code&gt;java.util.Optional&lt;/code&gt; 또는 &lt;code&gt;com.google.common.base.Optional&lt;/code&gt; 타입을 보고합니다.
&lt;p&gt;그러한 경우, 빈 배열 또는 컬렉션을 사용하여 결과가 없음을 나타내는 것이 더 명확합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; foo() {
    return Optional.empty();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드는 다음과 같이 작성할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; foo() {
    return List.of();
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: OptionalContainsCollection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaCanBeReplacedWithAnonymous" defaultSeverity="INFORMATION" displayName="람다를 익명 클래스로 바꾸기 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
익명 클래스로 바꿀 수 있는 람다 표현식을 보고합니다.
&lt;p&gt;
  익명 클래스 내에서 다른 메서드를 구현해야 하는 경우 람다 식을 익명 클래스로 확장하는 것이 유용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  s -&gt; System.out.println(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Consumer&amp;lt;String&amp;gt;() {
  @Override
  public void accept(String s) {
    System.out.println(s);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;람다 식&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LambdaCanBeReplacedWithAnonymous&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BoundedWildcard" defaultSeverity="WARNING" displayName="바운드된 와일드카드 사용 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://en.wikipedia.org/wiki/Wildcard_(Java)"&gt;바운드된 와일드카드&lt;/a&gt;를 사용할 수 있는 제네릭 메서드 매개변수를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process(Consumer&amp;lt;Number&amp;gt; consumer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음으로 바꿔야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process(Consumer&amp;lt;? super Number&amp;gt; consumer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  이 메서드 시그니처는 더 많은 타입을 허용하므로 더 유연합니다(&lt;code&gt;Consumer&amp;lt;Number&amp;gt;&lt;/code&gt;뿐만 아니라 &lt;code&gt;Consumer&amp;lt;Object&amp;gt;&lt;/code&gt;도 허용).
&lt;/p&gt;
&lt;p&gt;마찬가지로, 공변성 위치에 있는 타입 매개변수도 허용합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  T produce(Producer&amp;lt;T&amp;gt; p);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음으로 바꿔야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  T produce(Producer&amp;lt;? extends T&amp;gt; p);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;em&gt;Effective Java&lt;/em&gt; 3판에서 &lt;a href="https://en.wikipedia.org/wiki/Joshua_Bloch#Effective_Java"&gt;Joshua Bloch&lt;/a&gt;의 말을 인용하면 다음과 같습니다.
&lt;/p&gt;
&lt;blockquote&gt;
  &lt;h4&gt;항목 31: 바운드된 와일드카드를 사용하여 API 유연성 향상&lt;/h4&gt;
  까다롭기는 하지만, API에서 와일드카드 타입을 사용하면 API의 유연성이 훨씬 더 높아집니다.
  광범위하게 사용될 라이브러리를 작성하는 경우, 와일드카드 타입의 적절한 사용을 반드시 고려해야 합니다.
  프로듀서-extends, 컨슈머-super(PECS)라는 기본 규칙을 기억하세요.
  또한 모든 Comparable 및 Comparator가 컨슈머인 것도 기억하세요.
&lt;/blockquote&gt;

&lt;p&gt;
  보고 대상을 전환하려면 검사 옵션을 사용하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;
      무공변성 클래스. 예를 들어, 무공변성 클래스는 값을 허용(&lt;code&gt;List.add(T)&lt;/code&gt; 메서드를 통해)할 뿐만 아니라 생성(&lt;code&gt;T List.get()&lt;/code&gt; 메서드를 통해)하기도 하기 때문에 &lt;code&gt;java.util.List&amp;lt;T&amp;gt;&lt;/code&gt;입니다.
    &lt;/p&gt;
    &lt;p&gt;
      한편, &lt;code&gt;contravariant&lt;/code&gt; 클래스는 값을 받기만 합니다. 예를 들어, 유일한 메서드 &lt;code&gt;accept(T)&lt;/code&gt;가 포함된 &lt;code&gt;java.util.function.Consumer&amp;lt;T&amp;gt;&lt;/code&gt;가 이에 해당합니다. 유사하게, &lt;code&gt;covariant&lt;/code&gt; 클래스는 값을 생성하기만 합니다. 예를 들어, 유일한 메서드&lt;code&gt;T get()&lt;/code&gt;이 포함된 &lt;code&gt;java.util.function.Supplier&amp;lt;T&amp;gt;&lt;/code&gt;가 이에 해당합니다.
    &lt;/p&gt;
    &lt;p&gt;
      보통 공변성/반공변성 클래스에서는 바운드된 와일드카드가 종종 사용되지만 무공변성 클래스(예: &lt;code&gt;void process(List&amp;lt;? extends T&amp;gt; l)&lt;/code&gt;)에서는 지양됩니다.
      이러한 무공변성 클래스를 무시하고 &lt;code&gt;void process(List&amp;lt;T&amp;gt; l)&lt;/code&gt; 같은 엄격한 타입을 유지하려면 이 옵션을 비활성화합니다.
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      &lt;code&gt;private&lt;/code&gt; 메서드. 이 메서드는 public API의 일부가 아닌 것으로 간주될 수 있습니다.
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      인스턴스 메서드
    &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BoundedWildcard&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SingleElementAnnotation" defaultSeverity="INFORMATION" displayName="정규화되지 않은 어노테이션" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
축약 형식의 어노테이션을 보고하고 이를 속성 이름을 사용한 일반 형식으로 다시 작성하도록 제안합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @SuppressWarnings("foo")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @SuppressWarnings(value = "foo")
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SingleElementAnnotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnqualifiedStaticUsage" defaultSeverity="WARNING" displayName="정규화되지 않은 정적 액세스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스 이름으로 한정되지 않은 static 멤버의 사용을 보고합니다.
&lt;p&gt;
static 멤버가 동일한 클래스 내에 있는 경우는 유효하지만 혼동될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      foo();
      System.out.println(x);
    }

    static void baz() { foo(); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      Foo.foo();
      System.out.println(Foo.x);
    }

    static void baz() { Foo.foo(); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;다음 항목의 보고를 전환하려면 검사 설정을 사용하세요.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;
      static fields access&lt;br&gt;
      &lt;code&gt;void bar() { System.out.println(x); }&lt;/code&gt;
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      calls to static methods&lt;br&gt;
      &lt;code&gt;void bar() { foo(); }&lt;/code&gt;&lt;br&gt;
      &lt;code&gt;static void baz() { foo(); }&lt;/code&gt;
    &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  또한 정적이지 않은 컨텍스트에서 정적 멤버의 사용을 보고하기 위해 검사를 구성할 수 있습니다.
  위 예시에서는 &lt;code&gt;static void baz() { foo(); }&lt;/code&gt;를 보고하지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnqualifiedStaticUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BlockMarkerComments" defaultSeverity="WARNING" displayName="블록 마커 주석" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
코드 블록 마커로 사용되는 주석을 보고합니다.
빠른 수정은 해당 주석을 제거합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  while (i &amp;lt; 10) {
    i++;
  } // while 종료
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  while (i &amp;lt; 10) {
    i++;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BlockMarkerComments&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantFieldInitialization" defaultSeverity="WARNING" displayName="중복 필드 초기화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명시적으로 디폴트 값으로 초기화되어 있는 필드를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo = 0;
    List bar = null;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo;
    List bar;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 설정을 사용하여 명시적인 &lt;code&gt;null&lt;/code&gt; 초기화만 보고합니다. 예시는 다음과 같습니다.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo = 0;     // 경고 없음
    List bar = null; // 불필요한 필드 초기화 경고
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantFieldInitialization&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReassignedVariable" defaultSeverity="TEXT ATTRIBUTES" displayName="재할당된 변수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
코드를 읽고 파악하는 데 지장이 되는 재대입된 변수를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int value = 2 * (height + width);
  System.out.println("perimeter: " + value);

  value = height * width;
  System.out.println("area: " + value);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReassignedVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarilyQualifiedInnerClassAccess" defaultSeverity="INFORMATION" displayName="불필요한 내부 클래스 액세스 정규화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
감싸는 클래스의 이름으로 불필요하게 한정되는 내부 클래스의 참조를 보고합니다.
&lt;p&gt;이 한정은 안전하게 제거할 수 있으며, 때로는 내부 클래스를 위한 import 문을 추가합니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
     X.Y foo;
     class Y{}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
     Y foo;
     class Y{}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;import 문이 필요한 참조 무시&lt;/b&gt; 옵션을 사용하여 한정을 제거하여 import 문을 추가하는 내부 클래스 참조를 무시합니다.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessarilyQualifiedInnerClassAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SingleStatementInBlock" defaultSeverity="INFORMATION" displayName="코드 블록에 단일 구문이 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
코드 블록에 하나의 구문만 포함하는 제어 흐름 구문을 보고하고 제어 흐름 구문 본문에서 중괄호를 제거할 것을 제안합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x &gt; 0) {
    System.out.println("x is positive");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x &gt; 0) System.out.println("x is positive");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SingleStatementInBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantLabeledSwitchRuleCodeBlock" defaultSeverity="WARNING" displayName="라벨 지정된 switch 규칙 내 불필요한 코드 블록" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 코드 블록이 있는 &lt;code&gt;switch&lt;/code&gt; 구문 또는 &lt;code&gt;switch&lt;/code&gt; 표현식의 라벨 지정된 규칙을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = switch (n) {
    case 1 -&gt; { yield Integer.toString(n); }
    default -&gt; "default";
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = switch (n) {
    case 1 -&gt; Integer.toString(n);
    default -&gt; "default";
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 14부터 사용할 수 있는 Java 기능 &amp;#39;향상된 &amp;#39;switch&amp;#39; 블록&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantLabeledSwitchRuleCodeBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CStyleArrayDeclaration" defaultSeverity="WARNING" displayName="C 스타일 배열 선언" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열 대괄호가 변수 이름 뒤에 또는 메서드 매개변수 목록 뒤에 오는 C 스타일 구문으로 작성된 배열 선언을 보고합니다.
대부분의 코드 스타일은 배열 대괄호가 타입 이름 뒤에 있는 Java 스타일 배열 선언을 선호합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public&lt;/b&gt; String process(String value[])[] {
    return value;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public&lt;/b&gt; String[] process(String[] value) {
    return value;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;
메서드 반환 타입의 C 스타일 배열 선언만 보고하려면 &lt;b&gt;변수의 C 스타일 선언 무시&lt;/b&gt; 옵션을 사용하세요.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CStyleArrayDeclaration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JoinDeclarationAndAssignmentJava" defaultSeverity="INFORMATION" displayName="대입을 선언과 결합할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
변수 선언과 결합될 수 있는 변수 대입을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x;
  x = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정은 이 대입을 이니셜라이저로 변환합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JoinDeclarationAndAssignmentJava&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissortedModifiers" defaultSeverity="INFORMATION" displayName="잘못 정렬된 제어자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
표준 선호 순서(Java 언어 사양에 명시된 대로)로 되어 있지 않은 선언 제어자를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    native public final void foo();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public final native void foo();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MissortedModifiers&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 언어 수준 문제" path="Java"><inspection shortName="ForwardCompatibility" defaultSeverity="WARNING" displayName="전방 호환성" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이후 Java 버전에서 컴파일이 불가할 수 있는 Java 코드 구문을 보고합니다.
&lt;p&gt;다음과 같은 문제가 보고됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;식별자로 &lt;code&gt;assert&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt; 또는 &lt;code&gt;_&lt;/code&gt;이 사용된 경우&lt;/li&gt;
  &lt;li&gt;타입 이름으로 &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;yield&lt;/code&gt; 또는 &lt;code&gt;record&lt;/code&gt;가 제한된 식별자가 사용된 경우&lt;/li&gt;
  &lt;li&gt;정규화되지 않은 &lt;code&gt;yield&lt;/code&gt; 메서드 호출&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;module-info.java&lt;/code&gt; 내부의 &lt;code&gt;requires java.base&lt;/code&gt; 문에 있는 제어자&lt;/li&gt;
  &lt;li&gt;import 문 내의 불필요한 세미콜론&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 이 클래스는 이전에는 유효했지만 'yield' 식별자가 금지되면서,
  // Java 14로 컴파일되지 않습니다.
  public class yield {} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;해당 이슈를 제때 수정하면 향후 Java 버전으로의 마이그레이션이 간소화될 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ForwardCompatibility&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnnotationClass" defaultSeverity="WARNING" displayName="어노테이션 인터페이스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
어노테이션 인터페이스를 보고합니다.
그러한 인터페이스는 Java 1.4 이전 버전에서 지원되지 않습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: AnnotationClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertStatement" defaultSeverity="WARNING" displayName="'assert' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;assert&lt;/code&gt; 문을 보고합니다. 디폴트로 &lt;code&gt;assert&lt;/code&gt; 문은 프로덕션 환경에서 실행 도중 비활성화됩니다. 대신 로거 또는 예외를 사용해 보세요.
&lt;p&gt;&lt;code&gt;assert&lt;/code&gt; 문은 Java 1.3 이전 JVM에서 지원되지 않습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;이 검사는 Java 1.4부터 사용할 수 있는 Java 기능 &amp;#39;어설션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AssertStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VarargParameter" defaultSeverity="INFORMATION" displayName="vararg 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
임의의 매개변수 개수를 허용하는 메서드(vararg 메서드라고도 함)을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum EnumConstants {
  A(null), B, C;

  EnumConstants(String... ss) {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;가변 인수 매개변수를 동등한 배열 매개변수로 대체하는 빠른 수정을 사용할 수 있습니다. 메서드 호출의 관련 인수는 배열 이니셜라이저 표현식으로 래핑됩니다.
  빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum EnumConstants {
  A(null), B(new String[]{}), C(new String[]{});

  EnumConstants(String[] ss) {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;Varargs 메서드&lt;/i&gt;는 Java 5에 등장했습니다.
  이 검사는 이전 Java 버전과의 하위 호환성을 위해 다운그레이드하는 데 도움이 될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: VarargParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Annotation" defaultSeverity="WARNING" displayName="어노테이션" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
어노테이션을 보고합니다.
어노테이션은 Java 1.4 이전 JVM에서 지원되지 않습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: Annotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForeachStatement" defaultSeverity="WARNING" displayName="향상된 'for' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
향상된 &lt;code&gt;for&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int x: Arrays.asList(1, 2, 3)) {
    System.out.println(x);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Iterator&amp;lt;Integer&amp;gt; iterator = Arrays.asList(1, 2, 3).iterator(); iterator.hasNext(); ) {
    final int x = iterator.next();
    System.out.println(x);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;향상된&lt;/i&gt; &lt;code&gt;for&lt;/code&gt; &lt;i&gt;문&lt;/i&gt;은 Java 5에 등장했습니다.
  이 검사는 이전 Java 버전과의 하위 호환성을 위해 다운그레이드하는 데 도움이 될 수 있습니다.
&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ForeachStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnumClass" defaultSeverity="WARNING" displayName="열거형 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;b&gt;enum&lt;/b&gt; 클래스를 보고합니다.
그러한 구문은 Java 1.4 및 이전 JVM에서 지원되지 않습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: EnumClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Accessibility" path=""><inspection shortName="AndroidLintLabelFor" defaultSeverity="WARNING" displayName="Missing accessibility label" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing accessibility label&lt;br&gt;&lt;br&gt;Editable text fields should provide an &lt;code&gt;android:hint&lt;/code&gt; or, provided your &lt;code&gt;minSdkVersion&lt;/code&gt; is at least 17, they may be referenced by a view with a &lt;code&gt;android:labelFor&lt;/code&gt; attribute.&lt;br/&gt;
&lt;br/&gt;
When using &lt;code&gt;android:labelFor&lt;/code&gt;, be sure to provide an &lt;code&gt;android:text&lt;/code&gt; or an &lt;code&gt;android:contentDescription&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If your view is labeled but by a label in a different layout which includes this one, just suppress this warning from lint.&lt;br&gt;&lt;br&gt;Issue id: LabelFor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintKeyboardInaccessibleWidget" defaultSeverity="WARNING" displayName="Keyboard inaccessible widget" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Keyboard inaccessible widget&lt;br&gt;&lt;br&gt;A widget that is declared to be clickable but not declared to be focusable is not accessible via the keyboard. Please add the &lt;code&gt;focusable&lt;/code&gt; attribute as well.&lt;br&gt;&lt;br&gt;Issue id: KeyboardInaccessibleWidget&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintClickableViewAccessibility" defaultSeverity="WARNING" displayName="Accessibility in Custom Views" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Accessibility in Custom Views&lt;br&gt;&lt;br&gt;If a &lt;code&gt;View&lt;/code&gt; that overrides &lt;code&gt;onTouchEvent&lt;/code&gt; or uses an &lt;code&gt;OnTouchListener&lt;/code&gt; does not also implement &lt;code&gt;performClick&lt;/code&gt; and call it when clicks are detected, the &lt;code&gt;View&lt;/code&gt; may not handle accessibility actions properly. Logic handling the click actions should ideally be placed in &lt;code&gt;View#performClick&lt;/code&gt; as some accessibility services invoke &lt;code&gt;performClick&lt;/code&gt; when a click action should occur.&lt;br&gt;&lt;br&gt;Issue id: ClickableViewAccessibility&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGetContentDescriptionOverride" defaultSeverity="ERROR" displayName="Overriding getContentDescription() on a View" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Overriding &lt;code&gt;getContentDescription()&lt;/code&gt; on a View&lt;br&gt;&lt;br&gt;Overriding &lt;code&gt;getContentDescription()&lt;/code&gt; may prevent some accessibility services from properly navigating content exposed by your view. Instead, call &lt;code&gt;setContentDescription()&lt;/code&gt; when the content description needs to be changed.&lt;br&gt;&lt;br&gt;Issue id: GetContentDescriptionOverride&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAccessibilityFocus" defaultSeverity="WARNING" displayName="Forcing accessibility focus" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Forcing accessibility focus&lt;br&gt;&lt;br&gt;Forcing accessibility focus interferes with screen readers and gives an inconsistent user experience, especially across apps.&lt;br&gt;&lt;br&gt;Issue id: AccessibilityFocus&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintContentDescription" defaultSeverity="WARNING" displayName="Image without contentDescription" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Image without &lt;code&gt;contentDescription&lt;/code&gt;&lt;br&gt;&lt;br&gt;Non-textual widgets like ImageViews and ImageButtons should use the &lt;code&gt;contentDescription&lt;/code&gt; attribute to specify a textual description of the widget such that screen readers and other accessibility tools can adequately describe the user interface.&lt;br/&gt;
&lt;br/&gt;
Note that elements in application screens that are purely decorative and do not provide any content or enable a user action should not have accessibility content descriptions. In this case, set their descriptions to &lt;code&gt;@null&lt;/code&gt;. If your app's minSdkVersion is 16 or higher, you can instead set these graphical elements' &lt;code&gt;android:importantForAccessibility&lt;/code&gt; attributes to &lt;code&gt;no&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Note that for text fields, you should not set both the &lt;code&gt;hint&lt;/code&gt; and the &lt;code&gt;contentDescription&lt;/code&gt; attributes since the hint will never be shown. Just set the &lt;code&gt;hint&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: ContentDescription&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/accessibility/apps#special-cases"&gt;https://developer.android.com/guide/topics/ui/accessibility/apps#special-cases&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAccessibilityScrollActions" defaultSeverity="WARNING" displayName="Incomplete Scroll Action support" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incomplete Scroll Action support&lt;br&gt;&lt;br&gt;Views that behave like &lt;code&gt;ScrollView&lt;/code&gt; and support &lt;code&gt;ACTION_SCROLL_{FORWARD,BACKWARD}&lt;/code&gt; should also support &lt;code&gt;ACTION_SCROLL_{LEFT,RIGHT}&lt;/code&gt; and/or &lt;code&gt;ACTION_SCROLL_{UP,DOWN}&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AccessibilityScrollActions&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAccessibilityWindowStateChangedEvent" defaultSeverity="WARNING" displayName="Use of accessibility window state change events" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use of accessibility window state change events&lt;br&gt;&lt;br&gt;Sending or populating &lt;code&gt;TYPE_WINDOW_STATE_CHANGED&lt;/code&gt; events in your code is strongly discouraged. Instead, prefer to use or extend system-provided widgets that are as far down Android's class hierarchy as possible. System-provided widgets that are far down the hierarchy already have most of the accessibility capabilities your app needs. If you must extend &lt;code&gt;View&lt;/code&gt; or &lt;code&gt;Canvas&lt;/code&gt; directly, then still prefer to: set UI metadata by calling &lt;code&gt;Activity.setTitle&lt;/code&gt;, &lt;code&gt;ViewCompat.setAccessibilityPaneTitle&lt;/code&gt;, or &lt;code&gt;ViewCompat.setAccessibilityLiveRegion&lt;/code&gt;; implement &lt;code&gt;View.onInitializeAccessibilityNodeInfo&lt;/code&gt;; and (for very specialized custom controls) implement &lt;code&gt;View.getAccessibilityNodeProvider&lt;/code&gt; to provide a virtual view hierarchy. These approaches allow accessibility services to inspect the view hierarchy, rather than relying on incomplete information provided by events. Events like &lt;code&gt;TYPE_WINDOW_STATE_CHANGED&lt;/code&gt; will be sent automatically when updating this metadata, and so trying to manually send this event will result in duplicate events, or the event may be ignored entirely.&lt;br&gt;&lt;br&gt;Issue id: AccessibilityWindowStateChangedEvent&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Android Lint: Internationalization" path=""><inspection shortName="AndroidLintRtlCompat" defaultSeverity="ERROR" displayName="Right-to-left text compatibility issues" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Right-to-left text compatibility issues&lt;br&gt;&lt;br&gt;API 17 adds a &lt;code&gt;textAlignment&lt;/code&gt; attribute to specify text alignment. However, if you are supporting older versions than API 17, you must &lt;b&gt;also&lt;/b&gt; specify a gravity or layout_gravity attribute, since older platforms will ignore the &lt;code&gt;textAlignment&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: RtlCompat&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSetTextI18n" defaultSeverity="WARNING" displayName="TextView Internationalization" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TextView Internationalization&lt;br&gt;&lt;br&gt;When calling &lt;code&gt;TextView#setText&lt;/code&gt;&lt;br/&gt;
* Never call &lt;code&gt;Number#toString()&lt;/code&gt; to format numbers; it will not handle fraction separators and locale-specific digits properly. Consider using &lt;code&gt;String#format&lt;/code&gt; with proper format specifications (&lt;code&gt;%d&lt;/code&gt; or &lt;code&gt;%f&lt;/code&gt;) instead.&lt;br/&gt;
* Do not pass a string literal (e.g. "Hello") to display text. Hardcoded text can not be properly translated to other languages. Consider using Android resource strings instead.&lt;br/&gt;
* Do not build messages by concatenating text chunks. Such messages can not be properly translated.&lt;br&gt;&lt;br&gt;Issue id: SetTextI18n&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/localization.html"&gt;https://developer.android.com/guide/topics/resources/localization.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRelativeOverlap" defaultSeverity="WARNING" displayName="Overlapping items in RelativeLayout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Overlapping items in RelativeLayout&lt;br&gt;&lt;br&gt;If relative layout has text or button items aligned to left and right sides they can overlap each other due to localized text expansion unless they have mutual constraints like &lt;code&gt;toEndOf&lt;/code&gt;/&lt;code&gt;toStartOf&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: RelativeOverlap&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintByteOrderMark" defaultSeverity="ERROR" displayName="Byte order mark inside files" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Byte order mark inside files&lt;br&gt;&lt;br&gt;Lint will flag any byte-order-mark (BOM) characters it finds in the middle of a file. Since we expect files to be encoded with UTF-8 (see the EnforceUTF8 issue), the BOM characters are not necessary, and they are not handled correctly by all tools. For example, if you have a BOM as part of a resource name in one particular translation, that name will not be considered identical to the base resource's name and the translation will not be used.&lt;br&gt;&lt;br&gt;Issue id: ByteOrderMark&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Byte_order_mark"&gt;https://en.wikipedia.org/wiki/Byte_order_mark&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRtlEnabled" defaultSeverity="WARNING" displayName="Using RTL attributes without enabling RTL support" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using RTL attributes without enabling RTL support&lt;br&gt;&lt;br&gt;To enable right-to-left support, when running on API 17 and higher, you must set the &lt;code&gt;android:supportsRtl&lt;/code&gt; attribute in the manifest &lt;code&gt;&amp;lt;application&gt;&lt;/code&gt; element.&lt;br/&gt;
&lt;br/&gt;
If you have started adding RTL attributes, but have not yet finished the migration, you can set the attribute to false to satisfy this lint check.&lt;br&gt;&lt;br&gt;Issue id: RtlEnabled&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHardcodedText" defaultSeverity="WARNING" displayName="Hardcoded text" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardcoded text&lt;br&gt;&lt;br&gt;Hardcoding text attributes directly in layout files is bad for several reasons:&lt;br/&gt;
&lt;br/&gt;
* When creating configuration variations (for example for landscape or portrait) you have to repeat the actual text (and keep it up to date when making changes)&lt;br/&gt;
&lt;br/&gt;
* The application cannot be translated to other languages by just adding new translations for existing string resources.&lt;br/&gt;
&lt;br/&gt;
There are quickfixes to automatically extract this hardcoded string into a resource lookup.&lt;br&gt;&lt;br&gt;Issue id: HardcodedText&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRtlHardcoded" defaultSeverity="WARNING" displayName="Using left/right instead of start/end attributes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using left/right instead of start/end attributes&lt;br&gt;&lt;br&gt;Using &lt;code&gt;Gravity#LEFT&lt;/code&gt; and &lt;code&gt;Gravity#RIGHT&lt;/code&gt; can lead to problems when a layout is rendered in locales where text flows from right to left. Use &lt;code&gt;Gravity#START&lt;/code&gt; and &lt;code&gt;Gravity#END&lt;/code&gt; instead. Similarly, in XML &lt;code&gt;gravity&lt;/code&gt; and &lt;code&gt;layout_gravity&lt;/code&gt; attributes, use &lt;code&gt;start&lt;/code&gt; rather than &lt;code&gt;left&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
For XML attributes such as paddingLeft and &lt;code&gt;layout_marginLeft&lt;/code&gt;, use &lt;code&gt;paddingStart&lt;/code&gt; and &lt;code&gt;layout_marginStart&lt;/code&gt;. &lt;b&gt;NOTE&lt;/b&gt;: If your &lt;code&gt;minSdkVersion&lt;/code&gt; is less than 17, you should add &lt;b&gt;both&lt;/b&gt; the older left/right attributes &lt;b&gt;as well as&lt;/b&gt; the new start/end attributes. On older platforms, where RTL is not supported and the start/end attributes are unknown and therefore ignored, you need the older left/right attributes. There is a separate lint check which catches that type of error.&lt;br/&gt;
&lt;br/&gt;
(Note: For &lt;code&gt;Gravity#LEFT&lt;/code&gt; and &lt;code&gt;Gravity#START&lt;/code&gt;, you can use these constants even when targeting older platforms, because the &lt;code&gt;start&lt;/code&gt; bitmask is a superset of the &lt;code&gt;left&lt;/code&gt; bitmask. Therefore, you can use &lt;code&gt;gravity="start"&lt;/code&gt; rather than &lt;code&gt;gravity="left|start"&lt;/code&gt;.)&lt;br&gt;&lt;br&gt;Issue id: RtlHardcoded&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRtlSymmetry" defaultSeverity="WARNING" displayName="Padding and margin symmetry" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Padding and margin symmetry&lt;br&gt;&lt;br&gt;If you specify padding or margin on the left side of a layout, you should probably also specify padding on the right side (and vice versa) for right-to-left layout symmetry.&lt;br&gt;&lt;br&gt;Issue id: RtlSymmetry&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintConstantLocale" defaultSeverity="WARNING" displayName="Constant Locale" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Constant Locale&lt;br&gt;&lt;br&gt;Assigning &lt;code&gt;Locale.getDefault()&lt;/code&gt; to a constant is suspicious, because the locale can change while the app is running.&lt;br&gt;&lt;br&gt;Issue id: ConstantLocale&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEnforceUTF8" defaultSeverity="ERROR" displayName="Encoding used in resource files is not UTF-8" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Encoding used in resource files is not UTF-8&lt;br&gt;&lt;br&gt;XML supports encoding in a wide variety of character sets. However, not all tools handle the XML encoding attribute correctly, and nearly all Android apps use UTF-8, so by using UTF-8 you can protect yourself against subtle bugs when using non-ASCII characters.&lt;br/&gt;
&lt;br/&gt;
In particular, the Android Gradle build system will merge resource XML files assuming the resource files are using UTF-8 encoding.&lt;br&gt;&lt;br&gt;Issue id: EnforceUTF8&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWeekBasedYear" defaultSeverity="WARNING" displayName="Week Based Year" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Week Based Year&lt;br&gt;&lt;br&gt;The &lt;code&gt;DateTimeFormatter&lt;/code&gt; pattern &lt;code&gt;YYYY&lt;/code&gt; returns the &lt;i&gt;week&lt;/i&gt; based year, not the era-based year. This means that 12/29/2019 will format to 2019, but 12/30/2019 will format to 2020!&lt;br/&gt;
&lt;br/&gt;
If you expected this to format as 2019, you should use the pattern &lt;code&gt;yyyy&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: WeekBasedYear&lt;br&gt;&lt;br&gt;&lt;a href="https://stackoverflow.com/questions/46847245/using-datetimeformatter-on-january-first-cause-an-invalid-year-value"&gt;https://stackoverflow.com/questions/46847245/using-datetimeformatter-on-january-first-cause-an-invalid-year-value&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Java 23" path="Java/Java 언어 수준 마이그레이션 지원"><inspection shortName="MarkdownDocumentationCommentsMigration" defaultSeverity="INFORMATION" displayName="Javadoc 주석은 Markdown 문서 주석이 될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Markdown 문서 주석으로 변환될 수 있는 Javadoc 주석을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * For blubbering of the florz.
   *
   * Similar to {@link com.deeps.Querp querping} class.
   */
  class FlorzBlubber {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /// For blubbering of the florz.
  /// Similar to [querping][com.deeps.Querp] class.
  class FlorzBlubber {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2024.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: MarkdownDocumentationCommentsMigration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Gradle 선언" path=""><inspection shortName="DeclarativeUnresolvedReference" defaultSeverity="WARNING" displayName="해결되지 않은 참조" enabled="false" language="Declarative" pluginId="com.android.tools.gradle.dcl" pluginVersion="252.23892.409" isGlobalTool="false"></inspection></group><group name="XML" path=""><inspection shortName="CheckTagEmptyBody" defaultSeverity="WARNING" displayName="빈 요소 내용" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 비어 있는 XML 요소를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;user&gt;
    &amp;lt;name&gt;&amp;lt;/name&gt;
  &amp;lt;/user&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;user&gt;
    &amp;lt;name/&gt;
  &amp;lt;/user&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CheckTagEmptyBody&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlDuplicatedId" defaultSeverity="ERROR" displayName="중복 'id' 속성" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
XML과 HTML에서 &lt;code&gt;id&lt;/code&gt; 속성의 중복되는 값을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XmlDuplicatedId&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlWrongRootElement" defaultSeverity="ERROR" displayName="잘못된 루트 요소" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;&amp;lt;doctype&amp;gt;&lt;/code&gt; 태그에 지정된 이름과 다른 루트 태그 이름을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XmlWrongRootElement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlUnboundNsPrefix" defaultSeverity="WARNING" displayName="바운드되지 않은 네임스페이스 접두사" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
XML 내 바운드되지 않은 네임스페이스 접두사를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XmlUnboundNsPrefix&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckXmlFileWithXercesValidator" defaultSeverity="ERROR" displayName="외부 유효성 검사 실패" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지정된 DTD 또는 Xerces 유효성 검사기에 의해 탐지된 스키마를 포함하는 XML 파일 내 차이를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CheckXmlFileWithXercesValidator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlInvalidId" defaultSeverity="ERROR" displayName="해결되지 않은 ‘id' 참조" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
XML과 HTML의 어디에도 정의되지 않은 &lt;code&gt;id&lt;/code&gt;의 사용 위치를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XmlInvalidId&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlDefaultAttributeValue" defaultSeverity="WARNING" displayName="디폴트 값이 있는 불필요한 속성" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
XML 속성으로의 불필요한 디폴트 값 대입을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XmlDefaultAttributeValue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlUnusedNamespaceDeclaration" defaultSeverity="WARNING" displayName="사용되지 않는 스키마 선언" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
XML 내 사용되지 않는 네임스페이스 선언 또는 위치 힌트를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XmlUnusedNamespaceDeclaration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlDeprecatedElement" defaultSeverity="WARNING" displayName="지원 중단되는 심볼" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
곧 사용할 수 없게 될 XML 요소 또는 속성을 보고합니다.
&lt;p&gt;심볼은 텍스트 'deprecated'를 포함하는 XML 주석 또는 문서 태그로 표시할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XmlDeprecatedElement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlHighlighting" defaultSeverity="ERROR" displayName="XML 강조 표시" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
배치 코드 검사 결과 내 XML 유효성 검사 문제를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XmlHighlighting&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckDtdRefs" defaultSeverity="ERROR" displayName="해결되지 않은 DTD 참조" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
DTD 전용 참조 내 불일치를 보고합니다(예: XML 엔티티 참조 또는 DTD 요소 선언 참조).
DTD 및 XML 파일에서 작동합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CheckDtdRefs&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlUnresolvedReference" defaultSeverity="ERROR" displayName="확인되지 않은 참조" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
XML 내 해결되지 않은 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XmlUnresolvedReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlPathReference" defaultSeverity="ERROR" displayName="해결되지 않은 파일 참조" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
XML 내 해결되지 않은 파일 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XmlPathReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeprecatedClassUsageInspection" defaultSeverity="WARNING" displayName="XML에서 곧 사용할 수 없게 될 API 사용" enabled="false" language="XML" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
XML 파일에서 사용이 중단된 클래스 및 메서드의 사용 위치를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DeprecatedClassUsageInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 11" path="Java/Java 언어 수준 마이그레이션 지원"><inspection shortName="StringRepeatCanBeUsed" defaultSeverity="WARNING" displayName="String.repeat()을 사용할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;String.repeat()&lt;/code&gt; 메서드(Java 11부터 이용 가능) 하나로 대체 가능한 루프를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void append(StringBuilder sb, int count, Object obj) {
    for (int i = 0; i &amp;lt; count; i++) {
      sb.append(obj);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void append(StringBuilder sb, int count, Object obj) {
    sb.append(String.valueOf(obj).repeat(Math.max(0, count)));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  기본적으로 이 검사는 &lt;code&gt;count&lt;/code&gt;가 음수임을 정적으로 증명할 수 없을 경우 &lt;code&gt;count&lt;/code&gt;를 &lt;code&gt;Math.max(0, count)&lt;/code&gt;로 래핑합니다. 이는 &lt;code&gt;String.repeat()&lt;/code&gt;가 음수를 거부하여 발생하는 잠재적 의미 변경을 방지하기 위해 수행됩니다.
  필요한 경우 이 동작을 비활성화하려면 &lt;b&gt;가능한 의미 변경을 방지하기 위해 Math.max(0, count)를 추가&lt;/b&gt; 옵션을 사용합니다.&lt;/p&gt;
  &lt;p&gt;마찬가지로, 반복하려는 문자열이 &lt;code&gt;null&lt;/code&gt;일지 여부를 알 수 없는 경우, 잠재적 &lt;code&gt;NullPointerException&lt;/code&gt;를 방지하기 위해 해당 문자열을 &lt;code&gt;String.valueOf&lt;/code&gt;로 래핑할 수도 있습니다.
&lt;/p&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 11 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2019.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringRepeatCanBeUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReadWriteStringCanBeUsed" defaultSeverity="WARNING" displayName="'Files.readString()' 또는 'Files.writeString()'을 사용할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.nio.file.Files&lt;/code&gt;를 사용하여 &lt;code&gt;String&lt;/code&gt;을 바이트로 읽거나 쓰는 메서드 호출을 보고합니다.
이러한 호출은 Java 11에 도입된 &lt;code&gt;Files.readString()&lt;/code&gt; 및 &lt;code&gt;Files.writeString()&lt;/code&gt; 메서드 호출로 대체할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "example";
  Files.write(Paths.get("out.txt"), s.getBytes(StandardCharsets.UTF_8), StandardOpenOption.WRITE);
  s = new String(Files.readAllBytes(Paths.get("in.txt")), StandardCharsets.ISO_8859_1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "example";
  Files.writeString(Paths.get("out.txt"), s, StandardOpenOption.WRITE);
  s = Files.readString(Paths.get("in.txt"), StandardCharsets.ISO_8859_1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  유효하지 않은(매핑이 불가능한) 문자를 처리할 때 &lt;code&gt;readString()&lt;/code&gt;의 동작은 new String(bytes, charset)&lt;/code&gt;의 동작과는 다르다는 점에 유의하세요. &lt;code&gt;readString()&lt;/code&gt; 메서드는 이러한 경우 예외를 던지며, &lt;code&gt;new String(bytes, charset)&lt;/code&gt;는 유효하지 않은 문자를 대체 문자로 조용히 바꿉니다. 
  조용히 바꾸는 것이 바람직하다면 검사 경고를 억제하는 것이 좋습니다. 
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReadWriteStringCanBeUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="임베디드" path="Java/성능"><inspection shortName="RecordStoreResource" defaultSeverity="WARNING" displayName="'RecordStore'가 열렸으나 안전하게 닫히지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;try&lt;/code&gt; 블록 전에 열거나 대응하는 &lt;code&gt;finally&lt;/code&gt; 블록에서 닫지 않은 Java ME &lt;code&gt;javax.microedition.rms.RecordStore&lt;/code&gt; 리소스를 보고합니다.
&lt;p&gt;리소스를 닫기 전에 예외가 발생할 경우 의도치 않게 리소스의 누수가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;
  이 검사는 Java ME 및 리소스가 많이 제한된 기타 환경을 위한 것입니다.
  이 검사 결과를 검토 없이 적용하면 코드 명확성과 설계에 부정적인 영향을 미칠 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo1() throws RecordStoreException {
      RecordStore rs = RecordStore.openRecordStore("bar", true); // 경고
  }
  void foo2() throws RecordStoreException {
      RecordStore rs = RecordStore.openRecordStore("bar", true); // 경고 없음
      try {
          /* ... */
      } finally {
          rs.closeRecordStore();
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RecordStoreResource&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultiplyOrDivideByPowerOfTwo" defaultSeverity="WARNING" displayName="2의 거듭제곱으로 곱하기 또는 나누기" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
2의 거듭제곱으로 표현할 수 있는 상수 정수와 정수 값의 곱을 보고합니다. 이러한 표현식은 성능을 향상시키기 위해 오른쪽 또는 왼쪽 시프트 연산으로 대체할 수 있습니다.
&lt;p&gt;
  최신 JVM(예: HotSpot 또는 OpenJ9)에서는 JIT 컴파일러가 이러한 최적화를 수행하기 때문에 이 검사가 적절하지 않습니다.
  이 검사는 JIT 컴파일이 수행되지 않는 일부 임베디드 시스템에서만 유용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = x * 4;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;시프트 연산에 의한 곱셈이나 나눗셈을 대체하는 빠른 수정을 사용하는 것이 좋습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = x &amp;lt;&amp;lt; 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 옵션을 사용하여 해당 검사가 2의 거듭제곱으로 나누기도 보고하도록 합니다.
  2의 거듭제곱 나누기를 시프트로 바꾸기는 음수에 적용되지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MultiplyOrDivideByPowerOfTwo&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractClassWithOnlyOneDirectInheritor" defaultSeverity="WARNING" displayName="직접 상속자가 하나인 추상 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
직접 상속자가 하나만 있는 추상 클래스를 보고합니다. 이러한 클래스는 메모리가 제한적이거나 대역폭이 제한된 환경에서 훌륭한 설계 명확도를 제공할 수 있지만, 애플리케이션의 총 점유 공간을 불필요하게 증가시킵니다. 추상 클래스를 해당 상속자와 병합해보세요.
&lt;p&gt;
  이 검사는 Java ME 및 리소스가 많이 제한된 기타 환경을 위한 것입니다.
  이 검사 결과를 검토 없이 적용하면 코드 명확성과 설계에 부정적인 영향을 미칠 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Base {} // 보고됩니다

  class Inheritor extends Base {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AbstractClassWithOnlyOneDirectInheritor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayLengthInLoopCondition" defaultSeverity="WARNING" displayName="루프 조건의 Array.length" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루프 구문의 조건 부분에서 배열의 &lt;code&gt;.length&lt;/code&gt; 프로퍼티에 대한 액세스를 보고합니다. 리소스가 많이 제한된 환경에서 이러한 호출은 성능에 부정적인 영향을 미칠 수 있습니다.
&lt;p&gt;
  이 검사는 Java ME 및 리소스가 많이 제한된 기타 환경을 위한 것입니다.
  이 검사 결과를 검토 없이 적용하면 코드 명확성과 설계에 부정적인 영향을 미칠 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object[] x) {
    for (int i = 0; i &amp;lt; x.length; i++) { /**/ }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ArrayLengthInLoopCondition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SingleCharacterStartsWith" defaultSeverity="WARNING" displayName="단일 문자 'startsWith()' 또는 'endsWith()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단일 문자열 리터럴이 인수로 전달되는 &lt;code&gt;String.startsWith()&lt;/code&gt; 및 &lt;code&gt;String.endsWith()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  빠른 수정은 호출을 더 효율적으로 구현한 &lt;code&gt;String.charAt()&lt;/code&gt;으로 바꾸는 것이 좋습니다.
&lt;/p&gt;
&lt;p&gt;
  하지만 변경에 따른 성능 향상은 미미하며, 비 제로 길이 검사가 추가되어 코드 가독성이 낮아집니다. 따라서 엄격한 루프 내에서만 빠른 수정을 적용하는 것이 좋습니다.
&lt;/p&gt;
&lt;p&gt;
  이 검사는 Java ME 및 리소스가 많이 제한된 기타 환경을 위한 것입니다.
  이 검사 결과를 검토 없이 적용하면 코드 명확성과 설계에 부정적인 영향을 미칠 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean startsWithX(String s) {
    return s.startsWith("x");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean startsWithX(String s) {
    return !s.isEmpty() &amp;&amp; s.charAt(0) == 'x';
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SingleCharacterStartsWith&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodCallInLoopCondition" defaultSeverity="WARNING" displayName="루프 조건의 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루프 구문의 조건 부분에서 메서드 호출을 보고합니다. 리소스가 많이 제한된 환경에서 이러한 호출은 성능에 부정적인 영향을 미칠 수 있습니다.
&lt;p&gt;
  이 검사 결과를 검토 없이 적용하면 코드 명확성과 설계에 부정적인 영향을 미칠 수 있습니다.
  이 검사는 Java ME 및 리소스가 많이 제한된 기타 환경을 위한 것입니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "example";
  for (int i = 0; i &amp;lt; s.length(); i++) {
    System.out.println(s.charAt(i));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "example";
  int length = s.length();
  for (int i = 0; i &amp;lt; length; i++) {
    System.out.println(s.charAt(i));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;Iterator.hasNext()&lt;/code&gt; 등 일반 Java 반복 메서드 및 &lt;code&gt;Atomic*.compareAndSet&lt;/code&gt; 등 부수 효과가 있는 알려진 메서드 호출을 무시하려면 이 옵션을 사용합니다.
&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: MethodCallInLoopCondition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckForOutOfMemoryOnLargeArrayAllocation" defaultSeverity="WARNING" displayName="OutOfMemoryError 검사 없이 대규모 배열 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.OutOfMemoryError&lt;/code&gt;에 대해 확인하지 않는 대규모 배열 할당을 보고합니다. 메모리가 제한된 환경에서는 메모리 고갈이 있는지 대용량 데이터 객체 할당을 확인해야 할 수 있습니다.
&lt;p&gt;
  이 검사는 Java ME 및 리소스가 많이 제한된 기타 환경을 위한 것입니다.
  이 검사 결과를 검토 없이 적용하면 코드 명확성과 설계에 부정적인 영향을 미칠 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 옵션을 사용하여, 확인되지 않은 배열 할당에서 허용할 최대 요소 수를 지정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CheckForOutOfMemoryOnLargeArrayAllocation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InterfaceWithOnlyOneDirectInheritor" defaultSeverity="WARNING" displayName="직접 상속자가 하나인 인터페이스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
직접 상속자가 하나만 있는 인터페이스를 보고합니다.
이러한 인터페이스는 메모리가 제한적이거나 대역폭이 제한된 환경에서 훌륭한 설계 명확도를 제공할 수 있지만, 애플리케이션의 총 점유 공간을 불필요하게 증가시킵니다. 인터페이스를 해당 상속자와 병합해보세요.
&lt;p&gt;
  이 검사는 Java ME 및 리소스가 많이 제한된 기타 환경을 위한 것입니다.
  이 검사 결과를 검토 없이 적용하면 코드 명확성과 설계에 부정적인 영향을 미칠 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InterfaceWithOnlyOneDirectInheritor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConnectionResource" defaultSeverity="WARNING" displayName="연결이 열렸으나 안전하게 닫히지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;try&lt;/code&gt; 블록 전에 열지 않고 해당하는 &lt;code&gt;finally&lt;/code&gt; 블록에서 닫지 않은 Java ME &lt;code&gt;javax.microedition.io.Connection&lt;/code&gt; 리소스를 보고합니다. 리소스를 닫기 전에 예외가 발생할 경우 의도치 않게 리소스의 누수가 발생할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void example() throws IOException {
    Connection c = Connector.open("foo");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConnectionResource&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PrivateMemberAccessBetweenOuterAndInnerClass" defaultSeverity="WARNING" displayName="통합 접근자 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
중첩 클래스에서 외부 클래스의 비상수 &lt;code&gt;private&lt;/code&gt; 구성원으로의 참조를 보고합니다.
이러한 참조의 경우, javac은 package-private 합성 접근자 메서드를 생성하며, 이때 private으로 보이는 멤버가 실제로는 전체 패키지에서 액세스할 수 있기 때문에 보안이 손상될 수 있습니다.
&lt;p&gt;
  중첩 클래스와 외부 클래스는 별도의 클래스 파일로 컴파일됩니다. Java 가상머신은 일반적으로 한 클래스로부터 다른 클래스의 private 필드 및 메서드로의 액세스를 금지합니다. 중첩 클래스로부터 외부 클래스 private 멤버로의 액세스를 활성화하기 위해 javac은 package-private 합성 접근자 메서드를 생성합니다.
&lt;/p&gt;
&lt;p&gt;
  대신에 &lt;code&gt;private&lt;/code&gt; 멤버를 package-private으로 만들어 실제 접근성을 명확하게 합니다.
  이렇게 하면 약간의 메모리를 보존하여 리소스가 제한된 환경의 성능도 향상할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  이 검사는 프로젝트 또는 모듈의 언어 수준이 10 이하인 경우에만 보고합니다.
  Java 11 이상에서 접근자 메서드는 중첩 기반의 접근 제어로 인해 더는 생성되지 않습니다(&lt;a href="https://openjdk.org/jeps/181"&gt;JEP 181&lt;/a&gt;).
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
    private void x() {}

    class Inner {
      void y() {
        x();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
    void x() {}

    class Inner {
      void y() {
        x();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PrivateMemberAccessBetweenOuterAndInnerClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OverlyLargePrimitiveArrayInitializer" defaultSeverity="WARNING" displayName="기본 타입 배열에 지나치게 큰 이니셜라이저" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
요소가 너무 많은 원시 배열에 대한 배열 이니셜라이저 표현식을 보고합니다. 이니셜라이저는 각 배열 요소를 초기화하기 위해 코드를 생성해야 하기 때문에 클래스 파일의 용량이 지나치게 커질 수 있습니다. 메모리 또는 대역폭이 제한된 환경에서는 리소스 파일의 대규모 기본 배열을 로드하는 것이 더 효과적일 수 있습니다.
&lt;p&gt;
  이 검사는 Java ME 및 리소스가 많이 제한된 기타 환경을 위한 것입니다.
  이 검사 결과를 검토 없이 적용하면 코드 명확성과 설계에 부정적인 영향을 미칠 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  옵션을 사용하여 기본 배열 이니셜라이저에서 허용할 최대 요소 수를 지정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: OverlyLargePrimitiveArrayInitializer&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="OpenRewrite" path=""><inspection shortName="OpenRewriteYamlRecipe" defaultSeverity="ERROR" displayName="잘못된 OpenRewrite YAML 레시피" enabled="false" language="yaml" pluginId="com.intellij.openRewrite" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
OpenRewrite YAML 레시피 문제를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: OpenRewriteYamlRecipe&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Usability" path=""><inspection shortName="AndroidLintTypographyOther" defaultSeverity="WARNING" displayName="Other typographical problems" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Other typographical problems&lt;br&gt;&lt;br&gt;This check looks for miscellaneous typographical problems and offers replacement                     sequences that will make the text easier to read and your application more                     polished.&lt;br&gt;&lt;br&gt;Issue id: TypographyOther&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMonochromeLauncherIcon" defaultSeverity="WARNING" displayName="Monochrome icon is not defined" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Monochrome icon is not defined&lt;br&gt;&lt;br&gt;If &lt;code&gt;android:roundIcon&lt;/code&gt; and &lt;code&gt;android:icon&lt;/code&gt; are both in your manifest, you must either remove the reference to &lt;code&gt;android:roundIcon&lt;/code&gt; if it is not needed; or, supply the monochrome icon in the drawable defined by the &lt;code&gt;android:roundIcon&lt;/code&gt; and &lt;code&gt;android:icon&lt;/code&gt; attribute.&lt;br/&gt;
&lt;br/&gt;
For example, if &lt;code&gt;android:roundIcon&lt;/code&gt; and &lt;code&gt;android:icon&lt;/code&gt; are both in the manifest, a launcher might choose to use &lt;code&gt;android:roundIcon&lt;/code&gt; over &lt;code&gt;android:icon&lt;/code&gt; to display the adaptive app icon. Therefore, your themed application iconwill not show if your monochrome attribute is not also specified in &lt;code&gt;android:roundIcon&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: MonochromeLauncherIcon&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNegativeMargin" defaultSeverity="WARNING" displayName="Negative Margins" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Negative Margins&lt;br&gt;&lt;br&gt;Margin values should be positive. Negative values are generally a sign that you are making assumptions about views surrounding the current one, or may be tempted to turn off child clipping to allow a view to escape its parent. Turning off child clipping to do this not only leads to poor graphical performance, it also results in wrong touch event handling since touch events are based strictly on a chain of parent-rect hit tests. Finally, making assumptions about the size of strings can lead to localization problems.&lt;br&gt;&lt;br&gt;Issue id: NegativeMargin&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAlwaysShowAction" defaultSeverity="WARNING" displayName="Usage of showAsAction=always" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Usage of &lt;code&gt;showAsAction=always&lt;/code&gt;&lt;br&gt;&lt;br&gt;Using &lt;code&gt;showAsAction="always"&lt;/code&gt; in menu XML, or &lt;code&gt;MenuItem.SHOW_AS_ACTION_ALWAYS&lt;/code&gt; in Java code is usually a deviation from the user interface style guide.Use &lt;code&gt;ifRoom&lt;/code&gt; or the corresponding &lt;code&gt;MenuItem.SHOW_AS_ACTION_IF_ROOM&lt;/code&gt; instead.&lt;br/&gt;
&lt;br/&gt;
If &lt;code&gt;always&lt;/code&gt; is used sparingly there are usually no problems and behavior is roughly equivalent to &lt;code&gt;ifRoom&lt;/code&gt; but with preference over other &lt;code&gt;ifRoom&lt;/code&gt; items. Using it more than twice in the same menu is a bad idea.&lt;br/&gt;
&lt;br/&gt;
This check looks for menu XML files that contain more than two &lt;code&gt;always&lt;/code&gt; actions, or some &lt;code&gt;always&lt;/code&gt; actions and no &lt;code&gt;ifRoom&lt;/code&gt; actions. In Java code, it looks for projects that contain references to &lt;code&gt;MenuItem.SHOW_AS_ACTION_ALWAYS&lt;/code&gt; and no references to &lt;code&gt;MenuItem.SHOW_AS_ACTION_IF_ROOM&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AlwaysShowAction&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearRecents" defaultSeverity="WARNING" displayName="Wear OS: Recents and app resume" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wear OS: Recents and app resume&lt;br&gt;&lt;br&gt;In recents, correctly represent your app's activities, consistent with device implementation.&lt;br&gt;&lt;br&gt;Issue id: WearRecents&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/apps/launcher"&gt;https://developer.android.com/training/wearables/apps/launcher&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyFractions" defaultSeverity="WARNING" displayName="Fraction string can be replaced with fraction character" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Fraction string can be replaced with fraction character&lt;br&gt;&lt;br&gt;You can replace certain strings, such as 1/2, and 1/4, with dedicated characters for these, such as ½ (&amp;amp;#189;) and ¼ (&amp;amp;#188;). This can help make the text more readable.&lt;br&gt;&lt;br&gt;Issue id: TypographyFractions&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Number_Forms"&gt;https://en.wikipedia.org/wiki/Number_Forms&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconDuplicates" defaultSeverity="WARNING" displayName="Duplicated icons under different names" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicated icons under different names&lt;br&gt;&lt;br&gt;If an icon is repeated under different names, you can consolidate and just use one of the icons and delete the others to make your application smaller. However, duplicated icons usually are not intentional and can sometimes point to icons that were accidentally overwritten or accidentally not updated.&lt;br&gt;&lt;br&gt;Issue id: IconDuplicates&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAutofill" defaultSeverity="WARNING" displayName="Use Autofill" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use Autofill&lt;br&gt;&lt;br&gt;Specify an &lt;code&gt;autofillHints&lt;/code&gt; attribute when targeting SDK version 26 or higher or explicitly specify that the view is not important for autofill. Your app can help an autofill service classify the data correctly by providing the meaning of each view that could be autofillable, such as views representing usernames, passwords, credit card fields, email addresses, etc.&lt;br/&gt;
&lt;br/&gt;
The hints can have any value, but it is recommended to use predefined values like 'username' for a username or 'creditCardNumber' for a credit card number. For a list of all predefined autofill hint constants, see the &lt;code&gt;AUTOFILL_HINT_&lt;/code&gt; constants in the &lt;code&gt;View&lt;/code&gt; reference at &lt;a href="https://developer.android.com/reference/android/view/View.html"&gt;https://developer.android.com/reference/android/view/View.html&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
You can mark a view unimportant for autofill by specifying an &lt;code&gt;importantForAutofill&lt;/code&gt; attribute on that view or a parent view. See &lt;a href="https://developer.android.com/reference/android/view/View.html#setImportantForAutofill(int)"&gt;https://developer.android.com/reference/android/view/View.html#setImportantForAutofill(int)&lt;/a&gt;.&lt;br&gt;&lt;br&gt;Issue id: Autofill&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/text/autofill.html"&gt;https://developer.android.com/guide/topics/text/autofill.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGifUsage" defaultSeverity="WARNING" displayName="Using .gif format for bitmaps is discouraged" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;.gif&lt;/code&gt; format for bitmaps is discouraged&lt;br&gt;&lt;br&gt;The &lt;code&gt;.gif&lt;/code&gt; file format is discouraged. Consider using &lt;code&gt;.png&lt;/code&gt; (preferred) or &lt;code&gt;.jpg&lt;/code&gt; (acceptable) instead.&lt;br&gt;&lt;br&gt;Issue id: GifUsage&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource.html#Bitmap"&gt;https://developer.android.com/guide/topics/resources/drawable-resource.html#Bitmap&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconNoDpi" defaultSeverity="WARNING" displayName="Icon appears in both -nodpi and dpi folders" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon appears in both &lt;code&gt;-nodpi&lt;/code&gt; and dpi folders&lt;br&gt;&lt;br&gt;Bitmaps that appear in &lt;code&gt;drawable-nodpi&lt;/code&gt; folders will not be scaled by the Android framework. If a drawable resource of the same name appears &lt;b&gt;both&lt;/b&gt; in a &lt;code&gt;-nodpi&lt;/code&gt; folder as well as a dpi folder such as &lt;code&gt;drawable-hdpi&lt;/code&gt;, then the behavior is ambiguous and probably not intentional. Delete one or the other, or use different names for the icons.&lt;br&gt;&lt;br&gt;Issue id: IconNoDpi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintReportShortcutUsage" defaultSeverity="WEAK WARNING" displayName="Report shortcut usage" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Report shortcut usage&lt;br&gt;&lt;br&gt;Reporting shortcut usage is important to improving the ranking of shortcuts&lt;br&gt;&lt;br&gt;Issue id: ReportShortcutUsage&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/develop/ui/views/launch/shortcuts/managing-shortcuts"&gt;https://developer.android.com/develop/ui/views/launch/shortcuts/managing-shortcuts&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearBackNavigation" defaultSeverity="WARNING" displayName="Wear: Disabling Back navigation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wear: Disabling Back navigation&lt;br&gt;&lt;br&gt;Disabling swipe-to-dismiss is generally not recommended for Wear applications because the user expects to dismiss any screen with a swipe. If your activity does not require swipe-to-dismiss to be disabled, the recommendation is to remove the &lt;code&gt;android:windowSwipeToDismiss&lt;/code&gt; attribute from your theme declaration.&lt;br&gt;&lt;br&gt;Issue id: WearBackNavigation&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/views/exit#disabling-swipe-to-dismiss"&gt;https://developer.android.com/training/wearables/views/exit#disabling-swipe-to-dismiss&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintActivityIconColor" defaultSeverity="WARNING" displayName="Ongoing activity icon is not white" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Ongoing activity icon is not white&lt;br&gt;&lt;br&gt;The resources passed to &lt;code&gt;setAnimatedIcon&lt;/code&gt; and &lt;code&gt;setStaticIcon&lt;/code&gt; should be white with a transparent background, preferably a VectorDrawable or AnimatedVectorDrawable.&lt;br&gt;&lt;br&gt;Issue id: ActivityIconColor&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/ongoing-activity#best-practices"&gt;https://developer.android.com/training/wearables/ongoing-activity#best-practices&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconXmlAndPng" defaultSeverity="WARNING" displayName="Icon is specified both as .xml file and as a bitmap" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon is specified both as &lt;code&gt;.xml&lt;/code&gt; file and as a bitmap&lt;br&gt;&lt;br&gt;If a drawable resource appears as an &lt;code&gt;.xml&lt;/code&gt; file in the &lt;code&gt;drawable/&lt;/code&gt; folder, it's usually not intentional for it to also appear as a bitmap using the same name; generally you expect the drawable XML file to define states and each state has a corresponding drawable bitmap.&lt;br&gt;&lt;br&gt;Issue id: IconXmlAndPng&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingApplicationIcon" defaultSeverity="WARNING" displayName="Missing application icon" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing application icon&lt;br&gt;&lt;br&gt;You should set an icon for the application as whole because there is no default. This attribute must be set as a reference to a drawable resource containing the image (for example &lt;code&gt;@drawable/icon&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: MissingApplicationIcon&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/studio/publish/preparing#publishing-configure"&gt;https://developer.android.com/studio/publish/preparing#publishing-configure&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintViewConstructor" defaultSeverity="WARNING" displayName="Missing View constructors for XML inflation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing View constructors for XML inflation&lt;br&gt;&lt;br&gt;Some layout tools (such as the Android layout editor) need to find a constructor with one of the following signatures:&lt;br/&gt;
* &lt;code&gt;View(Context context)&lt;/code&gt;&lt;br/&gt;
* &lt;code&gt;View(Context context, AttributeSet attrs)&lt;/code&gt;&lt;br/&gt;
* &lt;code&gt;View(Context context, AttributeSet attrs, int defStyle)&lt;/code&gt;&lt;br/&gt;
&lt;br/&gt;
If your custom view needs to perform initialization which does not apply when used in a layout editor, you can surround the given code with a check to see if &lt;code&gt;View#isInEditMode()&lt;/code&gt; is false, since that method will return &lt;code&gt;false&lt;/code&gt; at runtime but true within a user interface editor.&lt;br&gt;&lt;br&gt;Issue id: ViewConstructor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSquareAndRoundTilePreviews" defaultSeverity="WARNING" displayName="TileProvider does not have round and square previews" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TileProvider does not have round and square previews&lt;br&gt;&lt;br&gt;Tile projects should specify preview resources for different screen shapes. The preview resource is specified in the manifest under tile service. And you have to make sure they have resources for different screen shapes.&lt;br&gt;&lt;br&gt;Issue id: SquareAndRoundTilePreviews&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/design/ui/wear/guides/surfaces/tiles#tile-previews"&gt;https://developer.android.com/design/ui/wear/guides/surfaces/tiles#tile-previews&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnnecessaryRequiredFeature" defaultSeverity="WARNING" displayName="Potentially unnecessary required feature" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Potentially unnecessary required feature&lt;br&gt;&lt;br&gt;Avoid unnecessarily requiring features that may exclude your app from being served onto devices it might otherwise support.&lt;br/&gt;
&lt;br/&gt;
Consider whether your application can function adequately without restrictive feature requirements by setting these to &lt;code&gt;android:required="false"&lt;/code&gt;. By doing so, you can increase the availability of your app to a broader set of devices, including tablets, laptops and cars.&lt;br&gt;&lt;br&gt;Issue id: UnnecessaryRequiredFeature&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconExpectedSize" defaultSeverity="WARNING" displayName="Icon has incorrect size" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon has incorrect size&lt;br&gt;&lt;br&gt;There are predefined sizes (for each density) for launcher icons. You should follow these conventions to make sure your icons fit in with the overall look of the platform.&lt;br&gt;&lt;br&gt;Issue id: IconExpectedSize&lt;br&gt;&lt;br&gt;&lt;a href="https://d.android.com/r/studio-ui/designer/material/iconography"&gt;https://d.android.com/r/studio-ui/designer/material/iconography&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyDashes" defaultSeverity="WARNING" displayName="Hyphen can be replaced with dash" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hyphen can be replaced with dash&lt;br&gt;&lt;br&gt;The "n dash" (u2013, &amp;amp;#8211;) and the "m dash" (u2014, &amp;amp;#8212;) characters are used for ranges (n dash) and breaks (m dash). Using these instead of plain hyphens can make text easier to read and your application will look more polished.&lt;br&gt;&lt;br&gt;Issue id: TypographyDashes&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Dash"&gt;https://en.wikipedia.org/wiki/Dash&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearPasswordInput" defaultSeverity="ERROR" displayName="Wear: Using password input" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wear: Using password input&lt;br&gt;&lt;br&gt;Your app must not ask the user to input password directly on the Wear device.&lt;br&gt;&lt;br&gt;Issue id: WearPasswordInput&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/apps/auth-wear#auth-methods"&gt;https://developer.android.com/training/wearables/apps/auth-wear#auth-methods&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintConvertToWebp" defaultSeverity="WARNING" displayName="Convert to WebP" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Convert to WebP&lt;br&gt;&lt;br&gt;The WebP format is typically more compact than PNG and JPEG. As of Android 4.2.1 it supports transparency and lossless conversion as well. Note that there is a quickfix in the IDE which lets you perform conversion.&lt;br/&gt;
&lt;br/&gt;
Previously, launcher icons were required to be in the PNG format but that restriction is no longer there, so lint now flags these.&lt;br&gt;&lt;br&gt;Issue id: ConvertToWebp&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintButtonStyle" defaultSeverity="WARNING" displayName="Button should be borderless" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Button should be borderless&lt;br&gt;&lt;br&gt;Button bars typically use a borderless style for the buttons. Set the &lt;code&gt;style="?android:attr/buttonBarButtonStyle"&lt;/code&gt; attribute on each of the buttons, and set &lt;code&gt;style="?android:attr/buttonBarStyle"&lt;/code&gt; on the parent layout&lt;br&gt;&lt;br&gt;Issue id: ButtonStyle&lt;br&gt;&lt;br&gt;&lt;a href="https://d.android.com/r/studio-ui/designer/material/dialogs"&gt;https://d.android.com/r/studio-ui/designer/material/dialogs&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBackButton" defaultSeverity="WARNING" displayName="Back button" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Back button&lt;br&gt;&lt;br&gt;According to the Android Design Guide,&lt;br/&gt;
&lt;br/&gt;
"Other platforms use an explicit back button with label to allow the user to navigate up the application's hierarchy. Instead, Android uses the main action bar's app icon for hierarchical navigation and the navigation bar's back button for temporal navigation."&lt;br/&gt;
&lt;br/&gt;
This check is not very sophisticated (it just looks for buttons with the label "Back"), so it is disabled by default to not trigger on common scenarios like pairs of Back/Next buttons to paginate through screens.&lt;br&gt;&lt;br&gt;Issue id: BackButton&lt;br&gt;&lt;br&gt;&lt;a href="https://d.android.com/r/studio-ui/designer/material/design"&gt;https://d.android.com/r/studio-ui/designer/material/design&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSmallSp" defaultSeverity="WARNING" displayName="Text size is too small" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Text size is too small&lt;br&gt;&lt;br&gt;Avoid using sizes smaller than 11sp.&lt;br&gt;&lt;br&gt;Issue id: SmallSp&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintButtonCase" defaultSeverity="WARNING" displayName="Cancel/OK dialog button capitalization" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Cancel/OK dialog button capitalization&lt;br&gt;&lt;br&gt;The standard capitalization for OK/Cancel dialogs is "OK" and "Cancel". To ensure that your dialogs use the standard strings, you can use the resource strings @android:string/ok and @android:string/cancel.&lt;br&gt;&lt;br&gt;Issue id: ButtonCase&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconColors" defaultSeverity="WARNING" displayName="Icon colors do not follow the recommended visual style" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon colors do not follow the recommended visual style&lt;br&gt;&lt;br&gt;Notification icons and Action Bar icons should only white and shades of gray. See the Android Design Guide for more details. Note that the way Lint decides whether an icon is an action bar icon or a notification icon is based on the filename prefix: &lt;code&gt;ic_menu_&lt;/code&gt; for action bar icons, &lt;code&gt;ic_stat_&lt;/code&gt; for notification icons etc. These correspond to the naming conventions documented in &lt;a href="https://d.android.com/r/studio-ui/designer/material/iconography"&gt;https://d.android.com/r/studio-ui/designer/material/iconography&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: IconColors&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconMissingDensityFolder" defaultSeverity="WARNING" displayName="Missing density folder" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing density folder&lt;br&gt;&lt;br&gt;Icons will look best if a custom version is provided for each of the major screen density classes (low, medium, high, extra-high, extra-extra-high). This lint check identifies folders which are missing, such as &lt;code&gt;drawable-hdpi&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Low density is not really used much anymore, so this check ignores the ldpi density. To force lint to include it, set the environment variable &lt;code&gt;ANDROID_LINT_INCLUDE_LDPI=true&lt;/code&gt;. For more information on current density usage, see &lt;a href="https://developer.android.com/about/dashboards"&gt;https://developer.android.com/about/dashboards&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: IconMissingDensityFolder&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/practices/screens_support.html"&gt;https://developer.android.com/guide/practices/screens_support.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTilePreviewImageFormat" defaultSeverity="ERROR" displayName="Tile preview is not compliant with standards" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Tile preview is not compliant with standards&lt;br&gt;&lt;br&gt;Tile projects should specify preview resources with aspect ratio 1:1 and at least 384px by 384px in size.&lt;br&gt;&lt;br&gt;Issue id: TilePreviewImageFormat&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/design/ui/wear/guides/surfaces/tiles#tile-previews"&gt;https://developer.android.com/design/ui/wear/guides/surfaces/tiles#tile-previews&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMipmapIcons" defaultSeverity="WARNING" displayName="Use Mipmap Launcher Icons" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use Mipmap Launcher Icons&lt;br&gt;&lt;br&gt;Launcher icons should be provided in the &lt;code&gt;mipmap&lt;/code&gt; resource directory. This is the same as the &lt;code&gt;drawable&lt;/code&gt; resource directory, except resources in the &lt;code&gt;mipmap&lt;/code&gt; directory will not get stripped out when creating density-specific APKs.&lt;br/&gt;
&lt;br/&gt;
In certain cases, the Launcher app may use a higher resolution asset (than would normally be computed for the device) to display large app shortcuts. If drawables for densities other than the device's resolution have been stripped out, then the app shortcut could appear blurry.&lt;br/&gt;
&lt;br/&gt;
To fix this, move your launcher icons from `drawable-`dpi to `mipmap-`dpi and change references from @drawable/ and R.drawable to @mipmap/ and R.mipmap.&lt;br/&gt;
&lt;br/&gt;
In Android Studio this lint warning has a quickfix to perform this automatically.&lt;br&gt;&lt;br&gt;Issue id: MipmapIcons&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyQuotes" defaultSeverity="WARNING" displayName="Straight quotes can be replaced with curvy quotes, and apostrophes with typographic apostrophes." enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Straight quotes can be replaced with curvy quotes, and apostrophes with typographic apostrophes.&lt;br&gt;&lt;br&gt;Straight single quotes and double quotes, when used as a pair, can be replaced by "curvy quotes" (or directional quotes). Use the right single quotation mark for apostrophes. Never use generic quotes ", ' or free-standing accents `, ´ for quotation marks, apostrophes, or primes. This can make the text more readable.&lt;br&gt;&lt;br&gt;Issue id: TypographyQuotes&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Quotation_mark"&gt;https://en.wikipedia.org/wiki/Quotation_mark&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconLocation" defaultSeverity="WARNING" displayName="Image defined in density-independent drawable folder" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Image defined in density-independent drawable folder&lt;br&gt;&lt;br&gt;The res/drawable folder is intended for density-independent graphics such as shapes defined in XML. For bitmaps, move it to &lt;code&gt;drawable-mdpi&lt;/code&gt; and consider providing higher and lower resolution versions in &lt;code&gt;drawable-ldpi&lt;/code&gt;, &lt;code&gt;drawable-hdpi&lt;/code&gt; and &lt;code&gt;drawable-xhdpi&lt;/code&gt;. If the icon &lt;b&gt;really&lt;/b&gt; is density independent (for example a solid color) you can place it in &lt;code&gt;drawable-nodpi&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: IconLocation&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/practices/screens_support.html"&gt;https://developer.android.com/guide/practices/screens_support.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWebpUnsupported" defaultSeverity="ERROR" displayName="WebP Unsupported" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WebP Unsupported&lt;br&gt;&lt;br&gt;The WebP format requires Android 4.0 (API 15). Certain features, such as lossless encoding and transparency, requires Android 4.2.1 (API 18; API 17 is 4.2.0.)&lt;br&gt;&lt;br&gt;Issue id: WebpUnsupported&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconMixedNinePatch" defaultSeverity="WARNING" displayName="Clashing PNG and 9-PNG files" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Clashing PNG and 9-PNG files&lt;br&gt;&lt;br&gt;If you accidentally name two separate resources &lt;code&gt;file.png&lt;/code&gt; and &lt;code&gt;file.9.png&lt;/code&gt;, the image file and the nine patch file will both map to the same drawable resource, &lt;code&gt;@drawable/file&lt;/code&gt;, which is probably not what was intended.&lt;br&gt;&lt;br&gt;Issue id: IconMixedNinePatch&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTextFields" defaultSeverity="WARNING" displayName="Missing inputType" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;inputType&lt;/code&gt;&lt;br&gt;&lt;br&gt;Providing an &lt;code&gt;inputType&lt;/code&gt; attribute on a text field improves usability because depending on the data to be input, optimized keyboards can be shown to the user (such as just digits and parentheses for a phone number). &lt;br/&gt;
&lt;br/&gt;
The lint detector also looks at the &lt;code&gt;id&lt;/code&gt; of the view, and if the id offers a hint of the purpose of the field (for example, the &lt;code&gt;id&lt;/code&gt; contains the phrase &lt;code&gt;phone&lt;/code&gt; or &lt;code&gt;email&lt;/code&gt;), then lint will also ensure that the &lt;code&gt;inputType&lt;/code&gt; contains the corresponding type attributes.&lt;br/&gt;
&lt;br/&gt;
If you really want to keep the text field generic, you can suppress this warning by setting &lt;code&gt;inputType="text"&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: TextFields&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearSplashScreen" defaultSeverity="WARNING" displayName="Wear: Use SplashScreen library" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wear: Use &lt;code&gt;SplashScreen&lt;/code&gt; library&lt;br&gt;&lt;br&gt;If your app implements a custom splash screen or uses a launcher theme, migrate your app to the &lt;code&gt;SplashScreen&lt;/code&gt; library, available in Jetpack, to ensure it displays correctly on all Wear OS versions. Starting in Android 12, the system always applies the new Android system default splash screen on cold and warm starts for all apps. By default, this system default splash screen is constructed using your app&amp;#8217;s launcher icon element and the &lt;code&gt;windowBackground&lt;/code&gt; of your theme (if it's a single color). If you do not migrate your app, your app launch experience on Android 12 and higher will be either degraded or may have unintended results.&lt;br&gt;&lt;br&gt;Issue id: WearSplashScreen&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/apps/splash-screen"&gt;https://developer.android.com/training/wearables/apps/splash-screen&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconDuplicatesConfig" defaultSeverity="WARNING" displayName="Identical bitmaps across various configurations" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Identical bitmaps across various configurations&lt;br&gt;&lt;br&gt;If an icon is provided under different configuration parameters such as &lt;code&gt;drawable-hdpi&lt;/code&gt; or &lt;code&gt;-v11&lt;/code&gt;, they should typically be different. This detector catches cases where the same icon is provided in different configuration folder which is usually not intentional.&lt;br&gt;&lt;br&gt;Issue id: IconDuplicatesConfig&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSelectableText" defaultSeverity="WARNING" displayName="Dynamic text should probably be selectable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Dynamic text should probably be selectable&lt;br&gt;&lt;br&gt;If a &lt;code&gt;&amp;lt;TextView&gt;&lt;/code&gt; is used to display data, the user might want to copy that data and paste it elsewhere. To allow this, the &lt;code&gt;&amp;lt;TextView&gt;&lt;/code&gt; should specify &lt;code&gt;android:textIsSelectable="true"&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
This lint check looks for TextViews which are likely to be displaying data: views whose text is set dynamically.&lt;br&gt;&lt;br&gt;Issue id: SelectableText&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconDensities" defaultSeverity="WARNING" displayName="Icon densities validation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon densities validation&lt;br&gt;&lt;br&gt;Icons will look best if a custom version is provided for each of the major screen density classes (low, medium, high, extra high). This lint check identifies icons which do not have complete coverage across the densities.&lt;br/&gt;
&lt;br/&gt;
Low density is not really used much anymore, so this check ignores the ldpi density. To force lint to include it, set the environment variable &lt;code&gt;ANDROID_LINT_INCLUDE_LDPI=true&lt;/code&gt;. For more information on current density usage, see &lt;a href="https://developer.android.com/about/dashboards"&gt;https://developer.android.com/about/dashboards&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: IconDensities&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/practices/screens_support.html"&gt;https://developer.android.com/guide/practices/screens_support.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintButtonOrder" defaultSeverity="WARNING" displayName="Button order" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Button order&lt;br&gt;&lt;br&gt;According to the Android Design Guide,&lt;br/&gt;
&lt;br/&gt;
"Action buttons are typically Cancel and/or OK, with OK indicating the preferred or most likely action. However, if the options consist of specific actions such as Close or Wait rather than a confirmation or cancellation of the action described in the content, then all the buttons should be active verbs. As a rule, the dismissive action of a dialog is always on the left whereas the affirmative actions are on the right."&lt;br/&gt;
&lt;br/&gt;
This check looks for button bars and buttons which look like cancel buttons, and makes sure that these are on the left.&lt;br&gt;&lt;br&gt;Issue id: ButtonOrder&lt;br&gt;&lt;br&gt;&lt;a href="https://d.android.com/r/studio-ui/designer/material/dialogs"&gt;https://d.android.com/r/studio-ui/designer/material/dialogs&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconDipSize" defaultSeverity="WARNING" displayName="Icon density-independent size validation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon density-independent size validation&lt;br&gt;&lt;br&gt;Checks the all icons which are provided in multiple densities, all compute to roughly the same density-independent pixel (&lt;code&gt;dip&lt;/code&gt;) size. This catches errors where images are either placed in the wrong folder, or icons are changed to new sizes but some folders are forgotten.&lt;br&gt;&lt;br&gt;Issue id: IconDipSize&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMenuTitle" defaultSeverity="ERROR" displayName="Missing menu title" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing menu title&lt;br&gt;&lt;br&gt;From the action bar documentation:&lt;br/&gt;
"It's important that you always define android:title for each menu item &amp;#8212; even if you don't declare that the title appear with the action item &amp;#8212; for three reasons:&lt;br/&gt;
&lt;br/&gt;
* If there's not enough room in the action bar for the action item, the menu item appears in the overflow menu and only the title appears.&lt;br/&gt;
* Screen readers for sight-impaired users read the menu item's title.&lt;br/&gt;
* If the action item appears with only the icon, a user can long-press the item to reveal a tool-tip that displays the action item's title.&lt;br/&gt;
&lt;br/&gt;
The android:icon is always optional, but recommended.&lt;br&gt;&lt;br&gt;Issue id: MenuTitle&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/appbar"&gt;https://developer.android.com/training/appbar&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconLauncherShape" defaultSeverity="WARNING" displayName="The launcher icon shape should use a distinct silhouette" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;The launcher icon shape should use a distinct silhouette&lt;br&gt;&lt;br&gt;According to the Android Design Guide (&lt;a href="https://d.android.com/r/studio-ui/designer/material/iconography"&gt;https://d.android.com/r/studio-ui/designer/material/iconography&lt;/a&gt;) your launcher icons should "use a distinct silhouette", a "three-dimensional, front view, with a slight perspective as if viewed from above, so that users perceive some depth."&lt;br/&gt;
&lt;br/&gt;
The unique silhouette implies that your launcher icon should not be a filled square.&lt;br&gt;&lt;br&gt;Issue id: IconLauncherShape&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconExtension" defaultSeverity="WARNING" displayName="Icon format does not match the file extension" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon format does not match the file extension&lt;br&gt;&lt;br&gt;Ensures that icons have the correct file extension (e.g. a &lt;code&gt;.png&lt;/code&gt; file is really in the PNG format and not for example a GIF file named &lt;code&gt;.png&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: IconExtension&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyEllipsis" defaultSeverity="WARNING" displayName="Ellipsis string can be replaced with ellipsis character" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Ellipsis string can be replaced with ellipsis character&lt;br&gt;&lt;br&gt;You can replace the string "..." with a dedicated ellipsis character, ellipsis character (u2026, &amp;amp;#8230;). This can help make the text more readable.&lt;br&gt;&lt;br&gt;Issue id: TypographyEllipsis&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Ellipsis"&gt;https://en.wikipedia.org/wiki/Ellipsis&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAllCaps" defaultSeverity="WARNING" displayName="Combining textAllCaps and markup" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Combining textAllCaps and markup&lt;br&gt;&lt;br&gt;The textAllCaps text transform will end up calling &lt;code&gt;toString&lt;/code&gt; on the &lt;code&gt;CharSequence&lt;/code&gt;, which has the net effect of removing any markup such as &lt;code&gt;&amp;lt;b&gt;&lt;/code&gt;. This check looks for usages of strings containing markup that also specify &lt;code&gt;textAllCaps=true&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AllCaps&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="스레딩 문제" path="Groovy"><inspection shortName="GroovyWaitWhileNotSynchronized" defaultSeverity="WARNING" displayName="동기화되지 않은 'wait()'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;해당하는 동기화된 구문 또는 동기화된 메서드 내에서 수행되지 않는 &lt;code&gt;wait()&lt;/code&gt; 호출을 보고합니다.&lt;/p&gt;
&lt;p&gt;잠금을 포함하지 않는 객체에서 &lt;code&gt;wait()&lt;/code&gt;를 호출하면 &lt;code&gt;IllegalMonitorStateException&lt;/code&gt;이 던져집니다.
그러한 구문이 반드시 오류인 것은 아니지만 필요한 잠금을 포함하는 메서드가 호출되기 전에 필요한 잠금을 얻을 수 있으므로 살펴볼 필요가 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyWaitWhileNotSynchronized&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyPublicFieldAccessedInSynchronizedContext" defaultSeverity="WARNING" displayName="동기화된 컨텍스트에서 비 private 필드 액세스" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동기화된 컨텍스트에서 액세스할 수 있는 비 &lt;code&gt;final&lt;/code&gt;, 비 &lt;code&gt;private&lt;/code&gt; 필드를 보고합니다.
&lt;p&gt;
  private이 아닌 필드에 항상 동기화된 방식으로 액세스할 수 있는 것은 아니며, 그렇게 '부분적으로 동기화된' 액세스는 예기치 않은 데이터 구조의 일관성 문제를 야기할 수 있습니다. 이 검사에서는 그 목적에 따라 생성자와 이니셜라이저에서의 액세스가 무시됩니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyPublicFieldAccessedInSynchronizedContext&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySynchronizationOnThis" defaultSeverity="WARNING" displayName="'this' 동기화" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;this&lt;/code&gt;를 잠금 표현식으로 사용하는 동기화를 보고합니다.
&lt;p&gt;
  보고된 구문에는 &lt;code&gt;this&lt;/code&gt;를 잠그는 &lt;code&gt;synchronized&lt;/code&gt; 블록과
&lt;code&gt;wait()&lt;/code&gt;를 대상으로 하는 &lt;code&gt;wait()&lt;/code&gt;, &lt;code&gt;notify()&lt;/code&gt; 또는 &lt;code&gt;notifyAll()&lt;/code&gt; 호출을 포함합니다.
  그러한 구문(예: 동기화된 메서드)은 주어진 객체를 잠그는 주체가 무엇인지 추적하기 어렵고 객체에 대한 '서비스 거부' 공격이 가능하도록 합니다. 대안으로 private 인스턴스 변수에 대한 잠금을 고려해보세요. 이러한 변수에 대한 액세스는 완전히 제어할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovySynchronizationOnThis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnsynchronizedMethodOverridesSynchronizedMethod" defaultSeverity="WARNING" displayName="비동기화된 메서드가 동기화된 메서드를 재정의" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;b&gt;synchronized&lt;/b&gt; 메서드를 재정의하는 비 &lt;b&gt;synchronized&lt;/b&gt; 메서드를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Base {
      &lt;b&gt;synchronized&lt;/b&gt; void foo() {
          // ...
      }
  }
  class Derived extends Base {
      @Override
      &lt;b&gt;void foo()&lt;/b&gt; {
          super.foo()
            // ...
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 &lt;code&gt;Bar&lt;/code&gt; 클래스 내에서 동기화되지 않은 &lt;code&gt;foo()&lt;/code&gt; 메서드가 동기화된 메서드를 재정의합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyUnsynchronizedMethodOverridesSynchronizedMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySynchronizationOnVariableInitializedWithLiteral" defaultSeverity="WARNING" displayName="리터럴로 초기화된 변수 동기화" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
리터럴로 초기화되는 객체를 잠그는 동기화된 블록을 보고합니다.
&lt;p&gt;
  문자열 리터럴은 억류(intern)되며 &lt;code&gt;Number&lt;/code&gt; 리터럴은 캐시에서 할당될 수 있습니다. 이로 인해 동일한 리터럴로 초기화된 객체를 사용하는 시스템의 다른 부분이 실제로는 동일한 객체에 대한 참조를 보유할 수 있습니다. 이때 문자열이 private으로 간주될 경우 예기치 않은 교착 상태가 발생할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovySynchronizationOnVariableInitializedWithLiteral&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAccessToStaticFieldLockedOnInstance" defaultSeverity="WARNING" displayName="static 필드에 대한 액세스가 인스턴스 데이터에서 잠겨 있음" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;this&lt;/code&gt;의 인스턴스 필드에서 잠긴
비 상수 static 필드에 대한 액세스를 보고합니다.
&lt;p&gt;
  인스턴스 데이터에서 static 필드를 잠가도 해당 필드가 다른 인스턴스에 의해 수정되는 것을 방지하지 못하므로 예기치 않은 경합 상태가 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static String s;
  def foo() {
      synchronized (this) {
          System.out.println(s); // 경고
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyAccessToStaticFieldLockedOnInstance&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySynchronizedMethod" defaultSeverity="WARNING" displayName="동기화된 메서드" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드에 사용된 &lt;code&gt;synchronized&lt;/code&gt; 제어자를 보고합니다.
&lt;p&gt;
  일부 코딩 표준에서는 &lt;code&gt;synchronized&lt;/code&gt; 제어자의 사용을 금지하며 대신 &lt;code&gt;synchronized&lt;/code&gt; 문을 권장합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovySynchronizedMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyEmptySyncBlock" defaultSeverity="WARNING" displayName="빈 'synchronized' 블록" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 비어 있는 &lt;code&gt;synchronized&lt;/code&gt; 문을 보고합니다. 이러한 구문은 이론적으로 의도한 의미일 수 있지만 혼란스러울 수 있으며 오타가 난 결과인 경우가 많습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
synchronized(lock) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyEmptySyncBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNestedSynchronizedStatement" defaultSeverity="WARNING" displayName="중첩된 'synchronized' 문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
중첩된 &lt;code&gt;synchronized&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;
  중첩된 &lt;code&gt;synchronized&lt;/code&gt; 문은 불필요하거나(잠금 객체가 동일할 경우) 교착상태에 빠지기 쉽습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyNestedSynchronizedStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyWhileLoopSpinsOnField" defaultSeverity="WARNING" displayName="while 루프가 필드에서 스핀" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt;이 아니며 다른 스레드에 의해 변경되기를 기다리는 필드의 값에서 스핀하는 &lt;code&gt;while&lt;/code&gt; 루프를 보고합니다.&lt;/p&gt;
&lt;p&gt;
그러한 루프는 루프 내에서 조금만 작업이 수행돼도 CPU 사용량이 크게 늘어날 뿐만 아니라 의도와 다른 의미를 가지게 될 가능성이 높습니다. Java 메모리 모델에서는 다른 스레드가 필드 값을 변경하는 경우에도 해당 루프가 완료되지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SpinsOnField {
      boolean ready = false;

      void run() {
          // 다른 스레드에서 markAsReady를 호출한 다음에도
          // 루프가 완료되지 않을 수 있습니다
          while (!ready) {
          }
          // 무언가 작업을 실행합니다
      }

      void markAsReady() {
          ready = true;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
또한 Java 9부터는 일부 하드웨어의 성능을 크게 끌어올릴 수 있도록 &lt;code&gt;volatile&lt;/code&gt; 필드의 스핀 루프 내에서 &lt;code&gt;Thread.onSpinWait()&lt;/code&gt;를 호출하는 것이 좋습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
이 검사 보고서가 빈 &lt;code&gt;while&lt;/code&gt; 루프만을 가지도록 하려면 아래 체크박스를 사용하세요.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyWhileLoopSpinsOnField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySynchronizationOnNonFinalField" defaultSeverity="WARNING" displayName="final이 아닌 필드 동기화" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
잠금 표현식이 &lt;code&gt;final&lt;/code&gt; 필드가 아닌 &lt;code&gt;synchronized&lt;/code&gt; 
문을 보고합니다.
&lt;p&gt;
  다양한 스레드가 같은 객체에서 작동할 때라도 다른 객체에서 잠길 가능성이 있으므로 그러한 구문이 유용한 의미를 가질 가능성이 낮습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovySynchronizationOnNonFinalField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyBusyWait" defaultSeverity="WARNING" displayName="바쁜 대기" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루프 내에서 발생하는 &lt;code&gt;java.lang.Thread.sleep()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  이러한 호출은 '대기하느라 바쁨'(busy-waiting)을 나타냅니다. 바쁜 대기 중인 스레드는 잠긴 리소스를 해제하지 않기 때문에 이 상태는 비효율적이기 쉽고, 예기치 않은 교착 상태가 발생할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyBusyWait&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDoubleCheckedLocking" defaultSeverity="WARNING" displayName="이중 검사된 락" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"&gt;이중 검사된 잠금&lt;/a&gt;을 보고합니다.
&lt;p&gt;
  이중 검사된 잠금은 동기화 비용을 줄이는 한편 스레드가 안전한 방식으로 요청 기반의 필드 초기화를 시도합니다.
  이 방식을 &lt;code&gt;volatile&lt;/code&gt;로 선언되지 않은 필드에서 사용할 경우, 스레드 안전이 유지되지 않습니다.
  Java 1.4 이하 버전을 사용할 경우, 이중 검사된 잠금은 &lt;code&gt;volatile&lt;/code&gt; 필드에서도 작동하지 않습니다.
  해당 문제와 관련한 자세한 설명은 위에 링크된 글을 참조하세요.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      private Helper helper = null

      Helper getHelper() {
          if (helper == null)
              synchronized(this) {
                  if (helper == null) {
                      helper = new Helper()
                  }
              }
          }
          return helper;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyDoubleCheckedLocking&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyWaitCallNotInLoop" defaultSeverity="WARNING" displayName="'wait()'가 루프에 없음" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;루프 내부에서 이루어지지 않는 &lt;code&gt;wait()&lt;/code&gt; 호출을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wait()&lt;/code&gt;는 보통 조건이 true가 될 때까지 스레드를 일시 중지할 때 사용되며 그러한 조건은 &lt;code&gt;wait()&lt;/code&gt;가 반환된 이후에 검사해야 합니다. 이를 가장 확실하게 수행하는 방법은 루프입니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyWaitCallNotInLoop&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyThreadStopSuspendResume" defaultSeverity="WARNING" displayName="Thread.stop(), Thread.suspend() 또는 Thread.resume() 호출" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Thread.stop()&lt;/code&gt;, &lt;code&gt;Thread.suspend()&lt;/code&gt; 또는 &lt;code&gt;Thread.resume()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  이러한 호출은 본질적으로 데이터 손상 및 교착상태로 이어지기 쉬우므로 사용하지 않는 것이 좋습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyThreadStopSuspendResume&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNotifyWhileNotSynchronized" defaultSeverity="WARNING" displayName="동기화되지 않은 'wait()' 또는 'notify()'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해당하는 동기화된 구문 또는 동기화된 메서드 내에 있지 않은 &lt;code&gt;notify()&lt;/code&gt; 및 &lt;code&gt;notifyAll()&lt;/code&gt;에 대한 호출을 보고합니다.
&lt;p&gt;
  잠금을 포함하지 않는 객체에서 이러한 메서드를 호출하면 &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; 예외가 던져집니다.
  그러한 구문이 반드시 오류인 것은 아니지만, 포함하는 메서드가 호출되기 전에 필요한 잠금을 얻을 수 있으므로 살펴볼 필요가 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyNotifyWhileNotSynchronized&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySystemRunFinalizersOnExit" defaultSeverity="WARNING" displayName="System.runFinalizersOnExit() 호출" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;System.runFinalizersOnExit()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  이는 Java 언어에서 가장 위험한 호출 중 하나입니다. 본질적으로 스레드에서 안전하지 않으며 데이터 손상, 교착상태를 야기할 수 있고 호출 지점과 멀리 떨어진 프로그램의 일부에 영향을 줄 수 있습니다.
  이 호출은 사용이 중단되었으므로 사용하지 않기를 강력히 권장합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovySystemRunFinalizersOnExit&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnconditionalWait" defaultSeverity="WARNING" displayName="조건 없는 'wait' 호출" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;동기화된 컨텍스트 내에서 조건 없이 호출되는 &lt;b&gt;wait()&lt;/b&gt;를 보고합니다.
일반적으로 &lt;b&gt;wait()&lt;/b&gt;는 어떤 조건이 true가 될 때까지 스레드를 차단하는 데 사용됩니다. &lt;b&gt;wait()&lt;/b&gt;가 조건 없이 호출되었다면 잠금을 획득하기 전에 조건을 검사한 경우가 대부분입니다. 그러한 경우 검사 시간과 잠금을 획득한 시간 사이에 조건이 true가 되는 순간 데이터 경합이 발생할 수 있습니다. 이 검사를 통해 발견한 구문이 항상 잘못된 건 아니지만, 검사해볼 가치는 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyUnconditionalWait&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="null 값 가능성 문제" path="Java/가능한 버그"><inspection shortName="NullableProblems" defaultSeverity="WARNING" displayName="@NotNull/@Nullable 문제" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
null 값 가능성을 표시하는 어노테이션과 관련된 문제를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;재정의하는 메서드에 어노테이션이 추가되지 않은 경우:
    &lt;pre&gt;&lt;code&gt;
abstract class A {
  @NotNull abstract String m();
}
class B extends A {
    String m() { return "empty string"; }
}
    &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 타입의 어노테이션: &lt;code&gt;@NotNull int myFoo;&lt;/code&gt; &lt;/li&gt;
  &lt;li&gt;동일한 멤버에 &lt;code&gt;@Nullable&lt;/code&gt; 및 &lt;code&gt;@NotNull&lt;/code&gt;이 모두 있는 경우: &lt;code&gt;@Nullable @NotNull String myFooString;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;null 가능한 요소의 컬렉션이 null이 아닌 요소의 컬렉션에 대입된 경우:
    &lt;pre&gt;&lt;code&gt;
void testList(List&amp;lt;@Nullable String&gt; nullableList) {
   List&amp;lt;@NotNull String&gt; list2 = nullableList;
}
    &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;어노테이션 구성&lt;/b&gt; 버튼을 사용하여 null 값 가능성을 표시하는 어노테이션을 지정하고 체크박스를 사용하여 검사가 경고를 표시할 지점을 세밀하게 설정합니다.&lt;/p&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 5 이상이며, 클래스 경로에서 null 값 가능성을 표시하는 어노테이션이 지원되는 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NullableProblems&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NotNullFieldNotInitialized" defaultSeverity="WARNING" displayName="@NotNull 필드가 초기화되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
생성자에서 초기화되지 않았으며 NotNull 어노테이션이 추가된 필드를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyClass {
  private @NotNull String value;

  public void setValue(@NotNull String value) {
    this.value = value;
  }

  public @NotNull String getValue() {
    return value;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  이러한 필드는 not-null 제약에 위배될 수 있습니다. 상기 예시에서 &lt;code&gt;setValue&lt;/code&gt; 매개변수에 NotNull 어노테이션이 추가되었지만, setter가 호출되지 않은 경우 &lt;code&gt;getValue&lt;/code&gt;가 null을 반환할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NotNullFieldNotInitialized&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnNull" defaultSeverity="WARNING" displayName="'null' 반환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
반환 값이 &lt;code&gt;null&lt;/code&gt;인 &lt;code&gt;return&lt;/code&gt; 문을 보고합니다.
이러한 구문은 유용한 경우도 있으나 코드가 &lt;code&gt;NullPointer Exception&lt;/code&gt;으로 실패하기 쉬워질 수 있습니다.
&lt;p&gt;
  메서드가 &lt;code&gt;null&lt;/code&gt;을 반환하도록 설계되어 있는 경우 &lt;code&gt;@Nullable&lt;/code&gt; 어노테이션과 함께 표시하는 것이 좋습니다. 그러면 해당 메서드가 이 검사에서 무시됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    public String getName () {
      return null;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    public @Nullable String getName () {
      return null;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  반환 타입이 &lt;code&gt;java.util.Optional&lt;/code&gt;인 경우 &lt;code&gt;null&lt;/code&gt;을 &lt;code&gt;Optional.empty()&lt;/code&gt;로 변환하는 추가적인 빠른 수정이 제안됩니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  다음 옵션을 사용해 검사를 구성하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;private&lt;/code&gt; 메서드를 무시할지 여부를 설정합니다.
    이는 익명 클래스 및 람다에서 &lt;code&gt;null&lt;/code&gt;을 반환하는 경우 또한 무시합니다.
  &lt;/li&gt;
  &lt;li&gt;
    배열, 컬렉션 객체 또는 일반 객체가 &lt;code&gt;null&lt;/code&gt; 값을 반환하는 경우, 혹은 이 셋의 조합이 보고되어야 하는지 여부를 설정합니다.
    반환 타입이 &lt;code&gt;java.util.Optional&lt;/code&gt;인 메서드에서 &lt;code&gt;null&lt;/code&gt;을 반환하는 경우는 항상 보고됩니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;b&gt;어노테이션 구성&lt;/b&gt;을 클릭하여 'nullable'로 간주되어야 하는 어노테이션을 지정하세요.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ReturnNull&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="코드 성숙도" path="Java"><inspection shortName="RedundantScheduledForRemovalAnnotation" defaultSeverity="WARNING" displayName="불필요한 @ScheduledForRemoval 어노테이션" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Java 9 이상 버전을 대상으로 하는 코드에서 &lt;code&gt;inVersion&lt;/code&gt; 속성이 없는 &lt;code&gt;@ApiStatus.ScheduledForRemoval&lt;/code&gt; 어노테이션의 사용을 보고합니다.
&lt;p&gt;
이러한 사용은 코드를 단순화하기 위해 &lt;code&gt;@Deprecated&lt;/code&gt; 어노테이션의 &lt;code&gt;forRemoval&lt;/code&gt; 속성으로 대체할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantScheduledForRemovalAnnotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObsoleteCollection" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 컬렉션 타입 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Vector&lt;/code&gt;, &lt;code&gt;java.util.Hashtable&lt;/code&gt; 및 &lt;code&gt;java.util.Stack&lt;/code&gt;의 사용 위치를 보고합니다.
&lt;p&gt;이러한 클래스의 사용 위치는 각각 &lt;code&gt;java.util.ArrayList&lt;/code&gt;, &lt;code&gt;java.util.HashMap&lt;/code&gt; 및 &lt;code&gt;java.util.ArrayDeque&lt;/code&gt;를 사용하도록 바꿀 수 있습니다.
이전 클래스는 여전히 지원되지만 JDK1.2 컬렉션 클래스에 의해 사용이 중단되었으므로 새로운 개발에서 사용되어서는 안 됩니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
사용이 중단된 컬렉션이 메서드 인수로 사용되거나 사용이 중단된 타입을 요구하는 변수에 대입된 경우를 무시하려면 &lt;b&gt;필요한 경우 사용이 중단된 컬렉션 타입 무시&lt;/b&gt; 옵션을 사용하세요.
이 옵션을 활성화하면 상당한 프로세서 리소스가 소비될 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ObsoleteCollection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtractMethodRecommender" defaultSeverity="WARNING" displayName="메서드를 추출할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
코드 조각을 별도의 메서드로 추출하여 코드를 더 명확하게 만들도록 제안합니다. 
이 검사에는 다음을 포함하여 추출에 사용할 좋은 후보를 선택할 때 도움이 되는 경험적 지식이 다수 포함되어 있습니다.
&lt;ul&gt;
  &lt;li&gt;추출된 조각에 비 로컬 제어 흐름이 없습니다&lt;/li&gt;
  &lt;li&gt;추출된 조각에 출력 변수가 하나뿐입니다&lt;/li&gt;
  &lt;li&gt;추출된 조각 내외부에서 출력 변수가 비슷하게 사용된 경우가 없습니다&lt;/li&gt;
  &lt;li&gt;추출된 조각에 입력 매개변수가 많지 않습니다(기본 3개 이하. 검사 옵션에서 구성 가능)&lt;/li&gt;
  &lt;li&gt;추출된 조각이 구성된 길이보다 짧지 않으나(기본 500자) 포함하는 메서드의 본문의 60%보다 길지 않습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ExtractMethodRecommender&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowablePrintedToSystemOut" defaultSeverity="WARNING" displayName="'Throwable'을 'System.out'으로 출력" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
예외가 인수로 사용된 &lt;code&gt;System.out.println()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;예외 기록을 위해 프린트 문을 사용하면 스택 추적을 숨기기때문에 문제를 조사하는 것이 복잡해질 수 있습니다.
  대신 로거를 사용하는 것을 권장합니다.&lt;/p&gt;
&lt;p&gt;예외 인수를 사용한 &lt;code&gt;System.out.print()&lt;/code&gt;, &lt;code&gt;System.err.println()&lt;/code&gt; 및 &lt;code&gt;System.err.print()&lt;/code&gt; 호출 또한 보고합니다. 예외 기록을 위해서 대신 로거를 사용하는 것이 좋습니다.&lt;/p&gt;
&lt;p&gt;제공된 빠른 수정은 &lt;b&gt;SLF4J&lt;/b&gt;와 &lt;b&gt;Log4j 2&lt;/b&gt;를 지원합니다.
&lt;code&gt;System.out.println()&lt;/code&gt; 호출을 로그 호출로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      foo();
  } catch (Exception e) {
      System.out.println(e);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      foo();
  } catch (Exception e) {
    log.error("e: ", e);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;수정에 사용할 로그 메서드&lt;/b&gt; 옵션을 사용하여 메시지를 로깅할 메서드를 지정하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThrowablePrintedToSystemOut&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Deprecation" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 API 사용" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지원 중단된 클래스, 필드 및 메서드가 사용된 경우를 보고합니다.
지원 중단된 멤버의 Javadoc에서 필요한 정보를 추출할 수 있는 경우 빠른 수정으로 지원 중단된 사용 위치를 자동으로 변환할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  class Interesting {

    /**
     * @deprecated {@link #newHotness()}를 대신 사용합니다
     */
    @Deprecated
    public void oldAndBusted() {}

    public void newHotness() {}
  }
  class ElseWhere {
    void x(Interesting i) {
      i.oldAndBusted(); // 여기에 지원 중단 경고 표시됩니다
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  class Interesting {

    /**
     * @deprecated {@link #newHotness()}를 대신 사용합니다
     */
    @Deprecated
    public void oldAndBusted() {}

    public void newHotness() {}
  }
  class ElseWhere {
    void x(Interesting i) {
      i.newHotness();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;기본적으로 이 검사는 이를 피하기 어렵거나 불가능한 경우 경고를 생성하지 않습니다.  예를 들어, 다음 코드는 보고하지 않습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  abstract class A { //라이브러리 코드
     @Deprecated
     abstract void m();
  }
  class B extends A { //프로젝트 코드
     @Override
     void m() {
        //작업 코드;
     }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;
  지원 중단된 멤버, 지원 중단된 추상 메서드 재정의, static이 아닌 import 문, 지원 중단된 클래스의 메서드 또는 동일한 최상위 클래스에서 검사를 비활성화하려면 검사 옵션을 사용하세요.
&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: Deprecation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemOutErr" defaultSeverity="INFORMATION" displayName="'System.out' 또는 'System.err' 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;System.out&lt;/code&gt; 또는 &lt;code&gt;System.err&lt;/code&gt;의 사용 위치를 보고합니다.
&lt;p&gt;그러한 구문은 보통 일시적인 디버그에 자주 사용되기 때문에 프로덕션 코드에서 제거하거나 더욱 강력한 로깅 기능으로 바꿔야 합니다.&lt;/p&gt;

&lt;p&gt;제공된 빠른 수정은 &lt;b&gt;SLF4J&lt;/b&gt;와 &lt;b&gt;Log4j 2&lt;/b&gt;를 지원합니다.
 &lt;code&gt;System.out&lt;/code&gt;과 &lt;code&gt;System.err&lt;/code&gt; 호출을 로그 호출로 바꿉니다&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public static void test(Object o) {
    System.out.println("Test: "+ o);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private static final Logger log = LoggerFactory.getLogger(Test.class);

  public static void test(Object o) {
      log.info("Test: {}", o);;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;'System.err'용 로그 메서드&lt;/b&gt; 옵션을 사용하여 'System.err' 호출의 메시지를 로깅할 메서드를 지정합니다.
  &lt;b&gt;'System.out'용 로그 메서드&lt;/b&gt; 옵션을 사용하여 'System.out' 호출의 메시지를 로깅할 메서드를 지정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SystemOutErr&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeprecatedIsStillUsed" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 멤버 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지원이 중단된 코드 내 클래스, 메서드 및 필드를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  class MyCode {
  @Deprecated
  void oldMethod() {}// 경고: "지원이 중단된 멤버가 있습니다"

  void newMethod() {
    oldMethod(); // 잊어버린 사용 위치
  }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;지원이 중단된 요소 내 사용 위치는 무시됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;참고:&lt;/b&gt; 성능상의 이유로, private이 아닌 멤버는 프로젝트 내에 이름이 거의 나오지 않는 경우에만 확인합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DeprecatedIsStillUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowablePrintStackTrace" defaultSeverity="WARNING" displayName="'printStackTrace()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인수가 없는 &lt;code&gt;Throwable.printStackTrace()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;그러한 구문은 보통 일시적인 디버그에 자주 사용되기 때문에 프로덕션 코드에서 제거하거나 더욱 강력한 기록 기능으로 바꿔야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThrowablePrintStackTrace&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadDumpStack" defaultSeverity="WARNING" displayName="'Thread.dumpStack()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Thread.dumpStack()&lt;/code&gt;의 사용 위치를 보고합니다.
&lt;p&gt;그러한 구문은 보통 일시적인 디버그에 자주 사용되기 때문에 프로덕션 코드에서 제거하거나 더욱 강력한 기록 기능으로 바꿔야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThreadDumpStack&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CommentedOutCode" defaultSeverity="WEAK WARNING" displayName="주석 처리된 코드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Java 코드를 포함하는 주석을 보고합니다.
&lt;p&gt;일반적으로 주석 처리된 코드는 금방 최신 코드에 뒤처지게 되어 잘못 이해될 수 있습니다.
대부분의 프로젝트는 버전 관리 시스템을 사용하므로 주석 처리된 코드를 삭제하고 버전 관리 시스템 기록을 사용하는 것이 좋습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CommentedOutCode&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfObsoleteDateTimeApi" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 date-time API 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Date&lt;/code&gt;, &lt;code&gt;java.util.Calendar&lt;/code&gt;, &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt;, &lt;code&gt;java.util.TimeZone&lt;/code&gt;, &lt;code&gt;java.util.SimpleTimeZone&lt;/code&gt;이 사용된 경우를 보고합니다.
&lt;p&gt;이러한 클래스는 계속 지원되지만 JDK8 Date-Time API에 의해 사용이 중단되었으므로 새로운 개발에서 사용되어서는 안 됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UseOfObsoleteDateTimeApi&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MarkedForRemoval" defaultSeverity="ERROR" displayName="제거로 표시된 API의 사용" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@Deprecated(&lt;b&gt;forRemoval&lt;/b&gt;=true)&lt;/code&gt;가 있는 제거하도록 표시된 곧 사용할 수 없게 될 API 사용 사례(클래스, 필드 및 메서드)를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  제거하도록 표시된 API를 사용하는 코드는 향후 API 버전에서 런타임 오류를 발생시킬 수 있습니다. 따라서 이 검사에 권장되는 심각도는 &lt;i&gt;오류&lt;/i&gt;입니다.&lt;/p&gt;
&lt;p&gt;
  기존에 곧 사용할 수 없게 될 항목에 대한 강조 표시와 동일한 코드 강조 표시를 사용하고 싶은 경우 심각도를 &lt;i&gt;Warning&lt;/i&gt;으로 변경할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MarkedForRemoval&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OptionalAssignedToNull" defaultSeverity="WARNING" displayName="Optional 타입에 사용되는 null 값" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Optional&lt;/code&gt; 변수에 대입되거나 &lt;code&gt;Optional&lt;/code&gt;을 반환하는 메서드에 의해 반환된 &lt;code&gt;null&lt;/code&gt;을 보고합니다.
&lt;p&gt;&lt;code&gt;Optional.empty()&lt;/code&gt; (또는 Guava의 경우 &lt;code&gt;Optional.absent()&lt;/code&gt;) 를 사용하여 빈 값을 표시하는 것을 권장합니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional&amp;lt;Integer&amp;gt; foo(boolean flag) {
    return flag ? Optional.of(42) : null;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional&amp;lt;Integer&amp;gt; foo(boolean flag) {
    return flag ? Optional.of(42) : Optional.empty();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;optional == null&lt;/code&gt; 같은 비교도 보고하려면 &lt;b&gt;Optional과 null 비교 결과 보고&lt;/b&gt; 옵션을 사용하세요. 이는 드문 경우(예: 선택적 필드의 지연된 초기화) 올바를 수 있지만 선택적 변수는 일반적으로 null이 아니며 &lt;code&gt;optional.isPresent()&lt;/code&gt;는 의도된 것일 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: OptionalAssignedToNull&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JPA Buddy" path=""><inspection shortName="com.intellij.jpb.ConverterSpecifiedIncorrectlyInspection" defaultSeverity="WARNING" displayName="컨버터의 타입이 속성 타입과 일치하지 않습니다" enabled="false" language="UAST" pluginId="com.haulmont.jpab" pluginVersion="252.23892.360" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 지정된 JPA 컨버터가 속성 타입과 일치하는지 확인합니다
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: com.intellij.jpb.ConverterSpecifiedIncorrectlyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="com.intellij.jpa.jpb.model.DataClassEqualsAndHashCodeInspection" defaultSeverity="WARNING" displayName="JPA 엔티티에 데이터 클래스는 권장되지 않습니다." enabled="false" language="kotlin" pluginId="com.haulmont.jpab" pluginVersion="252.23892.360" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 데이터 클래스에 대해 엔티티로 사용된 equals() 및 hashCode()가 있는지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: com.intellij.jpa.jpb.model.DataClassEqualsAndHashCodeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="com.intellij.jpb.UnsupportedTypeWithoutConverterInspection" defaultSeverity="WARNING" displayName="지원되지 않는 타입을 가진 속성은 @Transient이거나 사용자 지정 타입이거나 컨버터 선언이어야 합니다" enabled="false" language="UAST" pluginId="com.haulmont.jpab" pluginVersion="252.23892.360" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 알 수 없는 속성 타입에 지정된 컨버터가 있는지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: com.intellij.jpb.UnsupportedTypeWithoutConverterInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="com.intellij.jpb.LombokToStringInspection" defaultSeverity="WARNING" displayName="@ToString은 지연 로드되는 필드 및/또는 연결을 포함합니다. 이는 성능 및 메모리 사용량 문제를 일으킬 수 있습니다." enabled="false" language="JAVA" pluginId="com.haulmont.jpab" pluginVersion="252.23892.360" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 JPA 엔티티에 lazy 필드가 @lombok.ToString과 쌍으로 사용되었는지 확인합니다
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: com.intellij.jpb.LombokToStringInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="com.intellij.jpb.LombokToStringIncludeInspection" defaultSeverity="WARNING" displayName="이 필드는 @ToString에 포함되기 때문에 지연 로드됩니다. 성능 및 메모리 사용량 문제를 일으킬 수 있습니다." enabled="false" language="JAVA" pluginId="com.haulmont.jpab" pluginVersion="252.23892.360" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 JPA 엔티티에 lazy 필드가 @lombok.ToString과 쌍으로 사용되었는지 확인합니다
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: com.intellij.jpb.LombokToStringIncludeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="com.intellij.jpb.LombokEqualsAndHashCodeInspection" defaultSeverity="WARNING" displayName="JPA 엔티티에 @EqualsAndHashCode를 사용하는 것은 권장되지 않습니다. 중대한 성능 및 메모리 사용량 문제를 일으킬 수 있습니다." enabled="false" language="UAST" pluginId="com.haulmont.jpab" pluginVersion="252.23892.360" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 JPA 엔티티에 @lombok.EqualsAndHashCode가 사용되었는지 확인합니다
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: com.intellij.jpb.LombokEqualsAndHashCodeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="com.intellij.jpb.EntityIdMissingInspection" defaultSeverity="WARNING" displayName="엔티티에 기본 키가 없습니다" enabled="false" language="UAST" pluginId="com.haulmont.jpab" pluginVersion="252.23892.360" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 엔티티의 기본 키 속성이 있는지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: com.intellij.jpb.EntityIdMissingInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="com.intellij.jpb.LombokDataInspection" defaultSeverity="WARNING" displayName="JPA 엔티티에 @Data를 사용하는 것은 권장되지 않습니다. 중대한 성능 및 메모리 사용량 문제를 일으킬 수 있습니다." enabled="false" language="UAST" pluginId="com.haulmont.jpab" pluginVersion="252.23892.360" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 JPA 엔티티에 @lombok.Data가 사용되었는지 확인합니다
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: com.intellij.jpb.LombokDataInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="com.intellij.jpb.IncompatibleTableAnnotationInspection" defaultSeverity="WARNING" displayName="@Table 어노테이션은 SINGLE_TABLE 상속 전략과 같이 사용해서는 안 됩니다." enabled="false" language="UAST" pluginId="com.haulmont.jpab" pluginVersion="252.23892.360" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 SINGLE_TABLE 상속 전략을 가진 상위 항목의 하위 엔티티에 @Table 주석이 없는지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: com.intellij.jpb.IncompatibleTableAnnotationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="com.intellij.jpb.CompositeIdClassSerializable" defaultSeverity="WARNING" displayName="복합 ID 클래스는 Serializable을 구현해야 합니다" enabled="false" language="UAST" pluginId="com.haulmont.jpab" pluginVersion="252.23892.360" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 Serializable을 구현하는 복합 키 클래스를 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: com.intellij.jpb.CompositeIdClassSerializable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="com.intellij.jpb.DuplicateVersionAnnotationInspection" defaultSeverity="WARNING" displayName="클래스당 하나의 Version 프로퍼티 또는 필드가 사용되어야 합니다" enabled="false" language="UAST" pluginId="com.haulmont.jpab" pluginVersion="252.23892.360" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 @Version 어노테이션이 중복된 경우를 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: com.intellij.jpb.DuplicateVersionAnnotationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="com.intellij.jpb.NoArgsConstructorInspection" defaultSeverity="WARNING" displayName="엔티티에는인수 없는 public 또는 protected 생성자가 있어야 합니다" enabled="false" language="UAST" pluginId="com.haulmont.jpab" pluginVersion="252.23892.360" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 클래스에서 인수가 없는 생성자를 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: com.intellij.jpb.NoArgsConstructorInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="DOM 문제" path="JavaScript 및 TypeScript"><inspection shortName="XHTMLIncompatabilitiesJS" defaultSeverity="WARNING" displayName="호환되지 않는 XHTML 사용" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
XHTML 문서 관련 문제를 제시할 수 있는 공통된 JavaScript DOM 패턴을 보고합니다. 특히 탐지된 패턴은 문서 로드 형식이 XML인지 HTML 인지에 따라 완전히 다르게 동작합니다.
이 때문에 스크립트의 동작이 콘텐츠가 아닌 문서의 MIME 타입에 의존하는 경우, 감지하기 어려운 버그가 발생할 수 있습니다.
탐지된 패턴은
&lt;b&gt;document.body&lt;/b&gt;,
&lt;b&gt;document.images&lt;/b&gt;,
&lt;b&gt;document.applets&lt;/b&gt;,
&lt;b&gt;document.links&lt;/b&gt;,
&lt;b&gt;document.forms&lt;/b&gt;,
&lt;b&gt;document.anchors&lt;/b&gt;을 포함합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XHTMLIncompatabilitiesJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InnerHTMLJS" defaultSeverity="WARNING" displayName="'innerHTML' 프로퍼티 사용" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;innerHTML&lt;/code&gt; 프로퍼티를 사용하여 텍스트로서 DOM 노드에 액세스하는 JavaScript를 보고합니다.
대부분의 &lt;code&gt;innerHTML&lt;/code&gt; 사용은 &lt;code&gt;getElementByID()&lt;/code&gt; 및
&lt;code&gt;createElement()&lt;/code&gt; 등의 명시적인 DOM 호출로 실행하는 것이 좋습니다.  추가적으로, 
XML로 표시되는 경우 XHTML의 DOM를 포함한 XML DOM에서는 
&lt;code&gt;innerHTML&lt;/code&gt;이 작동하지 않습니다.  이는 버그 진단 시 어려움을
초래할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: InnerHTMLJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DocumentWriteJS" defaultSeverity="WARNING" displayName="'document.write()' 호출" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;document.write()&lt;/code&gt; 또는 &lt;code&gt;document.writeln()&lt;/code&gt;로의 메서드 호출을 보고합니다.
그러한 호출 사용은 대부분 &lt;code&gt;getElementByID()&lt;/code&gt; 및
&lt;code&gt;createElement()&lt;/code&gt; 등의 명시적인 DOM 호출로 실행하는 것이 좋습니다.  추가적으로, XML로 표시되는 경우 XHTML의 DOM를 포함한 XML DOM에서는 
&lt;code&gt;write()&lt;/code&gt; 및 &lt;code&gt;writeln()&lt;/code&gt; 호출이 작동하지 않습니다.  이는 버그를 지적하는 데 어려움을 초래할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DocumentWriteJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PlatformDetectionJS" defaultSeverity="WARNING" displayName="정확하지 않은 플랫폼 탐지" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
스크립트가 실행되는 브라우저 또는 운영 체제를 탐지하기 위한 
공통된 자바스크립트 패턴을 보고합니다. 이식 불가능한 구문을 지적하는 것 외에 
이러한 플랫폼 탐지 패턴은 일반적으로 불완전하고 쉽게 속아 넘어갑니다. 대부분의 경우, 전체 플랫폼을 탐지하려고 하기보다 각 환경 기능을 탐지하는 편이 더 낫습니다.
&lt;p&gt;탐지된 패턴은 다음을 포함합니다: &lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;document.all&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;document.layers&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;navigator.userAgent&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;navigator.oscpu&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;navigator.appName&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;navigator.appCodeName&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;navigator.platform&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PlatformDetectionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="언어 삽입" path=""><inspection shortName="LanguageMismatch" defaultSeverity="WARNING" displayName="언어 불일치" enabled="false" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
참조 언어가 사용 컨텍스트에서 기대되는 언어와 일치하지 않는 경우 보고합니다.

&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Language("JavaScript")
  String JS_CODE = "var x;";

  @Language("XPath")
  String XPATH_CODE = JS_CODE; // 여기서 경고
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LanguageMismatch&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnknownLanguage" defaultSeverity="ERROR" displayName="알 수 없는 언어 ID" enabled="false" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@Language&lt;/code&gt; 어노테이션에 사용된 언어 ID를 알 수 없는 경우를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Language("HMTL") String html;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnknownLanguage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InjectionNotApplicable" defaultSeverity="ERROR" displayName="삽입 어노테이션 적용 불가" enabled="false" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;String&lt;/code&gt; 또는 &lt;code&gt;String[]&lt;/code&gt; 이외의 타입이 있는 요소에 &lt;code&gt;@Language&lt;/code&gt; 어노테이션이 적용되는 경우 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Language("HTML") &lt;b&gt;int&lt;/b&gt; i;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;int&lt;/b&gt; i;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: InjectionNotApplicable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Spring WebSocket" path="Spring"><inspection shortName="SpringWebSocketConfigurationInspection" defaultSeverity="ERROR" displayName="잘못된 Spring WebSocket XML 기반 애플리케이션 컨텍스트" enabled="false" language="XML" pluginId="com.intellij.spring.websocket" pluginVersion="252.23892.360" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Spring Websocket XML 기반의 애플리케이션 컨텍스트와 관련된 이슈를 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;해결되지 않은 bean 참조&lt;/li&gt;
  &lt;li&gt;필요한 태그 또는 속성 누락&lt;/li&gt;
  &lt;li&gt;잘못된 프로퍼티 타입&lt;/li&gt;
  &lt;li&gt;일관성 없는 &lt;code&gt;enum&lt;/code&gt; 프로퍼티&lt;/li&gt;
  &lt;li&gt;참조된 bean의 잘못된 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans ... &amp;gt;
  
    &amp;lt;bean id="dummyBean" class="java.lang.String"/&amp;gt;
  
    &amp;lt;&lt;strong&gt;websocket:message-broker &lt;/strong&gt;application-destination-prefix="/app"&amp;gt; &amp;lt;!-- &amp;lt;simple-broker&amp;gt; 또는 &amp;lt;stomp-broker-relay&amp;gt; 중 하나가 반드시 필요합니다 --&amp;gt;
        &amp;lt;websocket:stomp-endpoint path="/hello" &amp;gt;
            &amp;lt;websocket:sockjs&amp;gt;
                &amp;lt;websocket:transport-handlers&amp;gt;
                    &amp;lt;ref bean="&lt;strong&gt;dummyBean&lt;/strong&gt;"/&amp;gt; &amp;lt;!-- Bean은 'org.springframework.web.socket.sockjs.transport.TransportHandler' 타입이어야 합니다 --&amp;gt;
                    &amp;lt;bean class=&lt;strong&gt;"java.lang.String"&lt;/strong&gt;/&amp;gt; &amp;lt;!-- java.lang.String'은 'org.springframework.web.socket.sockjs.transport.TransportHandler'에 대입할 수 없습니다 --&amp;gt;
                &amp;lt;/websocket:transport-handlers&amp;gt;
            &amp;lt;/websocket:sockjs&amp;gt;
        &amp;lt;/websocket:stomp-endpoint&amp;gt;
        &amp;lt;websocket:stomp-broker-relay/&amp;gt;
        &amp;lt;websocket:simple-broker prefix="/topic"/&amp;gt;
        &amp;lt;websocket:broker-channel&amp;gt;
            &amp;lt;websocket:executor keep-alive-seconds="10"/&amp;gt;
            &amp;lt;websocket:interceptors&amp;gt;
              &amp;lt;ref bean="&lt;strong&gt;dummyBean&lt;/strong&gt;"/&amp;gt;  &amp;lt;!-- Bean은 'org.springframework.messaging.support.ChannelInterceptor' 타입이어야 합니다 --&amp;gt;
              &amp;lt;bean class="&lt;strong&gt;java.lang.String&lt;/strong&gt;"/&amp;gt; &amp;lt;!-- java.lang.String'은 'org.springframework.messaging.support.ChannelInterceptor'에 대입할 수 없습니다 --&amp;gt;
            &amp;lt;/websocket:interceptors&amp;gt;
        &amp;lt;/websocket:broker-channel&amp;gt;
  &amp;lt;/websocket:message-broker&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringWebSocketConfigurationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Mutiny" path="Reactive Streams"><inspection shortName="MutinyCallingSubscribeInNonBlockingScope" defaultSeverity="WARNING" displayName="'reactive' 메서드에서 'subscribe' 호출" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;'reactive' 메서드의 &lt;code&gt;subscribe()&lt;/code&gt; 호출을 보고합니다.&lt;/p&gt;
&lt;p&gt;Publisherfmf 반환하는 메서드(&lt;code&gt;Uni&lt;/code&gt; 및 &lt;code&gt;Multi&lt;/code&gt; 포함)의 경우 &lt;code&gt;subscribe()&lt;/code&gt; 메서드를 직접 호출해서는 안 됩니다. 그러면 Reactive 호출 체인이 끊어질 수 있기 때문입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;subscribe()&lt;/code&gt; 대신 &lt;code&gt;flatMap()&lt;/code&gt;, &lt;code&gt;merge()&lt;/code&gt; 등의 합성 연산자를 사용해보세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  Multi&amp;lt;String&amp;gt; stringMulti(){
    Multi&amp;lt;String&amp;gt; multi = Multi.createFrom().item("abc");
    multi.subscribe(); // &amp;lt;- 비차단 컨텍스트에서 'subscribe' 호출 차단
    return multi;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MutinyCallingSubscribeInNonBlockingScope&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="구조 검색" path=""><inspection shortName="SSBasedInspection" defaultSeverity="WARNING" displayName="구조 검색 검사" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;편집 중인 파일에 적용할 수 있는 &lt;b&gt;Structural Search/Structural Replace&lt;/b&gt; 템플릿을 구성할 수 있도록 허용합니다.
&lt;/p&gt;
&lt;p&gt;모든 일치 항목이 강조 표시되며 구성한 템플릿 이름으로 표시됩니다.
&lt;b&gt;Structural Replace&lt;/b&gt; 패턴 또한 구성하는 경우, 해당 교체 옵션을 빠른 수정으로서 사용할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SSBasedInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Micronaut" path=""><inspection shortName="MnYamlConfig" defaultSeverity="WARNING" displayName="Micronaut application.yaml" enabled="false" language="yaml" pluginId="com.intellij.micronaut" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Micronaut 애플리케이션 &lt;code&gt;.yaml&lt;/code&gt; 구성 파일에서 지원이 중단된 구성 키 및 잘못된 값을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MnYamlConfig&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MnInjectionPoints" defaultSeverity="WARNING" displayName="해결되지 않은 캐시 어노테이션 매개변수 참조" enabled="false" language="UAST" pluginId="com.intellij.micronaut" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Bean 클래스에서 누락되거나 모호한 종속성이 있는 삽입점을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  interface Engine {}

  @Singleton
  class GasEngine implements Engine {}

  @Singleton
  class ElectricEngine implements Engine {}

  @Singleton
  class Car {

    @Inject
    Engine &lt;b&gt;engine&lt;/b&gt;; // 모호한 종속성: 삽입점과 일치하는 Bean이 여러 개 있습니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MnInjectionPoints&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MnCacheAnnotationParameters" defaultSeverity="ERROR" displayName="해결되지 않은 캐시 어노테이션 매개변수 참조" enabled="false" language="UAST" pluginId="com.intellij.micronaut" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;정의되지 않은 메서드 매개변수의 이름이 &lt;code&gt;매개변수&lt;/code&gt; 속성 값에 포함된 Micronaut Cache 어노테이션을 보고합니다.&lt;/p&gt;
&lt;p&gt;지원되는 어노테이션은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.cache.annotation.Cacheable&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.cache.annotation.CachePut&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;io.micronaut.cache.annotation.CacheInvalidate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @CachePut(parameters = "myParameter") // Error: Cannot resolve symbol 'myParameter'
  public String cachedMethod(String name_is_not_equal_to_myParameter) {
    return "...";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MnCacheAnnotationParameters&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MnPropertiesConfig" defaultSeverity="WARNING" displayName="Micronaut application.properties" enabled="false" language="Properties" pluginId="com.intellij.micronaut" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Micronaut 애플리케이션 &lt;code&gt;.properties&lt;/code&gt; 구성 파일에서 지원이 중단된 구성 키 및 잘못된 값을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MnPropertiesConfig&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MnUnresolvedPathVariable" defaultSeverity="WARNING" displayName="해결되지 않은 @PathVariable 참조" enabled="false" language="UAST" pluginId="com.intellij.micronaut" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;메서드 시그니처에 선언되어 있으나 URL 경로에 누락되었거나 그 반대인 &lt;code&gt;@PathVariable&lt;/code&gt; 매개변수를 보고합니다.
  빠른 수정에서는 누락된 매개변수를 추가합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Get("/path/{myVariable}/")
  public String handler(@PathVariable String name_is_not_equal_to_myVariable) {
    return "...";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 결과는 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Get("/path/{myVariable}/")
  public String handler(@PathVariable String myVariable) {
    return "...";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MnUnresolvedPathVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 9" path="Java/Java 언어 수준 마이그레이션 지원"><inspection shortName="ReplaceNullCheck" defaultSeverity="WARNING" displayName="Null 검사를 메서드 호출로 바꿀 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Objects&lt;/code&gt; 혹은 &lt;code&gt;Stream&lt;/code&gt;의 static 메서드 호출로 대체할 수 있는 &lt;code&gt;null&lt;/code&gt; 검사를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (message == null) {
    application.messageStorage().save(new EmptyMessage());
  } else {
    application.messageStorage().save(message);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  application.messageStorage()
    .save(Objects.requireNonNullElseGet(message, () -&gt; new EmptyMessage()));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;기존 코드보다 대체 코드의 길이가 더 긴 경우 경고하지 않음&lt;/b&gt; 옵션을 사용하여 기존 코드보다 대체 코드가 긴 경우 무시합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceNullCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java9CollectionFactory" defaultSeverity="WEAK WARNING" displayName="불변 컬렉션 생성을 컬렉션 팩토리 호출로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
수정 불가하지만 최신 컬렉션 factory 메서드로 변환 가능한 &lt;code&gt;java.util.Collections&lt;/code&gt; 컬렉션 호출을 보고합니다.
이는 Java 9에 도입된 &lt;code&gt;List.of()&lt;/code&gt;나 &lt;code&gt;Set.of()&lt;/code&gt; 또는 Java 10에 도입된 &lt;code&gt;List.copyOf()&lt;/code&gt;로 대체할 수 있습니다.

&lt;p&gt;&lt;code&gt;java.util.Collections&lt;/code&gt; 메서드와 Java 9 컬렉션 factory 메서드의 차이는 다음과 같습니다. 
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;null&lt;/code&gt; 값이 허용되지 않습니다.
  &lt;li&gt;고유한 요소 및 맵 키가 필요합니다.
  &lt;li&gt;반환된 컬렉션의 &lt;code&gt;List.contains()&lt;/code&gt; 또는 &lt;code&gt;Map.get()&lt;/code&gt; 등 쿼리 메서드에 &lt;code&gt;null&lt;/code&gt; 인수가 허용되지 않습니다.
&lt;/ul&gt;
&lt;p&gt;이 경우에 위반이 발생하면 예외가 던져집니다.
  이로써 마이그레이션 후 코드 의미가 변경될 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&gt; even = Collections.unmodifiableList(
    Arrays.asList(2, 4, 6, 8, 10, 2));
  List&amp;lt;Integer&gt; evenCopy = Collections.unmodifiableList(
    new ArrayList&amp;lt;&gt;(list1));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&gt; even = List.of(2, 4, 6, 8, 10, 2);
  List&amp;lt;Integer&gt; evenCopy = List.copyOf(list);
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
제공된 인수가 컴파일 타임 상수인 경우에만 보고하려면 &lt;b&gt;비상수 콘텐츠를 경고하지 않음&lt;/b&gt; 옵션을 사용합니다.
해당 옵션을 사용하면 기존 요소의 고유성과 &lt;code&gt;null&lt;/code&gt; 가능성을 정적으로 확인할 수 없을 때도 있으므로 동작 변경 가능성이 감소합니다.
&lt;p&gt;
  &lt;b&gt;'Map.ofEntries' 제안&lt;/b&gt; 옵션을 사용하면 11개 이상의 항목을 가진 수정 불가능한 맵을 &lt;code&gt;Map.ofEntries()&lt;/code&gt;로 대체하도록 제안 받습니다.
&lt;p&gt;&lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 9부터 사용할 수 있는 Java 기능 &amp;#39;컬렉션 팩토리 메서드&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Java9CollectionFactory&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaRequiresAutoModule" defaultSeverity="WARNING" displayName="자동 모듈의 종속성" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;requires&lt;/code&gt; 지시문에서 자동 모듈의 사용을 보고합니다.
&lt;p&gt;자동 모듈은 클래스 경로의 타입에 종속될 수 있으며 명시적 모듈로 변환되는 경우 이름 및 내보낸 패키지가 변경될 수 있으므로 불안정합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-Xlint:requires-automatic&lt;/code&gt; 및 &lt;code&gt;-Xlint:requires-transitive-automatic&lt;/code&gt; Javac 옵션에 해당합니다.
첫 번째 옵션은 자동 모듈이 사용된 경우 이를 인지하도록 합니다.
두 번째 옵션은 자동 모듈에 대한 묵시적 가독성을 설정하면 모듈 사용자가 위험에 처할 수 있음을 모듈 작성자에게 경고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  //module-info.java
  module org.printer {
    requires transitive drivers.corp.org; // 'drivers.corp.org'가 자동 모듈인 경우 보고됩니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;이행적 종속성만 강조 표시&lt;/b&gt; 옵션을 사용하여 이행적 종속성만 경고합니다.
&lt;/p&gt;
&lt;p&gt;이 검사는 Java 9부터 사용할 수 있는 Java 기능 &amp;#39;모듈&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JavaRequiresAutoModule&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="제어 흐름 이슈" path="JavaScript 및 TypeScript"><inspection shortName="ConditionalExpressionWithIdenticalBranchesJS" defaultSeverity="WARNING" displayName="동일한 브랜치가 있는 조건식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동일한 &lt;code&gt;then&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 브랜치를 포함하는 삼항 조건식을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ConditionalExpressionWithIdenticalBranchesJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantConditionalExpressionJS" defaultSeverity="WARNING" displayName="상수 조건식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
서식이 다음과 같은 조건식을 보고합니다: &lt;code&gt;true? result1: result2&lt;/code&gt; 또는 &lt;code&gt;false? result1: result2&lt;/b&gt;.
표현식을 단순화할 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ConstantConditionalExpressionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfStatementWithTooManyBranchesJS" defaultSeverity="WARNING" displayName="브랜치가 너무 많은 'if' 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
브랜치가 너무 많은 &lt;code&gt;if&lt;/code&gt; 문을 보고합니다. 그러한 구문은 혼란을 일으킬 수 있으며
보통 적절하지 않은 수준의 디자인 추상화를 나타냅니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 필드를 사용해 기대되는 브랜치의 최대 개수를 지정하세요.
&lt;p&gt;&lt;small&gt;Inspection ID: IfStatementWithTooManyBranchesJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryContinueJS" defaultSeverity="WARNING" displayName="불필요한 'continue' 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루프 끝의 불필요한 &lt;code&gt;continue&lt;/code&gt; 문을 보고합니다. 그러한 구문을 제거할 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryContinueJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLabelOnContinueStatementJS" defaultSeverity="WARNING" displayName="'continue' 문의 불필요한 라벨" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
제어의 흐름을 변경하지 않고 삭제할 수 있는 
라벨이 지정된 &lt;code&gt;continue&lt;/code&gt; 문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryLabelOnContinueStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrivialConditionalJS" defaultSeverity="WARNING" displayName="중복 조건식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
서식이 다음과 같은 조건식을 보고합니다.
&lt;pre&gt;&lt;code&gt;
condition ? true : false
condition ? false : true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  이러한 표현식은 다음으로 안전하게 변환할 수 있습니다.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
condition
!condition
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TrivialConditionalJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfStatementWithIdenticalBranchesJS" defaultSeverity="WARNING" displayName="브랜치가 동일한 'if' 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동일한 &lt;code&gt;then&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 브랜치를 포함하는 &lt;code&gt;if&lt;/code&gt; 문을 보고합니다. 그러한 구문은 거의
확실히 오류입니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IfStatementWithIdenticalBranchesJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessBooleanExpressionJS" defaultSeverity="WARNING" displayName="무의미한 구문 또는 부울 표현식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
의미가 없거나 쓸데없이 복잡한 bool 표현식 또는 구문을 보고합니다.
&lt;p&gt;예:
&lt;pre&gt;&lt;code&gt;
  let a = !(false &amp;&amp; x);
  let b = false || x;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 결과는 다음과 같습니다.
&lt;pre&gt;&lt;code&gt;
  let a = true;
  let b = x;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PointlessBooleanExpressionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLabelOnBreakStatementJS" defaultSeverity="WARNING" displayName="'break' 문의 불필요한 라벨" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
제어의 흐름을 변경하지 않고 삭제할 수 있는 라벨이 지정된 &lt;code&gt;break&lt;/code&gt; 문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryLabelOnBreakStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TailRecursionJS" defaultSeverity="WARNING" displayName="꼬리 재귀" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
꼬리 재귀, 즉 함수가 반환 전 마지막 액션으로 그 자체를 호출하는 경우를 보고합니다.  꼬리 재귀는 항상 루프로 바꿀 수 있으며, 그래야 훨씬 빠르게 처리됩니다.
일부 JavaScript 엔진은 이 최적화를 수행하는 반면 다른 엔진은 수행하지 않습니다.  그러므로 꼬리 재귀 해결책은 환경에 따라 성능 특성이 상당히 다를 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TailRecursionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousTypeOfGuard" defaultSeverity="WARNING" displayName="소리 없는 타입 가드 검사" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
받아들여지지 않는 &lt;code&gt;typeof&lt;/code&gt; 또는 &lt;code&gt;instanceof&lt;/code&gt; 타입 가드 검사를 보고합니다.
&lt;code&gt;typeof x&lt;/code&gt; 타입 가드는 다음 두 가지 경우 중 하나에 받아들여지지 않을 수 있습니다:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;typeof x&lt;/code&gt;는 절대 지정된 값에 해당하지 않습니다(예: &lt;code&gt;x&lt;/code&gt;가 'string | boolean' 타입인 경우 &lt;code&gt;typeof x === 'number'&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typeof x&lt;/code&gt;는 항상 지정된 값에 해당합니다(예: &lt;code&gt;x&lt;/code&gt;가 'string' 타입인 경우 &lt;code&gt;typeof x === 'string'&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;code&gt;x instanceof A&lt;/code&gt; 타입 가드는 다음 두 가지 경우 중 하나에 받아들여지지 않을 수 있습니다:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;x&lt;/code&gt;의 타입은 &lt;code&gt;A&lt;/code&gt;와 관련이 없습니다&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;x&lt;/code&gt;의 타입은 &lt;code&gt;A&lt;/code&gt;이거나 &lt;code&gt;A&lt;/code&gt;의 하위 타입입니다&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousTypeOfGuard&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnreachableCodeJS" defaultSeverity="WARNING" displayName="사용할 수 없는 코드" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
절대 실행할 수 없는 코드를 보고합니다. 이는 거의 확실히 오류를 나타냅니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnreachableCodeJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateConditionJS" defaultSeverity="WARNING" displayName="'if' 문의 중복 조건" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;if&lt;/code&gt; 문의 각기 다른 브랜치에서 중복된 조건을 보고합니다. 조건 중복은 보통 프로그래머의 실수를 나타냅니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (a) {
    ...
  } else if (a) {
    ...
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DuplicateConditionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryReturnJS" defaultSeverity="WARNING" displayName="불필요한 'return' 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 &lt;code&gt;return&lt;/code&gt; 문, 즉 값을 반환하지 않고 함수가 맨 아래까지 '폴 스루'하기 직전에 나타나는 &lt;code&gt;return&lt;/code&gt; 문을 보고합니다.
이러한 구문은 안전하게 제거할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryReturnJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrivialIfJS" defaultSeverity="WARNING" displayName="중복 'if' 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단일 대입 또는 &lt;code&gt;return&lt;/code&gt; 문으로 
단순화할 수 있는 &lt;code&gt;if&lt;/code&gt; 문을 
보고합니다.  &lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if(foo())
 {
  return true;
 }
 else
 {
   return false;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 코드는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;
 &lt;code&gt;return foo();&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TrivialIfJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopStatementThatDoesntLoopJS" defaultSeverity="WARNING" displayName="루프를 실행하지 않는 루프 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 최대 한 번 실행되는 것이 보증되는 &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, 또는 &lt;code&gt;do&lt;/code&gt; 문을 보고합니다. 이는 보통 오류를 나타냅니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LoopStatementThatDoesntLoopJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForLoopReplaceableByWhileJS" defaultSeverity="WARNING" displayName="'for' 루프를 'while' 루프로 바꿀 수 있음" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
초기화와 업데이트 구성 요소를 모두 포함하지 않는 &lt;code&gt;for&lt;/code&gt; 루프를 보고합니다. 루프를 간단한 &lt;code&gt;while&lt;/code&gt; 문으로 바꿀 것을 제안합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for(; exitCondition(); ) {
    process();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 결과는 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  while(exitCondition()) {
    process();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사가 자명하거나 존재하지 않는 조건을 포함하는 &lt;b&gt;for&lt;/b&gt; 루프를 무시하기를 원한다면 아래 체크박스를 사용하십시오.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ForLoopReplaceableByWhileJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLabelJS" defaultSeverity="WARNING" displayName="불필요한 라벨" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
사용되지 않는 라벨을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryLabelJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSObjectNullOrUndefined" defaultSeverity="WARNING" displayName="객체가 'null' 또는 'undefined'입니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;undefined&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt;인 객체에서 메서드 호출, 프로퍼티 접근, 또는 함수 호출로 발생한 오류를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSObjectNullOrUndefined&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JavaBeans 문제" path="Java"><inspection shortName="ClassWithoutConstructor" defaultSeverity="WARNING" displayName="생성자가 없는 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
생성자가 없는 클래스를 보고합니다.
&lt;p&gt;일부 코딩 표준에서는 이러한 클래스를 금지합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ClassWithoutConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithoutNoArgConstructor" defaultSeverity="WARNING" displayName="비인수 생성자가 없는 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인수를 취하지 않는 생성자가 없는 클래스를 보고합니다(즉, 매개변수가 없습니다).
일부 컨텍스트에서는 인수가 없는 생성자가 필요합니다. 예를 들어, 리플렉션을 사용하여 클래스를 생성해야 하는 경우가 이에 해당합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Bean {
    private String name;

    public Bean(String name) {
      this.name = name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  명시적 생성자가 없는 클래스를 무시하려면 아래 체크박스를 사용하세요.
  컴파일러는 그러한 클래스에 인수가 없는 디폴트 생성자를 제공합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: ClassWithoutNoArgConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldHasSetterButNoGetter" defaultSeverity="WARNING" displayName="필드에 setter는 있지만 getter가 없음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
setter 메서드는 있지만 getter 메서드가 없는 필드를 보고합니다.
&lt;p&gt;
  특정 Bean 컨테이너에서 Java Bean 사양 내에 사용될 때 그러한 필드는 작동하기 어려울 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FieldHasSetterButNoGetter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousGetterSetter" defaultSeverity="WARNING" displayName="의심스러운 getter/setter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름에 따라 필요하지 않는 필드에 액세스하는 getter 또는 setter 메서드를 보고합니다.
예를 들어, &lt;code&gt;getY()&lt;/code&gt;가 &lt;code&gt;x&lt;/code&gt; 필드를 반환하는 경우를 말합니다. 이는 보통 복사-붙여넣기 오류일 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Point {
    private int x;
    private int y;

    public void setX(int x) { // 경고: setter 'setX()'가  필드 'y'를 대입합니다
      this.y = x;
    }

    public int getY() { // 경고: getter 'getY()'가 필드 'x'를 반환합니다
      return x;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 체크박스를 사용하여 클래스 내 필드의 이름이 getter 또는 setter의 이름과 일치하는 경우를 보고하세요.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousGetterSetter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PropertyValueSetToItself" defaultSeverity="WARNING" displayName="자신에게 설정된 프로퍼티값" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
같은 객체 getter가 값으로 사용된 setter 메서드의 호출을 보고합니다.
보통 이러한 코드는 아무 것도 수행하지 않으며 의도되지 않은 것일 가능성이 큽니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bean.setPayerId(bean.getPayerId());&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PropertyValueSetToItself&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="코드" path="Spring/Spring Core"><inspection shortName="SpringContextConfigurationInspection" defaultSeverity="ERROR" displayName="잘못된 @ContextConfiguration" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 Spring 컨텍스트 구성을 보고합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;locations&lt;/code&gt; 속성 및 &lt;code&gt;@ContextConfiguration&lt;/code&gt; 메타 어노테이션에 해당하는 별칭 속성의 확인되지 않은 파일 및 디렉터리를 보고합니다.
  &lt;/li&gt;
  &lt;li&gt;누락된 디폴트 애플리케이션 컨텍스트 파일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자세한 내용은 &lt;a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/ContextConfiguration.html&gt;@ContextConfiguration&lt;/a&gt;을 참조하세요.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @ContextConfiguration(locations = "classpath:META-INF/unknown-context.xml") // "파일 'unknown-context.xml'을 해결할 수 없습니다"라고 보고됩니다
  class MyTests {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringContextConfigurationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringRequiredAnnotationInspection" defaultSeverity="ERROR" displayName="@Required Spring Bean 프로퍼티가 삽입되지 않았습니다" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;삽입되거나 오토와이어링되지 않은 &lt;code&gt;@Required&lt;/code&gt; setter bean 프로퍼티를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
&amp;lt;beans&amp;gt;
  &amp;lt;bean class="beans.MyComponent" id="foo"/&amp;gt;
  &amp;lt;!-- "필수 프로퍼티 누락: 'port'"를 보고합니다 --&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
public class MyComponent {
   @Required
   public void setPort(int port) // "필수 프로퍼티 'port'가 삽입되지 않았습니다"라고 보고됩니다
   {...}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringRequiredAnnotationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringLookupInjectionInspection" defaultSeverity="ERROR" displayName="Spring 구성 요소의 @Lookup 어노테이션 내 잘못 참조된 Bean" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Lookup.html"&gt;@Lookup&lt;/a&gt; 어노테이션의 &lt;code&gt;value&lt;/code&gt; 매개변수에 있는 잘못된 bean 참조를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Component public class FooBean {...}
  @Component public class OtherBean {...}

  @Component public class MyComponent {
  @Lookup("fooBean")
  public FooBean fooBean() {...}

  @Lookup("fooBean") // "Bean이 'OtherBean' 타입이어야 합니다"라고 보고됩니다
  public OtherBean otherBean() {...}

  @Lookup("unknown") // reports "Cannot resolve bean 'unknown'"
  public OtherBean fooBean() {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringLookupInjectionInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringCacheAnnotationsOnInterfaceInspection" defaultSeverity="WARNING" displayName="인터페이스/인터페이스 메서드에서 정의된 Cache* 어노테이션" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;인터페이스의 &lt;code&gt;@Cache*&lt;/code&gt; 어노테이션을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@Cache*&lt;/code&gt; 어노테이션은 구상 클래스(및 구상 클래스의 메서드)에만 추가해야 합니다.
&lt;code&gt;@Cache*&lt;/code&gt; 어노테이션을 인터페이스(또는 인터페이스 메서드)에 추가하려면 인터페이스 기반의 프록시를 사용해야 합니다.
Java 어노테이션은 인터페이스에서 상속되지 않으므로, 클래스 기반의 프록시(&lt;code&gt;proxy-target-class="true"&lt;/code&gt;) 또는 위빙 기반의 어스펙트(&lt;code&gt;mode="aspectj"&lt;/code&gt;)를 사용할 경우 프록싱 및 위빙 인프라는 캐싱 설정을 인식할 수 없습니다.
결과적으로 캐싱 프록시가 객체를 감싸지 않습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringCacheAnnotationsOnInterfaceInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringCacheableMethodCallsInspection" defaultSeverity="WARNING" displayName="@Cacheable 자기 호출 메서드 호출" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://docs.spring.io/spring-framework/reference/integration/cache/annotations.html"&gt;@Cacheable 사용&lt;/a&gt;: 프록시 모드(디폴트)에서는 프록시를 통해 들어오는 외부 메서드 호출만 인터셉트됩니다.
즉, 자기 호출(타깃 객체의 다른 메서드를 호출하는 타깃 객체 내의 메서드)은 호출된 메서드가 @Cacheable로 표시되어도 런타임에 실제 캐싱을 발생시키지 않습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringCacheableMethodCallsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringCacheableComponentsInspection" defaultSeverity="ERROR" displayName="잘못 구성된 'caching' 어노테이션" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
잘못된 'caching' 어노테이션을 보고합니다(예: &lt;code&gt;@Cacheable&lt;/code&gt;, &lt;code&gt;@CacheEvict&lt;/code&gt;, &lt;code&gt;@CachePut&lt;/code&gt;, &lt;code&gt;@CacheConfig&lt;/code&gt; 등).

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
@org.springframework.stereotype.Component
public class MyCacheManager implements CacheManager {...}

public class MyConfiguration {
   @Cacheable(value = "a",
       cacheResolver ="myCacheManager") // "Bean은 'org.springframework.cache.interceptor.CacheResolver' 타입이어야 합니다"라고 보고합니다
   public String getCache(String isbn) {...}

   @Cacheable(value = "abc",
   private String getAbc() // "어노테이션 캐싱은 public 메서드에 정의되어야 합니다"라고 보고됩니다
   {...}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringCacheableComponentsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringTestingOverridenBeanResolveInspection" defaultSeverity="ERROR" displayName="@MockitoBean, @MockitoSpyBean 및 @TestBean 어노테이션 내 잘못 참조된 Bean" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;MockitoBean, @MockitoSpyBean 및 @TestBean 어노테이션의 &lt;code&gt;value&lt;/code&gt; 매개변수에 있는 잘못된 bean/메서드 참조를 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@SpringBootTest
class TestBeanApplicationTests {
   @TestBean(value = "unknownBean", methodName="createUserService")  // 1. "'unknownBean' bean을 해결할 수 없습니다"  및 2. "심볼 'createUserService'를 해결할 수 없습니다"를 보고합니다
   UserService userService;

  @TestBean  // "static 팩토리 메서드를 찾을 수 없습니다"를 보고합니다
  UserService userService;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringTestingOverridenBeanResolveInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringTestingDirtiesContextInspection" defaultSeverity="WARNING" displayName="잘못된 @DirtiesContext 'mode' 구성" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/annotation/DirtiesContext.html"&gt;@DirtiesContext&lt;/a&gt; 어노테이션의 잘못된 'mode' 구성을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @ContextConfiguration
  @DirtiesContext(methodMode = MethodMode.AFTER_METHOD, // 어노테이션이 추가된 테스트 클래스에서 메서드 모드를 설정하는 것은 무의미합니다. 클래스 수준으로 제어하려면 classMode를 대신 사용하세요.
                  hierarchyMode = DirtiesContext.HierarchyMode.CURRENT_LEVEL) // 컨텍스트가 @ContextHierarchy를 통해 계층 구조의 일부로 구성된 경우, hierarchyMode를 사용해야 합니다
  public class MyTest {
    @DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS, // 어노테이션이 추가된 테스트 메서드에서 클래스 모드를 설정하는 것은 무의미합니다. 메서드 수준으로 제어하려면 methodMode를 대신 사용하세요.
                     hierarchyMode = DirtiesContext.HierarchyMode.CURRENT_LEVEL) // 컨텍스트가 @ContextHierarchy를 통해 계층 구조의 일부로 구성된 경우, hierarchyMode를 사용해야 합니다
    public void testFoo() {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringTestingDirtiesContextInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringTestingSqlInspection" defaultSeverity="WARNING" displayName="잘못된 @Sql 및 @SqlGroup 구성" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/jdbc/Sql.html&gt;@Sql&lt;/a&gt; 어노테이션의 &lt;code&gt;scripts&lt;/code&gt; 속성 및 &lt;code&gt;@Sql&lt;/code&gt; 메타 어노테이션에 해당하는 별칭 속성의 해결되지 않은 파일 참조를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @SqlGroup({
     @Sql("not-found"), // "파일 'not-found'를 해결할 수 없습니다"라고 보고됩니다
     @Sql("found.sql")
  })
  public class MyTestWithSqlData {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringTestingSqlInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringDependsOnUnresolvedBeanInspection" defaultSeverity="ERROR" displayName="@DependsOn 어노테이션의 잘못 참조된 bean" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html"&gt;@DependsOn&lt;/a&gt; 어노테이션의 &lt;code&gt;value&lt;/code&gt; 매개변수에서 잘못된 bean 참조를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Component
  @DependsOn("unknown")  // "'unknown' bean을 해결할 수 없음"을 보고함
  public class MyComponent {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringDependsOnUnresolvedBeanInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringConfigurationProxyMethods" defaultSeverity="ERROR" displayName="@Configuration proxyMethods 사용 위치 경고" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
부적절하게 사용된 프록시 메서드에 대한 경고를 보고합니다.

Spring Framework 5.2에는 @Configuration 클래스 처리 최적화가 도입되었으며, 이는 @Configuration(proxyBeanMethods = false) 속성을 통해 활성화할 수 있습니다.
&lt;p&gt;
&lt;code&gt;proxyBeanMethods&lt;/code&gt;를 비활성화하면, 프록시 인스턴스가 더 이상 생성되지 않으며 메서드를 호출하면 해당 메서드가 다시 호출됩니다(매번 새 인스턴스 반환).
그렇게 되면 컨텍스트에서 해당 Bean이 실제로 삽입되도록 보장할 수 없습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;잘못된 Bean 메서드 호출 예시:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
@Configuration(proxyBeanMethods = false)
class TestConfiguration {
  @Bean
  public FirstBean firstBean() {
    return new FirstBean();
  }

  @Bean
  public SecondBean secondBean() {
    return new SecondBean(firstBean()); // -&gt; 잘못된 호출
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;&lt;code&gt;proxyBeanMethods&lt;/code&gt;를 true로 설정하거나 다음과 같이 코드를 다시 작성할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
@Configuration(proxyBeanMethods = false)
class TestConfiguration {
  @Bean
  public FirstBean firstBean() {
    return new FirstBean();
  }

  @Bean
  public SecondBean secondBean(FirstBean someBean) { // -&gt; 올바르게 삽입된 인스턴스
    return new SecondBean(someBean);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또한 이 검사는 &lt;code&gt;@Configuration&lt;/code&gt; 스테레오 타입이 없는 클래스에서 실행되는 &lt;code&gt;@Bean&lt;/code&gt; 메서드 호출을 검사합니다('Bean Lite Mode'에서).&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
@Component
class TestComponent {
  @Bean
  public FirstBean firstBean() {
    return new FirstBean();
  }

  @Bean
  public SecondBean secondBean() {
    return new SecondBean(firstBean()); // -&gt; 잘못된 호출
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: SpringConfigurationProxyMethods&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringCacheableAndCachePutInspection" defaultSeverity="WARNING" displayName="동일한 메서드에서의 잘못된 @CachePut 및 @Cacheable 사용" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;동일 메서드에 선언된 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/CachePut.html"&gt;@CachePut&lt;/a&gt; 및 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html"&gt;@Cacheable&lt;/a&gt; 어노테이션을 보고합니다.&lt;/p&gt;

&lt;code&gt;@Cacheable&lt;/code&gt; 어노테이션이 있으면 메서드가 캐시를 사용하여 실행을 건너뛰는 반면 &lt;code&gt;@CachePut&lt;/code&gt;은 실행을 강제하여 캐시를 업데이트합니다.
이렇게 되면 예기치 않은 동작이 발생하므로 어노테이션 조건이 서로 배타적인 매우 특수한 경우를 제외하고는 사용해서는 안 됩니다.
또한 이러한 조건은 배타성 확인을 위해 사전에 유효성이 검사되므로 결과 객체(&lt;code&gt;#result&lt;/code&gt; 변수)에 의존해서는 안 됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringCacheableAndCachePutInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringJavaStaticMembersAutowiringInspection" defaultSeverity="WARNING" displayName="static 클래스 멤버에 대한 잘못된 Spring 구성 요소 오토와이어링 또는 삽입" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Spring 구성 요소에서 오토와이어링되거나 삽입된 static 메서드/필드를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@Component
public class MyComponent {
	@Autowired
	static FooInterface foo;  // "static 멤버를 오토와이어링하면 안 됩니다"라고 보고됩니다
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringJavaStaticMembersAutowiringInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringPropertySource" defaultSeverity="WARNING" displayName="@PropertySource 및 @TestPropertySource 위치 내 해결되지 않은 파일 참조" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/PropertySource.html&gt;@PropertySource&lt;/a&gt;
및 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/TestPropertySource.html"&gt;@TestPropertySource&lt;/a&gt; 어노테이션에서 해결되지 않은 파일 또는 디렉터리를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Configuration
  @PropertySource("classpath:/com/mycompany/unknown.properties") // "파일 unknown.properties를 해결할 수 없습니다"
  public class AppConfig {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringPropertySource&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringImportResource" defaultSeverity="WARNING" displayName="@ImportResource 위치 내 해결되지 않은 파일 참조" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ImportResource.html"&gt;@ImportResource&lt;/a&gt; 어노테이션의 &lt;code&gt;locations&lt;/code&gt; 속성 및 &lt;code&gt;@ImportResource&lt;/code&gt; 메타 어노테이션에 해당하는 별칭 속성에서 해결되지 않은 파일과 디렉터리를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Configuration
  @ImportResource(locations = "classpath:META-INF/unknown-context.xml") // reports "Cannot resolve file 'unknown-context.xml'"
  public class MyConfiguration {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringImportResource&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringProfileExpression" defaultSeverity="ERROR" displayName="잘못 구성된 @Profile 표현식" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된
&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Profile.html"&gt;@Profile&lt;/a&gt;
표현식을 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Spring 프로파일은 공백일 수 없습니다&lt;/li&gt;
  &lt;li&gt;Spring 프로파일 표현식에서 '&amp;' 및 '|' 연산자는 괄호 없이 함께 사용할 수 없습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  // 올바르게 구성됨
  @Configuration
  @Profile("a &amp; (b | c)")
  public class MyConfiguration {...}

  // empty 
  @Configuration
  @Profile() // "프로파일 표현식은 텍스트를 포함해야 합니다"라고 보고됩니다
  public class MyConfiguration {...}

  // mixed operators without  parentheses
  @Configuration
  @Profile("a &amp; b | c") // "형식이 잘못된 프로파일 표현식"이라고 보고됩니다
  public class MyConfiguration {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringProfileExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringJavaInjectionPointsAutowiringInspection" defaultSeverity="ERROR" displayName="Spring Bean 구성 요소 내 잘못된 오토와이어링" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Spring bean &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html"&gt;@Component&lt;/a&gt;, &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Service.html"&gt;@Service&lt;/a&gt; 및 그 외의 삽입 지점에서 발생한 모든 오토와이어링 문제를 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;'concrete' 타입 bean 2개 이상&lt;/li&gt;
  &lt;li&gt;'concrete' 타입 bean 없음&lt;/li&gt;
  &lt;li&gt;한정자가 있는 bean 없음&lt;/li&gt;
  &lt;li&gt;Spring bean 생성자에서 &lt;code&gt;@Autowired&lt;/code&gt;의 잘못된 사용 위치&lt;/li&gt;
  &lt;li&gt;유효한 Spring bean이 아닌 클래스에 삽입되거나 오토와이어링된 필드/메서드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
public interface FooInterface {...}
  @Component public class FooBean implements FooInterface {...}
  @Component public class OtherBean implements FooInterface {...}

@Component
public class MyComponent {
	@Autowired
	FooInterface foo;  // "오토와이어링을 수행할 수 없습니다. 'FooInterface' 타입의 bean이 2개 이상 있습니다.
                     // Bean: fooBean(FooBean.java), otherBean(OtherBean.java)"
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
@Component
public class MyComponent {
	@Autowired
	public MyComponent(BarBean bean) {...} // "단 하나의 @Autowired 생성자만 허용됩니다"라고 보고됩니다

	@Autowired
	public MyComponent(FooBean bean) {...} // "단 하나의 @Autowired 생성자만 허용됩니다"라고 보고됩니다
}

@Component
public class MyFactory {  // "일치하는 @Autowired 생성자가 없습니다"라고 보고됩니다
	public MyFactory(String str) {...}
	public MyFactory(int count) {...}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
public class FooBeanClass {
  @Autowired   // '올바른 Spring bean(@Component, @Service 등)에서 오토와이어링된 멤버를 정의해야 합니다'라고 보고됩니다
  ServiceBean bean;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringJavaInjectionPointsAutowiringInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ContextJavaBeanUnresolvedMethodsInspection" defaultSeverity="ERROR" displayName="@Bean 어노테이션 내 알 수 없는 init/destroy 메서드" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html"&gt;@Bean&lt;/a&gt; 어노테이션의 &lt;code&gt;initMethod&lt;/code&gt; 및 &lt;code&gt;destroyMethod&lt;/code&gt;에서 확인되지 않은 메서드 참조를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
MyBean 클래스에 'public void 'doInit'(){...}' 메서드가 포함되지 않을 경우, 'doInit' 표현식에서 "메서드를 해결할 수 없습니다"라고 보고됩니다.
&lt;pre&gt;&lt;code lang="java"&gt;
  public class MyBean {...}

  @Component
  public class MyComponent {
     @Bean(initMethod="doInit" )
     public MyBean myBean() {...}
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 예시에서 &lt;code&gt;MyBean&lt;/code&gt;이 &lt;code&gt;doInit()&lt;/code&gt; 메서드를 정의하지 않을 경우, 검사는 해결되지 않은 메서드 참조를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ContextJavaBeanUnresolvedMethodsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ScheduledMethodInspection" defaultSeverity="WARNING" displayName="잘못된 @Scheduled 메서드 시그니처" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html"&gt;@Scheduled&lt;/a&gt; 메서드를 보고합니다.&lt;/p&gt;

&lt;p&gt;Spring 문서에 따르면 예약된 메서드는 void를 반환해야 하며 인수가 올 수 없습니다.
  이 메서드가 애플리케이션 컨텍스트의 다른 객체와 상호작용해야 할 경우, 종속성 삽입을 통해 제공되어야 합니다.&lt;/p&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ScheduledMethodInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringComponentScan" defaultSeverity="ERROR" displayName="@ComponentScan 또는 해당 메타 어노테이션 내 잘못된 패키지" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ComponentScan.html&gt;@ComponentScan&lt;/a&gt; 어노테이션 및 &lt;code&gt;@ComponentScan&lt;/code&gt; 메타 어노테이션의 해당하는 별칭 속성에서 해결되지 않은 패키지를 보고합니다.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @ComponentScan(basePackages = {
     "com.my.company",
     "com.unknown" // "패키지 'unknown'을 해결할 수 없습니다"라고 보고됩니다
  }) +
  @Configuration +
  public class MyConfiguration {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringComponentScan&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringTestingTransactionalInspection" defaultSeverity="WARNING" displayName="잘못된 트랜잭션 생명 주기 메서드 선언" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html"&gt;@Transactional&lt;/a&gt; 어노테이션이 추가된 테스트 클래스에서 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/transaction/BeforeTransaction.html"&gt;@BeforeTransaction&lt;/a&gt;
및 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/transaction/AfterTransaction.html"&gt;@AfterTransaction&lt;/a&gt; 어노테이션이 추가된 잘못된 트랜잭션 수명 주기 메서드 선언을 보고합니다.&lt;/p&gt;

&lt;p&gt;어노테이션 추가된 메서드에는 인수나 반환 타입이 포함될 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @ContextConfiguration
  @Transactional
  public class AbstractShowcaseTest {
    @BeforeTransaction // 필요한 메서드 반환 타입은 'void'입니다
    public boolean setupData() {...}

    @AfterTransaction // 잘못된 인수 수
    public void disposeData(boolean a) throws Exception {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringTestingTransactionalInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringTransactionalComponentInspection" defaultSeverity="ERROR" displayName="@Transactional 구성 요소 내 잘못된 'PlatformTransactionManager' 선언" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
현재 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html"&gt;@Transactional&lt;/a&gt; 구성 요소에 대한 애플리케이션 컨텍스트에서 부적절하게 정의된 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html"&gt;PlatformTransactionManager&lt;/a&gt; 클래스를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringTransactionalComponentInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;

</inspection><inspection shortName="SpringScheduledMethodsInspection" defaultSeverity="ERROR" displayName="@Scheduled 어노테이션 내 잘못 참조된 bean" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;@Scheduled 어노테이션의 &lt;code&gt;scheduler&lt;/code&gt; 매개변수 내에서 잘못된 bean 참조를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Component public class UserController {...}
  @Component public class UserServiceAsyncTaskScheduler extends SimpleAsyncTaskScheduler {...}

  @Component public class UserService {
    @Scheduled(scheduler="userServiceAsyncTaskScheduler", cron="1 * * * * * ?")
    public void scheduleTask() {...}

    @Scheduled(scheduler="userController", cron="1 * * * * * ?") // "Bean은 TaskScheduler, ScheduledExecutorService 중 하나의 타입이어야 합니다"를 보고합니다
    public void scheduleTask_2() {...}

    @Scheduled(scheduler="unknown", cron="1 * * * * * ?")   // "bean 'unknown'을 해결할 수 없습니다"를 보고합니다
    public void scheduleTask_3() {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringScheduledMethodsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringTransactionalMethodCallsInspection" defaultSeverity="WARNING" displayName="@Transactional 자동 호출 메서드 호출" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction-declarative-annotations"&gt;@Transactional 사용&lt;/a&gt;: 프록시 모드(디폴트)에서는 프록시를 통해 들어오는 외부 메서드 호출만 인터셉트됩니다.
즉, 자기 호출(타깃 객체의 다른 메서드를 호출하는 타깃 객체 내의 메서드)은 호출된 메서드가 @Transactional로 표시되어도 런타임에 실제 트랜잭션을 발생시키지 않습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringTransactionalMethodCallsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AsyncMethodInspection" defaultSeverity="WARNING" displayName="잘못된 @Async 메서드 시그니처" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html"&gt;@Async&lt;/a&gt; 메서드의 잘못된 반환 타입을 보고합니다.&lt;/p&gt;

&lt;p&gt;대상 메서드 시그니처의 경우 모든 매개변수 타입이 허용됩니다.
  그러나 반환 타입은 &lt;code&gt;void&lt;/code&gt; 또는 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html"&gt;Future&lt;/a&gt;여야 합니다.
  또한 더 구체적인 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/concurrent/ListenableFuture.html"&gt;ListenableFuture&lt;/a&gt; 또는 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html"&gt;CompletableFuture&lt;/a&gt; 타입을 반환할 수 있으므로 비동기 작업과의 풍부한 상호작용이 가능하며 추가 처리 단계를 통한 즉각적 구성이 가능합니다.&lt;/p&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AsyncMethodInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringEventListenerInspection" defaultSeverity="WARNING" displayName="잘못 구성된 @EventListener 메서드" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/EventListener.html"&gt;@EventListener&lt;/a&gt; 메서드를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Configuration @ComponentScan
  open class Config

  data class MyEvent(val string: String)

  @Component
  class LogComponent {
    @EventListener // @EventListener 어노테이션이 추가된 메서드는 public이어야 합니다
    private fun logCommands(commandName: MyEvent) {}

    @EventListener // 메서드에 최대 1개의 매개변수가 있어야 합니다
    fun processCommand(commandName: MyEvent, text: String) {}
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringEventListenerInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringCacheNamesInspection" defaultSeverity="WARNING" displayName="잘못된 필수 캐시 이름 정의" enabled="false" language="UAST" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 &lt;code&gt;@Cache*&lt;/code&gt; 어노테이션 이름을 보고합니다.&lt;/p&gt;

&lt;p&gt;캐시 연산당 최소 1개 이상의 캐시 이름이 제공되어야 합니다(&lt;code&gt;@Cacheable("cache_name")&lt;/code&gt; 또는 &lt;code&gt;@Cacheable(cacheNames ="cache_name")&lt;/code&gt;).
&lt;code&gt;@CacheConfig#cacheNames()&lt;/code&gt;는 클래스 수준에서 일반적인 캐시 관련 설정을 공유하는 데 사용됩니다.&lt;/p&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringCacheNamesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringJavaAutowiredFieldsWarningInspection" defaultSeverity="WEAK WARNING" displayName="권장되지 않는 필드 삽입" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Spring 구성 요소에서 삽입 또는 오토와이어링된 필드를 보고합니다.&lt;/p&gt;

&lt;p&gt;빠른 수정은 필수 필드의 bean 및 어설션에서 권장되는 생성자 기반의 종속성 삽입을 제안합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class MyComponent {
  @Inject MyCollaborator collaborator; // 삽입된 필드

  public void myBusinessMethod() {
    collaborator.doSomething(); // NullPointerException을 던집니다
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;

&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class MyComponent {

  private final MyCollaborator collaborator;

  @Inject
  public MyComponent(MyCollaborator collaborator) {
    Assert.notNull(collaborator, "MyCollaborator must not be null!");
    this.collaborator = collaborator;
  }

  public void myBusinessMethod() {
    collaborator.doSomething(); // 이제 이 호출은 안전합니다
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringJavaAutowiredFieldsWarningInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring Boot" path="Spring"><inspection shortName="SpringBootReactorHooksOnDebug" defaultSeverity="WARNING" displayName="의심스러운 Hooks.onOperatorDebug() 사용 위치" enabled="false" language="UAST" pluginId="com.intellij.spring.boot" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;ReactorDebugAgent.init()&lt;/code&gt;이 호출된 경우 &lt;code&gt;Hooks.onOperatorDebug()&lt;/code&gt;가 사용된 위치를 보고합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;ReactorDebugAgent&lt;/code&gt;가 클래스 경로에 있고 &lt;code&gt;spring.reactor.debug-agent.enabled&lt;/code&gt;가 &lt;code&gt;true&lt;/code&gt;인 경우(디폴트 값) 시작 시 &lt;code&gt;ReactorDebugAgent.init()&lt;/code&gt;이 자동으로 호출됩니다.
  또한 &lt;code&gt;Hooks.onOperatorDebug()&lt;/code&gt; 및 &lt;code&gt;ReactorDebugAgent.init()&lt;/code&gt;으로 인해 Reactor에서 생성되는 디버그 스택 프레임이 두 배로 증가합니다.
  그뿐 아니라 &lt;code&gt;Hooks.onOperatorDebug()&lt;/code&gt;는 성능 오버헤드를 초래할 수 있습니다.
&lt;/p&gt;

&lt;p&gt;빠른 수정은 &lt;code&gt;Hooks.onOperatorDebug()&lt;/code&gt;의 호출을 제거합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public void hook() {
    Hooks.onOperatorDebug(); // 'ReactorDebugAgent가 초기화되는 동안 Hooks.onOperatorDebug()를 호출합니다'라고 보고됩니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public void hook() {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 Spring Boot 2.2.0 이후 버전에서만 트리거됩니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SpringBootReactorHooksOnDebug&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBootApplicationYaml" defaultSeverity="WARNING" displayName="잘못된 YAML 구성" enabled="false" language="yaml" pluginId="com.intellij.spring.boot" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  Spring Boot 애플리케이션 &lt;code&gt;.yaml&lt;/code&gt; 구성 파일에서 해결되지 않거나 지원이 중단된 구성 키 및 잘못된 값을 보고합니다. 이러한 요소는 런타임 오류로 이어질 수 있습니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
server:
  port: invalid # ' 'invalid'를 java.lang.Integer로 변환할 수 없습니다'라고 보고됩니다
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;지원 중단된 구성 키의 대체 키가 있는 경우 '대체 키 사용'이라는 빠른 수정을 적용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
logging:
  path: ${path} # '지원 중단된 구성 프로퍼티 'logging.path'를 보고합니다'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
logging:
  file:
    path: ${path}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
  구성 키가 &lt;code&gt;spring-configuration-metadata.json&lt;/code&gt;에 정의되지 않은 경우 '구성 키 정의'라는 빠른 수정을 적용하여 &lt;code&gt;META-INF/spring-additional-configuration-metadata.json&lt;/code&gt; 파일을 생성하고 필요한 키를 정의할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
new:
  key: value # Reports 'Cannot resolve configuration property 'new.key''
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정 적용 후 &lt;code&gt;META-INF/spring-additional-configuration-metadata.json&lt;/code&gt;에 다음 코드가 추가됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
{
  "properties": [
    {
      "name": "new.key",
      "type": "java.lang.String",
      "description": "Description for new.key."
  }
] }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;대체 토큰&lt;/b&gt; 옵션을 사용하여 구성 파일의 값 자리표시자에 사용할 토큰을 정의할 수 있습니다.
  이러한 토큰은 &lt;code&gt;beginToken*endToken&lt;/code&gt; 형식으로 지정됩니다.
  &lt;code&gt;*&lt;/code&gt;가 없을 경우 시작 및 종료 토큰이 동일한 것으로 가정됩니다.
&lt;/p&gt;
&lt;p&gt;
  예를 들어, 시작 및 종료 토큰 모두의 디폴트 값은 &lt;code&gt;@&lt;/code&gt;이며, 이를 통해 &lt;code&gt;some.property=@another.property@&lt;/code&gt;과 같은 자리표시자를 정의할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;대체 토큰(&lt;code&gt;@property.key@&lt;/code&gt;) 내부의 값은 강조 표시되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SpringBootApplicationYaml&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBootAdditionalConfig" defaultSeverity="ERROR" displayName="잘못된 additional-spring-configuration-metadata.json" enabled="false" language="JSON" pluginId="com.intellij.spring.boot" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  &lt;code&gt;additional-spring-configuration-metadata.json&lt;/code&gt; 구성 파일의 누락되거나 지원이 중단된 프로퍼티, 확인되지 않은 참조, 잘못된 값을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  {
    "properties": [
      {
        "name": "old.key",
        "type": "com.Unknown", // '클래스 'Unknown'을 해결할 수 없습니다'라고 보고됩니다
        "description": "Description for old.key", // '텍스트가 '.'로 끝나야 합니다'라고 보고됩니다
        "deprecation": {
          "replacement": "new.key", // '구성 키 참조 'new.key'를 해결할 수 없습니다'라고 보고됩니다
          "reason": "Reason", // '텍스트가 '.'로 끝나야 합니다'라고 보고됩니다
          "level": "warning"
         }
      },
      {
        "name": "duplicate", // ' 'duplicate'에 대해 중복된 항목'이라고 보고됩니다
        "type": "java.lang.String"
      },
      {
        "name": "duplicate", // ' 'duplicate'에 대해 중복된 항목'이라고 보고됩니다
        "type": "java.lang.String"
      },
      {
        // '필수 'name' 누락'이라고 보고됩니다
        "type": "java.lang.String"
      }
    ]
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SpringBootAdditionalConfig&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBootApplicationSetup" defaultSeverity="ERROR" displayName="잘못된 Spring Boot 애플리케이션 설정" enabled="false" language="UAST" pluginId="com.intellij.spring.boot" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;디폴트 패키지의 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 및 불필요한 &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 또는 &lt;code&gt;@ComponentScan&lt;/code&gt; 어노테이션을 보고합니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 불필요한 어노테이션을 제거합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
@SpringBootApplication
@ComponentScan // '불필요한 선언: @SpringBootApplication에 @ComponentScan이 이미 포함되어 있습니다'라고 보고됩니다
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @SpringBootApplication
  public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SpringBootApplicationSetup&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConfigurationProperties" defaultSeverity="ERROR" displayName="잘못된 @ConfigurationProperties" enabled="false" language="UAST" pluginId="com.intellij.spring.boot" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;@ConfigurationProperties&lt;/code&gt; 어노테이션에 정의된 잘못된 접두사를 보고합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;누락된 접두사&lt;/li&gt;
  &lt;li&gt;빈 접두사&lt;/li&gt;
  &lt;li&gt;중복 접두사&lt;/li&gt;
  &lt;li&gt;케밥 케이스 외의 표기법으로 작성된 접두사&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 어노테이션이 추가되었으나 &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt;로 등록되거나, Spring 구성 요소로 표시되거나, &lt;code&gt;@ConfigurationPropertiesScan&lt;/code&gt;을 통해 스캔되지 않은 클래스에서 이 검사가 트리거됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  프로젝트 또는 모듈의 Spring Boot 버전이 2.2.0 이상으로 설정된 경우, &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 어노테이션이 추가되었으나 &lt;code&gt;@ConfigurationPropertiesScan&lt;/code&gt;을 통해 스캔되지 않은 클래스에서만 이 검사가 트리거됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2018.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConfigurationProperties&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBootApplicationProperties" defaultSeverity="WARNING" displayName="잘못된 프로퍼티 구성" enabled="false" language="Properties" pluginId="com.intellij.spring.boot" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  Spring Boot 애플리케이션 &lt;code&gt;.properties&lt;/code&gt; 구성 파일에서 해결되지 않거나 지원이 중단된 구성 키 및 잘못된 값을 보고합니다. 이러한 요소는 런타임 오류로 이어질 수 있습니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
server.port=invalid # ' 'invalid'를 java.lang.Integer로 변환할 수 없습니다'라고 보고됩니다
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;지원 중단된 구성 키의 대체 키가 있는 경우 '대체 키 사용'이라는 빠른 수정을 적용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
logging.path=${path} # '지원 중단된 구성 프로퍼티 'logging.path' '를 보고합니다
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
logging.file.path=${path}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
  구성 키가 &lt;code&gt;spring-configuration-metadata.json&lt;/code&gt;에 정의되지 않은 경우 '구성 키 정의'라는 빠른 수정을 적용하여 &lt;code&gt;META-INF/spring-additional-configuration-metadata.json&lt;/code&gt; 파일을 생성하고 필요한 키를 정의할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
new.key=value #'구성 프로퍼티 'new.key'를 해결할 수 없습니다'라고 보고됩니다
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정 적용 후 &lt;code&gt;META-INF/spring-additional-configuration-metadata.json&lt;/code&gt;에 다음 코드가 추가됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
{
  "properties": [
    {
      "name": "new.key",
      "type": "java.lang.String",
      "description": "Description for new.key."
  }
] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또한 이 검사는 목록 및 맵 구성 키의 색인 표기 오류를 강조 표시합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
spring.datasource.schema[]=${schema} #'색인 값 누락'이라고 보고됩니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;
  &lt;b&gt;대체 토큰&lt;/b&gt; 옵션을 사용하여 구성 파일의 값 자리표시자에 사용할 토큰을 정의할 수 있습니다.
  이러한 토큰은 &lt;code&gt;beginToken*endToken&lt;/code&gt; 형식으로 지정됩니다.
  &lt;code&gt;*&lt;/code&gt;가 없을 경우 시작 및 종료 토큰이 동일한 것으로 가정됩니다.
&lt;/p&gt;
&lt;p&gt;
  예를 들어, 시작 및 종료 토큰 모두의 디폴트 값은 &lt;code&gt;@&lt;/code&gt;이며, 이를 통해 &lt;code&gt;some.property=@another.property@&lt;/code&gt;과 같은 자리표시자를 정의할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;대체 토큰(&lt;code&gt;@property.key@&lt;/code&gt;) 내부의 값은 강조 표시되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SpringBootApplicationProperties&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Interoperability" path="Android/Lint/Interoperability"><inspection shortName="AndroidLintNullSafeMutableLiveData" defaultSeverity="ERROR" displayName="LiveData value assignment nullability mismatch" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;LiveData value assignment nullability mismatch&lt;br&gt;&lt;br&gt;This check ensures that LiveData values are not null when explicitly                 declared as non-nullable.&lt;br/&gt;
&lt;br/&gt;
                Kotlin interoperability does not support enforcing explicit null-safety when using                 generic Java type parameters. Since LiveData is a Java class its value can always                 be null even when its type is explicitly declared as non-nullable. This can lead                 to runtime exceptions from reading a null LiveData value that is assumed to be                 non-nullable.&lt;br&gt;&lt;br&gt;Issue id: NullSafeMutableLiveData&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.lifecycle&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=413132"&gt;https://issuetracker.google.com/issues/new?component=413132&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="보안" path="Java"><inspection shortName="LoadLibraryWithNonConstantString" defaultSeverity="WARNING" displayName="비상수 문자열이 있는 'Statement.loadLibrary()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동적으로 생성된 문자열을 라이브러리 이름으로 간주하는 &lt;code&gt;java.lang.System.loadLibrary()&lt;/code&gt;, &lt;code&gt;java.lang.System.load()&lt;/code&gt;, &lt;code&gt;java.lang.Runtime.loadLibrary()&lt;/code&gt; 및 &lt;code&gt;java.lang.Runtime.load()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  생성된 라이브러리 이름 문자열은 보안 침해의 일반적인 원인이 됩니다.
  기본적으로 이 검사는 컴파일타임 상수를 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(int i) {
    System.loadLibrary("foo" + i);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
검사 설정을 사용하여 모든 &lt;code&gt;static final&lt;/code&gt; 필드를 상수로 간주합니다.
이 옵션이 활성화되면 다음과 같은 문자열은 무시되므로 주의하세요.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private static final String LIBRARY = getUserInput();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LoadLibraryWithNonConstantString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DesignForExtension" defaultSeverity="WARNING" displayName="확장을 위한 설계" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;static&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;final&lt;/code&gt; 또는 &lt;code&gt;abstract&lt;/code&gt;가 아니고, 그 본문이 비어 있지 않은 메서드를 보고합니다.
&lt;p&gt;
  이러한 메서드를 지양하는 스타일로 코딩하면 클래스의 컨트랙트가 하위 클래스에 의해 손상되는 것을 방지할 수 있습니다. 이 스타일의 장점은 하위 클래스가 상위 메서드를 호출하는 것을 잊어서 상위 클래스의 상태를 손상시킬 수 없다는 것입니다. 그 대가는 하위 클래스의 유연성이 제한된다는 것으로, 특히 상위 클래스에서 코드 실행을 방지할 수 없습니다. 빠른 수정을 사용하여, 누락된 제어자를 추가합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public boolean equals(Object o) { return true; }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public final boolean equals(Object o) { return true; }
  }
&lt;/code&gt;&lt;/pre&gt;
이 검사는 보안 환경에서 사용될 코드를 위한 것이며, 덜 제한적인 환경에는 적합하지 않을 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DesignForExtension&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicStaticCollectionField" defaultSeverity="WARNING" displayName="'public static' 컬렉션 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
수정 가능한 &lt;code&gt;public&lt;/code&gt;을 보고합니다. &lt;code&gt;static&lt;/code&gt; 컬렉션 필드.
&lt;p&gt;이 필드는 상수 값의 컬렉션을 저장하기 위해 자주 사용되지만 &lt;code&gt;final&lt;/code&gt;로 선언되어도 필드 내용이 변경될 수 있기 때문에 보안 위험의 요인이 될 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public static final List&amp;lt;String&amp;gt; EVENTS = new ArrayList&amp;lt;&amp;gt;();
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;옵션&lt;/b&gt; 항목에서 테이블을 사용하여 수정할 수 없는 컬렉션을 반환하는 메서드를 지정합니다.
  이 메서드로 초기화된 &lt;code&gt;public&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; 컬렉션 필드는 보고되지 않습니다.
&lt;p&gt;&lt;small&gt;Inspection ID: PublicStaticCollectionField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemSetSecurityManager" defaultSeverity="WARNING" displayName="'System.setSecurityManager()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;System.setSecurityManager()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;대부분의 경우는 무해하지만 &lt;code&gt;System.setSecurityManager()&lt;/code&gt; 호출은 보안 감사 시 면밀히 조사해야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SystemSetSecurityManager&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JDBCPrepareStatementWithNonConstantString" defaultSeverity="WARNING" displayName="비상수 문자열이 있는 'Connection.prepare*()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동적으로 생성된 문자열을 준비할 구문으로 간주하는 &lt;code&gt;java.sql.Connection.prepareStatement()&lt;/code&gt;, &lt;code&gt;java.sql.Connection.prepareCall()&lt;/code&gt; 또는 해당 변형의 호출을 보고합니다.
&lt;p&gt;
  생성된 SQL 구문은 보안 위반의 일반적인 원인입니다. 기본적으로 이 검사는 컴파일타임 상수를 무시합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String bar() { return "bar"; }

  Connection connection = DriverManager.getConnection("", "", "");
  connection.("SELECT * FROM user WHERE name='" + bar() + "'");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
검사 설정을 사용하여 모든 &lt;code&gt;static&lt;/code&gt; &lt;code&gt;final&lt;/code&gt; 필드를 상수로 간주합니다. 이 옵션이 활성화되면 다음과 같은 문자열은 무시되므로 주의하세요.
&lt;pre&gt;&lt;code&gt;
  static final String SQL = "SELECT * FROM user WHERE name='" + getUserInput() + "'";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JDBCPrepareStatementWithNonConstantString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RuntimeExecWithNonConstantString" defaultSeverity="WARNING" displayName="비상수 문자열이 있는 'Runtime.exec()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동적으로 생성된 문자열을 실행할 명령어로 간주하는 &lt;code&gt;java.lang.Runtime.exec()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  생성된 실행 문자열은 일반적으로 보안 침해의 원인이 됩니다.
  기본적으로 이 검사는 컴파일타임 상수를 무시합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String i = getUserInput();
  Runtime runtime = Runtime.getRuntime();
  runtime.exec("foo" + i); // 경고를 보고합니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
검사 설정을 사용하여 모든 &lt;code&gt;static&lt;/code&gt; &lt;code&gt;final&lt;/code&gt; 필드를 상수로 간주합니다.
이 옵션이 활성화되면 다음과 같은 문자열은 무시되므로 주의하세요.
&lt;pre&gt;&lt;code&gt;
  static final String COMMAND = "ping " + getDomainFromUserInput() + "'";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RuntimeExecWithNonConstantString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JDBCExecuteWithNonConstantString" defaultSeverity="WARNING" displayName="비상수 문자열이 있는 'Statement.execute()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동적으로 생성된 문자열을 실행할 쿼리로 간주하는 &lt;code&gt;java.sql.Statement.execute()&lt;/code&gt; 또는 해당 변형의 호출을 보고합니다.
&lt;p&gt;생성된 SQL 구문은 보안 침해의 일반적인 원인이 됩니다.
  기본적으로 이 검사는 컴파일타임 상수를 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ResultSet execute(Statement statement, String name) throws SQLException {
    return statement.executeQuery("select * from " + name); // 경고를 보고합니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
검사 옵션을 사용하여 모든 &lt;code&gt;static&lt;/code&gt; &lt;code&gt;final&lt;/code&gt; 필드를 상수로 간주합니다.
이 옵션이 활성화되면 다음과 같은 문자열은 무시되므로 주의하세요.
&lt;pre&gt;&lt;code&gt;
  private static final String SQL = "SELECT * FROM user WHERE name='" + getUserInput() + "'";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JDBCExecuteWithNonConstantString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassLoaderInstantiation" defaultSeverity="WARNING" displayName="'ClassLoader' 인스턴스화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.ClassLoader&lt;/code&gt; 클래스의 인스턴스화를 보고합니다.
&lt;p&gt;대부분의 경우는 무해하지만 &lt;code&gt;ClassLoader&lt;/code&gt;의 인스턴스화는 보안 감사 시 면밀히 조사해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Class&amp;lt;?&amp;gt; loadExtraClass(String name) throws Exception {
      try(URLClassLoader loader =
          new URLClassLoader(new URL[]{new URL("extraClasses/")})) {
        return loader.loadClass(name);
      }
    }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassLoaderInstantiation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalClone" defaultSeverity="WARNING" displayName="안전한 컨텍스트의 비 final 'clone()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;final&lt;/code&gt; 제어자가 없는 &lt;code&gt;clone()&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;
  &lt;code&gt;clone()&lt;/code&gt;은 생성자를 사용하지 않고 객체를 인스턴스화하기 위해 사용될 수 있으므로 &lt;code&gt;clone()&lt;/code&gt; 메서드를 재정의하도록 허용하면 객체가 손상되고 심지어 보안 문제가 발생할 수 있습니다. &lt;code&gt;clone()&lt;/code&gt; 메서드 또는 둘러싸는 클래스 자신을 &lt;code&gt;final&lt;/code&gt;로 만들어 이러한 결과를 방지할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Cloneable {
    @Override
    protected Object clone() throws CloneNotSupportedException {
      return super.clone();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonFinalClone&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CustomClassloader" defaultSeverity="WARNING" displayName="사용자 지정 'ClassLoader'가 선언됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.ClassLoader&lt;/code&gt;의 사용자 정의 하위 클래스를 보고합니다.
&lt;p&gt;
  이러한 클래스는 반드시 보안 구멍을 나타내는 것은 아니지만 보안 문제를 일으킬 가능성이 있기 때문에 면밀히 검사해야 합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CustomClassloader&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableDeserializableClassInSecureContext" defaultSeverity="WARNING" displayName="안전한 컨텍스트의 Serializable 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
직렬화되거나 역직렬화될 수 있는 클래스를 보고합니다.
&lt;p&gt;
  클래스가 &lt;code&gt;Serializable&lt;/code&gt; 인터페이스를 지원하며 &lt;code&gt;readObject()&lt;/code&gt; 및 &lt;code&gt;writeObject()&lt;/code&gt; 메서드가 항상 예외를 던지도록 정의되어 있지 않은 경우 직렬화될 수 있습니다. 직렬화 가능한 클래스는 안전한 사용을 위해 목적으로 한 코드 내에서 위험할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class DeserializableClass implements Serializable { // 클래스가 예외를 던지는 'writeObject()' 메서드를 포함하지 않습니다
    private int sensitive = 736326;

    private void readObject(ObjectInputStream in) {
        throw new Error();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class DeserializableClass implements Serializable {
    private int sensitive = 736326;

    private void readObject(ObjectInputStream in) {
        throw new Error();
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
        throw new java.io.NotSerializableException("DeserializableClass");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  다음 옵션을 사용해 검사를 구성하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    이 검사에서 보고되어서는 안 되는 상속자를 가진 클래스를 나열합니다.
    이는 상위 클래스에서 &lt;code&gt;Serializable&lt;/code&gt;을 상속받지만 직렬화를 의도하지 않은 클래스를 의미합니다.
    그러한 클래스를 무시하는 대신 항상 예외를 던지는 &lt;code&gt;readObject()&lt;/code&gt; 및 &lt;code&gt;writeObject()&lt;/code&gt; 메서드를 추가하는 것이 더 안전할 수 있습니다.
  &lt;/li&gt;
  &lt;li&gt;
    직렬화 가능한 익명 클래스를 무시할지 여부를 설정합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SerializableDeserializableClassInSecureContext&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnsecureRandomNumberGeneration" defaultSeverity="WARNING" displayName="안전하지 않은 난수 생성" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.Random&lt;/code&gt; 또는 &lt;code&gt;java.lang.Math.random()&lt;/code&gt; 사용을 보고합니다.
&lt;p&gt;
  안전한 환경에서는 &lt;code&gt;java.secure.SecureRandom&lt;/code&gt;을 선택하는 것이 좋습니다. 왜냐하면 암호상의 안전한 무작위 수를 생성할 수 있기 때문입니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  long token = new Random().nextLong();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnsecureRandomNumberGeneration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemProperties" defaultSeverity="WARNING" displayName="시스템 프로퍼티의 액세스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
아래의 메서드 중 하나를 사용하여 시스템 속성에 액세스하는 코드를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;System.getProperties()&lt;/code&gt;, &lt;code&gt;System.setProperty()&lt;/code&gt;,
    &lt;code&gt;System.setProperties()&lt;/code&gt;, &lt;code&gt;System.clearProperties()&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;Integer.getInteger()&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;Boolean.getBoolean()&lt;/code&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
시스템 속성에 액세스하는 것 자체는 보안 위험의 요인이 아니지만 악성 코드에서 자주 발견됩니다.
시스템 속성에 액세스하는 코드는 보안 감사 시 면밀하게 조사해야 합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SystemProperties&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CustomSecurityManager" defaultSeverity="WARNING" displayName="사용자 지정 'SecurityManager'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.SecurityManager&lt;/code&gt;의 사용자 정의 하위 클래스를 보고합니다.
&lt;p&gt;
  이러한 클래스는 반드시 보안 구멍을 나타내는 것은 아니지만 보안 문제를 일으킬 가능성이 있기 때문에 면밀히 전문적으로 검사해야 합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class CustomSecurityManager extends SecurityManager {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: CustomSecurityManager&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneableClassInSecureContext" defaultSeverity="WARNING" displayName="안전한 컨텍스트의 cloneable 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
복제될 수 있는 클래스를 보고합니다.
&lt;p&gt;
  클래스가 &lt;code&gt;Cloneable&lt;/code&gt; 인터페이스를 지원하고 해당 &lt;code&gt;clone()&lt;/code&gt; 메서드가 즉시 오류를 던지도록 정의되지 않은 경우 이 클래스를 복제할 수 있습니다. 복제 가능한 클래스는 안전한 사용을 위한 코드에서 위험할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;code&gt;class SecureBean implements Cloneable {}&lt;/code&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;&lt;code&gt;class SecureBean {}&lt;/code&gt;
&lt;p&gt;
클래스가 기존의 복제 가능한 클래스를 확장하거나 복제 가능한 인터페이스를 구현하는 경우, 빠른 수정을 적용하면 코드가 다음과 같이 됩니다. 
&lt;pre&gt;&lt;code&gt;class SecureBean extends ParentBean {
    @Override
    protected SecureBean clone() throws CloneNotSupportedException {
        throw new CloneNotSupportedException();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: CloneableClassInSecureContext&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicStaticArrayField" defaultSeverity="WARNING" displayName="'public static' 배열 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;public&lt;/code&gt;을 보고합니다. &lt;code&gt;static&lt;/code&gt; 배열 필드.
&lt;p&gt;
  이 필드는 상수 값 배열을 저장하기 위해 사용하는 경우가 많습니다. 그러나 이 필드는 보안 위험을 나타내며 &lt;code&gt;final&lt;/code&gt;로 선언하는 경우에도 데이터가 변경될 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public static String[] allowedPasswords = {"foo", "bar"};
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: PublicStaticArrayField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="프로토콜 버퍼" path=""><inspection shortName="PbDuplicatedImports" defaultSeverity="WARNING" displayName="중복 import 문" enabled="false" language="protobuf" pluginId="idea.plugin.protoeditor" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
사실상 동등한 import 문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PbDuplicatedImports&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="정규식" path=""><inspection shortName="RegExpSingleCharAlternation" defaultSeverity="WARNING" displayName="단일 문자 대체" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
RegExp의 단일 문자 대체를 보고합니다.
이는 문자 클래스를 사용하는 것보다 간단합니다.
이는 또한 일치율 개선에도 도움이 됩니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a|b|c|d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [abcd]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpSingleCharAlternation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpAnonymousGroup" defaultSeverity="WARNING" displayName="익명의 캡처 그룹 또는 숫자 역참조" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
정규식 내 익명 캡처 그룹과 숫자 역참조를 보고합니다.
이들은 정규식 파생 언어가 이름이 지정된 그룹 및 그룹 참조를 지원하는 경우에만 보고됩니다.
이름이 지정된 그룹 및 역참조는 코드 가독성을 높여주므로 이를 대신 사용하는 것이 좋습니다.
캡처가 필요하지 않은 경우 비 캡처 그룹을 사용해(예: &lt;code&gt;(xxx)&lt;/code&gt; 대신 &lt;code&gt;(?:xxx)&lt;/code&gt;) 일치 작업의 성능을 높이고 메모리 사용량을 줄일 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (\d\d\d\d)\1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;더 나은 정규식 패턴은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (?&amp;lt;quad&gt;\d\d\d\d)\k&amp;lt;quad&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpAnonymousGroup&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpRepeatedSpace" defaultSeverity="WARNING" displayName="연속 공백" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
정규식 내 두 개 이상의 연속된 공백을 보고합니다.
기본적으로 공백은 표시되지 않으므로 필요한 공백이 몇 개인지 확인하기 어려울 수 있습니다.
연속 공백을 단일 공백과 측정한 수량자로 교체하면 정규식이 더 명확해집니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (     )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ( {5})
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpRepeatedSpace&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CustomRegExpInspection" defaultSeverity="WARNING" displayName="사용자 지정 정규식 검사" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
사용자 지정 정규식 검사
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CustomRegExpInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpUnexpectedAnchor" defaultSeverity="WARNING" displayName="예기치 않은 위치의 시작 또는 종료 앵커" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
패턴 앞에 오지 않는 &lt;code&gt;^&lt;/code&gt; 또는 &lt;code&gt;\A&lt;/code&gt; 앵커와 패턴 끝에 붙지 않는 &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt; 또는 &lt;code&gt;\z&lt;/code&gt; 앵커를 보고합니다.
잘못된 위치에 있는 이들 정규식 앵커는 패턴이 무엇과도 일치하지 못하도록 합니다.
&lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 앵커는 대부분 리터럴 문자를 의도했다가 이스케이프를 빠뜨린 경우입니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (가격 $10)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;small&gt;2018.1의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpUnexpectedAnchor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpRedundantClassElement" defaultSeverity="WEAK WARNING" displayName="불필요한 '\d', '[:digit:]' 또는 '\D' 클래스 요소" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
한 클래스에서 &lt;code&gt;\w&lt;/code&gt; 또는 &lt;code&gt;[:word:]&lt;/code&gt;(&lt;code&gt;\D&lt;/code&gt; 및 &lt;code&gt;\W&lt;/code&gt;)와 함께 사용되는 불필요한 &lt;code&gt;\d&lt;/code&gt; 및 &lt;code&gt;[:digit:]&lt;/code&gt;을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [\w\d]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [\w]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.2의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpRedundantClassElement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpEscapedMetaCharacter" defaultSeverity="INFORMATION" displayName="이스케이프된 메타 문자" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이스케이프 처리된 메타 문자를 보고합니다.
일부 정규식 코드 스타일에서는 정규식을 더 쉽게 이해할 수 있도록 메타 문자를 문자 클래스 안에 넣도록 합니다.
&lt;code&gt;[&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt; 및 &lt;code&gt;^&lt;/code&gt; 메타 문자는 문자 클래스 안에서 추가적인 이스케이프 처리가 필요하므로 이 검사에서 경고되지 않습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \d+\.\d+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \d+[.]\d+
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpEscapedMetaCharacter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpSimplifiable" defaultSeverity="WEAK WARNING" displayName="정규 표현식을 단순화할 수 있습니다" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단순화할 수 있는 정규 표현식을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [a] xx* [ah-hz]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a x+ [ahz]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpSimplifiable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpDuplicateCharacterInClass" defaultSeverity="WARNING" displayName="문자 클래스 내 중복 문자" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
RegExp 문자 클래스 내 중복 문자를 보고합니다.
중복 문자는 불필요하며 제거하더라도 정규식의 의미가 변하지 않습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [aabc]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [abc]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpDuplicateCharacterInClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpUnnecessaryNonCapturingGroup" defaultSeverity="WARNING" displayName="불필요한 비 캡처 그룹" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
일치 결과에 영향을 주지 않는 불필요한 비 캡처 그룹을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Everybody be cool, (?:this) is a robbery!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Everybody be cool, this is a robbery!
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.1의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpUnnecessaryNonCapturingGroup&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpRedundantEscape" defaultSeverity="WARNING" displayName="중복 문자 이스케이프" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
의미를 유지하는 이스케이프되지 않은 문자로 대체할 수 있는 불필요한 문자 이스케이프 시퀀스를 보고합니다.
문자 클래스 외부에서 필요한 많은 이스케이프 시퀀스는 문자 클래스의 대괄호 &lt;code&gt;[]&lt;/code&gt; 안에서는 불필요합니다.
&lt;p&gt;
  문자 클래스 외부의 이스케이프되지 않은 여는 중괄호 &lt;code&gt;{&lt;/code&gt;는 일부 파생 언어에서는 허용되지만(JavaScript, Python 등), 중괄호를 문자로 이스케이프 처리해야 하는 파생 언어도 있으므로 혼란을 유발하고 패턴을 이식하기 어렵게 만들 수 있습니다.
  이러한 이유 때문에 이 검사는 이스케이프된 여는 중괄호를 보고하지 않습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \-\;[\.]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  -;[.]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;b&gt;Ignore escaped closing brackets '}' and ']'(이스케이프된 닫는 괄호 '}' 및 ']' 무시)&lt;/b&gt; 옵션은 문자 클래스 외부의 &lt;code&gt;\}&lt;/code&gt; 및 &lt;code&gt;\]&lt;/code&gt;가 정규식 파생 언어로 이스케이프 해제되도록 허용된 경우, 해당 괄호를 보고할지 여부를 지정합니다.
&lt;p&gt;&lt;small&gt;2017.3의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpRedundantEscape&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpDuplicateAlternationBranch" defaultSeverity="WARNING" displayName="대체 항목 내 중복 브랜치" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
정규식 대체 항목에 있는 중복 브랜치를 보고합니다.
중복 브랜치는 일치 작업을 느리게 만들고 표현식의 의도롤 모호하게 만듭니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (alpha|bravo|charlie|alpha)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (alpha|bravo|charlie)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpDuplicateAlternationBranch&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpEmptyAlternationBranch" defaultSeverity="WARNING" displayName="대체 항목 내 빈 브랜치" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
정규식 대체 항목에 있는 빈 브랜치를 보고합니다.
빈 브랜치는 빈 문자열하고만 일치하며 대부분의 경우 이는 기대한 결과가 아닙니다.
이 검사는 대체 항목의 앞 또는 뒤에 있는 단일한 빈 브랜치는 보고하지 않습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (alpha||bravo)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (alpha|bravo)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpEmptyAlternationBranch&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpRedundantNestedCharacterClass" defaultSeverity="WARNING" displayName="중복된 중첩 문자 클래스" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요하게 중첩된 문자 클래스를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [a-c[x-z]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [a-cx-z]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.2의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpRedundantNestedCharacterClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpOctalEscape" defaultSeverity="INFORMATION" displayName="8진 이스케이프" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
역참조와 혼동하기 쉬운 8진 이스케이프를 보고합니다.
혼동을 피하기 위해 16진 이스케이프를 사용하세요.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \07
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \x07
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpOctalEscape&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpSuspiciousBackref" defaultSeverity="WARNING" displayName="의심스러운 역참조" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
런타임 때 해결되지 않는 역참조를 보고합니다.
이는 역참조가 그 어떤 것과도 일치할 수 없다는 의미입니다.
역참조 이후 그룹이 정의되거나 그룹이 대체 항목의 다른 브랜치에서 정의되는 경우 역참조는 해결되지 않습니다.
&lt;p&gt;&lt;b&gt;역참조 이후 정의되는 그룹의 예시:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \1(abc)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;다른 브랜치에서 사용되는 그룹과 역참조의 예시:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a(b)c|(xy)\1z
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RegExpSuspiciousBackref&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JVM 언어" path=""><inspection shortName="UastIncorrectMimeTypeInspection" defaultSeverity="ERROR" displayName="잘못된 MIME 타입 선언" enabled="false" language="UAST" pluginId="com.intellij.microservices.jvm" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;HTTP 서버 및 클라이언트에 대한 잘못된 MIME 타입(예: &lt;code&gt;Content-Type&lt;/code&gt; 문자열)을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UastIncorrectMimeTypeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadRun" defaultSeverity="WARNING" displayName="'Thread.run()' 호출" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt; 또는 그 하위 클래스의 &lt;0&gt;run()&lt;/0&gt;에 대한 호출을 보고합니다.&lt;/p&gt;
&lt;p&gt;
  의도된 경우도 있지만 &lt;code&gt;run()&lt;/code&gt;은 새 스레드를 시작하지 않으므로 일반적으로 실수입니다.
  별도의 스레드에서 코드를 실행하려면 &lt;code&gt;start()&lt;/code&gt;를 사용해야 합니다.&lt;/p&gt;
&lt;p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThreadRun&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UastIncorrectHttpHeaderInspection" defaultSeverity="WARNING" displayName="알 수 없는 HTTP 헤더" enabled="false" language="UAST" pluginId="com.intellij.microservices.jvm" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  어떤 &lt;a href="https://www.iana.org/assignments/message-headers/message-headers.xml"&gt;공개적으로 알려진 헤더&lt;/a&gt;와도 일치하지 않는 알 수 없는 HTTP 헤더를 보고합니다. 빠른 수정에서는 추후 이 검사가 트리거되지 않도록 사용자 지정 헤더 목록에 헤더를 추가하도록 제안합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사에서는 동일한 이름의 사용자 지정 HTTP 헤더가 HTTP 클라이언트 그룹에 나열됩니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UastIncorrectHttpHeaderInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingDeprecatedAnnotationOnScheduledForRemovalApi" defaultSeverity="ERROR" displayName="제거 예정인 API에서 누락된 '@Deprecated' 어노테이션" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@ApiStatus.ScheduledForRemoval&lt;/code&gt;로 표시되며 &lt;code&gt;@Deprecated&lt;/code&gt;로 표시되지 않는 선언을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @ApiStatus.ScheduledForRemoval(inVersion = "2017.3")
  public void myLegacyMethod() { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 결과는 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Deprecated
  @ApiStatus.ScheduledForRemoval(inVersion = "2017.3")
  public void myLegacyMethod() { }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MissingDeprecatedAnnotationOnScheduledForRemovalApi&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Since15" defaultSeverity="ERROR" displayName="구성된 언어 수준에서 사용할 수 없는 API 사용" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구성된 언어 수준에서 지원되지 않는 API가 사용된 경우를 보고합니다.
이 검사는 다음 3가지를 수행합니다.
&lt;ul&gt;
  &lt;li&gt;언어 수준이 Java 7 미만일 때 일반화된 클래스의 사용 위치를 강조 표시합니다.&lt;/li&gt;
  &lt;li&gt;디폴트 메서드가 재정의되지 않고 언어 수준이 Java 8 미만일 때 강조 표시합니다.&lt;/li&gt;
  &lt;li&gt;언어 수준이 문서에 &lt;code&gt;@since&lt;/code&gt; 태그를 사용하여 표시된 것보다 낮을 때 API 사용 위치를 강조 표시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  프로젝트 또는 사용자 지정 언어 수준과 관련한 API 사용을 금지하려면 &lt;b&gt;API 사용 금지&lt;/b&gt; 옵션을 사용합니다.
&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: Since15&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnstableApiUsage" defaultSeverity="WARNING" displayName="불안정한 API 사용" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
어노테이션 중 하나가 불안정하다고 표시된 API의 사용 위치를 보고합니다. 그러한 API는 향후 버전에서 변경되거나 제거되므로 이를 사용하는 코드에서 오류가 발생합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;불안정한 API를 표시할 때 사용하는 어노테이션을 아래 표에 나열했습니다.&lt;/p&gt;
&lt;p&gt;기본적으로 이 검사는 불안정한 API의 선언이 동일한 프로젝트의 소스에 있는 경우 그 사용을 무시합니다. 그러한 경우 API를 변경할 때 사용 위치를 업데이트할 수 있습니다.
  하지만 프로젝트가 크다면 이는 불편할 수 있으므로 프로젝트 소스와 라이브러리에서 모두 선언된 불안정한 API의 사용을
보고하도록 &lt;b&gt;Ignore API declared in this project(이 프로젝트에서 선언한 API 무시)&lt;/b&gt; 옵션을 끌 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnstableApiUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UsagesOfObsoleteApi" defaultSeverity="TEXT ATTRIBUTES" displayName="ApiStatus.@Obsolete의 사용 위치" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@ApiStatus.Obsolete&lt;/code&gt; 어노테이션이 추가된 선언(클래스, 메서드, 필드)을 보고합니다.
&lt;p&gt;
  제대로 작동하지 않거나 더 새롭거나 우수하거나 일반적인 API가 있지만, 현재 API를 삭제할 수 없는 경우가 있습니다.
  이는 &lt;code&gt;@Deprecated&lt;/code&gt; 어노테이션의 더 약한 변형입니다.
  어노테이션이 있는 API는 새 코드에서 사용되지 않아야 하지만, 기존 코드의 마이그레이션을 연기하도록 허용되므로, 사용 위치는 경고로 간주되지 않습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UsagesOfObsoleteApi&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IllegalDependencyOnInternalPackage" defaultSeverity="ERROR" displayName="내부 패키지에 유효하지 않은 종속 요소" enabled="false" language="JVM" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명명된 모듈에서 내보내진 것이 아니며 패키지에 &lt;code&gt;module-info.java&lt;/code&gt;가 없는 모듈 내 참조를 보고합니다. 
&lt;p&gt;프로젝트의 일부 모듈이 Java 모듈로 마이그레이션되었지만 다른 부분은 아직 모듈화되지 않을 때 이러한 구성이 발생할 수 있습니다.
JDK와 마찬가지로, 이처럼 모듈화되지 않은 코드는 명명된 모듈에 있으며 명시적으로 내보내진 것이 아닌 코드에 액세스할 수 없습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IllegalDependencyOnInternalPackage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UrlHashCode" defaultSeverity="WARNING" displayName="'URL' 객체에서 'equals()' 또는 'hashCode()' 호출" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.net.URL&lt;/code&gt; 객체에 대한 &lt;code&gt;hashCode()&lt;/code&gt; 및 &lt;code&gt;equals()&lt;/code&gt; 호출과 &lt;code&gt;URL&lt;/code&gt; 객체를 맵과 세트에 추가하는 호출을 보고합니다.
&lt;p&gt;
  &lt;code&gt;URL&lt;/code&gt;의 &lt;code&gt;equals()&lt;/code&gt; 및 &lt;code&gt;hashCode()&lt;/code&gt; 메서드는 호스트 이름을 해결하기 위해 DNS 조회를 수행할 수 있습니다.
  이는 네트워크 및 DNS 서버의 가용성 및 속도에 따라 심각한 지연을 일으킬 수 있습니다.
  &lt;code&gt;java.net.URL&lt;/code&gt; 대신 &lt;code&gt;java.net.URI&lt;/code&gt;를 사용하면 DNS 조회를 방지할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  boolean urlEquals(URL url1, URL url2) {
      return url1.equals(url2);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UrlHashCode&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SqlSourceToSinkFlow" defaultSeverity="WARNING" displayName="안전하지 않은 문자열이 SQL로 사용됨" enabled="false" language="UAST" pluginId="com.intellij.persistence" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Java 및 Kotlin 언어에서 안전하지 않은 문자열이 SQL 쿼리로 메서드에 전달되는 경우를 보고합니다.
이는 SQL 삽입의 원인이 될 수 있습니다.
메서드의 목록의 출처는 &lt;b&gt;설정&lt;/b&gt; -  &lt;code&gt;SQL&lt;/code&gt;, &lt;code&gt;JPA QL&lt;/code&gt;, &lt;code&gt;Hibernate QL&lt;/code&gt; 및 &lt;code&gt;PostgreSQL&lt;/code&gt;의 &lt;b&gt;언어 인젝션&lt;/b&gt;입니다
&lt;p&gt;
  안전한 객체:
&lt;ul&gt;
  &lt;li&gt;문자열 리터럴, 인터페이스 인스턴스, 열거형 객체, int 및 래퍼, 부울 및 래퍼, 클래스 객체&lt;/li&gt;
  &lt;li&gt;리시버와 인수가 안전한 메서드 호출의 결과&lt;/li&gt;
  &lt;li&gt;문자열 리터럴만 대입되고 안전한 이니셜라이저가 있는 같은 파일 내의 private 필드&lt;/li&gt;
  &lt;li&gt;안전한 이니셜라이저가 있는 같은 파일 내의 final 필드&lt;/li&gt;
  &lt;li&gt;안전한 객체에서 대입된 지역 변수&lt;/li&gt;
  이 필드, 지역 변수 또는 매개변수는 메서드에 인수로 전달되거나 한정자로 사용되어서는 안 되며, 기본형, 래퍼 또는 불변이어야 합니다.
&lt;/ul&gt;
static final 필드는 안전한 것으로 간주됩니다.
&lt;p&gt;
  이 분석은 한 파일 내에서만 수행됩니다.
  예:
&lt;pre&gt;
&lt;code lang="java"&gt;
    public void save(String sql) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        jdbcTemplate.queryForList(sql);
    }
&lt;/code&gt;
&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2023.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SqlSourceToSinkFlow&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SourceToSinkFlow" defaultSeverity="WARNING" displayName="안전하지 않은 문자열이 안전한 메서드로 전달됨" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전하지 않은 객체가 &lt;code&gt;@Untainted&lt;/code&gt; 어노테이션으로 표시된 매개변수가 있는 메서드로 전달거나 어노테이션이 있는 메서드에서 반환되거나 어노테이션이 있는 필드, 매개변수 또는 지역 변수에 대입되는 경우를 보고합니다. 필드용 Kotlin &lt;code&gt;set&lt;/code&gt; 및 &lt;code&gt;get&lt;/code&gt; 메서드는 진입접으로 지원되지 않습니다.
&lt;p&gt;
  안전한 객체(같은 클래스 내)란 다음과 같습니다.
&lt;ul&gt;
  &lt;li&gt;문자열 리터럴, 인터페이스 인스턴스 또는 열거형 객체&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Untainted&lt;/code&gt;로 표시된 메서드를 호출한 결과&lt;/li&gt;
  &lt;li&gt;문자열 리터럴만 대입되고 안전한 이니셜라이저가 있는 private 필드&lt;/li&gt;
  &lt;li&gt;안전한 이니셜라이저가 있는 final 필드&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Untainted&lt;/code&gt;로 표시되었으며 안전하지 않은 객체로부터 대입되지 않은 지역 변수 또는 매개변수&lt;/li&gt;
  이 필드, 지역 변수 또는 매개변수는 메서드에 인수로 전달되거나 한정자로 사용되어서는 안 되며, 기본형, 래퍼 또는 불변이어야 합니다.
&lt;/ul&gt;
또한, static final 필드는 안전한 것으로 간주됩니다.
&lt;p&gt;
  이 분석은 한 파일 내에서만 수행됩니다. 다른 클래스의 종속성을 처리하려면 옵션을 사용하세요.
  이 분석은 private 또는 static 메서드까지 확장되며 심도 전달에 제한이 있습니다.
&lt;p&gt;
  예:
&lt;pre&gt;
&lt;code lang="java"&gt;
  void doSmth(boolean b) {
    String s = safe();
    String s1 = "other";
    if (b) s1 = s;
    sink(s);
  }

  String sink(@Untainted String s) {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;
  여기에서는 &lt;code&gt;s&lt;/code&gt;로 대입된 안전하지 않은 문자열이 없어 경고가 발생하지 않습니다. 반면:
&lt;pre&gt;
&lt;code lang="java"&gt;
  void doSmth(boolean b) {
    String s = safe();
    String s1 = "other";
    s1 = foo();
    if (b) s = s1;
    sink(s);        // 여기서 경고
  }
  
  String foo();

  String sink(@Untainted String s) {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;
  여기에서는 &lt;code&gt;foo&lt;/code&gt; 호출 결과 대입 뒤에 있는 &lt;code&gt;s1&lt;/code&gt;에 알 수 없는 상태가 있기 때문에 경고가 발생합니다.
  &lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SourceToSinkFlow&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EmptyMethod" defaultSeverity="WARNING" displayName="빈 메서드" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
제거 가능한 빈 메서드를 보고합니다.
&lt;p&gt;메서드 자체가 비어 있거나, 메서드가 재정의되거나, 빈 메서드로만 구현된 경우 빈 상태로 간주됩니다. 주석 및 자체 매개변수가 있는 &lt;code&gt;super()&lt;/code&gt; 호출만 포함된 메서드도 빈 상태로 간주됩니다.&lt;/p&gt;
&lt;p&gt;이 검사는 특수 어노테이션이 있는 메서드는 무시합니다(예: &lt;code&gt;javax.ejb.Init&lt;/code&gt; 및 &lt;code&gt;javax.ejb.Remove&lt;/code&gt; EJB 어노테이션).&lt;/p&gt;
&lt;p&gt;빠른 수정으로 불필요한 메서드를 안전하게 제거할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;주석 및 javadoc을 콘텐츠로 간주&lt;/b&gt; 옵션을 사용하여 주석이 포함된 메서드를 비어 있지 않은 메서드로 취급할지 선택합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;추가 특수 어노테이션&lt;/b&gt; 옵션을 사용하여 이 검사를 통해 무시할 추가 어노테이션을 구성합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EmptyMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverrideOnly" defaultSeverity="WARNING" displayName="메서드는 재정의만 가능" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@ApiStatus.OverrideOnly&lt;/code&gt;로 표시된 API 메서드 호출을 보고합니다.

&lt;p&gt;
  &lt;code&gt;@ApiStatus.OverrideOnly&lt;/code&gt; 어노테이션은 해당 메서드가 클라이언트 코드에 의해 구현되거나 재정의되어야 하고 직접 호출되지 않아야 함을 나타냅니다.
  이 패턴은 일반적으로 확장 메커니즘에서 나타나며, 이 메커니즘에서는 구현이 특정 인터페이스를 준수해야 하지만 이를 호출하는 것은 사용자가 해야 할 일이 아닙니다.
  이러한 확장 메커니즘의 한 예는 서비스 공급자 인터페이스입니다.
  이 어노테이션으로 클래스 또는 인터페이스를 표시하는 것은 해당 어노테이션으로 모든 메서드를 표시하는 것과 같습니다.
&lt;/p&gt;

&lt;p&gt;
  &lt;code&gt;@ApiStatus.OverrideOnly&lt;/code&gt; 어노테이션은 메서드가 서비스 제공자 인터페이스(SPI)의 일부임을 나타냅니다.
  선언하는 라이브러리의 클라이언트는 그러한 메서드를 직접 호출하는 것이 아니라 구현하거나 재정의해야 합니다.
  이 어노테이션으로 클래스 또는 인터페이스를 표시하는 것은 해당 어노테이션으로 모든 메서드를 표시하는 것과 같습니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  // 업스트림 라이브러리 코드 내
  @ApiStatus.OverrideOnly
  public class MyService {
    public void perform();
  }

  // 다운스트림 클라이언트 코드 내
  public class Foo {
    public void bar(myService: MyService) {
      myService.perform();
    }
  }
&lt;/code&gt;&lt;/pre&gt;

이 검사는 또한 어노테이션을 잘못 적용하여 발생하는 다음과 같은 문제를 탐지합니다.
&lt;ul&gt;
  &lt;li&gt;확장/재정의할 수 없는 클래스/메서드에 어노테이션 지정&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@ApiStatus.OverrideOnly&lt;/code&gt; 어노테이션이 이미 달린 클래스의 메서드에 불필요하게 어노테이션을 추가&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: OverrideOnly&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SystemGetProperty" defaultSeverity="WARNING" displayName="'System.getProperty(str)' 호출을 단순화할 수 있음" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 &lt;code&gt;System.getProperty(str)&lt;/code&gt;의 사용 위치를 보고하고 2가지 방법으로 수정을 제안합니다.
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;System.getProperty("path.separator")&lt;/code&gt; -&gt; &lt;code&gt;File.pathSeparator&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;System.getProperty("line.separator")&lt;/code&gt; -&gt; &lt;code&gt;System.lineSeparator()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;code&gt;System.lineSeparator()&lt;/code&gt;는 캐시 처리된 값을 반환하고 &lt;code&gt;System.getProperty("line.separator")&lt;/code&gt;는 매번 프로퍼티(구현에 따라 Hashtable 또는 CHM)를 호출하기 때문에 두 번째 방식은 오류가 발생할 확률이 낮을 뿐만 아니라 더 빠릅니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SystemGetProperty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Dependency" defaultSeverity="ERROR" displayName="잘못된 패키지 종속성" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
주어진 종속성 규칙에 따라 범위 사이의 불법적인 종속성을 보고합니다. 종속성 규칙을 사용해 사용 위치를 한 범위에서 다른 범위로 제한할 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;유효성 규칙을 사용자 지정하려면 아래의 &lt;b&gt;Configure dependency rules(종속성 규칙 구성)&lt;/b&gt; 버튼을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: Dependency&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnstableTypeUsedInSignature" defaultSeverity="WARNING" displayName="불안정한 타입이 시그니처에서 사용됨" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
시그니처의 불안정한 API 타입을 참조하지만, 마찬가지로 불안정한 어노테이션으로 표시되지 않은 클래스, 메서드 및 필드의 선언을 보고합니다.
&lt;p&gt;
  이 검사는 공용 API의 시그니처가 &lt;i&gt;unstable&lt;/i&gt;(내부, 실험적) 타입을 노출하지 않도록 합니다.
  예를 들어 메서드가 &lt;i&gt;experimental&lt;/i&gt; 클래스를 반환한다면 메서드 자체가 &lt;i&gt;experimental&lt;/i&gt;로 간주됩니다. 이는 해당 타입의 호환되지 않는 변경(삭제 또는 다른 패키지로의 이동)이 호환되지 않는 메서드 시그니처 변경으로 이어지지 않기 때문입니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;어떤 어노테이션으로 불안정한 API를 표시할지 지정하려면 아래 목록을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnstableTypeUsedInSignature&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BlockingMethodInNonBlockingContext" defaultSeverity="WARNING" displayName="비 블로킹 컨텍스트의 잠재적 블로킹 호출" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
스레드가 차단되어서는 안 되는 코드 조각에서 스레드를 차단하는 메서드 호출을 보고합니다.

&lt;p&gt;&lt;b&gt;예(프로젝트 Reactor):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
Flux.just("1").flatMap(f -&amp;gt; {
    Flux&amp;lt;String&amp;gt; just = loadUsersFromDatabase();
    just.toIterable(); // 오류: 비 블로킹 범위에서의 블로킹 연산자 호출
    return just;
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Schedulers.boundedElastic()&lt;/code&gt;과 같은 &lt;a href="https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking"&gt;적절한 스케줄러&lt;/a&gt;로 블로킹 코드를 실행하거나 다른 비 블로킹 API를 찾아보세요.&lt;/p&gt;

&lt;br/&gt;

&lt;p&gt;&lt;b&gt;예(Kotlin 코루틴):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="kotlin"&gt;
suspend fun exampleFun() {
    Thread.sleep(100); // 오류: suspend 함수 내 블로킹 메서드 호출
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Dispatchers.IO&lt;/code&gt;과 같은 &lt;a href="https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html"&gt;특별한 디스패처&lt;/a&gt;로 블로킹 코드를 실행하거나 다른 비 블로킹 API를 찾아보세요.&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;Blocking Annotations(차단 어노테이션)&lt;/b&gt; 목록에서 스레드를 차단하는 메서드를 표시하는 어노테이션을 지정하세요.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;Non-Blocking Annotations(비 Blocking 어노테이션)&lt;/b&gt; 목록에서 비 blocking 메서드를 표시하는 어노테이션을 지정하세요.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;지정한 어노테이션은 &lt;a href="https://www.jetbrains.com/help/idea/external-annotations.html"&gt;외부 어노테이션&lt;/a&gt;으로 사용할 수 있습니다&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BlockingMethodInNonBlockingContext&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MustAlreadyBeRemovedApi" defaultSeverity="ERROR" displayName="API가 이미 제거되었습니다." enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
선언하는 라이브러리의 현재 버전에서 제거되었어야 하는 &lt;code&gt;@ApiStatus.ScheduledForRemoval&lt;/code&gt;로 표시된 선언을 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;지정한 예약된 제거 버전을 사용자가 아래에서 설정한 버전과 비교합니다.&lt;/p&gt;
&lt;p&gt;
  마침표로 분리되고 선택적으로 &lt;code&gt;alpha&lt;/code&gt;, &lt;code&gt;beta&lt;/code&gt;, &lt;code&gt;snapshot&lt;/code&gt; 또는 &lt;code&gt;eap&lt;/code&gt; 접미사로 분리된 문자열로 버전을 지정합니다.
&lt;/p&gt;
&lt;p&gt;유효한 버전의 예: &lt;code&gt;1.0&lt;/code&gt;, &lt;code&gt;2.3.1&lt;/code&gt;, &lt;code&gt;2018.1&lt;/code&gt;, &lt;code&gt;7.5-snapshot&lt;/code&gt;, &lt;code&gt;3.0-eap&lt;/code&gt;
&lt;/p&gt;
&lt;p&gt;
  버전 비교는 직관적임: &lt;code&gt;1.0 &amp;lt; 2.0&lt;/code&gt;, &lt;code&gt;1.0-eap &amp;lt; 1.0&lt;/code&gt;, &lt;code&gt;2.3-snapshot &amp;lt; 2.3&lt;/code&gt; 등등
  자세한 비교 로직은 &lt;a
  href="https://github.com/JetBrains/intellij-community/blob/master/platform/util-rt/src/com/intellij/util/text/VersionComparatorUtil.java"&gt;VersionComparatorUtil&lt;/a&gt;의 구현을 참조하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MustAlreadyBeRemovedApi&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonExtendableApiUsage" defaultSeverity="WARNING" displayName="클래스, 인터페이스 또는 메서드가 확장되면 안 됨" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@ApiStatus.NonExtendable&lt;/code&gt;로 표시된 API 요소를 확장, 구현 또는 재정의하는 클래스, 인터페이스 및 메서드를 보고합니다.
&lt;p&gt;
  &lt;code&gt;@ApiStatus.NonExtendable&lt;/code&gt; 어노테이션은 클래스, 인터페이스 또는 메서드가 &lt;strong&gt;확장되거나, 구현되거나, 재정의되어서는 안 된다는 것&lt;/strong&gt;을 나타냅니다.
  그러한 인터페이스 및 클래스를 내부 라이브러리 구현으로 형 변환하는 것은 꽤 흔한 일이므로 클라이언트에서 다른 구현을 제공한다면 &lt;code&gt;ClassCastException&lt;/code&gt;이 발생합니다.
  그러한 클래스 및 인터페이스에 새 추상 메서드를 추가하면 클라이언트 구현에 대한 호환성을 잃습니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  // 업스트림 라이브러리 코드 내
  @ApiStatus.NonExtendable
  public interface MyService {
    public void perform();
  }

  // 다운스트림 클라이언트 코드 내
  public class MyServiceImpl implements MyService {
    @Override
    public void perform() {
      // ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;

이 검사는 또한 어노테이션을 잘못 적용하여 발생하는 다음과 같은 문제를 탐지합니다.
&lt;ul&gt;
  &lt;li&gt;확장/재정의할 수 없는 클래스/메서드에 어노테이션 지정&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@ApiStatus.NonExtendable&lt;/code&gt; 어노테이션이 이미 달린 클래스의 메서드에 불필요하게 어노테이션을 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NonExtendableApiUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SerializableHasSerialVersionUIDField" defaultSeverity="WARNING" displayName="'serialVersionUID'가 없는 serializable 클래스" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Serializable&lt;/code&gt;을 구현하고 &lt;code&gt;serialVersionUID&lt;/code&gt; 필드를 선언하지 않는 클래스를 보고합니다.
&lt;p&gt;
  &lt;code&gt;serialVersionUID&lt;/code&gt; 필드가 없으면, 클래스가 변경되면 이전에 직렬화된 버전을 읽을 수 없게 됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  class Main implements Serializable {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  class Main implements Serializable {
    private static final long serialVersionUID = -1446398935944895849L;
  }
&lt;/code&gt;&lt;/pre&gt;
JDK 14 이상의 언어 수준을 사용하는 경우, 빠른 수정에서는 &lt;code&gt;java.io.Serial&lt;/code&gt; 어노테이션도 추가합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;다음 옵션을 사용해 검사를 구성하세요.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    이 검사에서 보고되어서는 안 되는 상속자를 가진 클래스를 나열합니다.
    이는 상위 클래스에서 &lt;code&gt;Serializable&lt;/code&gt;을 상속받지만 직렬화를 의도하지 않은 클래스를 의미합니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;Serializable&lt;/code&gt; 익명 클래스를 무시할지 여부를 설정합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SerializableHasSerialVersionUIDField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuppressionAnnotation" defaultSeverity="WARNING" displayName="검사 숨기기 어노테이션" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
검사를 억제하는 주석 또는 어노테이션을 보고합니다.
&lt;p&gt;이 검사는 더 많은 검토를 위해 의도적으로 억제를 남길 때 유용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="Java"&gt;
@SuppressWarnings("unused")
static Stream&amp;lt;String&amp;gt; stringProvider() {
    return Stream.of("foo", "bar");
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SuppressionAnnotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Spring Cloud Stream" path="Spring"><inspection shortName="SpringCloudStreamMessageChannelInspection" defaultSeverity="WARNING" displayName="해결되지 않은 메시지 채널" enabled="false" language="UAST" pluginId="com.intellij.spring.cloud" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;@StreamListener&lt;/code&gt;, &lt;code&gt;@SendTo&lt;/code&gt;, &lt;code&gt;@Output&lt;/code&gt; 및 &lt;code&gt;@Input&lt;/code&gt; 어노테이션의 해결되지 않은 채널 속성을 보고합니다.&lt;/p&gt;
&lt;p&gt;잘못된 바인딩 이름을 사용하면 런타임에서 'Bean을 찾을 수 없습니다'라는 오류가 발생합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @EnableBinding(Sink.class)
  public class LogSource {
    @StreamListener(Sink.class)
	  public void log1() {
    }

    @StreamListener("invalid")  // '채널을 찾을 수 없습니다'라고 보고됩니다
	  public void log2() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SpringCloudStreamMessageChannelInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringCloudStreamInconsistencyInspection" defaultSeverity="WARNING" displayName="스트림 핸들러 메서드 오류" enabled="false" language="UAST" pluginId="com.intellij.spring.cloud" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;스트림 핸들러 메서드의 불일치 오류를 보고합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;@StreamListener&lt;/code&gt; 또는 &lt;code&gt;@StreamEmitter&lt;/code&gt; 어노테이션이 추가된 입력 및 출력 스트림 핸들러 메서드에는 다양한 제약이 있습니다.
  그러한 제약 위반 시 런타임 오류가 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;@StreamListener &lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 속성에 정의된 채널은 &lt;code&gt;@Input&lt;/code&gt; 또는 &lt;code&gt;@Output&lt;/code&gt; 어노테이션이 추가된 메서드 매개변수와 결합될 수 없습니다.
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@StreamListener&lt;/code&gt; 어노테이션이 추가된 메서드에 대한 입력 채널을 지정해야 합니다.&lt;/li&gt;
  &lt;li&gt;값을 반환할 수 있는 메서드에 대해 출력 채널을 지정해야 합니다&lt;/li&gt;
  &lt;li&gt;값을 반환하지 않는 메서드에 대해 출력 채널을 지정할 수 없습니다&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@StreamListener&lt;/code&gt; &lt;code&gt;condition&lt;/code&gt; 속성은 값을 반환하는 메서드에 대해 설정할 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SpringCloudStreamInconsistencyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="형 변환" path="Java/숫자 문제"><inspection shortName="UnnecessaryExplicitNumericCast" defaultSeverity="WARNING" displayName="불필요한 명시적 숫자 형 변환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
컴파일러가 묵시적으로 삽입하는 기본 숫자 형 변환을 보고합니다.
또한 컴파일러가 제거하는 모든 기본 숫자 형 변환을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int x = (short)5; // 형 변환이 javac 도구로 제거됩니다&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;code&gt;int x = 5;&lt;/code&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryExplicitNumericCast&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastThatLosesPrecision" defaultSeverity="WARNING" displayName="정밀도를 잃는 숫자 형 변환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
정확도를 떨어뜨릴 수 있는 기본 숫자 타입 간 형 변환 연산을 보고합니다.
&lt;p&gt;이러한 형 변환이 반드시 문제인 것은 아니지만, 예기치 않은 정확도의 저하가 발생한 경우 버그를 추적하기가 어려울 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int a = 420;
  byte b = (byte) a;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;int에서 및 char로의 형 변환 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;int&lt;/code&gt;에서 &lt;code&gt;char&lt;/code&gt;로의 형 변환을 무시합니다.
  이러한 타입의 형 변환은 &lt;code&gt;java.io.Reader&lt;/code&gt; 클래스의 &lt;code&gt;read()&lt;/code&gt; 메서드가 &lt;code&gt;int&lt;/code&gt;를 반환하기 때문에 I/O 연산을 구현할 때 종종 사용됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;int 128~255에서 byte로의 형 변환 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;int&lt;/code&gt;의 상수값(128~255)에서 &lt;code&gt;byte&lt;/code&gt;로의 형 변환을 무시합니다.
  이러한 값은 여전히 ​​1바이트 내에 들어갈 수 있는 음수로 오버플로됩니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CastThatLosesPrecision&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DoubleLiteralMayBeFloatLiteral" defaultSeverity="WARNING" displayName="'float'로 형 변환하면 'float' 리터럴이 될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;float&lt;/code&gt;로 즉시 형 변환되는 &lt;code&gt;double&lt;/code&gt; 리터럴 표현식을 보고합니다.
&lt;p&gt;이러한 리터럴 표현식은 동등한 &lt;code&gt;float&lt;/code&gt; 리터럴로 대체될 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float f = (float)1.1;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float f = 1.1f;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DoubleLiteralMayBeFloatLiteral&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IntLiteralMayBeLongLiteral" defaultSeverity="WARNING" displayName="'long'으로 형 변환하면 'long' 리터럴이 될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;long&lt;/code&gt;으로 즉시 형 변환되는 &lt;code&gt;int&lt;/code&gt; 리터럴 표현식을 보고합니다.
&lt;p&gt;이러한 리터럴 표현식은 동등한 &lt;code&gt;long&lt;/code&gt; 리터럴로 대체될 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Long l = (long)42;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Long l = 42L;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IntLiteralMayBeLongLiteral&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IntegerMultiplicationImplicitCastToLong" defaultSeverity="WARNING" displayName="정수 곱하기 또는 시프트가 'long'으로 묵시적 형 변환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
long으로 묵시적으로 형 변환되는 정수 곱셈 및 왼쪽 시프트 연산을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int i) {
    long val = 65536 * i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 코드는 다음과 같이 변경됩니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void x(int i) {
    long val = 65536&lt;b&gt;L&lt;/b&gt; * i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int i) {
    long value = i &amp;lt;&amp;lt; 24;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 코드는 다음과 같이 변경됩니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int i) {
    long value = (long) i &amp;lt;&amp;lt; 24;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  그러한 곱셈은 보통 실수이며 예기치 않게 오버플로 절단이 발생할 수 있습니다.
  &lt;code&gt;int&lt;/code&gt; 리터럴을 &lt;code&gt;long&lt;/code&gt; 리터럴(&lt;code&gt;65536&lt;b&gt;L&lt;/b&gt;&lt;/code&gt;)로 변환하면 문제를 해결할 수 있습니다.
&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: IntegerMultiplicationImplicitCastToLong&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring 통합" path="Spring"><inspection shortName="SpringIntegrationMethodEndpointInconsistency" defaultSeverity="WARNING" displayName="잘못된 Spring Integration 엔드포인트 메서드" enabled="false" language="JAVA" pluginId="com.intellij.spring.integration" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
잘못된 &lt;a href="https://spring.io/projects/spring-integration"&gt;Spring Integration&lt;/a&gt; 엔드포인트 메서드 선언을 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class MyEndpoints {
  @InboundChannelAdapter("channel")
  public void &lt;strong&gt;cannotBeVoid&lt;/strong&gt;() {...} // @InboundChannelAdapter 어노테이션이 추가된 메서드에는 반환 타입이 있어야 합니다

  @InboundChannelAdapter("channel")
  public String &lt;strong&gt;cannotHaveParams&lt;/strong&gt;(String s) {..} // A method annotated with @InboundChannelAdapter can't have arguments

  @&lt;strong&gt;Filter&lt;/strong&gt;(inputChannel = "channel", // 엔드포인트는 단 하나의 poller만 가질 수 있습니다
    outputChannel = "channel2",
    poller = {@Poller(fixedDelay = "100"), @Poller(fixedRate = "100")})
  public void testMultiplePollers() {
  }

  @Filter(inputChannel = "channel",
  outputChannel = "channel2",
  poller = @&lt;strong&gt;Poller&lt;/strong&gt;(value = "poller", maxMessagesPerPoll = "100"))
  public void testValue() {
  }

  @Filter(inputChannel = "channel",
    outputChannel = "channel2",
    poller = @&lt;strong&gt;Poller&lt;/strong&gt;(trigger = "trigger", cron = "0 */10 * * * *")) // 'trigger' 속성은 다른 속성과 상호 배타적입니다
  public void testTrigger() {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringIntegrationMethodEndpointInconsistency&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringIntegrationDeprecations21" defaultSeverity="WARNING" displayName="Spring 통합 2.1에서 곧 사용 중단" enabled="false" language="XML" pluginId="com.intellij.spring.integration" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;최신 버전의 &lt;a href="https://spring.io/projects/spring-integration"&gt;Spring Integration&lt;/a&gt; XML 기반 애플리케이션 컨텍스트에서 지원이 중단된 XML 요소를 보고합니다.&lt;/p&gt;

&lt;p&gt;자세한 내용은 &lt;a href="https://github.com/SpringSource/spring-integration/wiki/Spring-Integration-2.0-to-2.1-Migration-Guide"&gt;마이그레이션 가이드&lt;/a&gt;를 참조하세요.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;beans ... &amp;gt;
   &amp;lt;int:channel id="failChannel"
                dispatcher="&lt;strong&gt;failover&lt;/strong&gt;"/&amp;gt; &amp;lt;!-- 이 속성은 지원 중단되었습니다. 디스패처의 하위 요소를 사용하세요 --&amp;gt;
   &amp;lt;int:poller default="true"&amp;gt;
     &amp;lt;&lt;strong&gt;int:cron-trigger&lt;/strong&gt;  expression="5"/&amp;gt;  &amp;lt;!-- 이 요소는 Spring Integration 2.1에서 제거되었습니다. 대신 'cron' 속성을 사용하세요 --&amp;gt;
     &amp;lt;&lt;strong&gt;int:interval-trigger&lt;/strong&gt; interval="3"/&amp;gt; &amp;lt;!--  이 요소는 Spring Integration 2.1에서 제거되었습니다. 대신 interval-trigger 속성을 사용하세요 --&amp;gt;
  &amp;lt;/int:poller&amp;gt;
  &amp;lt;ftp:inbound-channel-adapter session-factory="ftpSessionFactory"
                               cache-sessions="&lt;strong&gt;false&lt;/strong&gt;" &amp;lt;!--  이 속성은 지원 중단되었습니다. 대신 CachingSessionFactory를 사용하세요 --&amp;gt;
                               channel="channel"/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringIntegrationDeprecations21&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnresolvedMessageChannel" defaultSeverity="WARNING" displayName="엔드포인트 메서드 어노테이션 내 잘못된 'channel' 속성" enabled="false" language="JAVA" pluginId="com.intellij.spring.integration" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;엔드포인트 메서드 어노테이션의 잘못된 채널 속성을 보고합니다(&lt;a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/annotation/Gateway.html"&gt;@Gateway&lt;/a&gt;,
&lt;a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/annotation/ServiceActivator.html"&gt;@ServiceActivator,&lt;/a&gt;
&lt;a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/annotation/Filter.html"&gt;@Filter&lt;/a&gt; 등).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  @Component
  public class MyComponent {}
     @Gateway(requestChannel = "requestChannel", replyChannel = "replyChannel")
     public void gateway() {...}

     @Gateway(
        requestChannel ="&lt;strong&gt;simpleBean&lt;/strong&gt;",   // Bean이 다음 타입 중 하나여야 합니다 org.springframework.integration.MessageChannel,org.springframework.messaging.MessageChannel
        replyChannel = "&lt;strong&gt;unknownChannel&lt;/strong&gt;")   // 채널을 찾을 수 없습니다
     public void errors() {...}

     @Bean
     public MyBean simpleBean() {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnresolvedMessageChannel&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;

</inspection><inspection shortName="SpringIntegrationModel" defaultSeverity="ERROR" displayName="잘못된 Spring Integration XML 기반 애플리케이션 컨텍스트" enabled="false" language="XML" pluginId="com.intellij.spring.integration" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href="https://spring.io/projects/spring-integration"&gt;Spring Integration&lt;/a&gt; XML 기반 애플리케이션 컨텍스트 관련 문제를 보고합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;해결되지 않은 bean 참조&lt;/li&gt;
  &lt;li&gt;필요한 태그 또는 속성 누락&lt;/li&gt;
  &lt;li&gt;잘못된 프로퍼티 타입&lt;/li&gt;
  &lt;li&gt;일관성 없는 &lt;code&gt;enum&lt;/code&gt; 프로퍼티&lt;/li&gt;
  &lt;li&gt;참조된 bean의 잘못된 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans ... &amp;gt;
  &amp;lt;int:channel id="channel"&amp;gt; &amp;lt;!-- 'dispatcher' and 'queue' can't be used together  --&amp;gt;
    &amp;lt;int:dispatcher failover="true"/&amp;gt;
    &amp;lt;int:priority-queue capacity="4"/&amp;gt;
  &amp;lt;/int:channel&amp;gt;
  
  &amp;lt;int:channel id="another" &amp;gt;
    &amp;lt;int:queue &amp;lt;!--Exactly one of 'message-store' or 'ref' is required  --&amp;gt;
              capacity="4" message-store="myMessageStore" ref="myQueue"/&amp;gt;
  &amp;lt;/int:channel&amp;gt;
  
   &amp;lt;int:gateway id="asyncGatewayError"
                async-executor="dummyBean"/&amp;gt; &amp;lt;!--Bean must be of 'java.util.concurrent.Executor' type  --&amp;gt;

   &amp;lt;int:delayer default-delay="3"
              message-store="myMessageStore"
              scheduler="scheduler"
              wait-for-tasks-to-complete-on-shutdown="false"/&amp;gt;
  &amp;lt;!--Bean must be of 'java.util.concurrent.Executor' type  --&amp;gt;
  &amp;lt;int:delayer
    default-delay="INVALID_VALUE"  &amp;lt;!--Cannot convert string 'INVALID_VALUE' to target class 'java.lang.Integer' --&amp;gt;
               message-store="dummyBean" &amp;lt;!-- Bean must be of 'org.springframework.integration.store.MessageStore' type--&amp;gt;
               scheduler="dummyBean" &amp;lt;!-- Bean must be one of these types: java.util.concurrent.ScheduledExecutorService,org.springframework.scheduling.TaskScheduler--&amp;gt;
               wait-for-tasks-to-complete-on-shutdown="INVALID_VALUE"/&amp;gt; &amp;lt;!-- Cannot resolve symbol 'INVALID_VALUE' --&amp;gt;

  &amp;lt;bean id="dummyBean" class="java.lang.String"/&amp;gt;
  &amp;lt;bean id="myMessageStore" class="org.springframework.integration.store.SimpleMessageStore"/&amp;gt;
  &amp;lt;task:scheduler id="scheduler"/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringIntegrationModel&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;

</inspection></group><group name="JSONPath" path=""><inspection shortName="JsonPathUnknownFunction" defaultSeverity="WARNING" displayName="알 수 없는 JSONPath 함수" enabled="false" language="JSONPath" pluginId="com.intellij.jsonpath" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
알려진 표준 함수 이름인 &lt;code&gt;concat&lt;/code&gt;, &lt;code&gt;keys&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt;, &lt;code&gt;stddev&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;이 아닌 JSONPath 함수 호출 내 알 수 없는 이름을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JsonPathUnknownFunction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonPathEvaluateUnknownKey" defaultSeverity="WARNING" displayName="JSONPath 표현식 평가에 사용된 알 수 없는 프로퍼티 키" enabled="false" language="JSONPath" pluginId="com.intellij.jsonpath" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
평가할 소스 JSON 문서에서 누락된 JSONPath 표현식 내 키를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JsonPathEvaluateUnknownKey&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonPathUnknownOperator" defaultSeverity="WARNING" displayName="알 수 없는 JSONPath 연산자" enabled="false" language="JSONPath" pluginId="com.intellij.jsonpath" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
표준 연산자인 &lt;code&gt;in&lt;/code&gt;,&lt;code&gt;nin&lt;/code&gt;,&lt;code&gt;subsetof&lt;/code&gt;,&lt;code&gt;anyof&lt;/code&gt;,&lt;code&gt;noneof&lt;/code&gt;,&lt;code&gt;size&lt;/code&gt;,&lt;code&gt;empty&lt;/code&gt;,&lt;code&gt;contains&lt;/code&gt;가 아닌 JSONPath 표현식 내 알 수 없는 연산자를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JsonPathUnknownOperator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Cron" path=""><inspection shortName="CronExpressionValidationInspection" defaultSeverity="ERROR" displayName="Cron 표현식 검증" enabled="false" language="CronExp" pluginId="com.intellij.cron" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 cron 식을 보고합니다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  1 5 4 * * 8 //cron 식 분석 실패. 값 8은 [0, 7] 범위 밖입니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CronExpressionValidationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="선언 중복성" path="Java"><inspection shortName="DefaultAnnotationParam" defaultSeverity="WARNING" displayName="디폴트 어노테이션 매개변숫값" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
어노테이션 매개변수가 &lt;code&gt;default&lt;/code&gt; 값에 대입된 경우를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @interface Test {
      Class&amp;lt;?&gt; expected() default Throwable.class;
  }

  @Test(expected = Throwable.class)
  void testSmth() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test()
  void testSmth() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DefaultAnnotationParam&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantLambdaParameterType" defaultSeverity="INFORMATION" displayName="불필요한 람다 매개변수 타입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
컨텍스트에서 추론 가능하므로 불필요한 람다 형식 매개변수 타입을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Map&amp;lt;String, Integer&amp;gt; map = ...
  map.forEach((String s, Integer i) -&gt; log.info(s + "=" + i));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 람다의 매개변수 타입을 제거합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Map&amp;lt;String, Integer&amp;gt; map = ...
  map.forEach((s, i) -&gt; log.info(s + "=" + i));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantLambdaParameterType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java9RedundantRequiresStatement" defaultSeverity="WARNING" displayName="module-info 내 불필요한 'requires' 지시문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Java Platform Module System &lt;code&gt;module-info.java&lt;/code&gt; 파일의 불필요한 &lt;code&gt;requires&lt;/code&gt; 지시문을 보고합니다.
모듈 &lt;code&gt;A&lt;/code&gt;에 모듈 &lt;code&gt;B&lt;/code&gt;가 필요하지만 모듈 &lt;code&gt;A&lt;/code&gt;의 코드가 &lt;code&gt;B&lt;/code&gt;에서 패키지나 클래스를 가져오지 않는 경우, &lt;code&gt;requires&lt;/code&gt; 지시문이 불필요합니다.
또한 모든 모듈에는 &lt;code&gt;java.base&lt;/code&gt; 모듈에 대한 종속성이 묵시적으로 선언되어 있으므로 &lt;code&gt;requires java.base;&lt;/code&gt; 지시문은 항상 불필요합니다.
&lt;p&gt;
  빠른 수정에서는 불필요한 &lt;code&gt;requires&lt;/code&gt; 지시문을 삭제합니다.
  삭제된 종속성에서 실제로 사용되는 모듈을 다시 내보낸 경우, 수정 기능은 이러한 모듈에 대한 &lt;code&gt;requires&lt;/code&gt; 지시문을 추가합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 9 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: Java9RedundantRequiresStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WeakerAccess" defaultSeverity="WARNING" displayName="선언 액세스를 제한할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
접근 제어자가 좁혀진 필드, 메서드 혹은 클래스를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Sample {
    void foo() {
        bar("foo", "foo");
    }
    void bar(String x, String y) { } // private일 수 있습니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Sample {
    void foo() {
        bar("foo", "foo");
    }
    private void bar(String x, String y) { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사의 옵션을 사용하여 제어자 변경 제안의 규칙을 정의합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: WeakerAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FinalMethodInFinalClass" defaultSeverity="WARNING" displayName="'final' 클래스의 'final' 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;final&lt;/code&gt; 클래스의 &lt;code&gt;final&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;&lt;code&gt;final&lt;/code&gt; 클래스는 상속될 수 없으므로 메서드를 &lt;code&gt;final&lt;/code&gt;로 표시하는 것은 불필요하며 혼동될 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;record Bar(int a, int b) {
  public final int sum() { 
     return a + b;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;record Bar(int a, int b) {
  public int sum() { 
     return a + b;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예시에 나오듯이 클래스는 명시적 또는 묵시적으로 &lt;code&gt;final&lt;/code&gt;로 표시될 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FinalMethodInFinalClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrivialFunctionalExpressionUsage" defaultSeverity="WARNING" displayName="함수식의 자명한 사용 위치" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
람다, 메서드 참조 또는 익명 클래스의 정의에서 직접 호출되는 함수형 인터페이스 메서드 호출을 보고합니다.
이러한 메서드 호출은 함수형 인터페이스 구현의 본문으로 바꿀 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean contains(List&amp;lt;String&amp;gt; names, String name) {
    return ((Predicate&amp;lt;String&amp;gt;)x -&gt; {
      return names.contains(x);
    }).test(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 메서드 호출은 다음과 같이 변경됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean contains(List&amp;lt;String&amp;gt; names, String name) {
    return names.contains(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TrivialFunctionalExpressionUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaModuleDefinition" defaultSeverity="WARNING" displayName="Java 모듈 정의 문제" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
module-info.java 파일의 기타 문제를 보고합니다. 예를 들어, 입력되었으나 내보내지지 않거나 사용되지 않은 서비스를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
module myModule {
  // 서비스가 입력되었으나 이를 포함하는 패키지가 내보내지지 않습니다
  provides com.example.MyService with com.example.MyServiceImpl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavaModuleDefinition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ProtectedMemberInFinalClass" defaultSeverity="WARNING" displayName="'final' 클래스의 'protected' 멤버" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;protected&lt;/code&gt; 제어자가 없는 &lt;code&gt;final&lt;/code&gt; 클래스에서 &lt;code&gt;protected&lt;/code&gt; 멤버를 보고합니다.
&lt;p&gt;&lt;code&gt;final&lt;/code&gt; 클래스는 상속될 수 없으므로 메서드를 &lt;code&gt;protected&lt;/code&gt;로 표시하면 혼동될 수 있습니다. 해당 멤버를 &lt;code&gt;private&lt;/code&gt; 또는 package-visible로 선언하는 것이 좋습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;record Bar(int a, int b) {
  protected int sum() { 
     return a + b;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;record Bar(int a, int b) {
  int sum() { 
     return a + b;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예시에 나오듯이 클래스는 명시적 또는 묵시적으로 &lt;code&gt;final&lt;/code&gt;로 표시될 수 있습니다.&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ProtectedMemberInFinalClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedLabel" defaultSeverity="WARNING" displayName="사용되지 않는 라벨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; 문의 대상이 아닌 라벨을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  label: &lt;b&gt;for&lt;/b&gt; (int i = 0; i &amp;lt; 10; i++) {
    &lt;b&gt;if&lt;/b&gt; (i == 3) {
      &lt;b&gt;break&lt;/b&gt;;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 라벨이 제거됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;for&lt;/b&gt; (int i = 0; i &amp;lt; 10; i++) {
    &lt;b&gt;if&lt;/b&gt; (i == 3) {
      &lt;b&gt;break&lt;/b&gt;;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnusedLabel&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SafeVarargsOnNonReifiableType" defaultSeverity="WARNING" displayName="@SafeVarargs를 구체화 타입에 적용할 수 없습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@SafeVarargs&lt;/code&gt;&lt;/0&gt;로 어노테이션된 가변 arity 메서드의 reifiable 타입을 보고합니다.
이 경우 어노테이션이 불필요합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    @SafeVarargs
    public final void processStrings(String... strings) {
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;어노테이션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SafeVarargsOnNonReifiableType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyInitializer" defaultSeverity="WARNING" displayName="빈 클래스 이니셜라이저" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
빈 클래스 이니셜라이저 블록을 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: EmptyInitializer&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SillyAssignment" defaultSeverity="WARNING" displayName="변수가 자기 대입됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
자신에게 대입된 변수를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 해당 대입을 제거합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SillyAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AccessStaticViaInstance" defaultSeverity="WARNING" displayName="인스턴스 참조를 통해 static 멤버에 액세스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스 자체가 아닌 클래스 인스턴스를 통한 &lt;code&gt;static&lt;/code&gt; 메서드 및 필드에 대한 참조를 보고합니다.
&lt;p&gt;Java 언어 사양에서 인스턴스 변수를 통한 static 멤버 참조가 허용되지만
  사용자는 메서드 결과가 인스턴스에 따라 달라진다고 생각할 수 있으므로 코드가 혼란을 유발할 수 있습니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 인스턴스 변수를 클래스 이름으로 바꿉니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s1 = s.valueOf(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = String.valueOf(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: AccessStaticViaInstance&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryModuleDependencyInspection" defaultSeverity="WARNING" displayName="불필요한 모듈 종속성" enabled="false" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
모듈에서 사용되지 않는 종속성을 보고합니다. 빠른 수정에서는 사용되지 않는 종속성을 안전하게 제거합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryModuleDependencyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantThrows" defaultSeverity="WARNING" displayName="Redundant throws clause" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
메서드의 시그니처에 선언되었지만 메서드 자체 또는 메서드의 구현 및 재정의하는 메서드에서 던지지 않은 예외를 보고합니다.
&lt;p&gt;이 검사는 직렬화와 관련된 메서드를 무시합니다(예: &lt;code&gt;readObject()&lt;/code&gt; 및 &lt;code&gt;writeObject()&lt;/code&gt; 메서드).&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void method() throws InterruptedException {
    System.out.println();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 선언에서 불필요한 예외를 제거하며 불필요한 &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt; 문을 정규화합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void method() {
    System.out.println();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;b&gt;참고:&lt;/b&gt; 에디터 내 강조 표시가 되는 동안 성능상의 이유로 일부 예외는 보고되지 않을 수 있습니다.
  모든 결과를 확인하려면 메인 메뉴의 &lt;b&gt;Code(코드) | Inspect Code(코드 검사)&lt;/b&gt; 또는 &lt;b&gt;Code(코드) | Analyze Code(코드 분석) | Run Inspection by Name(이름별로 검사 실행)&lt;/b&gt;을 선택하여 검사를 실행합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;진입점 메서드에서 던진 예외 무시&lt;/b&gt; 옵션을 사용하면 &lt;code&gt;main()&lt;/code&gt; 같은 메서드에서 던진 예외를 보고하지 않습니다.
  진입점 메서드는 &lt;a href="settings://Errors?Unused%20Declaration%20entry%20point"&gt;Java | 선언 중복성 | 사용되지 않는 선언&lt;/a&gt; 검사의 설정에서 구성할 수 있습니다.
  &lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantThrows&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantExplicitClose" defaultSeverity="WARNING" displayName="불필요한 'close()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
try-with-resources 블록 끝 부분의 불필요한 &lt;code&gt;close()&lt;/code&gt; 호출을 보고하고 제거할 것을 제안합니다.
&lt;p&gt;&lt;b&gt;예&lt;/b&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try(MyAutoCloseable ac = new MyAutoCloseable()) {
    foo();
    ac.close();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try(MyAutoCloseable ac = new MyAutoCloseable()) {
    foo();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantExplicitClose&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CanBeFinal" defaultSeverity="WARNING" displayName="선언은 'final' 제어자를 가질 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
필드, 메서드 또는 클래스 중 선언에 &lt;code&gt;final&lt;/code&gt; 제어자가 추가될 수 있는 항목을 보고합니다.
&lt;p&gt;final 클래스는 확장될 수 없으며, final 메서드는 재정의될 수 없고, final 필드는 재할당될 수 없습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Person {
    private String name;

    Person(String name) {
      this.name = name;
    }

    public String getName() {
      return name;
    }

    public String toString() {
      return getName();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public final class Person {
    private final String name;

    Person(String name) {
      this.name = name;
    }

    public final String getName() {
      return name;
    }

    public final String toString() {
      return getName();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;클래스 보고&lt;/b&gt; 및 &lt;b&gt;메서드 보고&lt;/b&gt; 옵션을 사용하여 보고할 선언을 정의합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CanBeFinal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedReturnValue" defaultSeverity="WARNING" displayName="메서드를 'void'로 만들 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
호출 시 반환 값이 사용되지 않는 메서드를 보고합니다.
해당 메서드의 반환 타입은 &lt;code&gt;void&lt;/code&gt;일 수 있습니다.
&lt;p&gt;Error Prone 또는 AssertJ의 &lt;code&gt;@CanIgnoreReturnValue&lt;/code&gt; 어노테이션이 추가된 메서드는 보고되지 않습니다.
  빠른 수정에서는 해당 메서드 시그니처를 업데이트하고 메서드 내부에서 &lt;code&gt;return&lt;/code&gt; 문을 제거합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 가시성 설정이 Protected 또는 Public인 경우 보고됩니다
  protected String myToUpperCase(String s) {
    return s.toUpperCase();
  }

  // 간단한 setter. 보고는 설정에 따라 다릅니다
  public String setStr(String str) {
    myStr = str;
    return myStr;
  }

  void test() {
    setStr("value");          // 반환 값이 사용되지 않습니다
    myToUpperCase("result");  // 반환 값이 사용되지 않습니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 두 메서드에 모두 적용된 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    protected void myToUpperCase(String s) {
      // 's.toUpperCase()'에 부수 효과가 없으므로
      // 'return'이 완전히 제거됩니다
    }

    public void setStr(String str) {
      myStr = str;
      // 'return'이 제거됩니다
    }
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;b&gt;참고:&lt;/b&gt; 에디터 내 강조 표시가 되는 동안 성능상의 이유로 일부 메서드는 보고되지 않을 수 있습니다.
  모든 결과를 확인하려면 &lt;b&gt;Code(코드) | Inspect Code(코드 검사)&lt;/b&gt; 또는 &lt;b&gt;Code(코드) | Analyze Code(코드 분석) | Run Inspection by Name(이름별로 검사 실행)&lt;/b&gt;을 사용하여 검사를 실행합니다&gt;
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;체인화 가능한 메서드 무시&lt;/b&gt; 옵션을 사용하여, 체인화 가능한 호출에서 사용되지 않는 반환값을 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;보고된 메서드의 최대 가시성&lt;/b&gt; 옵션을 사용하여 보고된 메서드의 최대 가시성을 제어합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnusedReturnValue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DuplicateThrows" defaultSeverity="WARNING" displayName="중복 throws" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 &lt;code&gt;throws&lt;/code&gt; 목록의 중복 예외를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f() throws Exception, Exception {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f() throws Exception {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;다른 예외가 하위 클래스인 예외 무시&lt;/b&gt; 옵션을 사용하여 다른 예외를 하위 클래스로 갖는 예외를 무시합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DuplicateThrows&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FunctionalExpressionCanBeFolded" defaultSeverity="WARNING" displayName="함수식을 접을 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
함수형 인터페이스 타입 메서드를 가리키므로 불필요한 객체 할당을 제거하는 한정자로 대체 가능한 메서드 참조 또는 람다 식을 보고합니다.

&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  SwingUtilities.invokeLater(r::run);
  SwingUtilities.invokeAndWait(() -&gt; r.run());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  SwingUtilities.invokeLater(r);
  SwingUtilities.invokeAndWait(r);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 8 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FunctionalExpressionCanBeFolded&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantRecordConstructor" defaultSeverity="WARNING" displayName="불필요한 레코드 생성자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Java 레코드에 선언된 불필요한 생성자를 보고합니다.
&lt;p&gt;&lt;b&gt;예시 1:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record Point(int x, int y) {
    public Point {} // 제거 가능합니다
  }
  
  record Point(int x, int y) {
    public Point(int x, int y) { // 제거 가능합니다
      this.x = x;
      this.y = y;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 불필요한 생성자를 제거합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예시 2:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
   // 간결한 생성자로 변환 가능합니다
  record Range(int from, int to) {
    public Range(int from, int to) {
      if (from &gt; to) throw new IllegalArgumentException();
      this.from = from;
      this.to = to;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 이 코드를 간결한 생성자로 변환합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 16부터 사용할 수 있는 Java 기능 &amp;#39;기록&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantRecordConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SameParameterValue" defaultSeverity="WARNING" displayName="메서드 매개변수 값은 항상 동일한 값입니다" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
항상 동일한 상수 값을 갖는 메서드 매개변수를 보고합니다.

&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static void printPoint(int x, int y) { // x는 항상 0입니다
    System.out.println(x + ", " + y);
  }

  public static void main(String[] args) {
    printPoint(0, 1);
    printPoint(0, 2);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정은 상수 값을 인라인화합니다. 이를 통해 메서드 구현을 간소화할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;빠른 수정이 없을 때 무시&lt;/b&gt; 옵션을 사용하여 다음의 경우 검사를 억제합니다.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;매개변수가 메서드 안에서 수정된 경우&lt;/li&gt;
  &lt;li&gt;전달되는 매개변숫값이 접근할 수 없는 필드에 대한 참조인 경우(Java에서만)&lt;/li&gt;
  &lt;li&gt;매개변수가 vararg인 경우(Java에서만)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  &lt;b&gt;메서드의 최대 가시성&lt;/b&gt; 옵션을 사용하여 보고될 메서드의 최대 가시성을 제어합니다.
&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;매개변수를 보고할 최소 메서드 사용 위치의 수&lt;/b&gt; 필드를 사용하여 매개변숫값이 같은 메서드의 최소 사용 위치 수를 지정하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SameParameterValue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SameReturnValue" defaultSeverity="WARNING" displayName="메서드가 항상 동일한 값을 반환" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
항상 같은 상수를 반환하는 메서드와 메서드 계층 구조를 보고합니다.
&lt;p&gt;
이 검사는 배치 모드(&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는 &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;)일 때와 에디터에서 즉시 사용할 때 다르게 동작합니다.
&lt;ul&gt;
  &lt;li&gt;배치 모드에서는 검사가 항상 같은 상수를 반환하는 메서드와 메서드 계층 구조를 보고합니다.&lt;/li&gt;
  &lt;li&gt;에디터에서는 검사가 2개 이상의 &lt;code&gt;return&lt;/code&gt; 문이 있으며, 상위 메서드가 없고 재정의가 되지 않는 메서드만 보고합니다. 메서드가 메서드를 재정의하거나 구현하는 경우, 해당 메서드가 특정 상수를 반환하도록 컨트랙트에서 요구할 수 있으며, 이때 여러 종료점을 두는 것이 좋습니다. 메서드가 재정의될 수 있는 경우 하위 클래스에서 다른 값이 반환될 수도 있습니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
                // 배치 모드에서만 경고:
    int xxx() { // 메서드 'xxx()' 및 해당하는 모든 재정의 메서드가 항상 '0'을 반환합니다
      return 0;
    }
  }

  class Y extends X {
    @Override
    int xxx() {
        return 0;
    }

                // 배치 모드에서만 경고:
    int yyy() { // 메서드 'yyy()'가 항상 '0'을 반환합니다
        return 0;
    }

                                  // 배치 모드 및 즉석 검사 모두 경고:
    final int zzz(boolean flag) { // 메서드 'zzz()'가 항상 '0'을 반환합니다
        if (Math.random() &gt; 0.5) {
            return 0;
        }
        return 0;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SameReturnValue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedLibrary" defaultSeverity="WARNING" displayName="사용되지 않는 라이브러리" enabled="false" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
코드에 직접 사용되지 않으면서 지정된 검사 범위에 연결된 라이브러리를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: UnusedLibrary&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="unused" defaultSeverity="WARNING" displayName="사용되지 않는 선언" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
사용되지 않거나 진입점에서 도달할 수 없는 클래스, 메서드 및 필드를 보고합니다.
&lt;p&gt; 진입점은 지정된 범위 밖의 메인 메서드, 테스트, 클래스 및 &lt;code&gt;module-info.java&lt;/code&gt;에서 액세스 가능한 클래스 등일 수 있습니다. 또한 이름 패턴 또는 어노테이션을 사용하여 사용자 지정 진입점을 구성할 수도 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Department {
    private Organization myOrganization;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예시에서 &lt;code&gt;Department&lt;/code&gt;는 명시적으로 &lt;code&gt;Organization&lt;/code&gt;을 참조하지만 &lt;code&gt;Department&lt;/code&gt; 클래스 자체가 사용되지 않으면 검사는 두 클래스를 모두 보고합니다. &lt;/p&gt;
&lt;p&gt;
  또한 이 검사는 해당 메서드 및 모든 메서드 구현/재정의에서 사용되지 않는 매개변수, 그리고 선언되었지만 사용되지 않는 지역 변수를 보고합니다.
&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;참고:&lt;/b&gt; 사용되지 않는 멤버 중 에디터 내 강조 표시로 보고되지 않는 멤버도 있습니다. 성능상의 이유로 private이 아닌 멤버는 프로젝트에서 이름이 거의 나오지 않는 경우에만 검사됩니다.
  모든 결과를 확인하려면 메인 메뉴의 &lt;b&gt;Code(코드) | Inspect Code(코드 검사)&lt;/b&gt; 또는 &lt;b&gt;Code(코드) | Analyze Code(코드 분석) | Run Inspection by Name(이름별로 검사 실행)&lt;/b&gt;을 선택하여 검사를 실행합니다.
&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;하단의 가시성 설정을 사용하여 보고할 멤버를 구성합니다. 예를 들어, &lt;code&gt;private&lt;/code&gt; 메서드만 보고하도록 구성하면 &lt;code&gt;private&lt;/code&gt; 내부 클래스의 &lt;code&gt;public&lt;/code&gt; 메서드는 보고되지만 최상위 클래스의 &lt;code&gt;protected&lt;/code&gt; 메서드는 무시됩니다.&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;entry points(진입점)&lt;/b&gt; 탭을 사용하여 검사 실행 중에 검토할 진입점을 구성합니다.&lt;/p&gt;
&lt;p&gt; 검사 결과가 준비되면 진입점을 수동으로 추가할 수 있습니다.&lt;/p&gt;
&lt;p&gt; 코드에서 지원되지 않는 프레임워크를 사용한 경우 몇 가지 옵션이 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프레임워크에서 어노테이션이 필요한 경우 &lt;b&gt;어노테이션...&lt;/b&gt; 버튼을 사용해 프레임워크의 어노테이션을 구성합니다.&lt;/li&gt;
  &lt;li&gt;프레임워크에서 어노테이션이 필요하지 않은 경우 프레임워크에서 필요한 클래스 이름 패턴을 구성합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이렇게 하면 프레임워크 내부에서 액세스 가능하며 어노테이션이 추가된 코드가 사용된 것으로 취급됩니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: unused&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="모듈화 문제" path="Java"><inspection shortName="ClassIndependentOfModule" defaultSeverity="WARNING" displayName="해당 모듈에의존하지 않는 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
다음 조건에 해당하는 클래스를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;해당 모듈의 다른 클래스에 종속되지 않음&lt;/li&gt;
  &lt;li&gt;해당 모듈에 있는 다른 클래스의 종속성이 아님&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 클래스는 임시 또는 일관성 없는 모듈화 전략을 나타내며, 이동하는 것이 좋은 경우가 종종 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassIndependentOfModule&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassOnlyUsedInOneModule" defaultSeverity="WARNING" displayName="다른 모듈에서만 사용되는 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
다음 조건에 해당하는 클래스를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;해당 모듈의 다른 클래스에 종속되지 않음&lt;/li&gt;
  &lt;li&gt;다른 모듈의 클래스에 종속됨&lt;/li&gt;
  &lt;li&gt;해당 기타 모듈의 클래스에 대한 유일한 종속성임&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 클래스는 종속되어 있는 모듈로 이동할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassOnlyUsedInOneModule&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ModuleWithTooManyClasses" defaultSeverity="WARNING" displayName="클래스가 너무 많은 모듈" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
너무 많은 클래스를 포함하는 모듈을 보고합니다. 과도하게 큰 모듈은 디자인 명확도가 부족함을 나타냅니다.
Java, Kotlin 및 Groovy 클래스가 개수에 포함됩니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;최대 클래스 수&lt;/b&gt; 필드를 사용하여 모듈이 포함하는 최대 클래스 개수를 지정하세요.&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ModuleWithTooManyClasses&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ModuleWithTooFewClasses" defaultSeverity="WARNING" displayName="클래스가 너무 적은 모듈" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
너무 적은 클래스를 포함하는 모듈을 보고합니다. 과도하게 작은 모듈은 너무 세분화된 디자인을 나타냅니다.
Java, Kotlin 및 Groovy 클래스가 개수에 포함됩니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;최소 클래스 수&lt;/b&gt; 필드를 사용하여 모듈이 포함하는 최소 클래스 개수를 지정하세요.&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ModuleWithTooFewClasses&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InconsistentLanguageLevel" defaultSeverity="WARNING" displayName="일관되지 않은 언어 수준 설정" enabled="false" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
언어 수준이 더 높은 다른 모듈에 종속된 모듈을 보고합니다. 
&lt;p&gt;이러한 종속성을 제거하거나 해당 모듈의 언어 수준을 높여야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InconsistentLanguageLevel&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="장황하거나 중복 코드 구문" path="Java"><inspection shortName="ConditionCoveredByFurtherCondition" defaultSeverity="WARNING" displayName="조건이 추가 조건에 포함됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
후속 조건에 의해 완전히 검사되므로 불필요한 조건을 보고합니다.
&lt;p&gt;예를 들어, &lt;code&gt;value != -1 &amp;&amp; value &gt; 0&lt;/code&gt; 조건에서 첫 번째 부분은 불필요합니다. 
false인 경우 두 번째 부분도 false입니다.
또는 &lt;code&gt;obj != null &amp;&amp; obj instanceof String&lt;/code&gt;과 같은 조건에서는
  &lt;code&gt;instanceof&lt;/code&gt; 연산자가 null이 아님을 의미하므로 null 검사는 불필요합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConditionCoveredByFurtherCondition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MappingBeforeCount" defaultSeverity="WARNING" displayName="count() 이전의 매핑 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;count()&lt;/code&gt; 호출 바로 앞에 있는 &lt;code&gt;map()&lt;/code&gt; 또는 &lt;code&gt;boxed()&lt;/code&gt;와 같이 불필요한 &lt;code&gt;Stream&lt;/code&gt; API 호출을 보고합니다.
&lt;p&gt;
  이러한 호출은 최종 집계를 변경하지 않으므로 제거할 수 있습니다. 코드가 그러한 매핑 호출에 있는 람다의 부수 효과에 의존하는 것일 수도 있습니다. 그러나 스트림 체인 내의 부수 효과에 의존하는 것은 매우 좋지 않습니다. 그러한 호출이 추후의 Java 버전에서 제거되지 않는다는 보장은 없습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // map() 호출은 불필요합니다
  long count = list.stream().filter(s -&gt; !s.isEmpty()).map(s -&gt; s.trim()).count();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2024.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MappingBeforeCount&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantClassCall" defaultSeverity="WARNING" displayName="중복 'isInstance()' 또는 'cast()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.Class&lt;/code&gt; 메서드의 불필요한 호출을 보고합니다.
&lt;p&gt;예를 들어, &lt;code&gt;Xyz.class.isInstance(object)&lt;/code&gt;를 &lt;code&gt;object instanceof Xyz&lt;/code&gt;로 대체할 수 있습니다.
instanceof 검사가 선호됩니다. 메서드가 고유하므로 성능은 동일할 수 있지만 static 검사를 더 잘 표현합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantClassCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastCanBeRemovedNarrowingVariableType" defaultSeverity="WARNING" displayName="변수 타입이 너무 취약하여 불필요한 형 변환 발생" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
변수 타입이 형 변환 타입으로 좁혀진 경우 제거할 수 있는 형 변환을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object x = "  string  ";
  System.out.println(((String)x).trim());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
여기서 &lt;code&gt;x&lt;/code&gt; 타입을 &lt;code&gt;String&lt;/code&gt;으로 변경하는 것은 불필요한 형 변환입니다. 제안된 빠른 수정을 통해 변수 타입을 업데이트하고 해당 변수에 대한 모든 불필요한 형 변환을 제거할 수 있습니다.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String x = "  string  ";
  System.out.println(x.trim());
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CastCanBeRemovedNarrowingVariableType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantCast" defaultSeverity="WARNING" displayName="불필요한 타입 변환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 형 변환 식을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static Object toObject(String s) {
    return (Object) s;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    static Object toObject(String s) {
    return s;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  명확화를 위한 형 변환(예: &lt;code&gt;Object&lt;/code&gt;가 기대되는 컬렉션 호출 내 형 변환)을 무시하려면 아래 체크박스를 사용하세요.
&lt;pre&gt;&lt;code&gt;
  static void removeFromList(List&amp;lt;String&amp;gt; l, Object o) {
    l.remove((String)o);
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: RedundantCast&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrivialStringConcatenation" defaultSeverity="WARNING" displayName="빈 문자열과 연결" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자열 연결 내에서 빈 문자열 피연산자를 보고합니다.
빈 문자열 연결을 사용하여 &lt;code&gt;String&lt;/code&gt;이 아닌 객체나 기본 타입을 &lt;code&gt;String&lt;/code&gt;으로 변환할 수 있으나 &lt;code&gt;String.valueOf()&lt;/code&gt; 메서드 호출을 사용하는 것이 더 명확합니다.
&lt;p&gt;
  빠른 수정에서는 연결을 단순화하도록 제안합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(int x, int y) {
    String s = "" + x + " ; " + y;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(int x, int y) {
    String s = x + " ; " + y;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  빈 문자열을 제거하려면 다른 피연산자를 &lt;code&gt;String.valueOf()&lt;/code&gt;로 변환해야 하는 경우를 무시하려면 &lt;b&gt;빈 문자열을 다른 변경 사항 없이 제거할 수 있을 때만 보고&lt;/b&gt; 옵션을 사용하세요.
&lt;p&gt;&lt;small&gt;Inspection ID: TrivialStringConcatenation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantUnmodifiable" defaultSeverity="WARNING" displayName="수정할 수 없는 컬렉션 래퍼의 불필요한 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Collections&lt;/code&gt; 클래스 내부의 수정 불가능한 컬렉션 래퍼에 대한 불필요한 호출을 보고합니다.
&lt;p&gt;수정 불가능한 컬렉션 래퍼에 전달된 인수가 이미 불변 인수인 경우 해당 래핑은 불필요합니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; x = Collections.unmodifiableList(Collections.singletonList("abc"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; x = Collections.singletonList("abc");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;수정 불가능한 컬렉션을 반환하는 메서드를 발견하기 위해 이 검사는 &lt;code&gt;org.jetbrains.annotations.Unmodifiable&lt;/code&gt;
및 &lt;code&gt;org.jetbrains.annotations.UnmodifiableView&lt;/code&gt; 어노테이션을 사용합니다.
해당 어노테이션을 사용하여 검사를 수정 불가능한 자체 컬렉션 래퍼로 확장합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantUnmodifiable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LombokSetterMayBeUsed" defaultSeverity="WARNING" displayName="Lombok @Setter 사용 가능" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
lombok &lt;code&gt;@Setter&lt;/code&gt; 어노테이션으로 대체될 수 있는 표준 setter 메서드를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.Date;

  public class MyClass {
    /**
     * 처리 날짜.
     */
    private Date processDate;

    /**
     * 날짜 설정.
     *
     * @param 날짜
     */
    public void setProcessDate(Date param) {
      processDate = param;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정/정리를 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import lombok.Setter;
  import java.util.Date;

  @Setter
  public class MyClass {
    /**
     * 처리 날짜.
     * -- SETTER --
     * 날짜 설정.
     *
     * @param 날짜
     */
    private Date processDate;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lombok 라이브러리가 구성된 경우에만 보고합니다. lombok을 해제하려는 경우 lombok 사이트를 참조하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2023.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LombokSetterMayBeUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantCompareCall" defaultSeverity="WARNING" displayName="중복 'compare()' 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;compare&lt;/code&gt; 메서드가 불필요한 비교를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean result = Integer.compare(a, b) == 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean result = a == b;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantCompareCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ManualMinMaxCalculation" defaultSeverity="WARNING" displayName="최소/최대 수동 계산" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
두 숫자의 최솟값 또는 최댓값을 수동으로 계산하는 대신 &lt;code&gt;Math.max()&lt;/code&gt; 또는 &lt;code&gt;Math.min()&lt;/code&gt; 호출을 사용하여 계산할 수 있는 경우를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int min(int a, int b) {
    return b &amp;lt; a ? b : a;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int min(int a, int b) {
    return Math.min(a, b);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;float&lt;/code&gt; 타입에 대해 이 검사를 비활성화하려면 &lt;b&gt;Disable for float and double(float 및 double에 대해 비활성화)&lt;/b&gt; 옵션을 사용하세요.
  이 옵션은 빠른 수정에서 &lt;code&gt;NaN&lt;/code&gt;을 처리할 때 &lt;code&gt;float&lt;/code&gt;/&lt;code&gt;double&lt;/code&gt; 타입의 의미를 약간 변경할 수 있으므로 유용합니다. 그럼에도 불구하고, 대부분의 경우 이 검사는 &lt;code&gt;NaN&lt;/code&gt;을 고려하지 않는 미세한 버그를 실질적으로 수정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2019.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ManualMinMaxCalculation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OnlyOneElementUsed" defaultSeverity="WARNING" displayName="하나의 요소만 사용됩니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
생성 시 하나의 요소만 쿼리되는 목록, 배열 및 문자열을 보고합니다.
이런 표현식은 리팩터링 후에 나타날 수 있으며 대부분 액세스되는 요소로 대체할 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(new int[] {1,2,3,4,5}[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(3);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: OnlyOneElementUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonStrictComparisonCanBeEquality" defaultSeverity="WEAK WARNING" displayName="비엄격 불일치 '&gt;=' 또는 '&lt;='는 '=='로 교체 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
데이터 흐름 분석에서 하나의 피연산자 값만 만족하는 부등식 조건문을 보고합니다.
이러한 조건을 등식 조건으로 바꾸면 코드가 더 명확해집니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x &gt;= 10) {
    ...
    if (x &lt;= 10) { // 'x == 10'으로 바꿀 수 있음
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonStrictComparisonCanBeEquality&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExplicitArrayFilling" defaultSeverity="WARNING" displayName="명시적 배열 채우기" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Arrays.setAll()&lt;/code&gt; 또는 &lt;code&gt;Arrays.fill()&lt;/code&gt; 호출로 대체 가능한 루프를 보고합니다.
&lt;p&gt;이 검사는 프로젝트나 모듈의 언어 수준이 8 이상인 경우 루프를 &lt;code&gt;Arrays.setAll()&lt;/code&gt;로 대체하도록 제안합니다.
  모든 언어 수준에서 &lt;code&gt;Arrays.setAll()&lt;/code&gt;로 루프를 대체할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i=0; i&amp;lt;array.length; i++) {
     array[i] = calc(i);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Arrays.setAll(array, this::calc);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExplicitArrayFilling&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateBranchesInSwitch" defaultSeverity="WEAK WARNING" displayName="'switch' 내 중복 브랜치" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 브랜치에 동일한 코드가 포함된 &lt;code&gt;switch&lt;/code&gt; 문 또는 표현식을 보고하고 중복 브랜치 병합을 제안합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;switch&lt;/b&gt; (n) {
    &lt;b&gt;case&lt;/b&gt; 1:
      System.out.println(n);
      &lt;b&gt;break&lt;/b&gt;;
    &lt;b&gt;case&lt;/b&gt; 2:
      System.out.println(n);
      &lt;b&gt;break&lt;/b&gt;;
    &lt;b&gt;default&lt;/b&gt;:
      System.out.println("default");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;switch&lt;/b&gt; (n) {
    &lt;b&gt;case&lt;/b&gt; 1:
    &lt;b&gt;case&lt;/b&gt; 2:
      System.out.println(n);
      &lt;b&gt;break&lt;/b&gt;;
    &lt;b&gt;default&lt;/b&gt;:
      System.out.println("default");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DuplicateBranchesInSwitch&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExcessiveRangeCheck" defaultSeverity="WARNING" displayName="과도한 범위 검사" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
값 범위를 검사하여 1회 검사로 간소화할 수 있는 조건 체인을 보고합니다.
&lt;p&gt;빠른 수정은 조건 체인을 간소화된 표현식으로 대체합니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  x &gt; 2 &amp;&amp; x &amp;lt; 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  x == 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  arr.length == 0 || arr.length &gt; 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  arr.length != 1
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExcessiveRangeCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyOptionalCallChains" defaultSeverity="WARNING" displayName="Optional API 호출 체인을 단순화할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단순화할 수 있는 &lt;b&gt;Optional&lt;/b&gt; 호출 체인을 보고합니다. 가능한 단순화의 몇 가지 예는 다음과 같습니다:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;optional.map(x -&gt; true).orElse(false)&lt;/code&gt; &amp;rarr; &lt;code&gt;optional.isPresent()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;optional.map(x -&gt; Optional.of(x.trim())).orElseGet(Optional::empty)&lt;/code&gt; &amp;rarr; &lt;code&gt;optional.map(String::trim)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;optional.map(x -&gt; (String)x).orElse(null)&lt;/code&gt; &amp;rarr; &lt;code&gt;(String) optional.orElse(null)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Optional.ofNullable(optional.orElse(null))&lt;/code&gt; &amp;rarr; &lt;code&gt;optional&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;val = optional.orElse(null); val != null ? val : defaultExpr &lt;/code&gt; &amp;rarr; &lt;code&gt;optional.orElse(defaultExpr)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;val = optional.orElse(null); if(val != null) expr(val) &lt;/code&gt; &amp;rarr; &lt;code&gt;optional.ifPresent(val -&gt; expr(val))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SimplifyOptionalCallChains&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyCollector" defaultSeverity="WARNING" displayName="단순화 가능한 컬렉터" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
간소화할 수 있는 컬렉터를 보고합니다.
&lt;p&gt;특히 캐스케이드 &lt;code&gt;groupingBy()&lt;/code&gt; 컬렉터는 한층 단순하지만 성능은 더 뛰어날 수 있는 &lt;code&gt;toMap()&lt;/code&gt; 컬렉터를 사용하여 표현할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Collectors.groupingByConcurrent(String::length, Collectors.collectingAndThen(Collectors.maxBy(String::compareTo), Optional::get));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Collectors.toConcurrentMap(String::length, Function.identity(), BinaryOperator.maxBy(String::compareTo));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SimplifyCollector&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryBreak" defaultSeverity="WARNING" displayName="불필요한 'break' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
모든 불필요한 &lt;code&gt;break&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;제거된 후 실행되는 다른 구문이 없는 &lt;code&gt;break&lt;/code&gt;문은 불필요합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (e) {
    case A -&amp;gt; {
        System.out.println("A");
        break; // 'break' 문이 불필요함을 보고합니다
    }
    default -&amp;gt; {
        System.out.println("Default");
        break; // 'break' 문이 불필요함을 보고합니다
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryBreak&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObviousNullCheck" defaultSeverity="WARNING" displayName="null 검사 메서드가 명백히 null이 아닌 인수로 호출됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
null 검사 메서드(예: &lt;code&gt;Objects.requireNonNull&lt;/code&gt; 또는 &lt;code&gt;Assert.assertNotNull&lt;/code&gt;)가 null이 확실히 아닌 값(예: 새로 생성된 객체)에 호출된 경우를 보고합니다. 이러한 검사를 불필요하며 프로그래밍 오류일 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final String greeting = Objects.requireNonNull("Hi!");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final String greeting = "Hi!";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;2017.2의 새로운 기능&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ObviousNullCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLabelOnContinueStatement" defaultSeverity="WARNING" displayName="'continue' 문의 불필요한 라벨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 라벨이 지정된 &lt;code&gt;continue&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  LABEL:
  while (a &amp;gt; b) {
    System.out.println("Hello");
    // 아래 코드는 루프 내 마지막 구문입니다
    // 그러므로 불필요한 라벨 및 continue를 제거할 수 있습니다
    continue LABEL;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryLabelOnContinueStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantEscapeInRegexReplacement" defaultSeverity="WARNING" displayName="정규식 대체 문자열의 불필요한 이스케이프" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
정규식 메서드의 대체 문자열에서 불필요한 이스케이프를 보고합니다.
정규식 대체 문자열에서 어떤 문자든 이스케이프할 수 있지만 &lt;code&gt;$&lt;/code&gt; 및 &lt;code&gt;\&lt;/code&gt; 문자만 이스케이프가 필수적입니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  string.replaceAll("a", "\\b");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  string.replaceAll("a", "b");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantEscapeInRegexReplacement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryStringEscape" defaultSeverity="WARNING" displayName="불필요하게 이스케이프된 문자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;String&lt;/code&gt; 리터럴(선택적으로 &lt;code&gt;char&lt;/code&gt; 리터럴 포함)에서 불필요하게 이스케이프 처리된 문자를 보고합니다.
&lt;p&gt;탭 문자는 공백과 구분이 어려울 수 있기 때문에 이스케이프 처리가 필수가 아님에도 이스케이프 처리된 탭 문자(&lt;0&gt;\t&lt;/0&gt;)는 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "\'Scare\' quotes";
  String t = """
    All you need is\n\tLove\n""";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "'Scare' quotes";
  String t = """
    All you need is
    \tLove
    """;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryStringEscape&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExcessiveLambdaUsage" defaultSeverity="WARNING" displayName="과도한 람다 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동일한 방식으로 작동하지만 람다 대신 구체적인 값을 허용하는 대체 메서드가 있는 경우 자명한 람다 식이 사용되었는지 보고합니다.
&lt;p&gt;이 검사는 코드를 간소화하는 데 도움이 됩니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional.orElseGet(() -&gt; null)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional.orElse(null)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;람다 식&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ExcessiveLambdaUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateExpressions" defaultSeverity="WEAK WARNING" displayName="동일한 표현식의 여러 찾은 항목" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
표현식의 결과를 다시 사용할 수 있는 경우 메서드(또는 생성자, 클래스 이니셜라이저) 내에서 찾은 동일 표현식의 여러 위치를 보고합니다.
&lt;p&gt;
  표현식에 부수 효과가 없으며 &lt;code&gt;Object.equals()&lt;/code&gt;에서 결과가 항상 동일한 경우 해당 표현식이 보고됩니다.
  이러한 표현식의 예시는 &lt;code&gt;a + b&lt;/code&gt;, &lt;code&gt;Math.max(a, b)&lt;/code&gt;, &lt;code&gt;a.equals(b)&lt;/code&gt;,
  &lt;code&gt;s.substring(a,b)&lt;/code&gt;입니다. 결과가 항상 동일한지 확인하기 위해, 표현식에 사용된 변수가 표현식의 찾은 항목 간의 값을 변경하지 않는지 검증됩니다.&lt;/p&gt;
&lt;p&gt;
  이러한 표현식에는 &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;BigDecimal&lt;/code&gt;과 같은 불변 클래스의 메서드 및  &lt;code&gt;Objects&lt;/code&gt;, &lt;code&gt;Math&lt;/code&gt;(&lt;code&gt;random()&lt;/code&gt; 제외) 등의 유틸리티 클래스가 포함될 수 있습니다.
  &lt;code&gt;Object.equals()&lt;/code&gt;, &lt;code&gt;Object.hashCode()&lt;/code&gt;, &lt;code&gt;Object.toString()&lt;/code&gt;,
  &lt;code&gt;Comparable.compareTo()&lt;/code&gt; 및 &lt;code&gt;Comparator.compare()&lt;/code&gt;처럼 잘 알려진 메서드 역시 일반적으로 눈에 띄는 부수 효과가 없으므로 적합합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;표현식 복잡성 임계값&lt;/b&gt; 옵션을 사용하여 표현식 복잡성의 최소 임계값을 지정합니다. 숫자를 더 크게 지정하면 짧은 표현식에 대한 보고가 제거됩니다.
&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;Path.of&lt;/code&gt; 및 &lt;code&gt;Paths.get&lt;/code&gt; 호출은 동일한 인수가 있는 경우 동등한 호출로 처리됩니다. 이러한 호출은 인수의 복잡도와 상관없이 항상 보고됩니다. 이 동작은 다른 복잡도 임곗값을 사용하여 조정할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2018.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DuplicateExpressions&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantComparatorComparing" defaultSeverity="WARNING" displayName="비교자 메서드를 단순화할 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
간소화될 수 있는 &lt;code&gt;Comparator&lt;/code&gt; 결합자 구문을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  c.thenComparing(Comparator.comparing(function));

  Comparator.comparing(Map.Entry::getKey);

  Collections.max(list, Comparator.reverseOrder());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  c.thenComparing(function)

  Map.Entry.comparingByKey()

  Collections.min(list, Comparator.naturalOrder());
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantComparatorComparing&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastCanBeReplacedWithVariable" defaultSeverity="INFORMATION" displayName="형 변환을 변수로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
같은 값을 가진 기존 지역 또는 패턴 변수로 바꿀 수 있는 형 변환 ​​연산을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object obj) {
    String s = (String) obj;
    System.out.println(((String) obj).trim());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object obj) {
    String s = (String) obj;
    System.out.println(s.trim());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CastCanBeReplacedWithVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryContinue" defaultSeverity="WARNING" displayName="불필요한 'continue' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;continue&lt;/code&gt; 문이 루프에서 도달할 수 있는 마지막 구문인 경우를 보고합니다.
이러한 &lt;code&gt;continue&lt;/code&gt; 문은 불필요하며 안전하게 제거할 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String element: elements) {
    System.out.println();
    continue;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String element: elements) {
    System.out.println();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 검사는 JSP 파일을 분석하지 않습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  완전한 &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; 문의 &lt;code&gt;then&lt;/code&gt; 브랜치에 있는 &lt;code&gt;continue&lt;/code&gt; 문을 무시하려면 &lt;b&gt;'else' 브랜치가 있는 'if' 문의 then 브랜치에서 무시&lt;/b&gt; 옵션을 사용하세요.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String element: elements) {
    if(element.isEmpty()) {
      continue;
    } else {
      //...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryContinue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnreachableCatch" defaultSeverity="WARNING" displayName="도달할 수 없는 catch 섹션" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Java 언어 사양에서 허용되더라도 실행되지 않는 catch 섹션을 보고합니다.
&lt;p&gt;
  도달할 수 없는 catch 섹션은 보통 Java 컴파일러에서 허용되지 않고 컴파일 오류로 보고되지만, 어떤 경우에 Java 언어에서 요구되는 분석은 완료되지 않습니다.
  이 검사는 강화된 분석을 제공하며 컴파일러가 보고하지 않은 도달할 수 없는 catch 섹션을 보고합니다.
  이러한 섹션은 불필요하며 안전하게 제거할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void method() {
    try { 
      throw new FileNotFoundException(); 
    }
    catch (FileNotFoundException e) { 
      
    }
    catch (IOException e) {
      // 이 catch는 사양에서 허용되지만
      // 실행되지 않습니다
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;불필요한 catch 섹션을 제거하는 빠른 수정이 제공됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void method() {
    try { 
      throw new FileNotFoundException(); 
    }
    catch (FileNotFoundException e) { 
      
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2025.1에서 추가&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnreachableCatch&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringBufferReplaceableByString" defaultSeverity="WARNING" displayName="'StringBuilder'를 'String'로 바꾸기 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단일한 &lt;code&gt;String&lt;/code&gt; 연결과 바꿀 수 있는 &lt;code&gt;StringBuffer&lt;/code&gt;, &lt;code&gt;StringBuilder&lt;/code&gt; 또는 &lt;code&gt;StringJoiner&lt;/code&gt;의 사용을 보고합니다.
&lt;p&gt;&lt;code&gt;String&lt;/code&gt; 연결을 사용하면 코드가 짧고 단순해집니다.&lt;/p&gt;
&lt;p&gt;
이 검사는 제안된 교체가 최신 JVM에서 중대한 성능 문제를 야기하지 않는 경우만 보고합니다. 대부분의 경우 &lt;code&gt;String&lt;/code&gt; 연결의 성능은 향상될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  StringBuilder result = new StringBuilder();
  result.append("i = ");
  result.append(i);
  result.append(";");
  return result.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String result = "i = " + i + ";";
  return result;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringBufferReplaceableByString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantCollectionOperation" defaultSeverity="WARNING" displayName="중복 'Collection' 연산" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
더 간단한 대안이 있는 불필요하게 복잡한 컬렉션 연산을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(String[] array, Collection&amp;lt;String&amp;gt; collection) {
    String[] strings = Arrays.asList(array).subList(0, 10).toArray(new String[0]);
    boolean contains = collection.containsAll(Collections.singletonList("x"));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(String[] array, Collection&amp;lt;String&amp;gt; collection) {
    String[] strings = Arrays.copyOf(array, 10);
    boolean contains = collection.contains("x");
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantCollectionOperation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceOnLiteralHasNoEffect" defaultSeverity="WARNING" displayName="대체 작업이 효과가 없습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
효과가 없는 &lt;code&gt;String&lt;/code&gt; 메서드 &lt;code&gt;replace()&lt;/code&gt;, &lt;code&gt;replaceAll()&lt;/code&gt; 또는 &lt;code&gt;replaceFirst()&lt;/code&gt;
호출을 보고합니다. 이러한 호출은 한정자 및 검색 문자열이 컴파일 시간 상수이며 검색 문자열을 한정자에서 찾을 수 없을 때 아무 효과가 없습니다. 이러한 호출은 불필요하며 오류일 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 교체로 수행되는 작업이 없습니다
  "hello".replace("$value$", value);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceOnLiteralHasNoEffect&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantTypeArguments" defaultSeverity="WARNING" displayName="중복 타입 인수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
컴파일러에서 명백히 추론되므로 생략 가능한 명시적 인수 타입을 가진 매개변수화된 메서드의 호출을 보고합니다.
&lt;p&gt;
  불필요한 타입 인수는 사용할 필요가 없으며 코드 가독성을 저해합니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = Arrays.&amp;lt;String&amp;gt;asList("Hello", "World");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;불필요한 타입 인수를 제거하는 빠른 수정이 제공됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = Arrays.asList("Hello", "World");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantTypeArguments&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantStreamOptionalCall" defaultSeverity="WARNING" displayName="'Stream' 또는 'Optional' 호출 체인 내 불필요한 단계" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;map(x -&amp;gt; x)&lt;/code&gt;, &lt;code&gt;filter(x -&amp;gt; true)&lt;/code&gt; 등의 불필요한 &lt;code&gt;Stream&lt;/code&gt;이나 &lt;code&gt;Optional&lt;/code&gt; 호출 또는 불필요한 &lt;code&gt;sorted()&lt;/code&gt;나 &lt;code&gt;distinct()&lt;/code&gt; 호출을 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;단, &lt;code&gt;streamOfIntegers.map(Integer::valueOf)&lt;/code&gt;와 같은 코드에서 매핑 작업은 &lt;code&gt;requireNonNull()&lt;/code&gt; 검사로 작동합니다. 스트림은 &lt;code&gt;null&lt;/code&gt;을 포함하는 경우 &lt;code&gt;NullPointerException&lt;/code&gt;을 던지므로 완전히 불필요한 것은 아닙니다.
  해당 사례가 보고되지 않도록 하려면 &lt;b&gt;Report redundant boxing in Stream.map()(Stream.map()에서 불필요한 박싱 보고)&lt;/b&gt; 옵션을 비활성화하세요.&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantStreamOptionalCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryReturn" defaultSeverity="WARNING" displayName="불필요한 'return' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;void&lt;/code&gt;를 반환하는 생성자 및 메서드 끝에 있는 &lt;code&gt;return&lt;/code&gt; 문을 보고합니다. 이러한 구문은 불필요하며 안전하게 제거할 수 있습니다.
&lt;p&gt;이 검사는 JSP 파일에서 보고하지 않습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; message() {
    System.out.println("Hello World");
    &lt;b&gt;return&lt;/b&gt;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; message() {
    System.out.println("Hello World");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;code&gt;else&lt;/code&gt; 브랜치도 포함하는 &lt;code&gt;if&lt;/code&gt; 문의 then 브랜치 내 &lt;code&gt;return&lt;/code&gt; 문을 무시하려면 &lt;b&gt;'else' 브랜치가 있는 'if' 문의 then 브랜치에서 무시&lt;/b&gt; 옵션을 사용하세요.
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryReturn&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LombokGetterMayBeUsed" defaultSeverity="WARNING" displayName="Lombok @Getter 사용 가능" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
lombok &lt;code&gt;@Getter&lt;/code&gt; 어노테이션으로 대체될 수 있는 표준 getter 메서드를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.Date;

  public class MyClass {
    /**
     * 처리 날짜.
     */
    private Date processDate;

    /**
     * 날짜를 반환함.
     *
     * @return 날짜
     */
    public Date getProcessDate() {
      return processDate;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정/정리를 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import lombok.Getter;
  import java.util.Date;

  @Getter
  public class MyClass {
    /**
     * 처리 날짜.
     * -- GETTER --
     * 날짜를 반환함.
     *
     * @return 날짜
     */
    private Date processDate;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lombok 라이브러리가 구성된 경우에만 보고합니다. lombok을 해제하려는 경우 lombok 사이트를 참조하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2023.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LombokGetterMayBeUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringOperationCanBeSimplified" defaultSeverity="WARNING" displayName="중복 'String' 연산" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단순화된 표현식으로 바꿀 수 있는 &lt;code&gt;String&lt;/code&gt; 생성자 및 &lt;code&gt;toString()&lt;/code&gt; 또는 &lt;code&gt;substring()&lt;/code&gt; 등의 메서드에 대한 불필요한 호출을 보고합니다.
&lt;p&gt;예를 들어, &lt;code&gt;"string".substring(0)&lt;/code&gt;, &lt;code&gt;"string".toString()&lt;/code&gt; 또는 &lt;code&gt;new StringBuilder().toString().substring(1,3)&lt;/code&gt;과 같은 코드에서 이러한 메서드 호출은 안전하게 제거할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(new String("message"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println("message");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  빠른 수정은 불필요한 생성자 호출을 제거하며 이는 &lt;code&gt;String&lt;/code&gt; 참조의 상등성에 영향을 줄 수 있습니다.
  바람직하지 않은 방법이라고 할지라도 이것을 유지할 필요가 있는 경우에는 경고를 억제하거나 검사 설정으로 불필요한 &lt;code&gt;String&lt;/code&gt; 생성자 호출을 무시하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  위의 예시와 같은 코드를 보고하지 않으려면 아래의 &lt;b&gt;String 생성자 호출을 보고 안 함&lt;/b&gt; 옵션을 사용하세요.
  이렇게 하면 코드에서 다른 객체 ID를 보장하기 위하여 &lt;code&gt;new String()&lt;/code&gt; 호출을 사용하는 빠른 수정을 적용한 후에도 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt;를 사용한 String 비교 결과가 바뀌는 것을 방지할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  다음과 같은 코드를 보고하지 않으려면, 아래의 &lt;b&gt;인수가 1개인 substring() 호출은 보고 안 함&lt;/b&gt; 옵션을 사용하세요.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  stringBuilder.append(string.substring(5));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이는 다음으로 바꿀 수 있습니다.
&lt;pre&gt;&lt;code&gt;
  stringBuilder.append(string, 5, string.length());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;2018.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringOperationCanBeSimplified&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyStreamApiCallChains" defaultSeverity="WARNING" displayName="Stream API 호출 체인을 단순화할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
간소화할 수 있는 Stream API 호출 체인을 보고합니다.
단순화하면 컬렉션 순회 도중 임시 객체의 생성이 방지되는 경우가 많습니다.
&lt;p&gt;
  이 검사는 다음의 호출 체인을 대체합니다.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;collection.stream().forEach()&lt;/code&gt; &amp;rarr; &lt;code&gt;collection.forEach()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;collection.stream().collect(toList/toSet/toCollection())&lt;/code&gt; &amp;rarr; &lt;code&gt;new CollectionType&amp;lt;&amp;gt;(collection)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;collection.stream().toArray()&lt;/code&gt; &amp;rarr; &lt;code&gt;collection.toArray()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Arrays.asList().stream()&lt;/code&gt; &amp;rarr; &lt;code&gt;Arrays.stream()&lt;/code&gt; 또는 &lt;code&gt;Stream.of()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IntStream.range(0, array.length).mapToObj(idx -&gt; array[idx])&lt;/code&gt; &amp;rarr; &lt;code&gt;Arrays.stream(array)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IntStream.range(0, list.size()).mapToObj(idx -&gt; list.get(idx))&lt;/code&gt; &amp;rarr; &lt;code&gt;list.stream()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Collections.singleton().stream()&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.of()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Collections.emptyList().stream()&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.empty()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.filter().findFirst().isPresent()&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.anyMatch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(counting())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.count()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(maxBy())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.max()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(mapping())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.map().collect()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(reducing())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.reduce()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(summingInt())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.mapToInt().sum()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.mapToObj(x -&gt; x)&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.boxed()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.map(x -&gt; {...; return x;})&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.peek(x -&gt; ...)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;!stream.anyMatch()&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.noneMatch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;!stream.anyMatch(x -&gt; !(...))&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.allMatch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.map().anyMatch(Boolean::booleanValue)&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.anyMatch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IntStream.range(expr1, expr2).mapToObj(x -&gt; array[x])&lt;/code&gt; &amp;rarr; &lt;code&gt;Arrays.stream(array, expr1, expr2)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Collection.nCopies(count, ...)&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.generate().limit(count)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.sorted(comparator).findFirst()&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.min(comparator)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;optional.orElseGet(() -&gt; { throw new ...; })&lt;/code&gt; &amp;rarr; &lt;code&gt;optional.orElseThrow()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  일부 경우에는 대체의 의미가 조금 다를 수 있습니다. 예를 들어, &lt;code&gt;Collections.synchronizedList(...).stream().forEach()&lt;/code&gt;는 동기화되지 않으나 &lt;code&gt;Collections.synchronizedList(...).forEach()&lt;/code&gt;는 동기화됩니다.
  또한 결과 요소가 &lt;code&gt;null&lt;/code&gt;인 경우 &lt;code&gt;collect(Collectors.maxBy())&lt;/code&gt;는 빈 &lt;code&gt;Optional&lt;/code&gt;을 반환하나 이러한 경우 &lt;code&gt;Stream.max()&lt;/code&gt;는 &lt;code&gt;NullPointerException&lt;/code&gt;을 던집니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SimplifyStreamApiCallChains&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLabelOnBreakStatement" defaultSeverity="WARNING" displayName="'break' 문의 불필요한 라벨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 라벨이 지정된 &lt;code&gt;break&lt;/code&gt; 문을 보고합니다. 그러한 라벨은 제어 흐름을 변경하지 않지만 코드를 이해하기 어렵게 만듭니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  label:
  for(int i = 0; i &amp;lt; 10; i++) {
    if (shouldBreak()) break label;
    // 작업 수행
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  label:
  for(int i = 0; i &amp;lt; 10; i++) {
    if (shouldBreak()) break;
    // 작업 수행
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryLabelOnBreakStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantJavaTimeOperations" defaultSeverity="WARNING" displayName="'java.time' 객체에서의 불필요한 계산" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;!-- Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license. --&gt;
&lt;html&gt;
&lt;body&gt;
중복 'java.time' 객체의 중복 연산을 보고합니다.
&lt;ul&gt;
  &lt;li&gt;간단한 메서드 호출을 사용할 수 있거나 생성을 피할 수 있으나 JDK &lt;code&gt;java.time&lt;/code&gt; 패키지를 사용하여 불필요하게 날짜/시간 객체가 생성.&lt;/li&gt;
  &lt;li&gt;더 구체적인 메서드 호출로 바꿀 수 있으나 &lt;code&gt;java.time.temporal.ChronoField&lt;/code&gt;와
    &lt;code&gt;java.time.temporal.ChronoUnit&lt;/code&gt;을 인수로 사용하는 &lt;code&gt;java.time&lt;/code&gt; 메서드 호출.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;isAfter()&lt;/code&gt;, &lt;code&gt;isBefore()&lt;/code&gt; 혹은 &lt;code&gt;isEqual()&lt;/code&gt; 호출로 대체될 수 있는 &lt;code&gt;compareTo()&lt;/code&gt; 호출을 이용한 &lt;code&gt;java.time&lt;/code&gt; 비교.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예:&lt;/p&gt;
- 이전:
&lt;pre&gt;&lt;code&gt;
LocalDateTime now = LocalDateTime.now();
return LocalDateTime.from(now);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
LocalDateTime now = LocalDateTime.now();
return now;
&lt;/code&gt;&lt;/pre&gt;
- 이전:
&lt;pre&gt;&lt;code&gt;
LocalTime localTime = LocalTime.now();
int minute = localTime.get(ChronoField.MINUTE_OF_HOUR);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
LocalTime localTime = LocalTime.now();
int minute = localTime.getMinute();
&lt;/code&gt;&lt;/pre&gt;
- 이전:
&lt;pre&gt;&lt;code&gt;
  LocalDate date1 = LocalDate.now();
  LocalDate date2 = LocalDate.now();
  boolean t = date1.compareTo(date2) &gt; 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  LocalDate date1 = LocalDate.now();
  LocalDate date2 = LocalDate.now();
  boolean t = date1.isAfter(date2);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2024.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantJavaTimeOperations&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryDefault" defaultSeverity="WARNING" displayName="열거형 'switch' 문의 불필요한 'default'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
가능한 모든 값이 &lt;code&gt;case&lt;/code&gt; 브랜치에서 다뤄지기 때문에 도달할 수 없는 &lt;code&gt;default&lt;/code&gt; 브랜치를 포함하는 열거형 &lt;code&gt;switch&lt;/code&gt; 구문 또는 표현식을 보고합니다.
&lt;p&gt;그러한 요소는 모든 열거형 상수가 &lt;code&gt;case&lt;/code&gt; 브랜치에서 다뤄지지 않는 경우 컴파일되지 않기 때문에 특히 &lt;code&gt;switch&lt;/code&gt; 식에서 불필요합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;switch&lt;/code&gt; 식을 보고하려면 언어 수준을 14로 구성해야 합니다.
&lt;/p&gt;
&lt;p&gt;제공된 빠른 수정은 &lt;code&gt;default&lt;/code&gt; 브랜치를 제거합니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum E { A, B }
  int foo(E e) {
    return switch (e) {
      case A -&amp;gt; 1;
      case B -&amp;gt; 2;
      default -&amp;gt; 3;
    };
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum E { A, B }
  int foo(E e) {
    return switch (e) {
      case A -&amp;gt; 1;
      case B -&amp;gt; 2;
    };
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;switch 식 내 불필요한 &lt;code&gt;default&lt;/code&gt; 브랜치만 보고하려면 &lt;b&gt;switch 식만 보고&lt;/b&gt; 옵션을 사용하세요.&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryDefault&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaExistingMethodCanBeUsed" defaultSeverity="WEAK WARNING" displayName="기존의 static 메서드 본문 복사" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
기존 static 메서드와 동일한 Java 코드 조각을 보고하고 기존의 static 메서드를 재사용하도록 제안합니다. 기존 메서드를 재사용하면 코드가 짧아지고 가독성이 좋아집니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  static List&amp;lt;String&amp;gt; readFileAndTrim(Path path) throws IOException {
    List&amp;lt;String&amp;gt; lines = Files.readAllLines(path);
    return lines.stream().map(String::trim).toList();
  }
  
  static List&amp;lt;String&amp;gt; readFileAndTrim(String path) throws IOException {
    Path p = Path.of(path);
    List&amp;lt;String&amp;gt; lines = Files.readAllLines(p);
    return lines.stream().map(String::trim).toList();
  }
&lt;/code&gt;&lt;/pre&gt;
여기서 두 번째 메서드는 첫 번째 메서드와 상당히 유사하므로, 첫 번째 메서드를 구현에 재사용할 수 있습니다.
빠른 수정이 적용된 후 결과는 다음과 같습니다.
&lt;pre&gt;&lt;code lang="java"&gt;
  static List&amp;lt;String&amp;gt; readFileAndTrim(Path path) throws IOException {
    List&amp;lt;String&amp;gt; lines = Files.readAllLines(path);
    return lines.stream().map(String::trim).toList();
  }

  static List&amp;lt;String&amp;gt; readFileAndTrim(String path) throws IOException {
    Path p = Path.of(path);
    return readFileAndTrim(p);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;2024.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavaExistingMethodCanBeUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantLengthCheck" defaultSeverity="WARNING" displayName="불필요한 배열 길이 확인" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열 반복 처리 앞에 오는 불필요한 배열 길이 검사를 보고합니다. 배열 길이가 0인 경우 반복 처리를 건너뛰므로, 명시적으로 길이를 검사할 필요가 없습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(String[] array) {
    if (array.length != 0) { // 불필요한 검사
      for (String str : array) {
        System.out.println(str);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 길이 검사를 제거하거나 래핑 해제하도록 제안합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(String[] array) {
    for (String str : array) {
      System.out.println(str);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantLengthCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantArrayCreation" defaultSeverity="WARNING" displayName="불필요한 배열 생성" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
vararg 매개변수로서 전달되도록 특별히 생성된 배열을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Arrays.asList(new String[]{"Hello", "world"})&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;빠른 수정은 배열 이니셜라이저를 개별 인수로 대체합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Arrays.asList("Hello", "world")&lt;/code&gt;&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantArrayCreation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantFileCreation" defaultSeverity="WARNING" displayName="불필요한 'File' 인스턴스 생성" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;String&lt;/code&gt; 경로만 사용될 수 있으나 다음 생성자 중 하나가 사용된 불필요한 &lt;code&gt;File&lt;/code&gt; 생성을 보고합니다. &lt;code&gt;FileInputStream&lt;/code&gt;, &lt;code&gt;FileOutputStream&lt;/code&gt;,
&lt;code&gt;FileReader&lt;/code&gt;, &lt;code&gt;FileWriter&lt;/code&gt;, &lt;code&gt;PrintStream&lt;/code&gt;, &lt;code&gt;PrintWriter&lt;/code&gt;, &lt;code&gt;Formatter&lt;/code&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
InputStream is = new FileInputStream(new File("in.txt"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
InputStream is = new FileInputStream("in.txt");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantFileCreation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantEmbeddedExpression" defaultSeverity="WARNING" displayName="문자열 템플릿 내의 불필요한 임베디드 표현식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;STR&lt;/code&gt; 템플릿에서 자명한 리터럴이나 빈 표현식과 같이 불필요한 임베디드 표현식을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(STR."Hello \{"world"}");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(STR."Hello world");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2023.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 21-preview부터 사용할 수 있는 Java 기능 &amp;#39;문자열 템플릿&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantEmbeddedExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Micronaut" path="Micronaut"><inspection shortName="MnELInspection" defaultSeverity="WARNING" displayName="잘못된 Micronaut Expression Language(MicronautEl) 구문" enabled="false" language="MicronautEL" pluginId="com.intellij.micronaut" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Micronaut Expression Language(MicronautEL) 코드 내에서 해결되지 않은 참조와 같은 구문 오류를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
import io.micronaut.context.annotation.Value;
import io.micronaut.http.annotation.Controller;

@Controller("/owners")
class OwnerController {
    @Value("#{T(java.lang.Math).&lt;strong&gt;unknown&lt;/strong&gt;()}") // 'unknown' 메서드를 해결할 수 없음
    double injectedValue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MnELInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="CDI(컨텍스트 및 종속성 주입)" path=""><inspection shortName="CdiUnknownProducersForDisposerMethodInspection" defaultSeverity="WARNING" displayName="프로듀서가 없는 disposer 메서드 매개변수" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;해당하는 producer 메서드가 없는 disposer 메서드를 보고합니다.&lt;/p&gt;
&lt;p&gt;각 disposer 메서드는 해당하는 producer 메서드 또는 producer 필드의 반환 타입과 동일한 타입의 폐기된 매개변수를 정확히 하나만 포함해야 합니다. producer 메서드 또는 producer 필드에 대한 disposer 메서드를 검색할 때 컨테이너는 폐기된 매개변수의 타입 및 한정자를 고려합니다. 폐기된 매개변수가 같은 Bean 클래스에서 선언된 producer 메서드 또는 producer 필드로 해결되는 경우, 컨테이너는 해당 producer 메서드 또는 producer 필드에서 반환된 모든 인스턴스를 제거할 때 이 메서드를 호출해야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiUnknownProducersForDisposerMethodInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CdiAlternativeInspection" defaultSeverity="ERROR" displayName="거부된 @Alternative bean" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  거부된 &lt;code&gt;@Alternative&lt;/code&gt; Bean을 보고합니다.
  Bean은 &lt;code&gt;@Vetoed&lt;/code&gt; 어노테이션이 추가된 경우나 거부된 패키지에 선언되어 있는 경우에 거부된 것으로 간주되어야 합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiAlternativeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiDomBeans" defaultSeverity="WARNING" displayName="beans.xml 내 잘못된 bean 정의" enabled="false" language="XML" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;beans.xml&lt;/code&gt; 구성 파일 내 잘못된 Bean 정의를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiDomBeans&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiSpecializesInspection" defaultSeverity="ERROR" displayName="잘못된 @Specializes 사용 위치" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;@Specializes&lt;/code&gt; 어노테이션의 잘못된 사용을 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특수화 Bean은 다른 Bean을 확장해야 합니다&lt;/li&gt;
  &lt;li&gt;특수화하는 메서드는 직속 상위 클래스의 &lt;code&gt;@Produces&lt;/code&gt; 메서드를 재정의해야 함&lt;/li&gt;
  &lt;li&gt;특수화하는 클래스 및 특수화된 클래스에서 &lt;code&gt;@Named&lt;/code&gt; 어노테이션을 사용할 수 없음&lt;/li&gt;
  &lt;li&gt;두 개 이상의 클래스는 동일한 상위 클래스를 특수화할 수 없음&lt;/li&gt;
  &lt;li&gt;특수화 메서드는 static일 수 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiSpecializesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiDisposerMethodInspection" defaultSeverity="ERROR" displayName="잘못된 disposer 메서드" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 disposer 메서드를 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;abstract일 수 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Disposes&lt;/code&gt; 어노테이션이 추가되어 있는 폐기된 매개변수가 정확히 하나만 있어야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiDisposerMethodInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiNormalScopeInspection" defaultSeverity="WARNING" displayName="디폴트가 아닌 범위가 있는 Bean이 public 필드를 선언" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;디폴트 &lt;code&gt;@Dependent&lt;/code&gt; 범위 안에 있지 않은 public 인스턴스 필드를 포함하는 매니지드 Bean을 보고합니다.
  CDI 사양에 따르면, 컨텍스트 범위(&lt;code&gt;@RequestScoped&lt;/code&gt;, &lt;code&gt;@ApplicationScoped&lt;/code&gt;, &lt;code&gt;@SessionScoped&lt;/code&gt;, &lt;code&gt;ConversationScoped&lt;/code&gt;)는 public 인스턴스 필드를 포함하는 매니지드 Bean에 허용되지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @ApplicationScoped // 경고: 디폴트가 아닌 범위를 가진 Bean은 public 필드를 포함할 수 없습니다
  class Car {
    public String engine;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiNormalScopeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiTypedAnnotationInspection" defaultSeverity="ERROR" displayName="잘못된 @Typed 어노테이션 사용 위치" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;다음 규칙을 위반하는 &lt;code&gt;@Typed&lt;/code&gt; 어노테이션의 사용을 보고합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;producer 메서드에만 &lt;code&gt;@Typed&lt;/code&gt; 어노테이션을 추가할 수 있음&lt;/li&gt;
  &lt;li&gt;Bean 타입이 &lt;code&gt;@Typed어노테이션에서 언급된 타입에 해당해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiTypedAnnotationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiScopeInspection" defaultSeverity="WARNING" displayName="잘못된 bean 범위" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 Bean 범위를 보고합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;싱글턴 Bean은 &lt;code&gt;@ApplicationScoped&lt;/code&gt; 또는 &lt;code&gt;@Dependent&lt;/code&gt;여야 함&lt;/li&gt;
  &lt;li&gt;세션 스테이트리스 Bean은 &lt;code&gt;@Dependent&lt;/code&gt;여야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiScopeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiObservesInspection" defaultSeverity="ERROR" displayName="잘못된 observer 메서드" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 observer 메서드 정의를 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하나의 &lt;code&gt;@Observes&lt;/code&gt; 매개변수만 포함해야 함&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Disposes&lt;/code&gt; 어노테이션이 추가된 매개변수를 포함할 수 없음&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Inject&lt;/code&gt; 및 &lt;code&gt;@Produces&lt;/code&gt; 어노테이션이 추가될 수 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiObservesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiManagedBeanInconsistencyInspection" defaultSeverity="ERROR" displayName="잘못된 매니지드 Bean 정의" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 Bean 정의 규칙을 보고합니다.&lt;/p&gt;
&lt;p&gt;최상위 Java 클래스는 다음 경우에 단순한 Bean이 될 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;매개변수화된 타입이 아닌 경우&lt;/li&gt;
  &lt;li&gt;비 static 내부 클래스가 아닌 경우&lt;/li&gt;
  &lt;li&gt;구체 클래스이거나 &lt;code&gt;@Decorator&lt;/code&gt; 어노테이션이 추가된 클래스인 경우&lt;/li&gt;
  &lt;li&gt;적절한 생성자를 포함하는 경우: 클래스에 매개변수가 없는 생성자가 있거나 클래스가 &lt;code&gt;@Initializer&lt;/code&gt; 어노테이션이 추가된 생성자를 선언하는 경우
  &lt;/li&gt;
  &lt;li&gt;다음 인터페이스 중 하나를 구현하지 않는 경우: 
    &lt;code&gt;javax.servlet.Servlet&lt;/code&gt;,
    &lt;code&gt;javax.servlet.Filter&lt;/code&gt;,
    &lt;code&gt;javax.servlet.ServletContextListener&lt;/code&gt;,
    &lt;code&gt;javax.servlet.http.HttpSessionListener&lt;/code&gt;,
    &lt;code&gt;javax.servlet.ServletRequestListener&lt;/code&gt;,
    &lt;code&gt;javax.ejb.EnterpriseBean&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.faces.component.UIComponent&lt;/code&gt;를 확장하지 않는 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiManagedBeanInconsistencyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiUnproxyableBeanTypesInspection" defaultSeverity="ERROR" displayName="프록시될 수 없는 Bean 타입의 잘못된 사용" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;프록시할 수 없는 Bean 타입의 잘못된 사용을 보고합니다.&lt;/p&gt;
&lt;p&gt;다음 타입은 올바른 Bean 타입이지만 컨테이너에서 프록시할 수 없습니다.
  매개변수가 없는 비 private 생성자를 포함하지 않는 클래스
  final로 선언된 클래스
  final 메서드, 원시 타입, 배열 타입을 포함하는 클래스&lt;/p&gt;

&lt;p&gt;이 검사는 그러한 Bean 타입에 대한 다음과 같은 위반 사례를 보고합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;패시베이션 처리 범위를 선언하는 매니지드 Bean은 &lt;code&gt;java.io.Serializable&lt;/code&gt;이어야 함&lt;/li&gt;
  &lt;li&gt;비 serializable 타입의 Bean은 부동태화 범위의 Bean에 삽입할 수 없음&lt;/li&gt;
  &lt;li&gt;컨테이너는 삽입된 일반 범위의 Bean을 프록시할 수 있어야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiUnproxyableBeanTypesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CdiStereotypeInspection" defaultSeverity="ERROR" displayName="잘못된 @Stereotype 어노테이션 클래스" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 &lt;code&gt;@Stereotype&lt;/code&gt; 어노테이션 클래스를 보고합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;비어 있지 않은 &lt;code&gt;@Named&lt;/code&gt; 어노테이션은 스테레오타입에 허용되지 않음&lt;/li&gt;
  &lt;li&gt;한정자 어노테이션은 스테레오타입에 허용되지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiStereotypeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiInterceptorInspection" defaultSeverity="ERROR" displayName="바인딩 타입이 없는 @Interceptor 클래스" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;바인딩 타입이 없는 &lt;code&gt;@Interceptor&lt;/code&gt; 클래스를 보고합니다. 인터셉터는 최소 하나의 인터셉터 바인딩을 지정해야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiInterceptorInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiStereotypeRestrictionsInspection" defaultSeverity="ERROR" displayName="Bean의 스테레오타입에서 범위 충돌 발생" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;범위가 지정되지 않은 경우에 또는 각기 다른 범위에서 여러 스테레오타입을 가지는 클래스를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiStereotypeRestrictionsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CdiDecoratorInspection" defaultSeverity="ERROR" displayName="잘못된 @Decorator 클래스" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 &lt;code&gt;@Decorator&lt;/code&gt; Bean 정의를 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;final일 수 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Delegate&lt;/code&gt; 어노테이션이 추가되어 있는 위임 속성(필드 또는 매개변수)이 정확히 하나만 있어야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiDecoratorInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiInjectInspection" defaultSeverity="ERROR" displayName="잘못된 종속성 삽입 위치" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 삽입점(CDI 사양을 위반하며 &lt;code&gt;@Inject&lt;/code&gt; 어노테이션이 추가된 필드, 메서드, 매개변수)을 보고합니다.&lt;/p&gt;

&lt;p&gt;필드 요구 조건:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;static 또는 final일 수 없음&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Produces&lt;/code&gt; 어노테이션이 추가될 수 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;삽입을 포함하는 메서드 요구 조건:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;static 또는 abstract일 수 없음&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Disposes&lt;/code&gt; 및 &lt;code&gt;@Observes&lt;/code&gt; 어노테이션이 추가된 매개변수를 포함할 수 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CdiInjectInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CdiInjectionPointsInspection" defaultSeverity="WARNING" displayName="모호한 종속성이 있는 삽입점" enabled="false" language="UAST" pluginId="com.intellij.cdi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Bean 클래스 내 모호한 종속성을 지니는 삽입점을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  interface Engine {}

  @Singleton
  class GasEngine implements Engine {}

  @Singleton
  class ElectricEngine implements Engine {}

  @Singleton
  class Car {
    @Inject Engine &lt;b&gt;engine&lt;/b&gt;; // 모호한 종속성: 삽입점과 일치하는 Bean이 여러 개 있습니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CdiInjectionPointsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="발생할 수 있는 버그" path="Java"><inspection shortName="NewObjectEquality" defaultSeverity="WARNING" displayName="새 객체를 '=='를 사용하여 비교" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대신 새로 할당된 객체에 &lt;code&gt;equals()&lt;/code&gt;를 호출하는 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt;를 적용하는 코드를 보고합니다.
&lt;p&gt;
  새로 할당된 객체에 대한 참조는 기존 객체를 가리킬 수 없으므로 비교는 항상 &lt;code&gt;false&lt;/code&gt;로 평가됩니다. 이 검사는 단순한 메서드에서 반환된 새로 생성된 객체 또한 보고할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Object obj) {
    if (new Object() == obj) {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Object obj) {
    if (new Object().equals(obj)) {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;small&gt;2018.3의 새로운 기능&lt;/small&gt;
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NewObjectEquality&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NewStringBufferWithCharArgument" defaultSeverity="WARNING" displayName="'char'인수가 있는 StringBuilder 생성자 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;char&lt;/code&gt;가 인수로 사용된 &lt;code&gt;StringBuffer&lt;/code&gt; 및 &lt;code&gt;StringBuilder&lt;/code&gt; 생성자 호출을 보고합니다.
이 경우&lt;code&gt;char&lt;/code&gt;는 확인 없이 정수 타입으로 변환되며 버퍼의 초기 용량으로 해석됩니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new StringBuilder('(').append("1").append(')');
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new StringBuilder("(").append("1").append(')');
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NewStringBufferWithCharArgument&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenationMissingWhitespace" defaultSeverity="WARNING" displayName="문자열 연결에 공백이 누락되었을 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
공백이 누락된, 즉 왼쪽 끝이 유니코드 문자 또는 숫자로 끝나며 오른쪽이 유니코드 문자 또는 숫자로 시작하는 문자열 연결을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String sql = "SELECT column" +
               "FROM table";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  연결의 왼쪽 및 오른쪽의 모두 리터럴인 경우에만 보고하려면 &lt;b&gt;가변 문자열과의 연결 무시&lt;/b&gt; 옵션을 사용하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringConcatenationMissingWhitespace&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SortedCollectionWithNonComparableKeys" defaultSeverity="WARNING" displayName="비교 불가능한 요소가 있는 정렬된 컬렉션" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
요소 타입이 &lt;code&gt;Comparable&lt;/code&gt; 인터페이스를 구현하지 않으며 자연스러운 순서에 의존하는 &lt;code&gt;TreeSet&lt;/code&gt;등의 정렬된 컬렉션의 생성을 보고합니다.
&lt;p&gt;그러한 컬렉션은 올바르게 작동하지 않을 가능성이 높습니다.&lt;/p&gt;
&lt;p&gt;
  컬렉션 요소 타입이 비교 불가능한 슈퍼타입인 경우 거짓 양성이 발생할 수 있지만 컬렉션은 비교 가능한 서브타입만을 가지도록 의도되어 있습니다. 이러한 경우라 하더라도 앞서 언급한 접근 방식은 오류를 일으키기 쉬우므로 컬렉션 요소 타입의 범위를 좁히거나 슈퍼타입을 &lt;code&gt;Comparable&lt;/code&gt;로 선언하는 것이 더 낫습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 검사는 컬렉션 요소가 &lt;code&gt;extends Comparable&lt;/code&gt;로 선언되지 않은 타입 매개변수인 경우 또한 보고합니다.
  제공된 옵션을 사용하여 타입 매개변수의 경고를 억제할 수 있습니다(예: API 호환성을 유지하기 위해).
&lt;/p&gt;
&lt;p&gt;
  &lt;small&gt;2018.3의 새로운 기능&lt;/small&gt;
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SortedCollectionWithNonComparableKeys&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WriteOnlyObject" defaultSeverity="WARNING" displayName="쓰기 전용 객체" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
수정되었지만 쿼리되지 않은 객체를 보고합니다.
&lt;p&gt;이 검사는 일부 라이브러리 메서드에 대해 추론되거나 어노테이션이 미리 추가될 수 있는 메서드 변형 컨트랙트에 의존합니다. 컬렉션, 맵, 문자열 빌더와 같은 타입은 더 정확한 다른 검사에서 보고하므로 이 검사에서는 보고하지 않습니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  AtomicReference&amp;lt;String&amp;gt; ref = new AtomicReference&amp;lt;&amp;gt;();
  ref.set("hello"); // ref가 다시 사용되지 않습니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;Ignore impure constructors(순수하지 않은 생성자 무시)&lt;/b&gt; 옵션을 사용하여, 순수한지 알 수 없는 생성자 또는 메서드에 의해 생성된 객체를 처리할지 여부를 제어합니다.
  해당 옵션을 선택하지 않으면 생성 중 객체 참조가 의도적으로 누수된 경우 거짓양성 오류가 삽입될 수 있습니다.
&lt;/p&gt;
&lt;b&gt;&lt;small&gt;2021.2의 새로운 기능&lt;/small&gt;&lt;/b&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: WriteOnlyObject&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantAssertCondition" defaultSeverity="WARNING" displayName="'assert' 문 내 상수 조건" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;assert&lt;/code&gt; 문의 상수 조건을 보고합니다. 상수 조건이 있는 &lt;code&gt;assert&lt;/code&gt; 문은 항상 실패하거나 항상 성공합니다.
이러한 구문은 리팩터링 후에 남겨질 수 있으며 의도되지 않았을 가능성이 높습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void foo() {
        assert true;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 1.4부터 사용할 수 있는 Java 기능 &amp;#39;어설션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ConstantAssertCondition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverflowingLoopIndex" defaultSeverity="WARNING" displayName="루프가 0번 또는 수십억 번 실행됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
색인 오버플로 없이 완료 불가능한 루프 또는 전혀 실행되지 않는 루프를 보고합니다.
일반적으로 이는 업데이트 연산 중 실수로 인해 발생합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(int s) {
    for (int i = s; i &gt; 12; i++) { // i-- should be here
      System.out.println(i);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: OverflowingLoopIndex&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnreachableCode" defaultSeverity="WARNING" displayName="도달할 수 없는 코드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
데이터 흐름 분석에 따라 절대 도달되지 않는 코드를 보고합니다. 
이는 항상 true 또는 false인 이전 조건의 결과이거나 도달할 수 없는 루프 본문 또는 catch 섹션일 수 있습니다. 항상 그렇지는 않지만, 일반적으로 도달할 수 없는 코드는 이전 경고의 결과일 수 있으므로, "Null 가능성 및 데이터 흐름 문제", "상수값" 또는 "빈 컨테이너 내 불필요한 연산"과 같은 검사 경고 형식을 확인하면 원인을 더 명확하게 파악할 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void finishApplication() {
    System.exit(0);
    System.out.println("Application is terminated"); // 도달할 수 없는 코드
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  단, 이러한 삽입은 메서드 컨트랙트 추론에 의존한다는 점에 유의하세요. 특히 항상 예외를 던지는 static 또는 final 메서드를 호출하면 '항상 실패하는' 컨트랙트가 추론되며 메서드 호출 이후의 코드는 도달 불가능한 것으로 간주됩니다. 예:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void run() {
    performAction();
    System.out.println("Action is performed"); // 도달할 수 없는 코드
  }
  
  static void performAction() {
    throw new AssertionError();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  이로 인해 코드 후처리가 사용되는 경우(예: 어노테이션 처리기가 메서드 본문을 유용한 다른 것으로 대체하는 경우), 위양성이 발생할 수 있습니다. 위양성 경고를 방지하려면, &lt;code&gt;org.jetbrains:annotations&lt;/code&gt; 패키지의 명시적인 &lt;code&gt;@org.jetbrains.annotations.Contract&lt;/code&gt; 어노테이션으로 자동 컨트랙트 추론을 억제하세요.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void run() {
    performAction();
    System.out.println("Action is performed"); // 더 이상 경고가 발생하지 않습니다
  }

  @Contract("-&gt; _") // 구현이 대체됩니다
  static void performAction() {
    throw new AssertionError();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;2024.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnreachableCode&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IncorrectDateTimeFormat" defaultSeverity="WARNING" displayName="잘못된 'DateTimeFormat' 패턴" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;!-- Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license. --&gt;
&lt;html&gt;
&lt;body&gt;
잘못된 날짜 및 시간 양식 패턴을 보고합니다.
&lt;p&gt;다음과 같은 오류가 보고됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;'TT'와 같이 지원되지 않는 패턴 문자&lt;/li&gt;
  &lt;li&gt;'#'과 같이 예약된 문자 사용&lt;/li&gt;
  &lt;li&gt;잘못된 안쪽 여백 사용&lt;/li&gt;
  &lt;li&gt;짝이 맞지 않는 대괄호&lt;/li&gt;
  &lt;li&gt;유효하지 않은 양의 패턴 문자가 연속됨&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  DateTimeFormatter.ofPattern("[][]]"); // 여는 '[' 없이 닫는 ']' 
  DateTimeFormatter.ofPattern("TT"); // 잘못된 패턴 문자 'T'
  DateTimeFormatter.ofPattern("{"); // 예약된 문자 '{'가 사용됨
  DateTimeFormatter.ofPattern("MMMMMM"); // 패턴 문자 'M'이 너무 많이 연속됨
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IncorrectDateTimeFormat&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousReturnByteInputStream" defaultSeverity="WARNING" displayName="'InputStream.read()'로부터 반환된 의심스러운 바이트 값" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;InputStream.read()&lt;/code&gt; 메서드를 구현하는 메서드에서 반환된 &lt;code&gt;byte&lt;/code&gt; 타입의 표현식을 보고합니다.
&lt;p&gt;
  byte 타입은 &lt;code&gt;-128&lt;/code&gt;에서 &lt;code&gt;127&lt;/code&gt;까지의 값을 포함하지만 &lt;code&gt;InputStream.read()&lt;/code&gt;는 &lt;code&gt;0&lt;/code&gt;에서 &lt;code&gt;255&lt;/code&gt; 내의 값을 반환하기 때문에 이러한 식은 의심스럽습니다.
  빠른 수정이 비트마스크 &lt;code&gt;0xFF&lt;/code&gt;를 적용하여 표현식을 부호가 없는 &lt;code&gt;byte&lt;/code&gt;로 변환합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
class MyInputStream extends InputStream {
  int pos = 0;
  byte[] data;

  MyInputStream(byte[] input) {
    data = input;
  }

  @Override
  public int read() {
    if (pos == data.length) {
      return -1;
    }
    return data[pos++]; // 문제 발생
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class MyInputStream extends InputStream {
  int pos = 0;
  byte[] data;

  MyInputStream(byte[] input) {
    data = input;
  }

  @Override
  public int read() {
    if (pos == data.length) {
      return -1;
    }
    return data[pos++] &amp; 0xFF;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2023.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousReturnByteInputStream&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DataFlowIssue" defaultSeverity="WARNING" displayName="null 가능성 및 데이터 흐름 문제" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
데이터 흐름 분석을 기반으로 항상 null 값 가능성 컨트랙트를 위배하거나, 예외를 발생시키거나, 불필요한 코드 구문을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (array.length &amp;lt; index) {
  System.out.println(array[index]);
} // 배열 색인이 항상 범위를 벗어납니다
if (str == null) System.out.println("str is null");
System.out.println(str.trim());
// 마지막 구문이 NPE를 던질 수 있습니다

@NotNull
Integer square(@Nullable Integer input) {
    // 메서드 컨트랙트 위반입니다
    return input == null ? null : input * input;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;a href="https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html"&gt;null 값 가능성을 표시하는&lt;/a&gt; 어노테이션, &lt;code&gt;&lt;a href="https://www.jetbrains.com/help/idea/contract-annotations.html"&gt;@Contract&lt;/a&gt;&lt;/code&gt; 어노테이션, &lt;code&gt;@Range&lt;/code&gt; 어노테이션 등 여러 어노테이션으로 검사 동작이 제어될 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;null 가능 값이 사용되는 메서드/필드/매개변수에 대한 @Nullable 어노테이션 제안&lt;/b&gt; 옵션을 사용하여, null 가능 값이 어노테이션 없는 매개변수가 포함된 메서드에 인수로 전달되거나, 어노테이션 없는 필드에 저장되거나, 어노테이션 없는 메서드에서 반환되는 경우를 경고합니다. 이러한 경우 검사에서는 &lt;code&gt;@Nullable&lt;/code&gt; 어노테이션 전달을 제안합니다. 또한 &lt;b&gt;어노테이션 구성&lt;/b&gt; 버튼을 사용해 null 값 가능성을 표시하는 어노테이션을 구성할 수도 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;어노테이션이 없는 멤버 및 매개변수를 @Nullable로 취급&lt;/b&gt; 옵션을 사용하면 어노테이션이 없는 멤버가 null일 수 있다고 가정되므로, 
    이러한 멤버를 null이 아닌 컨텍스트에서 사용해서는 안 됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;null 리터럴 인수가 사용되었으나 null이 아닌 필수 매개변수 보고&lt;/b&gt; 옵션을 사용하여, null일 수 없으나(예: 메서드 본문에서 즉시 역참조된 경우) &lt;code&gt;null&lt;/code&gt; 리터럴이 전달된 호출 위치가 있는 메서드 매개변수를 보고합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;null이 아닌 값을 항상 반환하는 null 가능한 메서드 보고&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;@Nullable&lt;/code&gt; 어노테이션이 추가되었으나 항상 null이 아닌 값을 반환하는 메서드를 보고합니다. 이 경우 어노테이션을 &lt;code&gt;@NotNull&lt;/code&gt;로 변경하는 것이 좋습니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;assert 문 무시&lt;/b&gt; 옵션을 사용하여 검사에서 &lt;code&gt;assert&lt;/code&gt; 문이 취급되는 방식을 제어합니다. 기본적으로 이 옵션은 비활성화되어 있습니다. 즉, 어설션이 실행되는 것으로 간주됩니다(-ea 모드). 이 옵션을 활성화하면 어설션이 완전히 무시됩니다(-da 모드).&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;일부 코드 경로에서만 발생하는 문제 보고&lt;/b&gt; 옵션을 사용하여 일부 코드 경로에서만 발생할 수 있는 문제를 보고할지 여부를 제어합니다. 이 옵션이 비활성화된 경우, &lt;i&gt;예외 가능&lt;/i&gt; 등의 경고가 보고되지 않습니다. 검사는 &lt;i&gt;예외 반드시 발생&lt;/i&gt;과 같은 경고만 보고합니다. 특히 코드에 null 값 가능성 및 컨트랙트 어노테이션이 일관되게 추가되지 않은 경우, 이 모드를 통해 거짓 양성의 수를 현저히 줄일 수 있습니다. 따라서 이는 기존 코드 베이스에서 가장
     중요한 문제를 찾는 데 유용합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  IntelliJ IDEA 2022.3 이전에 이 검사는 '상수 조건 및 예외' 검사의 일부였습니다.
  이제는 두 가지 검사인 '상숫값'과 'Null 가능성 및 데이터 흐름 문제'로 나뉩니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DataFlowIssue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReflectionForUnavailableAnnotation" defaultSeverity="WARNING" displayName="소스 전용 어노테이션에 대한 리플렉티브 액세스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
런타임이 아닐 시 어노테이션의 존재를 반영적으로 검사하려는 시도를 보고합니다.
&lt;p&gt;보존 정책이 &lt;code&gt;SOURCE&lt;/code&gt; 또는 &lt;code&gt;CLASS&lt;/code&gt;(디폴트)로 설정된 어노테이션을  테스트하기 위해 &lt;code&gt;Class.isAnnotationPresent()&lt;/code&gt;를 사용하면 항상 부정적인 결과가 발생합니다. 이러한 실수는 간과하기 쉽습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  {
    getClass().isAnnotationPresent(SourceAnnotation.class); //항상 false
  }

  @Retention(RetentionPolicy.SOURCE)
  @interface SourceAnnotation {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;어노테이션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReflectionForUnavailableAnnotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastConflictsWithInstanceof" defaultSeverity="WARNING" displayName="'instanceof'와의 충돌 형 변환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 타입에 대한 &lt;code&gt;instanceof&lt;/code&gt; 검사 뒤에 오는 타입 변환 표현식을 보고합니다.
&lt;p&gt;
  의도된 경우도 있으나 그러한 구문은 오류일 가능성이 높으며 런타임 시 &lt;code&gt;java.lang.ClassCastException&lt;/code&gt;를 발생시킵니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    int whenCharSequenceCastToNumber(Object o){
      if (o instanceof CharSequence) {
        return ((Number) o).intValue();
      }
      return 0;
    }

    int earlyReturnWhenNotCharSequence(Object o){
      if (!(o instanceof CharSequence)) return 0;
      return ((Number)o).intValue();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: CastConflictsWithInstanceof&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyStatementBody" defaultSeverity="WARNING" displayName="본문이 비어 있는 구문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 비어 있는 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;의도된 경우도 있으나 이러한 코드는 혼란을 일으킬 수 있으며 보통 오타가 난 결과입니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 JSP 파일에서 비활성화되어 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EmptyStatementBody&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ResultSetIndexZero" defaultSeverity="WARNING" displayName="JDBC ResultSet의 색인 0 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.sql.ResultSet&lt;/code&gt; 또는 &lt;code&gt;java.sql.PreparedStatement&lt;/code&gt;의 열 0으로 액세스를 시도하는 경우를 보고합니다.
역사적인 이유로 &lt;code&gt;java.sql.ResultSet&lt;/code&gt; 및 &lt;code&gt;java.sql.PreparedStatement&lt;/code&gt;의 열에는 &lt;b&gt;0&lt;/b&gt;이 아닌 &lt;b&gt;1&lt;/b&gt;부터 번호가 매겨져 있으며 0열로의 액세스는 JDBC 프로그래밍에서 자주 발생하는 오류입니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String getName(ResultSet rs) {
    &lt;b&gt;return&lt;/b&gt; rs.getString(0);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ResultSetIndexZero&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousMethodCalls" defaultSeverity="WARNING" displayName="의심스러운 컬렉션 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
실제 인수 타입이 컬렉션의 요소 타입과 일치하지 않는 매개변수화된 컬렉션의 메서드 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; list = getListOfElements();
  list.remove(""); // remove가 강조 표시됩니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 설정에서 다음과 같이 올바를 수도 있는 코드에 대한 경고를 비활성화할 수 있습니다:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public boolean accept(Map&amp;lt;Integer, String&amp;gt; map, Object key) {
    return map.containsKey(key);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousMethodCalls&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StringEquality" defaultSeverity="WARNING" displayName="'equals()' 대신 '=='를 사용하여 문자열 비교" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자열 비교를 위해 &lt;b&gt;==&lt;/b&gt; 또는 &lt;b&gt;!=&lt;/b&gt;를 사용하는 코드를 보고합니다.
&lt;p&gt;
  이 연산자는 내용을 비교하지 않고 참조 상등 관계를 판단합니다.
  대부분의 경우 문자열은 &lt;code&gt;equals()&lt;/code&gt;를 사용하여 비교해야 합니다. 이 연산자는 문자열이 각기 다른 객체인 경우 문자별 비교를 수행합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(String s, String t) {
    final boolean b = t == s;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;t&lt;/code&gt;가 null이 아닌 것으로 알려진 경우 '안전하지 않은' 빠른 수정을 적용하여 다음과 비슷한 결과를 얻는 것이 안전합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(String s, String t) {
    final boolean b = t.equals(s);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: StringEquality&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MisspelledEquals" defaultSeverity="WARNING" displayName="'equals()' 대신 'equal()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단일 매개변수가 있는 &lt;code&gt;equal()&lt;/code&gt; 선언을 보고합니다.
일반적으로 이는 오타이며, 실제로 의도한 것은 &lt;code&gt;equals()&lt;/code&gt;입니다.
&lt;p&gt;메서드 이름을 &lt;code&gt;equals&lt;/code&gt;로 바꾸는 빠른 수정을 사용하는 것이 좋습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public boolean equal(Object obj) {
      return true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public boolean equals(Object obj) {
      return true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MisspelledEquals&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousToArrayCall" defaultSeverity="WARNING" displayName="의심스러운 'Collection.toArray()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
의심스러운 &lt;code&gt;Collection.toArray()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;다음 유형의 호출은 의심스러운 것으로 간주됩니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    배열 인수의 타입이 결과가 변환될 배열 타입과 같지 않은 경우
  &lt;/li&gt;
  &lt;li&gt;
    배열 인수의 타입이 컬렉션 선언 내 타입 매개변수와 일치하지 않는 경우
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
void m1(List list) {
  Number[] ns = (Number[]) list.toArray(new String[0]);
}

void m2(List&amp;lt;Number&amp;gt; list) {
  Number[] ns = list.toArray(new String[0]);
}
&lt;/code&gt;&lt;/pre&gt;


&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousToArrayCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnsupportedChronoFieldUnitCall" defaultSeverity="WARNING" displayName="지원되지 않는 'java.time.temporal.ChronoUnit' 및 'java.time.temporal.ChronoField'가 있는 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;!-- Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license. --&gt;
&lt;html&gt;
&lt;body&gt;
지원되지 않는 &lt;code&gt;java.time.temporal.ChronoField&lt;/code&gt; 또는
&lt;code&gt;java.time.temporal.ChronoUnit&lt;/code&gt; 열거형 상수를 인수로 갖는 &lt;code&gt;java.time&lt;/code&gt; 메서드 호출(&lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;getLong()&lt;/code&gt;,
&lt;code&gt;with()&lt;/code&gt;, &lt;code&gt;plus()&lt;/code&gt;, &lt;code&gt;minus()&lt;/code&gt;)을 보고합니다.
이러한 호출은 런타임 시 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;을 던집니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
LocalTime localTime = LocalTime.now();
int year = localTime.get(ChronoField.YEAR);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2023.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnsupportedChronoFieldUnitCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HashCodeUsesNonFinalVariable" defaultSeverity="WARNING" displayName="최종이 아닌 필드가 'hashCode()'에서 참조됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
final이 아닌 변수에 액세스하는 &lt;code&gt;hashCode()&lt;/code&gt; 구현을 보고합니다.
&lt;p&gt;
  그러한 액세스를 사용하면 &lt;code&gt;hashCode()&lt;/code&gt;가 객체 수명 주기의 각기 다른 시점에 다른 결과를 반환할 수 있어 표준 컬렉션 클래스 사용 시 문제가 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Drink {
    String name;
    Drink(String name) { this.name = name; }
    @Override public int hashCode() {
      return Objects.hash(name); // 경고
    }
  }
  ...
    Drink coffee = new Drink("Coffee");
    priceMap.put(coffee, 10.0);
    coffee.name = "Tea";
    double coffeePrice = priceMap.get(coffee); // 찾을 수 없음
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;필드를 final로 만드는 빠른 수정이 제안됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Drink {
    final String name;
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: HashCodeUsesNonFinalVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MismatchedCollectionQueryUpdate" defaultSeverity="WARNING" displayName="컬렉션의 쿼리 및 업데이트 불일치" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
콘텐츠가 쿼리된 다음 업데이트되지 않거나 업데이트된 다음 쿼리되지 않는 컬렉션을 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  그러한 일관되지 않은 쿼리 및 업데이트는 무의미하며 불필요한 코드 또는 오타를 나타냅니다.
&lt;/p&gt;
&lt;p&gt;
  검사 설정을 사용하여 업데이트/쿼리 메서드와 일치하는 이름 패턴을 지정하세요.
  요소를 반환하는 쿼리 메서드가 자동으로 탐지되며 출력 매개변수(예: an &lt;code&gt;OutputStream&lt;/code&gt;)로 데이터를 쓰는 메서드만 지정해야 합니다.
&lt;p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;메서드 &lt;code&gt;store()&lt;/code&gt;를 포함하는 사용자 지정 &lt;code&gt;FixedStack&lt;/code&gt; 클래스가 있다고 가정합니다.
&lt;pre&gt;&lt;code&gt;
  public class FixedStack&amp;lt;T&amp;gt; extends Collection&amp;lt;T&amp;gt; {
    public T store(T t) {
      // 구현
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음과 같이 일치하지 않는 쿼리를 보고하도록 &lt;code&gt;store&lt;/code&gt;를 업데이트 메서드 테이블에 추가할 수 있습니다:
&lt;pre&gt;&lt;code&gt;
  void test(int i) {
    FixedStack&amp;lt;Integer&amp;gt; stack = new FixedStack&amp;lt;&amp;gt;();
    stack.store(i);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MismatchedCollectionQueryUpdate&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringTokenizerDelimiter" defaultSeverity="WARNING" displayName="'StringTokenizer' 내 구분자 중복" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구분자 인자에 중복 문자가 있는 &lt;code&gt;StringTokenizer()&lt;/code&gt; 생성자 호출 혹은 &lt;code&gt;extToken()&lt;/code&gt; 메서드 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void printTokens(String text) {
    StringTokenizer tokenizer = new StringTokenizer(text, "\n\n");
    while (tokenizer.hasMoreTokens()) {
      System.out.println(tokenizer.nextToken());
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void printTokens(String text) {
    StringTokenizer tokenizer = new StringTokenizer(text, "\n");
    while (tokenizer.hasMoreTokens()) {
      System.out.println(tokenizer.nextToken());
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: StringTokenizerDelimiter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayHashCode" defaultSeverity="WARNING" displayName="배열에서 'hashCode()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열의 잘못된 해시 코드 계산을 보고합니다.
&lt;p&gt;배열의 해시 코드를 올바르게 계산하려면 다음을 사용하세요.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;선형 배열: &lt;code&gt;Arrays.hashcode()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;다차원 배열: &lt;code&gt;Arrays.deepHashcode()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
이 메서드는 입력 값의 시퀀스가 배열을 포함하는 경우 &lt;code&gt;Objects.hash()&lt;/code&gt;와 함께 사용되어야 합니다(예:&lt;code&gt;Objects.hash(string, Arrays.hashcode(array))&lt;/code&gt;).
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ArrayHashCode&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MismatchedStringBuilderQueryUpdate" defaultSeverity="WARNING" displayName="'StringBuilder'의 쿼리 및 업데이트 불일치" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
내용이 읽기는 되지만 쓰기 가능하지 않거나 쓰기는 되지만 읽기 가능하지 않은 &lt;code&gt;StringBuilder&lt;/code&gt;, &lt;code&gt;StringBuffer&lt;/code&gt; 또는 &lt;code&gt;StringJoiner&lt;/code&gt; 객체를 보고합니다.
&lt;p&gt;그러한 일관되지 않은 읽기 및 쓰기는 무의미하며 불필요하거나 불완전하거나 잘못된 코드를 나타냅니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void m1() {
    StringBuilder sb = new StringBuilder();
    sb.append("a");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MismatchedStringBuilderQueryUpdate&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousInvocationHandlerImplementation" defaultSeverity="WARNING" displayName="의심스러운 'InvocationHandler' 구현" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;hashCode()&lt;/code&gt;, &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;toString()&lt;/code&gt;과 같은 표준 &lt;code&gt;Object&lt;/code&gt; 메서드를 프록시하지 않는 &lt;code&gt;InvocationHandler&lt;/code&gt; 구현을 보고합니다.
&lt;p&gt;이러한 메서드를 처리하지 못하면 프록시 인스턴스에서 해당 메서드 호출 시 예기치 않은 문제가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  InvocationHandler myHandler = (proxy, method, params) -&amp;gt; {
    System.out.println("Hello World!");
    &lt;b&gt;return&lt;/b&gt; null;
  };
  Runnable myProxy = (Runnable) Proxy.newProxyInstance(
    Thread.currentThread().getContextClassLoader(),
    &lt;b&gt;new&lt;/b&gt; Class[] {Runnable.class}, myHandler
  );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  이 코드 스니펫은 &lt;code&gt;Runnable.run()&lt;/code&gt; 메서드만 프록시하도록 설계되어 있습니다.
  하지만 &lt;code&gt;hashCode()&lt;/code&gt;와 같은 &lt;code&gt;Object&lt;/code&gt; 메서드 호출 또한 프록시됩니다.
  이 때문에 예를 들어 &lt;code&gt;myProxy&lt;/code&gt;를 &lt;code&gt;HashSet&lt;/code&gt;에 추가하는 경우에 &lt;code&gt;NullPointerException&lt;/code&gt;과 같은 문제가 발생할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.2의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousInvocationHandlerImplementation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousArrayCast" defaultSeverity="WARNING" displayName="의심스러운 배열 형 변환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
의심스러운 배열 형 변환을 보고합니다.
배열 타입 변환은 더 세부적인 배열 타입으로 변환하는 경우 의심스러운 것으로 간주됩니다. 그러한 형 변환은 컴파일타임에 허용되지만 런타임 시 &lt;code&gt;ClassCastException&lt;/code&gt;을 발생시키며 실패할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Number[] numbers = new Number[]{1L, 2L, 4L};
  Long[] longs = (Long[])numbers;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousArrayCast&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EndlessStream" defaultSeverity="WARNING" displayName="쇼트 서킷이 아닌 연산이 스트림을 무한으로 소비합니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
무한 스트림을 소비하는 비단락 회로 연산을 보고합니다. 예외를 던져 이러한 연산을 완료할 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Stream.iterate(0, i -&gt; i + 1).collect(Collectors.toList())
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EndlessStream&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SafeVarargsHasNoEffect" defaultSeverity="WARNING" displayName="@SafeVarargs가 안전하지 않을 수 있는 연산을 억제합니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@SafeVarargs&lt;/code&gt; 메서드 내에서 vararg 매개변수가 다른 항목으로 재할당되는 쓰기 작업을 보고합니다.
이러한 경우 새로 할당된 배열은 호출 위치의 가변 arity 인수와 관련이 없으며 더는 안전하지 않을 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    @SafeVarargs
    public final &amp;lt;T&amp;gt; void test(T[] tt, T... t) {
        t = tt;
        System.out.println(t[0]);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;어노테이션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SafeVarargsHasNoEffect&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MismatchedArrayReadWrite" defaultSeverity="WARNING" displayName="배열의 일치하지 않는 읽기 및 쓰기" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
내용이 읽히지만 업데이트되지 않거나 업데이트되지만 읽히지 않는 배열을 보고합니다. 그러한 일관되지 않은 읽기 및 쓰기 무의미하며 불필요하거나 불완전하거나 잘못된 코드를 나타냅니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final int[] bar = new int[3];
  bar[2] = 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: MismatchedArrayReadWrite&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparatorMethodParameterNotUsed" defaultSeverity="WARNING" displayName="의심스러운 'Comparator.compare()' 구현" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Comparator.compare()&lt;/code&gt; 및 &lt;code&gt;Comparable.compareTo()&lt;/code&gt; 구현의 문제를 보고합니다.
&lt;p&gt;다음과 같은 경우가 보고됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    매개변수가 사용되지 않은 경우를 보고합니다. 이는 오타이며 나머지 매개변수가 자신과 비교되거나 메서드가 올바르게 구현되지 않을 가능성이 높습니다.
  &lt;/li&gt;
  &lt;li&gt;
    요소가 동일한 경우 메서드가 &lt;code&gt;0&lt;/code&gt;을 반환하지 않는 것은 자명합니다. 이러한 비교 메서드는 동일한 요소가 나올 때 컨트랙트를 위반하며 예기치 않은 결과를 초래할 수 있습니다. 특히 일부 데이터에서 정렬 시 예외가 발생하며 실패할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;
    비교 메서드는 양수 또는 음수 값을 반환하지 않습니다. 컨트랙트를 충족하려면 비교 메서드가 양수 값을 반환하는 경우, 인수가 역순으로 제공되면 음수 값을 반환해야 합니다.
  &lt;/li&gt;
  &lt;li&gt;
    비교 메서드는 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;를 반환합니다. 컨트랙트에서 허용되지만, 일부 호출 사이트에서 단항 뺄셈 연산자를 사용하여 비교 메서드의 반환값을 올바르지 않게 반전시킬 수 있으므로 오류가 발생하기 쉽습니다.
    &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;의 부정 값은 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;입니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Comparator&amp;lt;String&amp;gt; lambda =
    (a, b) -&amp;gt; a.length() &amp;gt; b.length()
              ? 0
              : Math.random() &amp;gt; 0.5 ? -1 : 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ComparatorMethodParameterNotUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceAllDot" defaultSeverity="WARNING" displayName="의심스러운 정규식 인수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
첫 번째 인수가 하나의 정규식 메타 문자 인수인 &lt;code&gt;String.replaceAll()&lt;/code&gt; 또는 &lt;code&gt;String.split()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  정규식 메타 문자는 &lt;code&gt;.$|()[{^?*+\&lt;/code&gt; 중 하나입니다. 이러한 문자는 정규 표현식에서 특별한 의미를 가집니다.
  예를 들어, 점은 모든 문자에 일치하기 때문에 &lt;code&gt;"ab.cd".replaceAll(".", "-")&lt;/code&gt;을 호출하면 &lt;code&gt;"-----"&lt;/code&gt;이 생성됩니다.
  대신 이스케이프된 배리언트 &lt;code&gt;\\."&lt;/code&gt;가 의도되었을 가능성이 높습니다.
&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;File.separator&lt;/code&gt;를 정규식으로 사용하는 경우도 보고됩니다. &lt;code&gt;File.separator&lt;/code&gt;에는 플랫폼별 값이 있습니다. Linux 및 Mac에서는 &lt;code&gt;/&lt;/code&gt;와 같지만 Windows에서는 &lt;code&gt;\&lt;/code&gt;와 같습니다. 이는 유효한 정규 표현식이 아니므로 이러한 코드는 이식 가능하지 않습니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  s.replaceAll(".", "-");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  s.replaceAll("\\.", "-");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceAllDot&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticFieldReferenceOnSubclass" defaultSeverity="WARNING" displayName="static 필드가 하위 클래스를 통해 참조됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
호출이 선언하는 클래스 자체에 의해서가 아니라 하위 클래스에 의해 한정된 static 필드로의 액세스를 보고합니다.
&lt;p&gt;
  Java는 그러한 정규화를 허용하지만 그러한 액세스는 상속과 재정의가 미묘하게 혼동되고 있음을 나타낼 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    static int foo = 0;
  }

  class Child extends Parent { }

  void bar() {
    System.out.println(Child.foo);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 결과는 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    static int foo = 0;
  }

  class Child extends Parent { }

  void bar() {
    System.out.println(Parent.foo);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StaticFieldReferenceOnSubclass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayEquals" defaultSeverity="WARNING" displayName="배열에서 'equals()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
두 배열을 비교하기 위한 &lt;code&gt;equals()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;배열에서 &lt;code&gt;equals()&lt;/code&gt;를 호출하면 ID가 비교되며 이는 &lt;code&gt;==&lt;/code&gt;를 사용하는 것과 동등합니다.
  두 배열의 내용을 비교하려면 &lt;code&gt;Arrays.equals()&lt;/code&gt;를 사용하세요. 혹은 다차원 배열을 비교하려면 &lt;code&gt;Arrays.deepEquals()&lt;/code&gt;를 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void sample(int[] first, int[] second){
    if (first.equals(second)) return;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void sample(int[] first, int[] second){
    if (Arrays.equals(first, second)) return;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ArrayEquals&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnsatisfiedRange" defaultSeverity="WARNING" displayName="반환 값이 선언된 범위를 벗어남" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
선언된 메서드 반환 범위를 준수하지 않는 메서드에서 반환된 숫자 값을 보고합니다.
몇 가지 어노테이션을 사용하여 메서드 반환 범위를 선언할 수 있습니다:
&lt;ul&gt;
  &lt;li&gt;JetBrains 어노테이션 패키지의 &lt;code&gt;org.jetbrains.annotations.Range&lt;/code&gt;('from' 및 'to' 지정)&lt;/li&gt;
  &lt;li&gt;Checker Framework 어노테이션 패키지의 &lt;code&gt;org.checkerframework.common.value.qual.IntRange&lt;/code&gt;('from' 및 'to' 지정)&lt;/li&gt;
  &lt;li&gt;Checker Framework 어노테이션 패키지의 &lt;code&gt;org.checkerframework.checker.index.qual.GTENegativeOne&lt;/code&gt;(범위: '&gt;= -1')&lt;/li&gt;
  &lt;li&gt;Checker Framework 어노테이션 패키지의 &lt;code&gt;org.checkerframework.checker.index.qual.NonNegative&lt;/code&gt;(범위: '&gt;= 0')&lt;/li&gt;
  &lt;li&gt;Checker Framework 어노테이션 패키지의 &lt;code&gt;org.checkerframework.checker.index.qual.Positive&lt;/code&gt;(범위: '&gt; 0')&lt;/li&gt;
  &lt;li&gt;JSR 305 어노테이션 패키지의 &lt;code&gt;javax.annotation.Nonnegative&lt;/code&gt;(범위: '&gt;= 0')&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.validation.constraints.Min&lt;/code&gt;(최솟값 지정)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.validation.constraints.Max&lt;/code&gt;(최댓값 지정)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Range(from = 0, to = Integer.MAX_VALUE) int getValue() {
    // 경고: -1은 선언된 범위에서 벗어납니다
    return -1;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnsatisfiedRange&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ThrowableNotThrown" defaultSeverity="WARNING" displayName="'Throwable'이 던져지지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
생성된 &lt;code&gt;Throwable&lt;/code&gt;이 실제로 한 번도 던져지지 않는 경우, &lt;code&gt;Throwable&lt;/code&gt; 또는 그 하위 클래스의 인스턴스화를 보고합니다.
또한 이 검사는 메서드 호출의 결과가 던져지지 않는 경우 &lt;code&gt;Throwable&lt;/code&gt; 또는 그 하위 클래스의 인스턴스를 반환하는 메서드 호출을 보고합니다.
&lt;p&gt;Error Prone 또는 AssertJ의 &lt;code&gt;@CanIgnoreReturnValue&lt;/code&gt; 어노테이션이 추가된 메서드 호출은 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void check(String s) {
        if (s == null) {
            new NullPointerException("s");
        }
        // ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThrowableNotThrown&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MagicConstant" defaultSeverity="WARNING" displayName="매직 상수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
'magic' 상수로 대체 가능한 표현식을 보고합니다.
&lt;p&gt;예시 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 단순 리터럴 '2'가 사용되었습니다. 경고가 발생합니다
  Font font = new Font("Arial", 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예시 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 사전 정의된 상수가 사용되었습니다. 적절합니다
  Font font = new Font("Arial", Font.ITALIC)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  가능한 경우 빠른 수정은 사전 정의된 적절한 상수를 삽입합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 검사의 해당 동작은 &lt;code&gt;org.intellij.lang.annotations.MagicConstant&lt;/code&gt; 어노테이션으로 제어됩니다.
  일부 표준 Java 라이브러리 메서드는 어노테이션이 미리 추가되어 있으나 코드에서 이 어노테이션을 사용할 수도 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MagicConstant&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EqualsUsesNonFinalVariable" defaultSeverity="WARNING" displayName="최종이 아닌 필드가 'equals()'에서 참조됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
final이 아닌 변수에 액세스하는 &lt;code&gt;equals()&lt;/code&gt; 구현을 보고합니다. 이러한 액세스를 사용하면 &lt;code&gt;equals()&lt;/code&gt;이 객체 수명 주기의 각기 다른 시점에 다른 결과를 반환할 수 있어 표준 컬렉션 클래스 사용 시 문제가 발생할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Person {
    private String lastName;

    @Override
    public boolean equals(Object obj) {
      ...
      Person other = (Person) obj;
      if (lastName == null) {
        if (!lastName.equals(other.lastName)) {
        return false;
      ...
      }
    }
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: EqualsUsesNonFinalVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastToIncompatibleInterface" defaultSeverity="WARNING" displayName="호환되지 않는 타입으로 형 변환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
형 변환된 식에 형 변환된 클래스/인터페이스 타입을 확장/구현하는 클래스/인터페이스 타입이나 그러한 하위 클래스가 없는 타입 변환 식을 보고합니다.
&lt;p&gt;
  이러한 구문은 오류가 발생하기 쉬우며 런타임 시 &lt;code&gt;java.lang.ClassCastException&lt;/code&gt;을 던집니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface A {}
  interface Z {}
  static class C {}

  void x(C c) {
    if (c instanceof Z) {
      A a = ((A)c); // 호환되지 않는 인터페이스 'A'로 형 변환
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: CastToIncompatibleInterface&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CovariantEquals" defaultSeverity="WARNING" displayName="공분산 'equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
포함하는 클래스에 인수 타입으로 &lt;code&gt;java.lang.Object&lt;/code&gt;를 취하는 &lt;code&gt;equals()&lt;/code&gt;의 다른 오버로드가 없는 경우, &lt;code&gt;java.lang.Object&lt;/code&gt; 이외의 인수 타입을 취하는 &lt;code&gt;equals()&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;
  공변성 버전의 &lt;code&gt;equals()&lt;/code&gt;는 &lt;code&gt;Object.equals(Object)&lt;/code&gt; 메서드를 재정의하지 않습니다. 이는 런타임 시 예기치 않은 동작을 초래할 수 있습니다. 예를 들어, 클래스가 &lt;code&gt;Object.equals(Object)&lt;/code&gt; 메서드를 재정의해야 하는 표준 컬렉션 클래스를 생성하는 데 사용되는 경우를 말합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      public boolean equals(Foo foo) {  // 경고
          return false;
      }
  }
  class Bar {
      public boolean equals(Bar bar) {  // 경고 없음
          return false;
      }
      @Override
      public boolean equals(Object obj) {
          return false;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: CovariantEquals&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MathRoundingWithIntArgument" defaultSeverity="WARNING" displayName="'int' 인수로 math 반올림 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;int&lt;/code&gt;를 인수로 사용하는 &lt;code&gt;Math&lt;/code&gt; 및 &lt;code&gt;StrictMath&lt;/code&gt;의 &lt;code&gt;round()&lt;/code&gt;, &lt;code&gt;ceil()&lt;/code&gt;,
&lt;code&gt;floor()&lt;/code&gt;, &lt;code&gt;rint()&lt;/code&gt; 메서드에 대한 호출을 보고합니다.
&lt;p&gt;이러한 메서드는 인수가 &lt;code&gt;long&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt;이어야 하는 경우에 호출할 수가 있으며, 예기치 않은 결과가 나올 수 있습니다.&lt;/p&gt;
&lt;p&gt;이 검사는 &lt;code&gt;double&lt;/code&gt;로 형 변환하기 위해 이러한 표현식(&lt;code&gt;round&lt;/code&gt; 제외)을 단순화하는 수정을 제공합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 2;
  double d1 = Math.floor(i);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 2;
  double d1 = i;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2023.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MathRoundingWithIntArgument&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalOfNullableMisuse" defaultSeverity="WARNING" displayName="null 또는 null이 아닌 인수와 Optional.ofNullable을 같이 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
항성 null이거나 항상 null이 아닌 인수가 전달되는 &lt;code&gt;Optional.ofNullable()&lt;/code&gt;의 사용 위치를 보고합니다.
이러한 경우에는 &lt;code&gt;Optional.ofNullable()&lt;/code&gt;을 사용할 이유가 없습니다. &lt;code&gt;Optional.empty()&lt;/code&gt; 또는 &lt;code&gt;Optional.of()&lt;/code&gt;를 사용하여 각각 항상 비어 있거나 항상 비어 있지는 않은 Optional을 생성하는 의도를 명시적으로 표시해야 합니다. 또한, &lt;code&gt;Optional.ofNullable()&lt;/code&gt; 인수 내에 실수가 있을 수 있으므로 검사할 필요가 있습니다.
&lt;p&gt;
  예:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Optional&amp;lt;String&amp;gt; empty = Optional.ofNullable(null); // Optional.empty();이어야 함
Optional&amp;lt;String&amp;gt; present = Optional.ofNullable("value"); // Optional.of("value");이어야 함 
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: OptionalOfNullableMisuse&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedAssignment" defaultSeverity="WARNING" displayName="사용되지 않는 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대입 후 사용되지 않은 대입 값을 보고합니다.
대입 값이 사용되지 않을 경우 대입을 제거하여 코드 길이를 줄이고 불필요한 대입을 피하는 것이 좋습니다.
&lt;p&gt;다음과 같은 경우가 보고됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;변수가 대입된 후 한 번도 읽히지 않는 경우&lt;/li&gt;
  &lt;li&gt;변수가 읽히기 전에 항상 새 값으로 덮어쓰이는 경우&lt;/li&gt;
  &lt;li&gt;(위의 두 가지 이유 중 하나로) 변수 이니셜라이저가 불필요한 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;
&lt;b&gt;Report redundant initializers(불필요한 이니셜라이저 보고)&lt;/b&gt; 옵션을 사용하여 불필요한 이니셜라이저를 보고합니다.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int getI() {
    int i = 0; // 불필요한 이니셜라이저
    i = 2;
    return i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;b&gt;이항식으로 대체될 수 있는 접두사 식을 보고&lt;/b&gt; 옵션을 사용하면 &lt;code&gt;++i&lt;/code&gt;가 &lt;code&gt;i + 1&lt;/code&gt;로 대체될 수 있는 경우를 보고합니다.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int preInc(int value) {
    int res = value;
    return ++res;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;b&gt;변경된 값이 사용되지 않는 접미사 식을 보고&lt;/b&gt; 옵션을 사용하면 &lt;code&gt;i&lt;/code&gt;의 값이 추후에 사용되지 않는 &lt;code&gt;i++&lt;/code&gt; 경우를 보고합니다.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int postInc(int value) {
    int res = value;
    return res++;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;b&gt;값이 사용되지 않는 패턴 변수 보고&lt;/b&gt; 옵션을 사용하면 패턴 변수의 값이 사용되기 전에 재정의되는 경우를 보고합니다.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (object instanceof String s) {
      s = "hello";
      System.out.println(s);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;b&gt;값이 사용되지 않는 반복 매개변수를 보고&lt;/b&gt; 옵션을 사용하면 강화된 &lt;code&gt;for&lt;/code&gt; 구문 내에서 반복 매개변수의 값이 사용되기 전에 재정의되는 경우를 보고합니다.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String arg : args) {
      arg = "test";
      System.out.println(arg);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnusedAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EqualsAndHashcode" defaultSeverity="WARNING" displayName="equals() 및 hashCode()가 쌍으로 되어 있지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;equals()&lt;/code&gt; 메서드를 재정의하지만 &lt;code&gt;hashCode()&lt;/code&gt; 메서드를 재정의하지 않거나 그 반대인 클래스를 보고합니다. 이러한 클래스가 &lt;code&gt;Collection&lt;/code&gt; 또는 &lt;code&gt;HashMap&lt;/code&gt;에 추가되면 문제가 발생할 수 있습니다.
&lt;p&gt;빠른 수정은 누락된 메서드에 대한 디폴트 구현을 생성합니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class StringHolder {
  String s;

  @Override public int hashCode() {
    return s != null ? s.hashCode() : 0;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class StringHolder {
  String s;

  @Override public int hashCode() {
    return s != null ? s.hashCode() : 0;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof StringHolder)) return false;

    StringHolder holder = (StringHolder)o;

    if (s != null ? !s.equals(holder.s) : holder.s != null) return false;

    return true;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EqualsAndHashcode&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousArrayMethodCall" defaultSeverity="WARNING" displayName="의심스러운 'Arrays' 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인수 타입이 일치하지 않으며 &lt;code&gt;Arrays.fill()&lt;/code&gt;과 같이 제네릭이 아닌 배열 조작 메서드를 호출하는 경우를 보고합니다.
그러한 호출은 유용하지 않으며 실수일 가능성이 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int foo(String[] strings) {
    return Arrays.binarySearch(strings, 1);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousArrayMethodCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CompareToUsesNonFinalVariable" defaultSeverity="WARNING" displayName="최종이 아닌 필드가 'compareTo()'에서 참조됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;compareTo()&lt;/code&gt; 구현 내 &lt;code&gt;final&lt;/code&gt;이 아닌 필드로의 액세스를 보고합니다.
&lt;p&gt;
  그러한 액세스를 사용하면 &lt;code&gt;compareTo()&lt;/code&gt;가 객체 수명 주기의 각기 다른 시점에 다른 결과를 반환할 수 있어 &lt;code&gt;java.util.TreeSet&lt;/code&gt;과 같은 표준 컬렉션 클래스 사용 시 문제가 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  필드에 대한 쓰기 권한이 없는 경우에만 필드를 &lt;code&gt;final&lt;/code&gt;로 만드는 빠른 수정을 사용할 수 있습니다. 그렇지 않으면 수정이 제안되지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo implements Comparable&amp;lt;Foo&amp;gt;{
    private int index;
    Foo(int idx) {
      index = idx;
    }
    @Override
    public int compareTo(Foo foo) {
     return Integer.compare(this.index, foo.index);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo implements Comparable&amp;lt;Foo&amp;gt;{
    private final int index;
    Foo(int idx) {
      index = idx;
    }
    @Override
    public int compareTo(Foo foo) {
      return Integer.compare(this.index, foo.index);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: CompareToUsesNonFinalVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VariableNotUsedInsideIf" defaultSeverity="WARNING" displayName="'null' 검사된 참조가 'if' 내부에서 사용되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;if&lt;/code&gt; 문의 조건 또는 조건식에서 null 값 가능성이 검사되었으나 &lt;code&gt;if&lt;/code&gt; 문 내부에서 사용되지 않은 변수에 대한 참조를 보고합니다.
&lt;p&gt;
  이는 보통 검사가 불필요하거나 변수가 실수로 &lt;code&gt;if&lt;/code&gt; 문 내부에서 참조되지 않았음을 의미합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Integer i) {
    if (i != null) { // 여기서 'i'가 'if' 문 내부에서 사용되지 않습니다
      System.out.println();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: VariableNotUsedInsideIf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NumberEquality" defaultSeverity="WARNING" displayName="'equals()' 대신 '=='를 사용하여 숫자 비교" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Number&lt;/code&gt; 상등 관계를 테스트 하기 위해 &lt;code&gt;equals()&lt;/code&gt; 대신 &lt;b&gt;==&lt;/b&gt; 또는 &lt;b&gt;!=&lt;/b&gt;를 사용하는 코드를 보고합니다.
&lt;p&gt;
  오토박싱을 사용하면 래퍼 타입의 두 원시 타입 대신 두 인스턴스를 비교하는 실수를 범하기 쉽습니다(예: &lt;code&gt;int&lt;/code&gt; 대신 &lt;code&gt;Integer&lt;/code&gt; 비교).
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void foo(Integer a, Integer b) {
    final boolean bool = a == b;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;a&lt;/code&gt;가 null이 아닌 것으로 알려진 경우 '안전하지 않은' 빠른 수정을 적용하여 다음과 비슷한 결과를 얻는 것이 안전합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void foo(Integer a, Integer b) {
    final boolean bool = a.equals(b);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: NumberEquality&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassGetClass" defaultSeverity="WARNING" displayName="의심스러운 'Class.getClass()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.Class&lt;/code&gt; 인스턴스에서 호출되는 &lt;code&gt;getClass()&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;결과는 항상 &lt;code&gt;Class.class&lt;/code&gt;와 동일하므로, 이런 경우는 대개 실수입니다.
실수인 경우 &lt;code&gt;getClass()&lt;/code&gt; 호출을 제거하고 한정자를 직접 사용하는 것이 좋습니다.
  의도된 동작인 경우 혼동을 피하기 위해 &lt;code&gt;Class.class&lt;/code&gt;를 명시적으로 작성하는 것이 좋습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Class&amp;lt;?&amp;gt; clazz) {
    String name = clazz.getClass().getName();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;가능한 빠른 수정 중 하나가 적용된 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Class&amp;lt;?&amp;gt; clazz) {
    String name = clazz.getName();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassGetClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SubtractionInCompareTo" defaultSeverity="WARNING" displayName="'compareTo()'의 뺄셈" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;compareTo()&lt;/code&gt; 메서드 및 &lt;code&gt;java.util.Comparator.compare()&lt;/code&gt;를 구현하는 메서드 내 뺄셈을 보고합니다.
&lt;p&gt;
  정수 뺄셈의 결과를 &lt;code&gt;compareTo()&lt;/code&gt; 메서드의 결과로 사용하는 것은 관용적 표현이지만 이 구문은 정수 오버플로가 발생할 경우 탐지하기 어렵고 까다로운 버그를 일으킬 수 있습니다.
  정수 값을 직접 비교하여 &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt;을 반환하는 것이 대부분의 경우에 더 좋습니다.
&lt;/p&gt;
&lt;p&gt;
  정수 타입으로 즉시 변환되는 부동소수점 값에 대한 뺄셈 또한 보고됩니다. 반올림에 의해 정확도가 떨어질 수 있기 때문입니다.
&lt;/p&gt;
&lt;p&gt;
  이 검사는 값의 범위가 제한되어 있어 오버플로가 발생하지 않는다고 정적으로 판단되는 경우에는 보고하지 않습니다.
  또한 &lt;code&gt;0&lt;/code&gt;보다 같거나 큰 &lt;code&gt;int&lt;/code&gt; 수에 대한 뺄셈은 오버플로를 일으키지 않습니다.
  그러므로 이 검사는 그러한 경우에 경고하지 않습니다.
&lt;/p&gt;
&lt;p&gt;
  항상 0 이상의 값을 반환하는 메서드는 &lt;code&gt;javax.annotation.Nonnegative&lt;/code&gt; 어노테이션 함께 표시하거나 이 검사의 옵션에서 지정할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class DoubleHolder implements Comparable&amp;lt;DoubleHolder&amp;gt; {
    double d;
    public int compareTo(DoubleHolder that) {
        return (int)(this.d - that.d);
    }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음 예시에서 &lt;code&gt;String.length()&lt;/code&gt;는 음수가 아니기 때문에 경고가 발생하지 않습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A implements Comparable&amp;lt;A&amp;gt; {
    final String s = "";
    public int compareTo(A a) {
        return s.length() - a.s.length();
    }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  뺄셈 내부에 사용하기에 안전한 메서드를 나열하려면 옵션을 사용하세요.
  메서드가 항상 &lt;code&gt;0&lt;/code&gt;보다 같거나 큰 &lt;code&gt;int&lt;/code&gt; 값을 반환하는 경우 안전합니다.
&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: SubtractionInCompareTo&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NullArgumentToVariableArgMethod" defaultSeverity="WARNING" displayName="가변인수 메서드에 대한 혼란스러운 인수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
vararg 매개변수 위치에 호출이 &lt;code&gt;null&lt;/code&gt; 또는 vararg 매개변수의 하위 타입 배열인 하나의 인수를 가지는 가변 arity 메서드 호출을 보고합니다.
이러한 인수는 vararg 호출 또는 비 vararg 호출 중 어느 것이 필요한지 명확하지 않아 혼동될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String[] ss = new String[]{"foo", "bar"};
  System.out.printf("%s", ss);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예시에서 전체 배열이 아닌 첫 번째 배열 요소만 출력됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;가변 arity 메서드&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NullArgumentToVariableArgMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousTernaryOperatorInVarargsCall" defaultSeverity="WARNING" displayName="vararg 메서드 호출 내의심스러운 삼항 연산자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열과 비 배열 브랜치가 혼합된 3항 연산자를 사용하는 vararg 메서드 호출을 보고합니다.
&lt;p&gt;
완료 시 두 개의 브랜치가 배열에 래핑됩니다. 그 결과 배열 브랜치는 2차원 배열로 전환되며 문제가 발생할 가능성이 있습니다.
&lt;/p&gt;
&lt;p&gt;
빠른 수정은 비 배열 브랜치를 배열에 래핑하여, 컴파일러가 변환하지 못하도록 방지합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    static void bar(boolean flag) {
        Object[] a = {1, 2};
        Object b = "hello";
        foo(flag ? a : b);
    }
    static void foo(Object... obj) {
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정 후: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    static void bar(boolean flag) {
        Object[] a = {1, 2};
        Object b = "hello";
        foo(flag ? a : new Object[]{b});
    }
    static void foo(Object... obj) {
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;2020.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;가변 arity 메서드&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousTernaryOperatorInVarargsCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverwrittenKey" defaultSeverity="WARNING" displayName="덮어쓰기한 Map, Set 또는 배열 요소" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;add&lt;/code&gt;/&lt;code&gt;put&lt;/code&gt; 호출의 시퀀스 내 &lt;code&gt;Map&lt;/code&gt; 키, &lt;code&gt;Set&lt;/code&gt; 요소, 배열 요소를 덮어쓰는 코드, 또는 &lt;code&gt;Set.of&lt;/code&gt;(런타임 오류를 발생시킴)와 같은 Java 9 factory 메서드를 사용하는 코드를 보고합니다.
&lt;p&gt;이는 보통 복사-붙여넣기 오류로 발생합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.put("A", 1);
  map.put("B", 2);
  map.put("C", 3);
  map.put("D", 4);
  map.put("A", 5); // 키 'A'가 중복되어 이전에 작성된 항목을 덮어씀
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: OverwrittenKey&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MeaninglessRecordAnnotationInspection" defaultSeverity="WARNING" displayName="의미 없는 레코드 어노테이션" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
의미 없이 레코드 구성 요소에 사용된 어노테이션을 보고합니다.
&lt;p&gt;이는 두 가지 경우에 발생할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;보고된 어노테이션에 METHOD 대상이 있지만 대응하는 접근자가 명시적으로 정의된 경우&lt;/li&gt;
  &lt;li&gt;보고된 어노테이션에 PARAMETER 대상이 있지만 표준 생성자가 명시적으로 정의된 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@Target(ElementType.METHOD)
@interface A { }
  
// 어노테이션은 바이트코드로 표시되지 않습니다
// 해당 어노테이션은 접근자로 전달되어야 하지만 접근자가 명시적으로 정의되었기 때문입니다
record R(@A int x) {
  public int x() { return x; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 16부터 사용할 수 있는 Java 기능 &amp;#39;기록&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MeaninglessRecordAnnotationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstantiationOfUtilityClass" defaultSeverity="WARNING" displayName="유틸리티 클래스의 인스턴스화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;new&lt;/code&gt; 키워드를 사용한 유틸리티 클래스의 인스턴스화를 보고합니다.
&lt;p&gt;
  유틸리티 클래스에서는 모든 필드 및 메서드가 &lt;code&gt;static&lt;/code&gt;입니다.
  그러한 클래스의 인스턴스화는 불필요할 가능성이 높으며 실수를 나타냅니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyUtils {
    public static double cube(double x) {
      return x * x * x;
    }
  }
  class Main {
    public static void main(String[] args) {
      // 유틸리티 클래스의 인스턴스화
      MyUtils utils = new MyUtils();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  유틸리티 클래스가 인스턴스화되는 것을 방지하려면 &lt;code&gt;private&lt;/code&gt; 생성자를 사용하는 것이 좋습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InstantiationOfUtilityClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MathRandomCastToInt" defaultSeverity="WARNING" displayName="'int'로 'Math.random()' 형 변환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;int&lt;/code&gt; 타입으로 즉시 형 변환되는 &lt;code&gt;Math.random()&lt;/code&gt; 호출을 보고합니다. 
&lt;p&gt;&lt;code&gt;0.0&lt;/code&gt;(포함)과 &lt;code&gt;1.0&lt;/code&gt;(제외) 사이의 &lt;code&gt;double&lt;/code&gt;을 &lt;code&gt;int&lt;/code&gt; 타입으로 변환하면 항상 0으로 버림 처리됩니다. 0(포함)과 곱셈 인수(제외) 사이의 값을 얻기 위해 &lt;code&gt;int&lt;/code&gt;로 타입을 변환하기 전에 값을 임의의 인수와 곱해야 합니다.
  다른 가능한 해결책은 &lt;code&gt;java.util.Random&lt;/code&gt;의 &lt;code&gt;nextInt()&lt;/code&gt; 메서드를 사용하는 것입니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;b&gt;int&lt;/b&gt; r = (&lt;b&gt;int&lt;/b&gt;)Math.random() * 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;b&gt;int&lt;/b&gt; r = (&lt;b&gt;int&lt;/b&gt;)(Math.random() * 10);
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MathRandomCastToInt&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousListRemoveInLoop" defaultSeverity="WARNING" displayName="루프 내 의심스러운 'List.remove()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
오름차순 카운트 루프 내부의 &lt;code&gt;list.remove(index)&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  항목 제거 후 목록이 짧아지며 다음 요소를 건너뛰므로 이러한 호출은 의심스럽습니다. 간단한 수정은 제거 후에 색인 변수를 줄이는 것이지만, 반복자를 통해 제거하거나 &lt;code&gt;removeIf()&lt;/code&gt; 메서드(Java 8 이후)를 사용하는 것이 더 강력한 대안압니다.
  &lt;code&gt;remove()&lt;/code&gt;가 루프에서 한 번 이상 호출되지 않을 것으로 기대하는 경우 뒤에 &lt;code&gt;break&lt;/code&gt;를 추가해 보세요.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public static void main(String[] args) {
    process(new ArrayList&amp;lt;&gt;(
      Arrays.asList("1", "2", "|", "3", "4")));
  }

  static void process(List&amp;lt;String&amp;gt; list) {
    for (int i = 0; i &amp;lt; list.size(); i++) {
      if (list.get(i).equals("|")) {
        list.remove(i);
        continue;
      }
      System.out.println(list.get(i));
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드는 &lt;code&gt;1 2 3 4&lt;/code&gt;가 출력될 것처럼 보이지만 실제로는 &lt;code&gt;3&lt;/code&gt;이 출력에서 건너뛰어집니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousListRemoveInLoop&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparableImplementedButEqualsNotOverridden" defaultSeverity="WARNING" displayName="'Comparable'은 구현되었으나 'equals()'가 재정의되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.Comparable&lt;/code&gt;을 구현하지만 &lt;code&gt;equals()&lt;/code&gt;를 재정의하지 않는 클래스를 보고합니다.
&lt;p&gt;
  &lt;code&gt;equals()&lt;/code&gt;가 재정의되지 않은 경우, &lt;code&gt;equals()&lt;/code&gt; 구현이 &lt;code&gt;compareTo()&lt;/code&gt; 구현과 일관되지 않습니다. 그러한 클래스의 객체가 &lt;code&gt;java.util.SortedSet&lt;/code&gt;와 같은 컬렉션에 추가된 경우, 이 컬렉션은 &lt;code&gt;equals()&lt;/code&gt;의 항에 정의된 &lt;code&gt;java.util.Set&lt;/code&gt;의 컨트랙트를 위반합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Length implements Comparable&amp;lt;Length&gt; {
    private int cm = 0;

    @Override
    public int compareTo(@NotNull Length o) {
      if (cm == o.cm) return 0;
      return cm &amp;lt; o.cm ? -1 : 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Length implements Comparable&amp;lt;Length&gt; {
    private int cm = 0;

    @Override
    public int compareTo(@NotNull Length o) {
      if (cm == o.cm) return 0;
      return cm &amp;lt; o.cm ? -1 : 1;
    }

    @Override
    public boolean equals(Object o) {
      return o instanceof Length &amp;&amp; compareTo((Length) o) == 0;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ComparableImplementedButEqualsNotOverridden&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousIndentAfterControlStatement" defaultSeverity="WARNING" displayName="중괄호 없는 제어문 뒤의의심스러운 들여쓰기" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
중괄호 없는 제어문 뒤의 구문의 의심스러운 들여쓰기를 보고합니다.
&lt;p&gt;
  그러한 들여쓰기는 구문이 실제로는 제어문 실행 후 무조건 실행되지만 제어문 내부에 있는 것처럼 보이게 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar {
      void foo(int i) {
          if (i == 0)
              System.out.println("foo");
              System.out.println("bar"); // 경고
          if (i == 1);
              System.out.println("great"); // 경고
          if (i == 42)
              System.out.println("answer");
                  System.out.println("question"); // 경고
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousIndentAfterControlStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousSystemArraycopy" defaultSeverity="WARNING" displayName="의심스러운 'System.arraycopy()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
의심스러운 &lt;code&gt;System.arraycopy()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;그러한 호출은 다음 경우에 의심스럽습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소스 또는 대상이 배열 타입이 아닌 경우
&lt;li&gt;소스 및 대상의 타입이 다른 경우
&lt;li&gt;복사된 청크 길이가 &lt;code&gt;src.length - srcPos&lt;/code&gt;보다 긴 경우
&lt;li&gt;복사된 청크 길이가 &lt;code&gt;dest.length - destPos&lt;/code&gt;보다 긴 경우
&lt;li&gt;소스와 대상이 같은 배열일 때 범위가 항상 교차하는 경우
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo() {
    int[] src = new int[] { 1, 2, 3, 4 };
    System.arraycopy(src, 0, src, 1, 2); // 경고: 범위가 교차하는 같은 배열로 복사
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousSystemArraycopy&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantValue" defaultSeverity="WARNING" displayName="상숫값" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt;과 같이 항상 같은 결과를 도출하는 표현식과 조건을 보고합니다.
이러한 표현식은 해당하는 상숫값으로 대체될 수 있으며, 코드 내에 버그가 있다는 의미일 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  // 항상 true
  // 원인: &amp;&amp; 대신 ||이 사용됨
  if (x &amp;gt; 0 || x &amp;lt; 10) {}

  System.out.println(str.trim());
  // 항상 false
  // 원인: null 검사 전에 변수가 역참조됨
  if (str == null) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;a href="https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html"&gt;null 값 가능성을 표시하는&lt;/a&gt; 어노테이션,
  &lt;code&gt;&lt;a href="https://www.jetbrains.com/help/idea/contract-annotations.html"&gt;@Contract&lt;/a&gt;&lt;/code&gt; 어노테이션, 
  &lt;code&gt;@Range&lt;/code&gt; 어노테이션 등 여러 어노테이션으로 검사 동작을 제어할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;항상 true임이 정적으로 입증된 조건이 포함된 어설션을 보고하지 않음&lt;/b&gt; 옵션을 사용하여 항상 true임이 정적으로 입증된 어설션을 보고하지 않습니다. &lt;code&gt;if (alwaysFalseCondition) throw new IllegalArgumentException();&lt;/code&gt;와 같은 조건도 이에 포함됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;assert 문 무시&lt;/b&gt; 옵션을 사용하여 검사에서 &lt;code&gt;assert&lt;/code&gt; 문이 취급되는 방식을 제어합니다.
    기본적으로 어설션은 실행되는 것으로 간주됩니다(&lt;code&gt;-ea&lt;/code&gt; 모드).
    이 옵션이 활성화되면 어설션이 무시됩니다(&lt;code&gt;-da&lt;/code&gt; 모드).&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;상수가 변수에 저장되면 경고&lt;/b&gt; 옵션을 사용하여 값이 상수로 알려진 변수가 사용되면 경고를 표시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  IntelliJ IDEA 2022.3 이전에 이 검사는 &lt;i&gt;상수 조건 및 예외&lt;/i&gt; 검사의 일부였습니다.
  이 검사는 &lt;i&gt;상숫값&lt;/i&gt;과 &lt;i&gt;Null 가능성 및 데이터 흐름 문제&lt;/i&gt;를 포함한 두 가지 검사로 분할되었습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConstantValue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AssertWithSideEffects" defaultSeverity="WARNING" displayName="부수 효과가 있는 'assert' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">  &lt;html&gt;
&lt;body&gt;
부수효과를 초래하는 &lt;code&gt;assert&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;
  어설션은 해제될 수 있기 때문에 이러한 부수효과가 항상 발생하지는 않으며 이는 미묘한 버그를 일으킬 수 있습니다. 이 검사에서 흔히 탐지되는 바람직하지 않은 부수 효과는 변수 및 필드의 변경입니다. 메서드 호출이 포함된 경우 1단계 깊이 분석됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assert i++ &amp;lt; 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;이 검사는 Java 1.4부터 사용할 수 있는 Java 기능 &amp;#39;어설션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AssertWithSideEffects&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ComparatorResultComparison" defaultSeverity="WARNING" displayName="compare 메서드의 의심스러운 사용 위치" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
0이 아닌 상수를 포함하는 &lt;code&gt;Comparator.compare()&lt;/code&gt; 또는 &lt;code&gt;Comparable.compareTo()&lt;/code&gt; 호출의 결과 비교를 보고합니다.
컨트랙트에 따라 이러한 메서드는 -1, 0 또는 1이 아닌 정수만 반환할 수 있으므로 특정 숫자와 비교하는 것은 좋지 않은 방법입니다. 널리 사용되는 일부 비교 메서드(예: &lt;code&gt;String.compareTo()&lt;/code&gt;)는 실제로 [-1..1] 범위 밖의 값을 반환하며, 이렇게 비교할 경우 잘못된 프로그램 동작이 발생할 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void validate(String s1, String s2) {
    // 1에 대한 비교는 잘못됨.
    if (s1.compareTo(s2) == 1) {
      throw new IllegalArgumentException("Incorrect order");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void validate(String s1, String s2) {
    if (s1.compareTo(s2) &gt; 0) {
      throw new IllegalArgumentException("Incorrect order");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ComparatorResultComparison&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CopyConstructorMissesField" defaultSeverity="WARNING" displayName="복사 생성자에 필드가 누락됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스의 모든 필드를 복사하지 않는 복사 생성자를 보고합니다.
&lt;p&gt;
  이니셜라이저가 있는 &lt;code&gt;final&lt;/code&gt; 필드 및 &lt;code&gt;transient&lt;/code&gt; 필드는 복사할 필요가 없는 것으로 간주됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Point {

    private int x;
    private int y;

    Point(int x, int y) {
      this.x = x;
      this.y = y;
    }

    Point(Point other) {
      // 필드 x 및 y가 초기화되지 않았습니다
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CopyConstructorMissesField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceofIncompatibleInterface" defaultSeverity="WARNING" displayName="호환되지 않는 타입이 있는 'instanceof'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
검사된 식에 &lt;code&gt;instanceof&lt;/code&gt; 식의 오른쪽에 있는 클래스/인터페이스 타입을 확장/구현하지 않고 하위 클래스가 없는 클래스/인터페이스 타입이 있는 &lt;code&gt;instanceof&lt;/code&gt; 식을 보고합니다.
&lt;p&gt;
  라이브러리 코드로 의도되긴 하였으나 프로젝트에서 선언된 클래스의 어떠한 인스턴스도 &lt;code&gt;instanceof&lt;/code&gt; 테스트를 통과할 수 없기 때문에 이러한 구조는 오류를 일으키기 쉽습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo { }

  interface Bar { }
  
  class Main {
      void test(Foo f, Bar b) {
          if (f instanceof Bar) { // 문제
              System.out.println("fail");
          }
          if (b instanceof Foo) { // 문제
              System.out.println("fail");
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: InstanceofIncompatibleInterface&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IteratorHasNextCallsIteratorNext" defaultSeverity="WARNING" displayName="'next()'를 호출하는 'Iterator.hasNext()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
반복자 인스턴스에서 &lt;code&gt;Iterator.next()&lt;/code&gt; 또는 &lt;code&gt;ListIterator.previous()&lt;/code&gt;를 호출하는 &lt;code&gt;Iterator.hasNext()&lt;/code&gt; 또는 &lt;code&gt;ListIterator.hasPrevious()&lt;/code&gt; 구현을 보고합니다. &lt;code&gt;hasNext()&lt;/code&gt;와 같은 메서드는 반복자 상태를 수정하면 안 되는 반면 &lt;code&gt;next()&lt;/code&gt;는 수정해야 하므로 그러한 호출은 오류입니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyIterator implements Iterator&amp;lt;Integer&amp;gt; {
    public boolean hasNext() {
      return next() != null;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IteratorHasNextCallsIteratorNext&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CapturingCleaner" defaultSeverity="WARNING" displayName="Cleaner는 객체 참조를 캡처합니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
등록되어 있는 참조를 캡처하는 &lt;code&gt;Cleaner.register()&lt;/code&gt;에 전달된 &lt;code&gt;Runnable&lt;/code&gt;을 보고합니다.
참조가 캡처되면 도달할 수 없는 팬텀이 되며 정리 액션이 호출되지 않습니다.
&lt;p&gt;이 문제의 가능한 원인은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;static이 아닌 메서드, 필드 또는 &lt;code&gt;this&lt;/code&gt; 자체를 사용하는 람다&lt;/li&gt;
  &lt;li&gt;버전 18까지의 Java에서 static이 아닌 내부 클래스(익명 여부 무관)는 항상 이 참조를 캡처합니다&lt;/li&gt;
  &lt;li&gt;인스턴스 메서드 참조&lt;/li&gt;
  &lt;li&gt;static이 아닌 내부 클래스에서 외부 클래스의 static이 아닌 멤버로 액세스하는 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;보고되는 코드 샘플: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int fileDescriptor;
  Cleaner.Cleanable cleanable = Cleaner.create().register(this, () -&gt; {
    System.out.println("adsad");
    //&lt;i&gt;this&lt;/i&gt;는 &lt;i&gt;fileDescriptor&lt;/i&gt;를 통해 캡처됩니다
    fileDescriptor = 0;
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 9 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2018.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CapturingCleaner&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsBetweenInconvertibleTypes" defaultSeverity="WARNING" displayName="변환할 수 없는 타입의 객체 간의 'equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대상과 인수의 유형이 호환되지 않는 &lt;code&gt;equals()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;그러한 호출은 이론적으로 유용할 수 있으나 버그일 가능성이 높습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new HashSet&amp;lt;String&amp;gt;().equals(new TreeSet&amp;lt;Integer&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EqualsBetweenInconvertibleTypes&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InconsistentTextBlockIndent" defaultSeverity="WARNING" displayName="텍스트 블록의 일관되지 않은 공백 들여쓰기" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
공백과 탭 문자를 모두 사용하여 들여쓰기된 텍스트 블록을 보고합니다.
javac의 텍스트 블록 처리에서는 공백과 탭을 동일하게 취급하기 때문에 이러한 들여쓰기는 예상치 못한 결과를 발생시킬 수 있습니다.
&lt;p&gt;다음 예시에서 공백 및 탭은 각각 &lt;code&gt;·&lt;/code&gt; 및 &lt;code&gt;␉&lt;/code&gt;로 표시되며 에디터에서 탭 1개는 공백 2개와 동일합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
String colors = """
····red
␉ ␉ green
····blue""";
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이러한 문자열을 출력한 후 결과는 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
··red
green
··blue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;컴파일러가 각 줄의 시작 부분에서 동일한 수의 공백 문자를 제거한 후에도
일부 줄에는 선행 공백이 남아 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 15부터 사용할 수 있는 Java 기능 &amp;#39;텍스트 블록 리터럴&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: InconsistentTextBlockIndent&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalGetWithoutIsPresent" defaultSeverity="WARNING" displayName="isPresent() 검사 없이 Optional.get()이 호출됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Optional&lt;/code&gt;에 값이 있는지 확인하지 않고 &lt;code&gt;get()&lt;/code&gt;을 호출하는 경우를 보고합니다.
&lt;p&gt;빈 &lt;code&gt;Optional&lt;/code&gt; 인스턴스에서 &lt;code&gt;Optional.get()&lt;/code&gt;을 호출하면 예외가 발생합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; x(List&amp;lt;Integer&gt; list) {
    &lt;b&gt;final&lt;/b&gt; Optional&amp;lt;Integer&gt; optional =
      list.stream().filter(x -&gt; x &gt; 10).findFirst();
    &lt;b&gt;final&lt;/b&gt; Integer result = optional.get(); // 문제 발생
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;스트림 및 선택적 API&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: OptionalGetWithoutIsPresent&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayEquality" defaultSeverity="WARNING" displayName="'Arrays.equals()' 대신 '=='를 사용하여 배열 비교" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열의 상등 관계를 테스트하기 위해 사용된 연산자 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt;를 보고합니다.
대부분의 경우 배열 내용의 상등 관계 테스트는 의도된 것으로, &lt;code&gt; java.util.Arrays.equals()&lt;/code&gt; 메서드를 사용하여 실행할 수 있습니다.
&lt;p&gt;
  빠른 수정은 &lt;code&gt;==&lt;/code&gt;를 &lt;code&gt;java.util.Arrays.equals()&lt;/code&gt;로 바꿀 것을 제안합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object[] x, Object[] y) {
    boolean comparison = x == y;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object[] x, Object[] y) {
    boolean comparison = Arrays.equals(x, y);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ArrayEquality&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MismatchedStringCase" defaultSeverity="WARNING" displayName="'String' 연산에서 일치하지 않는 case" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대문자만 포함된 문자열에서 소문자를 검색하거나 그 반대로 검색하기 때문에 항상 같은 값(&lt;code&gt;-1&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt;)을 반환하는 &lt;code&gt;String&lt;/code&gt; 메서드 호출을 보고합니다.
&lt;p&gt;보고된 메서드에는 &lt;code&gt;equals&lt;/code&gt;, &lt;code&gt;startsWith&lt;/code&gt;, &lt;code&gt;endsWith&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt;, &lt;code&gt;indexOf&lt;/code&gt; 및 &lt;code&gt;lastIndexOf&lt;/code&gt;가 포함됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
  if (columnName.toLowerCase().equals("ID")) {...}
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MismatchedStringCase&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IterableUsedAsVararg" defaultSeverity="WARNING" displayName="Iterable이 가변인수로 사용됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
vararg 메서드 호출에서 &lt;code&gt;Collection&lt;/code&gt; 또는 &lt;code&gt;Iterable&lt;/code&gt;이 의심스럽게 사용된 위치를 보고합니다.
&lt;p&gt;예를 들어, 다음 메서드의 경우에 보고됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;T&amp;gt; boolean contains(T needle, T... haystack) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음과 같은 호출은&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if(contains("item", listOfStrings)) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;목록이 단일 요소 배열로 래핑되므로 의심스럽게 보입니다.
  이 코드의 컴파일이 완료되어 예외 없이 실행될 수 있지만
  실수로 사용되었을 가능성이 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;가변 arity 메서드&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IterableUsedAsVararg&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringEqualsCharSequence" defaultSeverity="WARNING" displayName="'CharSequence'인수로 'String.equals()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;CharSequence&lt;/code&gt;가 인수로 사용된 &lt;code&gt;String.equals()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  &lt;code&gt;String.equals()&lt;/code&gt;는 &lt;code&gt;String&lt;/code&gt; 인수에 대해서만 &lt;code&gt;true&lt;/code&gt;를 반환할 수 있습니다.
  &lt;code&gt;String&lt;/code&gt;을 내용을 &lt;code&gt;String&lt;/code&gt;이 아닌 &lt;code&gt;CharSequence&lt;/code&gt; 인수와 비교하려면 &lt;code&gt;contentEquals()&lt;/code&gt; 메서드를 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean equals(String s, CharSequence ch) {
    return s.equals(ch);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean equals(String s, CharSequence ch) {
    return s.contentEquals(ch);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;small&gt;2017.3의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringEqualsCharSequence&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExpressionComparedToItself" defaultSeverity="WARNING" displayName="표현식이 자신과 비교됩니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
좌측과 우측 피연산자가 같은 표현식인 비교식을 보고합니다.
표현식을 자신과 비교하는 것이 의도된 것일 때도 있지만, 대부분의 경우 실수입니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 의도는 left.getLength() == right.getLength()이었을 수 있음
  boolean result = left.getLength() == left.getLength();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  부수 효과를 생성할 수 있는 비교를 무시하려면, &lt;b&gt;부수 효과가 있는 조건 무시&lt;/b&gt; 옵션을 사용하세요.
이 옵션을 비활성화하면 예를 들어 같은 메서드가 후속 호출에 따라 다른 값을 반환하는 경우와 같이 거짓 양성으로 이어질 수 있습니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  native int unknownMethod();
  
  ...
  
  if (unknownMethod() &amp;gt; unknownMethod()) {
    System.out.println("Got it");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;unknownMethod()&lt;/code&gt;의 잠재적인 부수 효과(예시) 때문에 &lt;b&gt;부수 효과가 있는 조건 무시&lt;/b&gt; 옵션이 비활성화된 경우에만 경고가 트리거됩니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2024.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExpressionComparedToItself&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InfiniteRecursion" defaultSeverity="WARNING" displayName="무한 재귀" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
예외가 던져지지 않는 한 자신을 무한으로 호출하는 메서드를 보고합니다.
&lt;p&gt;
  이 검사에서 보고된 메서드는 정상적으로 반환할 수 없습니다.
  그러한 동작은 의도된 것일 수 있으나 많은 경우에 실수입니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  int baz() {
      return baz();
  }&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: InfiniteRecursion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticCallOnSubclass" defaultSeverity="WARNING" displayName="static 메서드가 하위 클래스를 통해 참조됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
호출이 선언하는 클래스 자체에 의해서가 아니라 하위 클래스에 의해 한정된 정적 메서드 호출을 보고합니다.
&lt;p&gt;
  Java는 그러한 클래스 정규화를 허용하지만 그러한 호출은 상속과 재정의가 미묘하게 혼동되고 있음을 나타낼 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    public static void print(String str) {}
  }
  class Child extends Parent {}

  Child.print("Hello, world!");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Parent.print("Hello, world!");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: StaticCallOnSubclass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenationInFormatCall" defaultSeverity="WARNING" displayName="'format()' 호출에 대한 인수로서의 문자열 연결" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
서식 문자열 인수로 사용된, 상수가 아닌 문자열 연결을 보고합니다.
&lt;p&gt;
  의도된 경우도 있으나 보통 서식 지정 메서드를 잘못 사용한 것이며 연결된 문자열에서 사용된 변수가 &lt;code&gt;%&lt;/code&gt;와 같은 특수문자를 포함하는 경우 예기치 않은 예외가 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  또한 이는 &lt;code&gt;,&lt;/code&gt;가 필요한 곳에 &lt;code&gt;+&lt;/code&gt;를 입력하여 문자열 서식의 인수를 잘못 연결한 결과일 때도 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static String formatGreeting(String userName) {
    return String.format("Hello, " + userName);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  여기서 &lt;code&gt;userName&lt;/code&gt;은 서식 문자열의 일부로 해석됩니다. 이 때문에 &lt;code&gt;IllegalFormatException&lt;/code&gt;(예: &lt;code&gt;userName&lt;/code&gt;이 &lt;code&gt;'%'&lt;/code&gt;인 경우)이 발생하거나 거대한 양의 메모리를 사용(예: &lt;code&gt;userName&lt;/code&gt;이 &lt;code&gt;'%2000000000%'&lt;/code&gt;인 경우)할 수 있습니다.
  이 호출은 &lt;code&gt;String.format("Hello, %s", userName);&lt;/code&gt;과 같이 바꿔야 합니다.
&lt;/p&gt;
&lt;p&gt;
  이 검사는 &lt;code&gt;java.util.Formatter&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;, &lt;code&gt;java.io.PrintWriter&lt;/code&gt; 또는 &lt;code&gt;java.io.PrintStream&lt;/code&gt;의 서식 지정 메서드 호출을 검사합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringConcatenationInFormatCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsOnSuspiciousObject" defaultSeverity="WARNING" displayName="'equals()'가 이를 재정의하지 않는 클래스에서 호출됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;StringBuilder&lt;/code&gt;, &lt;code&gt;StringBuffer&lt;/code&gt; 및 &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; 패키지의 인스턴스에서 &lt;code&gt;equals()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;해당 클래스에서 &lt;code&gt;equals()&lt;/code&gt; 메서드는 재정의되지 않으므로 두 객체의 내용이 동일한 경우에도 &lt;code&gt;false&lt;/code&gt;를 반환할 수 있습니다.
  의도한 참조 동등성이라면 &lt;code&gt;==&lt;/code&gt;를 사용하여 혼동을 피하는 것이 좋습니다.&lt;/p&gt;
&lt;code&gt;StringBuilder&lt;/code&gt;, &lt;code&gt;StringBuffer&lt;/code&gt;, &lt;code&gt;AtomicBoolean&lt;/code&gt;,
&lt;code&gt;AtomicInteger&lt;/code&gt;, &lt;code&gt;AtomicBoolean&lt;/code&gt; 및 &lt;code&gt;AtomicLong&lt;/code&gt;에 대한 빠른 수정을 사용하여 내용 비교로 변환할 수 있습니다.
이 빠른 수정은 인스턴스 중 하나가 null일 경우 의미를 바꿀 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void test(StringBuilder sb1, StringBuilder sb2) {
    boolean result = sb1.equals(sb2); // Suspicious
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void test(StringBuilder sb1, StringBuilder sb2) {
      boolean result = sb1.toString().equals(sb2.toString());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EqualsOnSuspiciousObject&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectToString" defaultSeverity="WARNING" displayName="디폴트 값 'toString()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.Object&lt;/code&gt;의 기본 구현을 사용하는 &lt;code&gt;toString()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;디폴트 구현은 의도적으로 사용되는 경우는 드물지만 실수로 사용될 수 있습니다.&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;java.lang.Object&lt;/code&gt; 인터페이스 또는 추상 클래스 타입의 객체에서 &lt;code&gt;toString()&lt;/code&gt;을 호출하는 경우는 이 검사에서 무시됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar {
      void foo1(Bar bar) {
          String s = bar.toString(); // 경고
          /* ... */
      }

      void foo2(Object obj) {
          String s = obj.toString(); // 경고 없음
          /* ... */
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ObjectToString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IgnoreResultOfCall" defaultSeverity="WARNING" displayName="메서드 호출의 결과가 무시됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
결과가 무시되는 메서드 호출을 보고합니다.
&lt;p&gt;대부분의 메서드에서 결과를 무시하는 것은 올바르지만 일부는 거의 틀림없는 오류입니다. 결과 무시가 오류일 가능성이 있는 메서드의 예로는 실제로 읽은 바이트 개수를 반환하는 &lt;code&gt;java.io.inputStream.read()&lt;/code&gt;, 및 &lt;code&gt;java.lang.String&lt;/code&gt; 또는 &lt;code&gt;java.math.BigInteger&lt;/code&gt;의 모든 메서드가 포함됩니다. 이러한 메서드는 부수 효과를 일으키지 않으므로 결과를 무시해도 무의미합니다.
&lt;/p&gt;
&lt;p&gt;다음 메서드 호출이 검사됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;단순한 getter(필드 반환 이외의 동작 없음)&lt;/li&gt;
  &lt;li&gt;이 검사의 설정에 지정된 메서드&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.jetbrains.annotations.Contract(pure=true)&lt;/code&gt; 어노테이션이 추가된 메서드&lt;/li&gt;
  &lt;li&gt;.*.&lt;code&gt;CheckReturnValue&lt;/code&gt; 어노테이션이 추가된 메서드&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.CheckReturnValue&lt;/code&gt; 어노테이션이 추가된 클래스 또는 패키지 내 메서드&lt;/li&gt;
  &lt;li&gt;모든 비 라이브러리 메서드(선택)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Error Prone 또는 AssertJ의 &lt;code&gt;@CanIgnoreReturnValue&lt;/code&gt; 어노테이션이 추가된 메서드에 대한 호출은 보고되지 않습니다.

&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 설정을 사용하여 검사할 클래스를 지정하세요.
  메서드는 Java 정규 표현식 구문을 사용한 이름 또는 이름 패턴으로 대조됩니다.
  클래스의 경우 정규화된 이름을 사용하세요. 각 항목은 클래스 및 모든 상속자에 적용됩니다.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: IgnoreResultOfCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectEquality" defaultSeverity="INFORMATION" displayName="'equals()' 대신 '=='를 사용하여 객체 비교" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  객체 상등성을 테스트하기 위해 &lt;code&gt;equals()&lt;/code&gt; 대신 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt;를 사용하는 코드를 보고합니다.
&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt;를 사용하여 객체를 비교하는 것은 상등성이 아닌 ID로 객체를 비교하기 때문에 보통 버그입니다.
  &lt;code&gt;null&lt;/code&gt;과의 비교는 보고되지 않습니다.
&lt;/p&gt;
&lt;p&gt;
  배열, &lt;code&gt;String&lt;/code&gt; 및 &lt;code&gt;Number&lt;/code&gt; 비교는 별도의 검사에서 보고됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;b&gt;if&lt;/b&gt; (list1 == list2) {
    &lt;b&gt;return&lt;/b&gt;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;b&gt;if&lt;/b&gt; (Objects.equals(list1, list2)) {
    &lt;b&gt;return&lt;/b&gt;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 설정을 사용하여 이 검사에 대한 예외를 구성하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ObjectEquality&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousDateFormat" defaultSeverity="WARNING" displayName="의심스러운 날짜 형식 패턴" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
실수로 사용되었을 가능성이 있는 날짜 형식 패턴을 보고합니다.
&lt;p&gt;다음과 같은 패턴이 보고됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;'w'가 근처에 없는 대문자 'Y'를 보고합니다. 이는 일반 'Year'(소문자 'y' 패턴)와 마찬가지로 거의 항상 'Week year'를 의미하지만 12월의 끝에 다음 년도를 가리킬 수 있습니다.&lt;/li&gt;
  &lt;li&gt;'H', 'K', 'h', 'k'(시간)에 가까운 대문자 'M'(월)을 보고합니다. 이는 소문자 'm'(분)을 의도한 것일 수 있습니다.&lt;/li&gt;
  &lt;li&gt;'y'(연도) 또는 'd'(월의 일)와 가까운 소문자 'm'(분)을 보고합니다. 대문자 'M'(월)을 의도한 것일 수 있습니다.&lt;/li&gt;
  &lt;li&gt;'M' 또는 'L'(월)과 가까운 대문자 'D'(년의 일)를 보고합니다. 이는 소문자 'd'(월의 일)를 의도한 것일 수 있습니다.&lt;/li&gt;
  &lt;li&gt;'m'(분)과 가까운 대문자 'S'(밀리초)를 보고합니다. 이는 소문자 's'(초)를 의도한 것일 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  예:&lt;br&gt;
  &lt;code&gt;new SimpleDateFormat("YYYY-MM-dd")&lt;/code&gt;: &lt;code&gt;"yyyy-MM-dd"&lt;/code&gt;를 의도한 것일 수 있습니다.&lt;br&gt;
  &lt;code&gt;new SimpleDateFormat("yyyy-MM-DD")&lt;/code&gt;: &lt;code&gt;"yyyy-MM-dd"&lt;/code&gt;를 의도한 것일 수 있습니다.&lt;br&gt;
  &lt;code&gt;new SimpleDateFormat("HH:MM")&lt;/code&gt;: &lt;code&gt;"HH:mm"&lt;/code&gt;을 의도한 것일 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousDateFormat&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenationInMessageFormatCall" defaultSeverity="WARNING" displayName="'MessageFormat.format()' 호출에 대한 인수로서의 문자열 연결" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;MessageFormat.format()&lt;/code&gt;을 호출하기 위한 인수로 사용된 상수가 아닌 문자열 연결을 보고합니다.
&lt;p&gt;
  의도된 경우도 있으나 보통 서식 지정 메서드를 잘못 사용한 것이며 연결된 문자열에서 사용된 변수가 &lt;code&gt; {&lt;/code&gt;와 같은 특수문자를 포함할 경우 예기치 않은 예외가 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  또한 이는 &lt;code&gt;,&lt;/code&gt;가 필요한 곳에 &lt;code&gt;+&lt;/code&gt;를 입력하여 문자열 서식의 인수를 잘못 연결한 결과일 때도 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String formatGreeting(String userName, int balance) {
    return MessageFormat.format("Hello, " + userName + "! Your balance is {0}.", balance);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  여기서 &lt;code&gt;userName&lt;/code&gt;은 서식 문자열의 일부로 해석되며 이 때문에 &lt;code&gt;IllegalArgumentException&lt;/code&gt;(예: &lt;code&gt;userName&lt;/code&gt;이 &lt;code&gt;"{"&lt;/code&gt;인 경우)이 발생할 수 있습니다.
  이 호출은 &lt;code&gt;MessageFormat.format("Hello, {0}! Your balance is {1}.", userName, balance)&lt;/code&gt;로 바꿔야 합니다.   
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: StringConcatenationInMessageFormatCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CollectionAddedToSelf" defaultSeverity="WARNING" displayName="컬렉션이 컬렉션 자신에게 추가됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Collection&lt;/code&gt; 또는 &lt;code&gt;java.util.Map&lt;/code&gt;의 메서드 호출 인수가 컬렉션 또는 맵 자체인 경우를 보고합니다.
해당 상황은 복사 및 붙여넣기의 결과로 원시 타입이 있는 코드에서 발생할 수 있습니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ArrayList list = new ArrayList&amp;lt;&amp;gt;();
  list.add(list); // 여기에서 경고 발생
  return list.hashCode(); // StackOverflowError를 던집니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CollectionAddedToSelf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfPropertiesAsHashtable" defaultSeverity="WARNING" displayName="'프로퍼티' 객체를 '해시테이블'로 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Properties&lt;/code&gt; 객체에서 다음 메서드를 호출하는 경우를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;putIfAbsent()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;putAll()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  역사적인 이유로 &lt;code&gt;java.util.Properties&lt;/code&gt;는 &lt;code&gt;java.util.Hashtable&lt;/code&gt;을 상속받지만 &lt;code&gt;String&lt;/code&gt; 외의 타입을 가진 프로퍼티 값의 손상을 방지하기 위해 그러한 메서드는 사용하지 않는 것이 좋습니다.
&lt;/p&gt;
&lt;p&gt;
  맵 내의 키와 값 매개변수가 모두 &lt;code&gt;String&lt;/code&gt; 타입인 경우 &lt;code&gt;java.util.Properties.putAll()&lt;/code&gt; 호출은 보고되지 않습니다.
  이러한 호출은 안전하며 더 나은 대안이 없습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object f(Properties props) {
    props.put("hello", "world");
    props.putIfAbsent("hello", "world");
    props.putAll(new HashMap&amp;lt;&amp;gt;());
    return props.get("Hello");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object f(Properties props) {
    props.setProperty("hello", "world");
    props.putIfAbsent("hello", "world");
    props.putAll(new HashMap&amp;lt;&amp;gt;());
    return props.getProperty("hello");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UseOfPropertiesAsHashtable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsWhichDoesntCheckParameterClass" defaultSeverity="WARNING" displayName="매개변수의 클래스를 확인하지 않는 'equals()' 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 매개변수의 타입을 검사하지 않는 &lt;code&gt;equals()&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;&lt;code&gt;equals()&lt;/code&gt; 메서드 내 매개변수 타입 검사에 실패하면 객체가 타입이 지정되지 않은 객체에서 사용되는 경우 잠재적 오류가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    int x;
    
    @Override
    public boolean equals(Object obj) {
      // obj이 MyClass가 아닌 경우 equals 메서드는 false를 반환해야 합니다
      return ((MyClass)obj).x == x;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EqualsWhichDoesntCheckParameterClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitArrayToString" defaultSeverity="WARNING" displayName="배열의 'toString()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;String&lt;/code&gt; 연결에 사용되거나 &lt;code&gt;System.out.println()&lt;/code&gt;과 같은 &lt;code&gt;java.io.PrintStream&lt;/code&gt; 메서드에 매개변수로 전달된 배열을 보고합니다.
&lt;p&gt;
  보통 배열 객체 자신이 아닌 배열의 내용이 사용되어야 합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Object[] objects) {
    System.out.println(objects);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Object[] objects) {
    System.out.println(Arrays.toString(objects));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ImplicitArrayToString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WrongPackageStatement" defaultSeverity="ERROR" displayName="잘못된 package 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
프로젝트 디렉터리 구조를 준수하지 않는 &lt;code&gt;package&lt;/code&gt; 문을 탐지합니다.
또한 클래스가 소스 루트 디렉터리에 직접 위치하지 않는 경우 &lt;code&gt;package&lt;/code&gt; 문이 없는 클래스를 보고합니다.
&lt;p&gt;Java 언어에는 엄격하게 규정되어 있지 않지만, 소스 루트 바로 아래에 있는 &lt;code&gt;com/example/myapp&lt;/code&gt; 디렉터리에 &lt;code&gt;com.example.myapp&lt;/code&gt; 패키지의 클래스를 보관하는 것이 좋습니다. 그러지 않으면 코드를 읽는 데 혼동이 생겨 일부 도구가 잘못 작동할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: WrongPackageStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncorrectMessageFormat" defaultSeverity="WARNING" displayName="잘못된 'MessageFormat' 패턴" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;!-- Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license. --&gt;
&lt;html&gt;
&lt;body&gt;
잘못된 메시지 형식 패턴이나 자리표시자의 잘못된 색인을 보고합니다
&lt;p&gt;다음과 같은 오류가 보고됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;분석되지 않았거나 음수인 색인&lt;/li&gt;
  &lt;li&gt;닫히지 않은 중괄호&lt;/li&gt;
  &lt;li&gt;짝이 없는 따옴표. 이 경우 패턴의 일부가 사용되지 않을 수 있습니다&lt;/li&gt;
  &lt;li&gt;따옴표의 개수가 잘못되었을 수 있습니다&lt;/li&gt;
  &lt;li&gt;중첩 choice 패턴의 하위 바운드가 잘못되었습니다&lt;/li&gt;
  &lt;li&gt;자리표시자의 색인이 잘못되었습니다. 이 경우 자리표시자가 대체되지 않거나 인수가 사용되지 않을 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  MessageFormat.format("{wrong}", 1); // 색인이 잘못됨
  MessageFormat.format("{0", 1); // 중괄호의 짝이 없음
  MessageFormat.format("'{0}", 1); // 따옴표의 짝이 없음
  MessageFormat.format("It''''s {0}", 1); // 'It's' 대신 'It''s'가 출력됨
  MessageFormat.format("{0}", 1, 2); // 패턴에서 색인이 '1'인 인수는 사용되지 않음
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;사용자 지정 MessageFormat 메서드&lt;/b&gt; 테이블을 사용하여 인수가 MessageFormat 패턴으로 확인되어야 하는 메서드 호출을 지정하세요.
  테이블에는 포함하는 클래스와 메서드 호출의 이름을 일치시키기 위한 완전히 정규화된 클래스 이름과 메서드 이름 정규식의 쌍이 포함되어 있습니다.
  클래스 이름은 하위 클래스와도 일치합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2023.2의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IncorrectMessageFormat&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassNewInstance" defaultSeverity="WARNING" displayName="안전하지 않은 'Class.newInstance()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.Class.newInstance()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  이 메서드는 검사된 예외를 포함하여 인수 없이 생성자를 통해 던져진 예외를 전달합니다. 이 메서드를 사용하면 컴파일러에 의해 실행되는 컴파일 타임 예외 검사를 효율적으로 우회할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  이 호출을 &lt;code&gt;java.lang.reflect.Constructor.newInstance()&lt;/code&gt; 메서드 호출로 바꾸는 빠른 수정이 제안됩니다. 이를 적용하면 (검사된) &lt;code&gt;java.lang.reflect.InvocationTargetException&lt;/code&gt;의 생성자에 의해 던져진 모든 예외를 래핑하여 이러한 문제를 피할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  clazz.newInstance()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  clazz.getConstructor().newInstance();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ClassNewInstance&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousNameCombination" defaultSeverity="WARNING" displayName="의심스러운 변수/매개변수 이름 조합" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대상 변수 또는 함수 매개변수의 이름이 대입된 값의 이름과 일치하지 않는 대입 또는 함수 호출을 보고합니다.
&lt;p&gt;예시 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;int&lt;/b&gt; x = 0;
  &lt;b&gt;int&lt;/b&gt; y = x; // x는 y 좌표로 사용됩니다
  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예시 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;int&lt;/b&gt; x = 0, y = 0;
  // x는 y 좌표로, y는 x 좌표로 사용됩니다
  Rectangle rc = &lt;b&gt;new&lt;/b&gt; Rectangle(y, x, 20, 20);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;&lt;b&gt;이름 그룹&lt;/b&gt; 영역을 사용하여 함께 사용할 수 없는 이름을 지정합니다. 매개변수 이름 또는 대입 대상 이름에 한 그룹의 단어가 포함되어 있으나 대입된 변수 또는 전달된 변수의 이름에는 다른 그룹의 단어가 포함되어 있는 경우 오류를 보고합니다.
&lt;p&gt;&lt;b&gt;메서드 무시&lt;/b&gt; 영역을 사용하여 검사하지 않으나 잠재적으로 의심스러운 이름을 가진 메서드를 지정합니다.
예를 들어, &lt;code&gt;Integer.compare()&lt;/code&gt; 매개변수의 이름이 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt;로 지정되었으나 좌표와 관련이 없을 수 있습니다.
&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousNameCombination&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IteratorNextDoesNotThrowNoSuchElementException" defaultSeverity="WARNING" displayName="'NosuchElementException'을 던질 수 없는 'Iterator.next()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.NoSuchElementException&lt;/code&gt;을 던지지 않는 &lt;code&gt;Iterator.next()&lt;/code&gt;의 구현을 보고합니다.
&lt;p&gt;
  그러한 구현은 &lt;code&gt;java.util.Iterator&lt;/code&gt;의 컨트랙트를 위반하며 반복자가 표준이 아닌 방식으로 사용되는 경우 탐지하기 어려운 버그를 초래할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Numbers implements Iterator&amp;lt;Integer&amp;gt; {
    @Override
    public Integer next() { // 경고
        if (hasNext()) {
            return generateNext();
        } else {
            return null; // 대신 NoSuchElementException을 던져야 합니다
        }
    }

    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IteratorNextDoesNotThrowNoSuchElementException&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsWithItself" defaultSeverity="WARNING" displayName="자신에서 'equals()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
객체와 자신의 상등성을 비교하는 &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;compareTo()&lt;/code&gt; 또는 이와 유사한 호출을 보고합니다.
이러한 메서드의 메서드 컨트랙트는 이러한 호출이 &lt;code&gt;true&lt;/code&gt;(&lt;code&gt;equals()&lt;/code&gt; 호출 시) 또는 &lt;code&gt;0&lt;/code&gt;(&lt;code&gt;compareTo()&lt;/code&gt; 호출 시)을 항상 반환하도록 지정합니다.
이 검사는 &lt;code&gt;Objects.equals()&lt;/code&gt;, &lt;code&gt;Objects.deepEquals()&lt;/code&gt;,
&lt;code&gt;Arrays.equals()&lt;/code&gt;, &lt;code&gt;Comparator.compare()&lt;/code&gt;, 테스트 프레임워크(JUnit, TestNG, AssertJ)의 &lt;code&gt;assertEquals()&lt;/code&gt; 메서드, &lt;code&gt;Integer.compare()&lt;/code&gt;, &lt;code&gt;Integer.compareUnsigned()&lt;/code&gt; 및 유사한 메서드의 호출도 검사합니다.
&lt;p&gt;
  매우 드물게 양쪽의 표현식이 같으나 별도의 객체를 생성하고 콘텐츠가 아닌 참조를 바탕으로 비교가 이뤄지므로, 검사가 false를 반환하는 &lt;code&gt;equals()&lt;/code&gt; 호출을 보고할 수 있습니다. 
  가장 간단한 예시는 &lt;code&gt;new Object().equals(new Object())&lt;/code&gt;입니다. 어떠한 경우든 이러한 호출은 의심스러우며 다른 의도였을 수 있습니다. 
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    boolean foo(Object o) {
        return o.equals(o); // 경고
    }

    boolean bar(String[] ss) {
        return Arrays.equals(ss, ss); // 경고
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EqualsWithItself&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InnerClassReferencedViaSubclass" defaultSeverity="WARNING" displayName="내부 클래스가 하위 클래스를 통해 참조됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
호출이 선언하는 클래스 자신이 아니라 하위 클래스에 의해 정규화된 내부 클래스 및 중첩 클래스로의 액세스를 보고합니다.
&lt;p&gt;
  Java는 그러한 정규화를 허용하지만 그러한 액세스는 상속과 재정의가 미묘하게 혼동되고 있음을 나타낼 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    static class Inner {}
  }

  class Sub extends Super {
    void test() {
      Sub.Inner s = new Sub.Inner(); // 'Inner' 클래스가 'Super' 클래스에서 선언되었으나 'Sub' 클래스를 통해 참조됩니다
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    static class Inner {}
  }

  class Sub extends Super {
    void test() {
      Super.Inner s = new Super.Inner();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: InnerClassReferencedViaSubclass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InvalidComparatorMethodReference" defaultSeverity="WARNING" displayName="'Comparator'에 잘못된 메서드 참조가 사용됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
컨트랙트를 충족하지 않는 &lt;code&gt;Comparator&lt;/code&gt; 인터페이스에 매핑된 메서드 참조를 보고합니다.
&lt;p&gt;
&lt;code&gt;Integer::max&lt;/code&gt;와 같은 일부 메서드 참조는 &lt;code&gt;Comparator&lt;/code&gt; 인터페이스에 매핑될 수 있습니다.
그러나 &lt;code&gt;Comparator&lt;/code&gt;로 사용하는 것은 무의미하며 결과 예측이 어려울 수 있습니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ArrayList&amp;lt;Integer&amp;gt; ints = foo();
  ints.sort(Math::min);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ArrayList&amp;lt;Integer&amp;gt; ints = foo();
  ints.sort(Comparator.reverseOrder());
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InvalidComparatorMethodReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Contract" defaultSeverity="WARNING" displayName="Contract 문제" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 &lt;code&gt;@Contract&lt;/code&gt; 어노테이션의 문제를 보고합니다. 보고할 수 있는 문제 유형은 다음과 같습니다.
&lt;ul&gt;
&lt;li&gt;컨트랙트 구문 오류&lt;/li&gt;
&lt;li&gt;메서드 시그니처를 준수하지 않는 컨트랙트(잘못된 매개변수 개수)&lt;/li&gt;
&lt;li&gt;컨트랙트와 모순되는 메서드 구현(예: 컨트랙트에 &lt;code&gt;false&lt;/code&gt;로 표시되었으나 &lt;code&gt;true&lt;/code&gt;를 반환하는 경우)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // method has no parameters, but contract expects 1
  @Contract("_ -&gt; fail")
  &lt;b&gt;void&lt;/b&gt; x() {
    &lt;b&gt;throw&lt;/b&gt; new AssertionError();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: Contract&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ResultOfObjectAllocationIgnored" defaultSeverity="WARNING" displayName="객체 대입의 결과가 무시됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
할당된 객체가 무시되고 변수에 대입되어 있지 않거나 다른 방식으로 사용되지 않은 객체 할당을 보고합니다.
&lt;p&gt;
  그러한 할당 표현식은 Java에서 허용되지만 보통 의도하지 않은 것이거나 매우 이상한 객체 초기화 전략을 나타냅니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 검사에서 할당이 무시되어야 하는 클래스를 나열하려면 옵션을 사용하세요.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ResultOfObjectAllocationIgnored&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantOperationOnEmptyContainer" defaultSeverity="WARNING" displayName="빈 컨테이너에서의 불필요한 작업" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
빈 컬렉션, 맵, 배열에 사용된 불필요한 연산을 보고합니다.
&lt;p&gt;
  빈 컬렉션에 대한 반복, 요소 제거, 정렬, 기타 연산은 효과가 없으며 제거할 수 있습니다. 이는 버그의 신호일 수도 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (numbers.isEmpty()){
    // 부정 연산자가 누락되어 오류 발생
    int max = numbers.stream().max(Comparator.naturalOrder()).get();
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantOperationOnEmptyContainer&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonShortCircuitBoolean" defaultSeverity="WARNING" displayName="쇼트 서킷이 아닌 부울 표현식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단락 형태가 아닌 부울 'and' 및 'or'(&lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt; 및 &lt;code&gt;|=&lt;/code&gt;)의 사용 위치를 보고합니다.
비단락 버전은 유효한 경우도 있으나 대부분의 경우에는 단락 형식(&lt;code&gt;&amp;&amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt;)이 의도되며 그러한 의도치 않은 사용은 탐지하기 어려운 버그를 초래합니다.
&lt;p&gt;
  단락 버전을 사용하는 빠른 수정이 제안됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(boolean x, boolean y, boolean z) {
    if (x | y) { x |= z; }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(boolean x, boolean y) {
    if (x || y) { x = x || z; }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonShortCircuitBoolean&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScheduledThreadPoolExecutorWithZeroCoreThreads" defaultSeverity="WARNING" displayName="코어 스레드가 0인 'ScheduledThreadPoolExecutor'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;setCorePoolSize&lt;/code&gt; 메서드 또는 객체 생성자를 통해 &lt;code&gt;corePoolSize&lt;/code&gt;가 0으로 설정된 &lt;code&gt;java.util.concurrent.ScheduledThreadPoolExecutor&lt;/code&gt; 인스턴스를 보고합니다.
&lt;p&gt;
  코어 스레드가 0인 &lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;는 아무것도 실행하지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(int corePoolSize) {
      if (corePoolSize != 0) return;
      ThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(corePoolSize); // 경고
      executor.setCorePoolSize(corePoolSize); // 경고
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ScheduledThreadPoolExecutorWithZeroCoreThreads&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PrimitiveArrayArgumentToVariableArgMethod" defaultSeverity="WARNING" displayName="가변인수 메서드에 대한 기본형 배열 인수가 혼동됩니다." enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
가변 인자 매개변수 위치에서 호출이 기본 배열을 갖는 가변 인자 메서드 호출을 보고합니다.
이와 같은 원시 배열 인수는 예상과 달리 각각의 요소가 별도의 인수가 아니라 단일 요소 배열 인수로 래핑되어 혼란을 줄 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String.format("%s", new int[]{1, 2, 3});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String.format("%s", (Object) new int[]{1, 2, 3});
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;가변 arity 메서드&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PrimitiveArrayArgumentToVariableArgMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TextLabelInSwitchStatement" defaultSeverity="WARNING" displayName="'switch' 문의 텍스트 라벨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;switch&lt;/code&gt; 문 내 라벨이 지정된 구문을 보고합니다.
의도된 경우도 있으나 이러한 구문은 보통 오타가 난 결과입니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (x) {
      case 1:
      case2:   // 경고: 'switch' 문 내 텍스트 라벨 'case2:'
      case 3:
          break;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TextLabelInSwitchStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MalformedFormatString" defaultSeverity="WARNING" displayName="형식이 잘못된 서식 문자열" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
표준 Java 구문을 준수하지 않는 서식 문자열을 보고합니다.
&lt;p&gt;기본적으로 이 검사는 컴파일 시간 상수가 &lt;code&gt;java.util.Formatter&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;, &lt;code&gt;java.io.PrintWriter&lt;/code&gt; 또는&lt;code&gt;java.io.PrintStream&lt;/code&gt;에서 그에 해당하는 메서드의 인수로 사용되는 경우, 컴파일 시간 상수를 서식 문자열로 간주합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String.format("x = %d, y = %d", 42);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 설정을 사용하여 문자열 서식과 관련된 추가 클래스 및 메서드를 표시하세요.&lt;/p&gt;
&lt;p&gt;다른 대안으로 &lt;code&gt;org.intellij.lang.annotations.PrintFormat&lt;/code&gt; 어노테이션을 사용하여 서식 문자열 메서드 매개변수를 표시할 수도 있습니다. 이 경우 서식 인수 매개변수는 서식 문자열을 즉시 따라야 하며 마지막 메서드 매개변수여야 합니다. 예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void myFormatMethod(int mode, @PrintFormat String formatString, Object... args) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  이 방식으로 어노테이션이 추가된 메서드는 이 검사에서도 인식됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MalformedFormatString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousIntegerDivAssignment" defaultSeverity="WARNING" displayName="의심스러운 정수 나눗셈 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
오른쪽이 정수로 잘려서는 안 되는 나눗셈인 대입을 보고합니다.
&lt;p&gt;이 구문은 의도된 경우도 있으나 보통 버그입니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x = 18;
  x *= 3/2; // 정수 나눗셈의 결과 때문에 x는 변경되지 않습니다
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
이 코드는 다음으로 바꿔야 합니다.
&lt;pre&gt;&lt;code&gt;
  int x = 18;
  x *= 3.0/2;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 옵션에서 의심스러우나 올바른 나눗셈에 대한 경고(예: 피제수를 정적으로 계산할 수 없는 경우)를 비활성화할 수 있습니다.
&lt;pre&gt;&lt;code&gt;
  void calc(int d) {
     int x = 18;
     x *= d/2;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
  &lt;small&gt;2019.2의 새로운 기능&lt;/small&gt;
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousIntegerDivAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayObjectsEquals" defaultSeverity="WARNING" displayName="얕은 메서드 또는 'Objects' 메서드를 배열과 함께 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열 상등 관계 파악 또는 해시코드 계산을 위해 부적절한 메서드를 사용하는 것으로 보이는 표현식을 보고합니다.
&lt;p&gt;다음과 같은 메서드 호출이 보고됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 배열: &lt;code&gt;Object.equals()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;다차원 배열: &lt;code&gt;Arrays.equals()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;다차원 배열: &lt;code&gt;Arrays.hashCode()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ArrayObjectsEquals&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConfusingMainMethod" defaultSeverity="WARNING" displayName="혼동되는 'main()' 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Java 21 이내에서 'main'이라고 명명되었으나 &lt;code&gt;public static void main(String[])&lt;/code&gt; 시그니처를 가지지 않는 메서드를 보고합니다.
Java 21 사전 테스트 버전부터 검사가 package-private, protected 또는 인스턴스 main 메서드와 매개변수 및 매개변수가 없는 경우에 강조 표시하지 않습니다.
또한 익명 또는 로컬 클래스에 있는 main 메서드를 보고합니다.
익명 및 로컬 클래스는 완전히 정규화된 이름이 없으므로 실행할 수 없습니다.
&lt;p&gt;'main'이라는 이름의 메서드는 애플리케이션 진입점이 되기 때문에 그러한 메서드는 혼란을 일으킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    void main(String[] args) {} // 'public static' 제어자가 없기 때문에 경고가 발생합니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러한 메서드의 이름을 변경하는 빠른 수정은 에디터에서만 사용할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ConfusingMainMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Maven" path="Kotlin/ 마이그레이션"><inspection shortName="MavenCoroutinesDeprecation" defaultSeverity="ERROR" displayName="Maven에서 호환되지 않는 kotlinx.coroutines 종속성은 Kotlin 1.3 이상에서 사용" enabled="false" language="XML" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kotlin 1.3 또는 이후 버전과 호환성을 위해 업데이트해야 하는 Maven의 &lt;b&gt;kotlinx.coroutines&lt;/b&gt; 라이브러리 종속성을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MavenCoroutinesDeprecation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="국제화" path="Java"><inspection shortName="TimeToString" defaultSeverity="WARNING" displayName="'Time.toString()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.sql.Time&lt;/code&gt; 객체에서 &lt;code&gt;toString()&lt;/code&gt;을 호출하는 경우를 보고합니다. 그러한 호출은 국제화된 환경에서 보통 올바르지 않습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TimeToString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimpleDateFormatWithoutLocale" defaultSeverity="WARNING" displayName="로케일이 없는 'SimpleDateFormat'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Locale&lt;/code&gt;을 지정하지 않는 &lt;code&gt;java.util.SimpleDateFormat&lt;/code&gt; 또는 &lt;code&gt;java.time.format.DateTimeFormatter&lt;/code&gt;의 인스턴스화를 보고합니다.
이러한 호출은 OS 설정에 따라 달라지는 플랫폼 디폴트 로케일을 사용합니다.
이로 인해 코드가 다른 플랫폼에서 실행되거나 OS 설정이 변경될 때 예기치 못한 동작이 발생할 수 있습니다.
&lt;p&gt;&lt;code&gt;예:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new SimpleDateFormat("yyyy");
  DateTimeFormatter.ofPattern("d/M/y");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SimpleDateFormatWithoutLocale&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenation" defaultSeverity="WARNING" displayName="문자열 연결" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;String&lt;/code&gt; 연결을 보고합니다. 연결은 국제화된 환경에서 올바르지 않을 수 있으며 &lt;code&gt;java.text.MessageFormat&lt;/code&gt; 또는 유사한 클래스를 사용하여 바꿀 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String getMessage(String string, int number) {
    return string + number;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringConcatenation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DialogTitleCapitalization" defaultSeverity="WARNING" displayName="잘못된 문자열 대문자화" enabled="false" language="UAST" pluginId="com.intellij.java-i18n" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
&lt;code&gt;@Nls&lt;/code&gt; 어노테이션이 추가되어 있으며 대부분의 플랫폼 UI 가이드라인에 존재하는 대문자 표기 규칙을 준수하는 대문자 표기 매개변수를 포함하는 매서드 매개변수 및 반환 값 내 문자열을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  void setTitle(@NlsContexts.DialogTitle String title) {}
  setTitle("This is sentence capitalization but should be title"); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  setTitle("This Is Sentence Capitalization but Should Be Title"); 
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DialogTitleCapitalization&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="ConvertToBasicLatin" defaultSeverity="INFORMATION" displayName="기본이 아닌 라틴 문자" enabled="false" language="JAVA" pluginId="com.intellij.java-i18n" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자와 주석에 있는 비기본 라틴 문자를 보고합니다.
이 검사에서는 이러한 문자를 리터럴에서 유니코드 이스케이프로, 주석에서 HTML 엔티티로 바꾸는 수정을 제공합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // © 2021
  char c = '©';
  String s = "Áî";
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // &amp;amp;copy; 2021
  char c = '\u00a9';
  String s = "\u00c1\u00ee";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
기본적으로 이 검사는 에디터에서 강조 표시하지 않으며, 수정만을 제공합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: ConvertToBasicLatin&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToSuspiciousStringMethod" defaultSeverity="WARNING" displayName="의심스러운 'String' 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음의 호출을 보고합니다.
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;equals()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;equalsIgnoreCase()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;compareTo()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;compareToIgnoreCase()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;trim()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
   
  대신에 국제화된 문자열의 비교가 &lt;code&gt;java.text.Collator&lt;/code&gt;를 사용해야 할 것입니다.
  &lt;code&gt;String.trim()&lt;/code&gt;은 0x00와 0x20 사이의 제어 문자만 제거합니다.
  Java 11에 도입된 &lt;code&gt;String.strip()&lt;/code&gt; 메서드는 유니코드 인식 기능이 향상되었으며 대체 메서드로 사용할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CallToSuspiciousStringMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbsoluteAlignmentInUserInterface" defaultSeverity="WARNING" displayName="AWT/Swing 코드에서 절대 정렬 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
AWT 및 Swing의 절대 정렬 상수를 사용한 경우를 보고합니다. 국제화된 애플리케이션은 로케일 구성 요소 방향 설정에 따르기 위해 상대적 정렬을 사용합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  JPanel panel = new JPanel(new BorderLayout(2, 2));
  JLabel label = new JLabel("Hello World");
  panel.add(label, BorderLayout.NORTH);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  JPanel panel = new JPanel(new BorderLayout(2, 2));
  JLabel label = new JLabel("Hello World");
  panel.add(label, BorderLayout.PAGE_START);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AbsoluteAlignmentInUserInterface&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HardCodedStringLiteral" defaultSeverity="WARNING" displayName="하드코딩된 문자열" enabled="false" language="UAST" pluginId="com.intellij.java-i18n" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
하드코딩된 &lt;code&gt;String&lt;/code&gt; 리터럴의 모든 인스턴스를 보고합니다.
&lt;p&gt;국제화된 환경에서 하드코딩된 &lt;code&gt;String&lt;/code&gt; 리터럴은 오류일 가능성이 높습니다. 이 검사는 빈 문자열 및 공백으로만 구성된 문자열을 보고하지 않습니다. 빠른 수정을 사용하여 문자열 리터럴을 &lt;code&gt;java.util.ResourceBundle.getString()&lt;/code&gt; 메서드 호출로 변환할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: HardCodedStringLiteral&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringTokenizer" defaultSeverity="WARNING" displayName="'StringTokenizer' 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;StringTokenizer&lt;/code&gt; 클래스의 사용 위치를 보고합니다. 국제화된 환경에서 &lt;code&gt;StringTokenizer&lt;/code&gt;의 과도한 사용은 올바르지 않습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringTokenizer&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NumericToString" defaultSeverity="WARNING" displayName="'Number.toString()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Number&lt;/code&gt;를 확장하는 클래스의 객체에서 &lt;code&gt;toString()&lt;/code&gt;을 호출하는 경우를 보고합니다.
이러한 호출은 일반적으로 국제화된 환경에서 올바르지 않으며 일부 로케일 특정 형식을 대신 사용해야 합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Double d) {
    System.out.println(d.toString());
  }
&lt;/code&gt;&lt;/pre&gt;
이 문제는 다음과 같은 방법으로 수정할 수 있습니다.
&lt;pre&gt;&lt;code&gt;
  void print(Double d) {
    System.out.printf("%f%n", d);
  }
&lt;/code&gt;&lt;/pre&gt;
이는 호스트 환경을 기반으로 JVM을 시작하는 동안 설정된 디폴트 로케일을 사용하여 숫자의 서식을 지정합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NumericToString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CharacterComparison" defaultSeverity="WARNING" displayName="문자 비교" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;char&lt;/code&gt; 값의 서수 비교를 보고합니다. 국제화된 환경에서는 그러한 비교가 올바른 경우는 거의 없습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CharacterComparison&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryUnicodeEscape" defaultSeverity="WARNING" displayName="불필요한 유니코드 이스케이프 시퀀스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 유니코드 이스케이프 시퀀스를 보고합니다.
파일 인코딩이 이스케이프 처리 없이 문자를 처리할 수 있는 경우 유니코드 이스케이프 시퀀스는 불필요합니다.
이 검사는 줄바꿈 및 수평 탭을 제외하고 유니코드 제어 문자를 보고하지 않습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "\u0078";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "x";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryUnicodeEscape&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DateToString" defaultSeverity="WARNING" displayName="'Date.toString()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Date&lt;/code&gt; 객체에서 &lt;code&gt;toString()&lt;/code&gt;을 호출하는 경우를 보고합니다. 그러한 호출은 국제화된 환경에서 보통 올바르지 않습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DateToString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitDefaultCharsetUsage" defaultSeverity="WARNING" displayName="묵시적 플랫폼 디폴트 문자 집합" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
플랫폼 디폴트 문자 집합을 묵시적으로 사용하는 메서드 및 생성자를 호출을 보고합니다. 이러한 호출은 다른 디폴트 문자집합을 사용하는 시스템에서 결과가 달라질 수 있으며 예기치 않은 동작이 일어날 수도 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void foo(byte[] bytes) {
  String s = new String(bytes);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;해당하는 오버로드된 메서드를 사용할 수 있는 경우 명시적인 UTF-8 문자 집합을 지정하는 빠른 수정을 사용할 수 있습니다.
  빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void foo(byte[] bytes) {
  String s = new String(bytes, StandardCharsets.UTF_8);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ImplicitDefaultCharsetUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringToUpperWithoutLocale" defaultSeverity="WARNING" displayName="로케일이 없는 'String.toUpperCase()' 또는 'toLowerCase()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Locale&lt;/code&gt;을 지정하지 않는 &lt;code&gt;String&lt;/code&gt; 객체에서 &lt;code&gt;toUpperCase()&lt;/code&gt; 또는 &lt;code&gt;toLowerCase()&lt;/code&gt;를 호출하는 경우를 보고합니다. 이러한 경우 기본 시스템 로케일이 사용되므로 국제화된 환경에서 문제가 발생할 수 있습니다.
&lt;p&gt;
  예를 들어 코드 &lt;code&gt;"i".toUpperCase().equals("I")&lt;/code&gt;는 점이 있는 'i'와 점이 없는 'i'가 별도의 문자인 터키어 및 아제르바이잔어 로케일에서 &lt;code&gt;false&lt;/code&gt;를 반환합니다. 터키어 로케일에서 실행 중에 'i'를 포함하는 영어 문자열에서 &lt;code&gt;toUpperCase()&lt;/code&gt;를 호출하면 잘못된 결과가 반환됩니다. 아니면 HTML 태그와 같이 로케일에 의존하지 않는 것으로 취급해야 하는 문자열을 처리하는 경우에 이 때문에 오류가 발생할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StringToUpperWithoutLocale&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MagicCharacter" defaultSeverity="WARNING" displayName="매직 문자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상수 선언 없이 사용된 문자 리터럴을 보고합니다. 이러한 문자는 코드 가독성을 떨어뜨릴 수 있습니다. 또한, 문자가 코드 내 모든 위치가 아닌, 한 위치에서만 변경되는 경우 오류가 발생할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char c = 'c';&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MagicCharacter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateStringLiteralInspection" defaultSeverity="WARNING" displayName="문자열 리터럴 중복" enabled="false" language="JAVA" pluginId="com.intellij.java-i18n" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
프로젝트 전체에서 변경 없이 중복된 모든 문자열 리터럴을 보고합니다.
두 개의 빠른 수정이 제공됩니다. 하나는 중복되는 문자열에 상수를 삽입하고 프로젝트 전체에서 사용하는 것이고,
다른 하나는 특정 문자열 리터럴이 중복되는 위치를 모두 표시하는 것입니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C1 { String CONST1 = "duplicate string"; }
  class C2 { String CONST2 = "duplicate string"; }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;최소 문자열 길이&lt;/b&gt; 필드를 사용해 중복 탐지에 필요한 최소 문자열 길이를 설정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;@PropertyKey 표현식 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;org.jetbrains.annotations.PropertyKey&lt;/code&gt; 어노테이션이 추가된 메서드에 인수로 전달된 문자열을 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DuplicateStringLiteralInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Docker-compose" path=""><inspection shortName="ComposeUnquotedPorts" defaultSeverity="WEAK WARNING" displayName="따옴표로 묶이지 않은 포트 매핑" enabled="false" language="yaml" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Docker Compose 파일 내 따옴표로 묶이지 않은 포트 매핑을 보고합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#short-syntax-1"&gt;Compose 파일 사양&lt;/a&gt;에 따르면, YAML은 &lt;code&gt;xx:yy&lt;/code&gt; 형식의 숫자를 60진법으로 분석하기 때문에 60 미만의 컨테이너 포트를 사용할 때 &lt;code&gt;HOST:CONTAINER&lt;/code&gt; 형식으로 포트를 매핑하면 잘못된 결과가 발생할 수 있습니다.
  이러한 이유로 포트 매핑을 문자열로 명시적으로 항상 지정하는 것이 좋습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ports:
    - 3000
    - 3000-3005
    - 22:22
    - 8080:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ports:
    - "3000"
    - "3000-3005"
    - "22:22"
    - "8080:8080"
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ComposeUnquotedPorts&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComposeMissingKeys" defaultSeverity="ERROR" displayName="누락된 docker-compose YAML 키" enabled="false" language="yaml" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Docker Compose 파일 내 누락된 필수 키를 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ComposeMissingKeys&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComposeErroneousRelation" defaultSeverity="WARNING" displayName="docker-compose YAML에 있는 관계의 오류" enabled="false" language="yaml" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Docker Compose 파일 내에서 오류가 있는 관계를 보고합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a href="https://docs.docker.com/reference/compose-file/services/#volumes"&gt;Compose 파일 사양&lt;/a&gt;에 따르면, 특정 필드가 다른 키-값 쌍에 따라 유효하지 않을 수 있으며 오류를 일으킬 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  예를 들어 이러한 관계 중 하나가 볼륨 &lt;code&gt;source&lt;/code&gt; 필드입니다. 이 필드는 볼륨 &lt;code&gt;type&lt;/code&gt; 타입이 &lt;code&gt;tmpfs&lt;/code&gt;일 때 유효하지 않습니다.
&lt;/p&gt;
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ComposeErroneousRelation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComposeUnknownValues" defaultSeverity="ERROR" displayName="알 수 없는 docker-compose YAML 값" enabled="false" language="yaml" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Docker Compose 파일에서 인식되지 않는 값을 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ComposeUnknownValues&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComposeUnknownKeys" defaultSeverity="ERROR" displayName="알 수 없는 docker-compose YAML 키" enabled="false" language="yaml" pluginId="Docker" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Docker Compose 파일에서 인식되지 않는 키를 보고합니다.&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ComposeUnknownKeys&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="switch 문 이슈" path="JavaScript 및 TypeScript"><inspection shortName="JSUnreachableSwitchBranches" defaultSeverity="WARNING" displayName="도달할 수 없는 'switch' 문의 'case' 브랜치" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;switch&lt;/code&gt; 문의 도달할 수 없는 &lt;code&gt;case&lt;/code&gt; 브랜치를 보고합니다. &lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * @param {('foo' | 'bar')} p
 */
function foo(p) {
    switch (p) {
        case 'foo': break;
        case 'bar': break;
        case 'baz': break; // 도달할 수 없음
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSUnreachableSwitchBranches&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSMissingSwitchBranches" defaultSeverity="INFORMATION" displayName="'switch' 문에 분기가 누락되었습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;enum&lt;/code&gt; 또는 &lt;code&gt;union&lt;/code&gt; 타입의 변수에 대한 &lt;code&gt;switch&lt;/code&gt; 문에서 해당 타입의 일부의 값 옵션을 포함하지 않는 경우를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSMissingSwitchBranches&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DefaultNotLastCaseInSwitchJS" defaultSeverity="WARNING" displayName="'default'가 'switch'의 마지막 case가 아님" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
가장 마지막 케이스여야 할 &lt;code&gt;default&lt;/code&gt; 케이스가 다른 케이스 앞에 오기 때문에 혼란을 일으킬 수 있는 &lt;code&gt;switch&lt;/code&gt; 문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DefaultNotLastCaseInSwitchJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TextLabelInSwitchStatementJS" defaultSeverity="WARNING" displayName="'switch' 문의 텍스트 라벨" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
오타로 자주 발생하는 &lt;code&gt;switch&lt;/code&gt; 구문 내부의 라벨이 지정된 구문을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    &lt;b&gt;switch&lt;/b&gt;(x)
    {
        &lt;b&gt;case&lt;/b&gt; 1:
        case2:   //오타!
        &lt;b&gt;case&lt;/b&gt; 3:
            &lt;b&gt;break&lt;/b&gt;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TextLabelInSwitchStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSSwitchVariableDeclarationIssue" defaultSeverity="WARNING" displayName="변수가 선언되고 다른 'case' 절에서 사용됩니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;switch&lt;/code&gt; 내 하나의 &lt;code&gt;case&lt;/code&gt; 절로 선언되어 있으나 같은 구문의 다른&lt;code&gt;case&lt;/code&gt; 절에서 사용된 변수를 보고합니다.
블록 스코프의 변수에 대해, 이는 &lt;code&gt;ReferenceError&lt;/code&gt;를 발생시킵니다.
&lt;code&gt;var&lt;/code&gt; 변수에 대해 이는 잠재적 오류를 나타냅니다. &lt;p&gt;이 패턴이 의도적으로 사용된 경우, &lt;code&gt;var&lt;/code&gt; 변수에 대한 검사를 비활성화하십시오.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSSwitchVariableDeclarationIssue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedSwitchStatementJS" defaultSeverity="WARNING" displayName="중첩된 'switch' 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 &lt;code&gt;switch&lt;/code&gt; 문에 중첩된 &lt;code&gt;switch&lt;/code&gt; 문을 보고합니다.  들여쓰기가 일관되지 않은 경우 
중첩된 &lt;code&gt;switch&lt;/code&gt; 문은 혼란을 일으킬 가능성이 매우 큽니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NestedSwitchStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSDuplicateCaseLabel" defaultSeverity="WARNING" displayName="중복 'case' 라벨" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;switch&lt;/code&gt; 문 내 중복된 &lt;code&gt;case&lt;/code&gt; 라벨을 보고합니다. 이는 보통 오류를 나타냅니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSDuplicateCaseLabel&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FallThroughInSwitchStatementJS" defaultSeverity="WARNING" displayName="'switch' 문의 폴스루" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
제어가 한 브랜치에서 다른 브랜치로 진행되는 &lt;code&gt;switch&lt;/code&gt; 문을 보고합니다.  그러한 '폴스루'는 보통 오류를 나타냅니다(예:&lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;return&lt;/code&gt; 누락).
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FallThroughInSwitchStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSRedundantSwitchStatement" defaultSeverity="INFORMATION" displayName="'switch' 문은 중복이며 바꿀 수 있습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 비어 있거나 단 하나의 &lt;code&gt;case&lt;/code&gt; 브랜치 또는 &lt;code&gt;default&lt;/code&gt; 브랜치만 포함하는 &lt;code&gt;switch&lt;/code&gt; 문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSRedundantSwitchStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSMissingSwitchDefault" defaultSeverity="INFORMATION" displayName="'switch' 문에 'default' 분기가 없습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
일부의 가능한 값이 열거되지 않은 경우에 &lt;code&gt;default&lt;/code&gt; 절이 없는&lt;code&gt;switch&lt;/code&gt; 문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSMissingSwitchDefault&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="코드 품질 도구" path="JavaScript 및 TypeScript"><inspection shortName="JSHint" defaultSeverity="ERROR" displayName="JSHint" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://jshint.com/"&gt;JSHint&lt;/a&gt; linter에 의해 탐지된 문제를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSHint&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TsLint" defaultSeverity="WARNING" displayName="TSLint" enabled="false" language="TypeScript" pluginId="tslint" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://github.com/palantir/tslint"&gt;TSLint&lt;/a&gt;에 의해 탐지된 차이를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;br/&gt;&lt;br/&gt;
강조 표시는 각각의 개별 규칙에 대한 &lt;a href="https://palantir.github.io/tslint/usage/configuration/"&gt;TSLint 구성 파일&lt;/a&gt;에 지정된 규칙 심각도를 기반으로 합니다.
&lt;br/&gt;&lt;br/&gt;
'구성 파일에서 규칙 중요도 사용' 체크박스를 지워서 이 검사에 구성된 모든 TSLint 규칙 심각도를 사용하세요.
&lt;p&gt;&lt;small&gt;Inspection ID: TsLint&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StandardJS" defaultSeverity="ERROR" displayName="표준 코드 스타일" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://standardjs.com/"&gt;JavaScript Standard Style&lt;/a&gt; linter에 의해 탐지된 차이를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;br/&gt;&lt;br/&gt;
에디터의 강조 표시 심각도는 linter 보고서의 심각도 수준을 기반으로 합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: StandardJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Eslint" defaultSeverity="WARNING" displayName="ESLint" enabled="true" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://eslint.org"&gt;ESLint&lt;/a&gt;에 의해 탐지된 차이를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;br/&gt;&lt;br/&gt;
강조 표시는 각각의 개별 규칙에 대한 &lt;a href="https://eslint.org/docs/user-guide/configuring"&gt;ESLint 구성 파일&lt;/a&gt;에 지정된 규칙 심각도를 기반으로 합니다.
&lt;br/&gt;&lt;br/&gt;
'구성 파일에서 규칙 중요도 사용' 체크박스를 지워서 이 검사에 구성된 모든 ESLint 규칙 심각도를 사용하십시오.
&lt;p&gt;&lt;small&gt;Inspection ID: Eslint&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Maven" path=""><inspection shortName="MavenDuplicatePluginInspection" defaultSeverity="WARNING" displayName="중복 플러그인 선언" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;pom.xml 내 플러그인 선언 중복을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MavenDuplicatePluginInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenParentMissedVersionInspection" defaultSeverity="ERROR" displayName="상위 버전 누락됨" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;소비자 POM 기능을 지원하지 않는 버전에 대한 상위 버전 요소가 없는 경우를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MavenParentMissedVersionInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenNewElementsInOldSchema" defaultSeverity="ERROR" displayName="Wrong model version. Model version should be 4.1.0 for this tag" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  오래된 프로젝트 스키마의 새로운 모델 태그를 보고하고
  &lt;br&gt;
  프로젝트 스키마 업데이트를 제안합니다
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MavenNewElementsInOldSchema&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenNewModelVersionInOldSchema" defaultSeverity="ERROR" displayName="Wrong model version. Model version should be 4.1.0 for this tag" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  오래된 프로젝트 스키마의 새로운 모델 버전을 보고하고
  &lt;br&gt;
  프로젝트 스키마 업데이트를 제안합니다
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MavenNewModelVersionInOldSchema&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenRedundantGroupId" defaultSeverity="WARNING" displayName="불필요한 그룹 ID" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;상위 pom.xml에 이미 정의되었으므로 불필요한 &amp;lt;groupId&amp;gt; 정의를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MavenRedundantGroupId&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenModelVersionMissed" defaultSeverity="ERROR" displayName="'modelVersion' child tag should be defined" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  &amp;lt;modelVersion&amp;gt; 태그의 누락을 보고합니다
  &lt;br&gt;
  Maven 4 이상에서는 스키마 위치에서 파생되기 때문에 선택 사항입니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MavenModelVersionMissed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenParentMissedGroupIdArtifactIdInspection" defaultSeverity="ERROR" displayName="상위 groupId 또는 artifactId가 없습니다" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  &amp;lt;parent&amp;gt; 태그에 &amp;lt;groupId&amp;gt;와(과) &amp;lt;artifactId&amp;gt; 요소가 없으면 보고합니다.
  &lt;br&gt;(Maven 4 이상에서 상위 POM을 relativePath이 찾을 수 있다면 이러한 요소는 선택적입니다).
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MavenParentMissedGroupIdArtifactIdInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenDuplicateDependenciesInspection" defaultSeverity="WARNING" displayName="중복 종속성" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;종속성 중복을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MavenDuplicateDependenciesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenModelInspection" defaultSeverity="ERROR" displayName="Maven 모델 검사" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Maven 모델의 해결 문제를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MavenModelInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MavenPropertyInParent" defaultSeverity="WARNING" displayName="상위 설명 내 프로퍼티 사용 위치" enabled="false" language="XML" pluginId="org.jetbrains.idea.maven" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;모듈의 parent 정의에서 금지된 프로퍼티 사용 사례를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MavenPropertyInParent&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="OpenAPI 사양" path=""><inspection shortName="SwYamlUnresolvedReferencesInspection" defaultSeverity="ERROR" displayName="미해결 참조" enabled="false" language="yaml" pluginId="com.intellij.swagger" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
YAML 사양 파일에서 미해결 참조를 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SwYamlUnresolvedReferencesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwJsonMaybeSpecificationInspection" defaultSeverity="WARNING" displayName="가능한 OpenAPI/Swagger 사양 후보" enabled="false" language="JSON" pluginId="com.intellij.swagger" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
OpenAPI/Swagger 사양의 일부로 해석될 수 있는 JSON 파일을 탐지합니다.
&lt;p&gt;
  이러한 파일은 명시적인 사양 속성은 포함하지 않으나 인접한 기본 사양 파일에서 참조됩니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;
  다음의 예시는 같은 디렉터리에 있는 두 파일을 포함합니다. 첫 번째 파일은 일반적인 기본 사양 파일입니다.
  두 번째 파일은 첫 번째 파일에서 참조되며 따라서 사양으로 간주될 수 있다고 제안됩니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;기본 사양 파일 &lt;code&gt;openapi.yaml&lt;/code&gt;:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="yaml"&gt;
openapi: 3.1.0
components:
  schemas:
    CustomSchema:
      description: Custom schema object
      properties:
        foo:
          $ref: 'common.components.json#/components/schemas/CommonSchema'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;사양 파일 후보 &lt;code&gt;common.components.json&lt;/code&gt;:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="json"&gt;
{
  "components": { // 'Mark file as OpenAPI specification' 강조 표시
    "schemas": {
      "CommonSchema": {
        "description": "Common schema object reused in several specifications"
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SwJsonMaybeSpecificationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwJsonUnresolvedReferencesInspection" defaultSeverity="ERROR" displayName="미해결 참조" enabled="false" language="JSON" pluginId="com.intellij.swagger" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JSON 사양 파일에서 미해결 참조를 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SwJsonUnresolvedReferencesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwYamlMaybeSpecificationInspection" defaultSeverity="WARNING" displayName="가능한 OpenAPI/Swagger 사양 후보" enabled="false" language="yaml" pluginId="com.intellij.swagger" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
OpenAPI/Swagger 사양의 일부로 해석될 수 있는 YAML 파일을 탐지합니다.
&lt;p&gt;
  이러한 파일은 명시적인 사양 속성은 포함하지 않으나 인접한 기본 사양 파일에서 참조됩니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;
  다음의 예시는 같은 디렉터리에 있는 두 파일을 포함합니다. 첫 번째 파일은 일반적인 기본 사양 파일입니다.
  두 번째 파일은 첫 번째 파일에서 참조되며 따라서 사양으로 간주될 수 있다고 제안됩니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;기본 사양 파일 &lt;code&gt;openapi.yaml&lt;/code&gt;:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
openapi: 3.1.0
components:
  schemas:
    CustomSchema:
      description: Custom schema object
      properties:
        foo:
          $ref: 'common.components.yaml#/components/schemas/CommonSchema'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;사양 파일 후보 &lt;code&gt;common.components.yaml&lt;/code&gt;:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
components: # 'Mark file as OpenAPI specification' highlighting
  schemas:
    CommonSchema:
      description: Common schema object reused in several specifications
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SwYamlMaybeSpecificationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Shrinker" path="Android"><inspection shortName="ShrinkerUnresolvedReference" defaultSeverity="ERROR" displayName="Unresolved reference in Shrinker Config file" enabled="false" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Shrinker 구성에서 클래스 멤버에 대한 해결되지 않은 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ShrinkerUnresolvedReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ShrinkerInnerClassSeparator" defaultSeverity="ERROR" displayName="Invalid separator between class and inner class" enabled="false" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Shrinker 구성에서 클래스 사이 및 클래스 내부에 사용된 잘못된 구분 기호를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ShrinkerInnerClassSeparator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ShrinkerInvalidFlags" defaultSeverity="ERROR" displayName="Invalid flag in shrinker config" enabled="false" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Shrinker 구성에서 유효하지 않은 플래그를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ShrinkerInvalidFlags&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="R8IgnoredFlags" defaultSeverity="WARNING" displayName="Flags ignored by R8" enabled="false" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
R8이 무시한 플래그를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: R8IgnoredFlags&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ShrinkerArrayType" defaultSeverity="ERROR" displayName="Invalid using of array type" enabled="false" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  배열 타입 표기가 잘못 사용된 경우 보고합니다.
  &lt;br&gt;
  &lt;code&gt;type[]&lt;/code&gt;은 공백 없이 배열 타입에 사용되어야 합니다.
  &lt;br&gt;
  &lt;br&gt;
예: &lt;code&gt;java.lang.Object[]&lt;/code&gt;.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ShrinkerArrayType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="코루틴 검사" path="Kotlin"><inspection shortName="MapAwaitOnCollectionOfDeferred" defaultSeverity="WARNING" displayName="단일 'awaitAll()' 대신 'map { it.await() }'이 'Collection&lt;Deferred&gt;'에서 호출되었습니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;code&gt;Deferred&lt;/code&gt;의 컬렉션에 대한 &lt;code&gt;map { it.await() }&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  이는 더 간결하고 잠재적으로 더 효율적인 &lt;code&gt;awaitAll()&lt;/code&gt; 호출로 대체할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  자세한 내용은 &lt;code&gt;kotlinx.coroutines.awaitAll&lt;/code&gt;의 문서를 참조하세요.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  suspend fun waitForResult(results: List&amp;lt;Deferred&amp;lt;String&amp;gt;&amp;gt;): List&amp;lt;String&amp;gt; {
    return results.map { it.await() }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  suspend fun waitForResult(results: List&amp;lt;Deferred&amp;lt;String&amp;gt;&amp;gt;): List&amp;lt;String&amp;gt; {
    return results.awaitAll()
  }
&lt;/code&gt;&lt;/pre&gt;&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MapAwaitOnCollectionOfDeferred&lt;/small&gt;&lt;/p&gt;
&lt;/html&gt;</inspection><inspection shortName="PreferCurrentCoroutineContextToCoroutineContext" defaultSeverity="WARNING" displayName="잠재적으로 모호할 수 있는 'kotlin.coroutine.coroutineContext'의 사용 위치" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
Reports usages of &lt;code&gt;kotlin.coroutine.coroutineContext&lt;/code&gt; property
in code that has a dependency on &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library.
&lt;p&gt;
  When both &lt;code&gt;kotlin.coroutine.coroutineContext&lt;/code&gt; and &lt;code&gt;kotlinx.coroutines.CoroutineScope.coroutineContext&lt;/code&gt;
  can be present in the code, it can lead to confusion and potential bugs.
&lt;/p&gt;
&lt;p&gt;
  The &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library provides &lt;code&gt;currentCoroutineContext()&lt;/code&gt; function
  as a clearer alternative that should be preferred even when there is no explicit clash.
&lt;/p&gt;
&lt;p&gt;
  See the documentation for &lt;code&gt;kotlin.coroutine.coroutineContext&lt;/code&gt;
  and &lt;code&gt;kotlinx.coroutines.currentCoroutineContext&lt;/code&gt; for more details.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  suspend fun getCurrentJob(): Job? {
    return coroutineContext[Job]
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  suspend fun getCurrentJob(): Job? {
    return currentCoroutineContext()[Job]
  }
&lt;/code&gt;&lt;/pre&gt;&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PreferCurrentCoroutineContextToCoroutineContext&lt;/small&gt;&lt;/p&gt;
&lt;/html&gt;
</inspection><inspection shortName="ForEachJoinOnCollectionOfJob" defaultSeverity="WARNING" displayName="단일 'joinAll()' 대신 'forEach { it.join() }'이 'Collection&lt;Job&gt;'에서 호출되었습니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;code&gt;Job&lt;/code&gt; 컬렉션에 대한 &lt;code&gt;forEach { it.join() }&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  이는 더 간결하고 완전히 동등한 &lt;code&gt;joinAll()&lt;/code&gt; 호출로 대체할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  자세한 내용은 &lt;code&gt;kotlinx.coroutines.joinAll&lt;/code&gt; 문서를 참조하세요.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  suspend fun waitForJobs(jobs: List&amp;lt;Job&amp;gt;) {
    jobs.forEach { it.join() }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  suspend fun waitForJobs(jobs: List&amp;lt;Job&amp;gt;) {
    jobs.joinAll()
  }
&lt;/code&gt;&lt;/pre&gt;&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ForEachJoinOnCollectionOfJob&lt;/small&gt;&lt;/p&gt;
&lt;/html&gt;</inspection><inspection shortName="RunBlocking" defaultSeverity="WARNING" displayName="코루틴 내 RunBlocking" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
코루틴에서 도달할 수 있는 runBlocking 빌더를 보고합니다. 
&lt;p&gt;코루틴은 실행을 위해 스레드를 공유합니다. runBlocking 빌더가 코루틴에서 호출되는 경우, 기본 스레드를 차단하며 다른 코루틴이 해당 리소스를 사용하는 것을 막습니다. 이로 인해 성능 문제가 발생하거나, 좋지 않은 경우에는 스레드가 기아 상태에 빠질 수 있습니다.&lt;/p&gt;
&lt;p&gt;코루틴 기본형(suspend 함수 또는 빌더)에서 잠재적인 호출 스택을 runBlocking 빌더에 제공합니다.&lt;/p&gt;
&lt;p&gt;예: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  suspend fun main() {
      foo() 
   }

  fun foo() {
      runBlocking { suspendFunction() }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;가능한 솔루션: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  suspend fun main() {
      foo() 
   }

  suspend fun foo() {
      suspendFunction()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;재정의가 있는 함수 탐색&lt;/b&gt; 옵션을 사용하여 가상 함수 분석을 구성합니다.&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;분석 시 재정의가 있는 함수는 건너뛰려면 &lt;b&gt;아니요&lt;/b&gt; 옵션을 선택합니다.&lt;/li&gt;
    &lt;li&gt;정의된 피호출자 타입의 함수만 탐색하려면 &lt;b&gt;예, 재정의 제외&lt;/b&gt; 옵션을 선택합니다.&lt;/li&gt;
    &lt;li&gt;함수와 모든 재정의를 탐색하려면 &lt;b&gt;예, 재정의 포함&lt;/b&gt; 옵션을 선택합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: RunBlocking&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="제어 흐름 이슈" path="Groovy"><inspection shortName="GroovyConditionalWithIdenticalBranches" defaultSeverity="WARNING" displayName="동일한 브랜치가 있는 삼항식" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동일한 'then' 및 'else' 브랜치를 포함하는 삼항식을 보고합니다. 그러한 표현식은 거의 확실히 프로그래머가 일으킨 오류입니다.
&lt;p&gt;빠른 수정에서는 표현식을 'then' 브랜치로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  condition ? a.foo() : a.foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a.foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyConditionalWithIdenticalBranches&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyBreak" defaultSeverity="WARNING" displayName="'break' 문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;switch&lt;/code&gt; 문 외부에 있는 &lt;code&gt;break&lt;/code&gt; 문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyBreak&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConstantConditional" defaultSeverity="WARNING" displayName="상수 조건식" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
bool 상수를 조건으로 가지는 조건식을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  true ? result1 : result2
  false ? result1 : result2
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyConstantConditional&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyIfStatementWithIdenticalBranches" defaultSeverity="WARNING" displayName="브랜치가 동일한 if 문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동일한 'then' 및 &lt;code&gt;else&lt;/code&gt; 브랜치를 포함하는 &lt;code&gt;if&lt;/code&gt; 문을 보고합니다.
그러한 구문은 거의 확실히 프로그래머가 일으킨 오류입니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (condition) {
  print "foo"
} else {
  print "foo"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
print "foo"
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyIfStatementWithIdenticalBranches&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnnecessaryContinue" defaultSeverity="WARNING" displayName="불필요한 'continue' 문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;루프에서 마지막으로 도달할 수 있는 구문이 &lt;code&gt;continue&lt;/code&gt; 문일 경우 보고합니다.
이러한 &lt;code&gt;continue&lt;/code&gt; 문은 불필요하며 안전하게 제거할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for(int i in array) {
      println(i)
      &lt;b&gt;continue&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for(int i in array) {
      println(i)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;자세한 내용은 Java의 동일한 검사를 참조하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyUnnecessaryContinue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyLoopStatementThatDoesntLoop" defaultSeverity="WARNING" displayName="루프를 실행하지 않는 루프 문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 최대 한 번 실행되는 것이 보증되는 &lt;code&gt;for&lt;/code&gt; 또는 &lt;code&gt;while&lt;/code&gt; 문을 보고합니다. 그러한 구문이 의도적으로 작성되었을 수 있지만 보통은 오류를 나타냅니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  for (int i in 0..&amp;lt;10) {
    return
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyLoopStatementThatDoesntLoop&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrFinalVariableAccess" defaultSeverity="WARNING" displayName="final 변수 액세스" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
final 변수, 매개변수 및 필드에 대한 잘못된 대입 및 초기화되지 않은 final 필드를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrFinalVariableAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyIfStatementWithTooManyBranches" defaultSeverity="WARNING" displayName="브랜치가 너무 많은 if 문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
브랜치가 너무 많은 &lt;code&gt;if&lt;/code&gt; 문을 보고합니다.
그러한 구문은 혼동될 수 있으며 보통 적절하지 않은 수준의 설계 추상화를 나타냅니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (a) {
  print "foo"
} else if (b) {
  print "bar"
} else if (c) {
  print "baz"
} else if (d) {
  print "Too many branches"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 &lt;b&gt;최대 브랜치 수&lt;/b&gt; 필드를 사용하여 필요한 브랜치의 최대 개수를 지정하세요.
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyIfStatementWithTooManyBranches&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyTrivialConditional" defaultSeverity="WARNING" displayName="중복 조건식" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;x ? true : false&lt;/code&gt; 형식의 삼항 조건 연산자 또는 이와 비슷하며 쉽게 단순화할 수 있는 연산자를 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  foo() ? true : false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
foo()
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyTrivialConditional&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConditionalCanBeElvis" defaultSeverity="INFORMATION" displayName="삼항식을 elvis 식으로 바꿀 수 있음" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
elvis 식으로 바꿀 수 있는 삼항식을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def notNull(o, defaultValue) {
      o != null ? o : defaultValue
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def notNull(o, defaultValue) {
      o ?: defaultValue
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyConditionalCanBeElvis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnnecessaryReturn" defaultSeverity="WARNING" displayName="불필요한 'return' 문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;void&lt;/code&gt;를 반환하는 생성자 및 메서드 끝에 있는 &lt;code&gt;return&lt;/code&gt; 문을 보고합니다. 이는 불필요하며 안전하게 제거할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo (String s){
      print(s)
      &lt;b&gt;return&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo (String s){
      print(s)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;자세한 내용은 Java의 동일한 검사를 참조하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyUnnecessaryReturn&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConditionalCanBeConditionalCall" defaultSeverity="INFORMATION" displayName="삼항식을 안전한 호출로 바꿀 수 있음" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전한 호출로 바꿀 수 있는 삼항식을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def charArray(String s) {
      s == null ? null : s.toCharArray()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def charArray(String s) {
      s?.toCharArray()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyConditionalCanBeConditionalCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyReturnFromClosureCanBeImplicit" defaultSeverity="WARNING" displayName="'return' 문이 묵시적일 수 있음" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
묵시적으로 만들 수 있는 클로저의 끝에 있는 return 문을 보고합니다.
&lt;p&gt;
  Groovy 클로저는 마지막 구문의 값을 명시적으로 반환합니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def foo = {
    return 1
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def foo = {
    1
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyReturnFromClosureCanBeImplicit&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyTrivialIf" defaultSeverity="WARNING" displayName="중복 'if' 문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
하나의 대입 또는 &lt;code&gt;return&lt;/code&gt; 문으로 단순화할 수 있는 &lt;code&gt;if&lt;/code&gt;
문을 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (foo())
    return true;
  else
    return false;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyTrivialIf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyFallthrough" defaultSeverity="WARNING" displayName="'switch' 문의 폴스루" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
switch 문의 &lt;i&gt;폴스루&lt;/i&gt;를 보고합니다.  폴스루가 유용한 경우도 있으나 의도하지 않은 경우가 많으며 예상하지 못한 버그를 발생시킬 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
switch(n) {
  case 1:
    print 1
  case 2: // 'case 2'에 대한 'case 1' 폴스루 'case 2'의 구문은 'case 1' 뒤에 바로 실행됩니다.
    print 2
    break
  default:
    print "Default"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyFallthrough&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GroovyContinue" defaultSeverity="WARNING" displayName="'continue' 문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;continue&lt;/code&gt; 문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyContinue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConstantIfStatement" defaultSeverity="WARNING" displayName="상수 if 문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
bool 상수를 조건으로 가지는 &lt;code&gt;if&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (true) {
      // ...
  }
  if (false) {
      // ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyConstantIfStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySwitchStatementWithNoDefault" defaultSeverity="WARNING" displayName="default case가 없는 switch 문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;default&lt;/code&gt; 라벨을 포함하지 않는 &lt;code&gt;switch&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;
  일부 코드 관행에서는 모든 &lt;code&gt;switch&lt;/code&gt; 문에 이 라벨을 추가하도록 강제합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovySwitchStatementWithNoDefault&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="숫자 문제" path="Kotlin"><inspection shortName="KotlinBigDecimalEquals" defaultSeverity="WARNING" displayName="'BigDecimal'에서 'equals()' 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
두 개의 &lt;code&gt;java.math.BigDecimal&lt;/code&gt; 숫자를 비교하는 &lt;code&gt;==&lt;/code&gt; 혹은 &lt;code&gt;equals()&lt;/code&gt; 호출을 보고합니다.
두 개의 &lt;code&gt;java.math.BigDecimal&lt;/code&gt; 숫자는 값과 크기가 모두 동일한 경우에만 같기 때문에 이는 보통 실수입니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 조건이 false입니다
  val condition = BigDecimal("2.0") ==
      BigDecimal("2.00")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 조건이 true입니다
  val condition = BigDecimal("2.0").compareTo(
      BigDecimal("2.00")) == 0
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: KotlinBigDecimalEquals&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="종료" path="Java"><inspection shortName="Finalize" defaultSeverity="WARNING" displayName="'finalize()'는 재정의 불가" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Object.finalize()&lt;/code&gt; 메서드를 재정의하는 경우를 보고합니다.
&lt;p&gt;&lt;code&gt;Object.finalize()&lt;/code&gt; 문서에 따르면 다음과 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;
    종료화 메커니즘은 본질적으로 문제가 있습니다. 종료화는 성능 이슈, 교착상태, 중단을 초래할 수 있습니다. 파이널라이저 내 오류는 리소스 유출을 초래할 수 있습니다. 종료화가 더는 필요하지 않은 경우에도 이를 취소할 방법은 없으며, 서로 다른 객체의 &lt;code&gt;finalize&lt;/code&gt; 메서드가 호출될 때 순서가 지정되지 않습니다. 더욱이 종료자의 시점에 관해 보증할 수 없습니다. &lt;code&gt;finalize&lt;/code&gt; 메서드는 무기한 지연 후에야 최종화 가능한 객체에서 호출될 수 있습니다.
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;b&gt;자명한 'finalize()' 구현 무시&lt;/b&gt; 옵션을 사용하여 빈 메서드 본문 또는 &lt;code&gt;false&lt;/code&gt;로 평가되고 컴파일 시간 상수인 조건이 있는 &lt;code&gt;if&lt;/code&gt; 문만을 포함하는 본문의 &lt;code&gt;finalize()&lt;/code&gt; 구현을 무시합니다. 성능상의 이유로 자명하지 않은 &lt;code&gt;finalize()&lt;/code&gt;를 하위 클래스의 빈 구현으로 재정의하는 편이 더 유용할 수 있습니다. 또한 빈 final &lt;code&gt;finalize()&lt;/code&gt; 구현은 하위 클래스의 재정의를 방지하는 데 사용될 수도 있습니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: Finalize&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NoExplicitFinalizeCalls" defaultSeverity="WARNING" displayName="명시적으로 'finalize()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Object.finalize()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;&lt;code&gt;Object.finalize()&lt;/code&gt;를 명시적으로 호출할 경우 객체의 일관성이 깨질 수 있습니다.
  가비지 컬렉터는 해당 객체에 대한 참조가 없음을 확인하면 이 메서드를 자동으로 호출합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;finalize()&lt;/code&gt; 구현 내로부터의 &lt;code&gt;super.finalize()&lt;/code&gt; 호출이 정상이므로 이 검사는 해당 호출을 보고하지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  MyObject m = new MyObject();
  m.finalize();
  System.gc()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NoExplicitFinalizeCalls&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinalizeNotProtected" defaultSeverity="WARNING" displayName="'finalize()'는 public이 아닌 protected여야 함" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;public&lt;/code&gt;으로 선언된 &lt;code&gt;Object.finalize()&lt;/code&gt; 메서드의 모든 구현을 보고합니다.
&lt;p&gt;
  &lt;code&gt;Object.finalize()&lt;/code&gt;의 컨트랙트에 따라 가비지 컬렉터만 이 메서드를 호출합니다. 이 메서드를 public으로 만드는 것은 메서드가 다른 코드에서 사용될 수 있음을 의미하므로 혼동을 줄 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  다른 클래스에서 호출되는 것을 막기 위해 해당 메서드를 &lt;code&gt;protected&lt;/code&gt;로 만드는 빠른 수정이 제공됩니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;class&lt;/b&gt; X {
    &lt;b&gt;public void&lt;/b&gt; finalize() {
      /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;class&lt;/b&gt; X {
    &lt;b&gt;protected void&lt;/b&gt; finalize() {
      /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FinalizeNotProtected&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="TypeScript" path="JavaScript 및 TypeScript"><inspection shortName="TypeScriptSuspiciousConstructorParameterAssignment" defaultSeverity="WARNING" displayName="대입된 생성자 필드 매개변수" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
TypeScript 코드 내 클래스 필드가 생성자 파라미터로 선언되고 나서 이 파라미터가 대입되는 일반적인 실수를 보고합니다.&lt;br/&gt;
이 경우, 대응하는 필드는 대입되지 &lt;i&gt;않고&lt;/i&gt; 로컬 파라미터 값만 변경됩니다.
&lt;pre&gt;&lt;code&gt;
class Foo {
  constructor(private p: number) {
    p = 1; //must be this.p = 1;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptSuspiciousConstructorParameterAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptAbstractClassConstructorCanBeMadeProtected" defaultSeverity="WEAK WARNING" displayName="추상 클래스 생성자를 protected로 만들 수 있습니다" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
추상 클래스의 public 생성자를 보고하고 protected으로 만들 것을 제안합니다(public인 의미가 없기 때문에).
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptAbstractClassConstructorCanBeMadeProtected&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptRedundantGenericType" defaultSeverity="WEAK WARNING" displayName="불필요한 타입 인수" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
기본 인수와 동등하며 삭제가 가능한 타입 인수를 보고 합니다.
&lt;p&gt;
예:
&lt;pre&gt;&lt;code&gt;
type Foo&amp;lt;T=number&amp;gt; = T;
let z: Foo&amp;lt;number&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptRedundantGenericType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptMissingAugmentationImport" defaultSeverity="INFORMATION" displayName="증강 가져오기 누락" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명시적 가져오기 없이 &lt;a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation"&gt;보강 모듈&lt;/a&gt; 내 사용 위치를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptMissingAugmentationImport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptExplicitMemberType" defaultSeverity="INFORMATION" displayName="명시적 타입" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명시적 타입에 대한 현재 코드 스타일과 일치하지 않는 타입 어노테이션을 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  컨텍스트에서 추론되는 타입이 타입 어노테이션과 정확히 일치하지 않는 경우 타입 선언은 불필요합니다. 예:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    var pi: number = 3.14
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;일부 경우에는 명시적 타입을 반드시 포함하는 것이 좋습니다. 명시적 타입은 우발적 타입 변경을 방지하고 코드를 더욱 명시적으로 만듭니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptExplicitMemberType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptDuplicateUnionOrIntersectionType" defaultSeverity="WARNING" displayName="공용체 또는 교차 타입 구성 요소 중복" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
유니온 타입 또는 인터섹션 타입 내부의 중복 타입을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptDuplicateUnionOrIntersectionType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptMissingConfigOption" defaultSeverity="WARNING" displayName="tsconfig.json 옵션 누락 " enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;tsconfig.json&lt;/code&gt;에 명시적 옵션이 필요한 사용 위치를 보고합니다.
예를 들어, &lt;code&gt;.tsx&lt;/code&gt; 파일에서 JSX를 사용하려면 &lt;code&gt;tsconfig.json&lt;/code&gt;에 &lt;code&gt;'jsx'&lt;/code&gt; 프로퍼티가 포함되어야 합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptMissingConfigOption&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptUMDGlobal" defaultSeverity="WEAK WARNING" displayName="참조된 UMD 전역 변수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
현재 파일이 모듈(ECMAScript 또는 CommonJS)인 경우, Universal Module Definition (UMD) 전역 변수의 사용을 보고합니다.
명시적 import 문 없이 UMD 변수를 참조하면 라이브러리가 묵시적으로 포함되지 않은 경우 런타임 오류가 일어날 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptUMDGlobal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptCheckImport" defaultSeverity="ERROR" displayName="해결되지 않은 가져온 이름" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
TypeScript의&lt;code&gt;import&lt;/code&gt; 선언 내 해결되지 않은 이름 또는 바인딩을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptCheckImport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptLibrary" defaultSeverity="ERROR" displayName="전역 라이브러리 누락" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
심볼에 필요하지만 &lt;code&gt;tsconfig.json&lt;/code&gt; 내 &lt;code&gt;lib&lt;/code&gt; 컴파일러 옵션에 나열되어 있지 않은 TypeScript 라이브러리 파일을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptLibrary&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptFieldCanBeMadeReadonly" defaultSeverity="WEAK WARNING" displayName="필드가 읽기 전용일 수 있습니다" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
읽기 전용으로 만들 수 있는 private 필드를 보고합니다(예: 필드가 생성자에만 대입되는 경우).
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptFieldCanBeMadeReadonly&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptConfig" defaultSeverity="WARNING" displayName="일관되지 않은 tsconfig.json 프로퍼티" enabled="false" language="JSON" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
tsconfig.json 파일 내 &lt;code&gt;paths&lt;/code&gt;, &lt;code&gt;checkJs&lt;/code&gt;, 또는 &lt;code&gt;extends&lt;/code&gt; 프로퍼티의 불일치를 보고합니다.
&lt;br&gt;
&lt;code&gt;checkJs&lt;/code&gt; 프로퍼티에는 &lt;code&gt;allowJs&lt;/code&gt;가 필요합니다.
&lt;br&gt;
&lt;code&gt;extends&lt;/code&gt; 프로퍼티는 유효한 파일 참조여야 합니다.

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptConfig&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSEqualityComparisonWithCoercion.TS" defaultSeverity="WARNING" displayName="동치 연산자는 타입 강제 변환을 일으킬 수 있습니다" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
예기치 않은 타입 강제 변환을 일으킬 수 있는 상등 연산자의 사용 위치를 보고합니다.
&lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 상등 연산자를 타입 안전 &lt;code&gt;===&lt;/code&gt; 또는 &lt;code&gt;!==&lt;/code&gt; 연산자로 바꿀 것을 제안합니다.

&lt;p&gt;선택한 옵션에 따라 다음 중 하나가 보고됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 연산자의 모든 사용 위치.
  &lt;/li&gt;
  &lt;li&gt;
    null과의 비교를 제외한 모든 사용 위치. 일부 코드 스타일은 &lt;code&gt;x === null || x === undefined&lt;/code&gt; 대신 &lt;code&gt;x == null&lt;/code&gt;을 사용할 수 있도록 허용합니다.
  &lt;/li&gt;
  &lt;li&gt;
    의심스러운 표현식만(예: &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;''&lt;/code&gt;, 
&lt;code&gt;null&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, 
&lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt;와의 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 비교).
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSEqualityComparisonWithCoercion.TS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptJSXUnresolvedComponent" defaultSeverity="WEAK WARNING" displayName="해결되지 않은 JSX 구성 요소" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JSX 구성 요소에 대한 미해결 참조를 보고합니다.
참조 구성 요소가 프로젝트 또는 종속성으로 정의되어 있는 경우 import 문을 추가하거나 지정된 이름으로 새 구성 요소를 생성할 것을 권장합니다.
&lt;p&gt;새 구성 요소 템플릿을 '에디터 | 파일 및 템플릿'에서 수정할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptJSXUnresolvedComponent&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptValidateGenericTypes" defaultSeverity="ERROR" displayName="올바르지 않은 제네릭 타입 인수" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
함수, 인터페이스 또는 클래스 선언 내 유효하지 않은 타입 인수를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptValidateGenericTypes&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptValidateTypes" defaultSeverity="ERROR" displayName="타입 불일치" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
타입이 잘못된 매개변수, 반환 값, 또는 대입 표현식을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptValidateTypes&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptSmartCast" defaultSeverity="WARNING" displayName="좁혀진 타입" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
변수 타입이 타입 가드에 의해 좁혀진 변수의 사용 위치를 보고합니다.
심각도는 이 검사에 영향을 미치지 않습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptSmartCast&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeScriptUnresolvedReference" defaultSeverity="ERROR" displayName="해결되지 않은 TypeScript 참조" enabled="false" language="TypeScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
TypeScript 코드의 미해결 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeScriptUnresolvedReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="EditorConfig" path=""><inspection shortName="EditorConfigNoMatchingFiles" defaultSeverity="WARNING" displayName="일치하는 파일이 없음" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
&lt;code&gt;.editorconfig&lt;/code&gt; 파일이 위치한 디렉터리 내 모든 파일과 일치하는 패턴이 없는 와일드카드를 사용하는 섹션을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigNoMatchingFiles&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigCharClassRedundancy" defaultSeverity="WARNING" displayName="불필요한 문자 클래스" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
한 개의 문자로 구성된 문자 클래스를 보고합니다.
이러한 클래스는 &lt;code&gt;[a]&lt;/code&gt;&amp;rarr;&lt;code&gt;a&lt;/code&gt; 예와 같이 한 개의 문자로 단순화될 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigCharClassRedundancy&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigEmptyHeader" defaultSeverity="ERROR" displayName="빈 헤더" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
헤더가 빈 섹션을 보고합니다. 섹션 헤더는 &lt;code&gt;gitignore&lt;/code&gt;에서 지원하는 것과 유사한 형식의 파일 경로 glob을 포함해야 합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigEmptyHeader&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigPartialOverride" defaultSeverity="WEAK WARNING" displayName="겹치는 섹션" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
다른 섹션에 있는 다른 하위 집합과 겹치는 현재 섹션에 지정된 파일의 하위 집합을 보고합니다. 예:
&lt;code&gt;[{foo,bar}]&lt;/code&gt; 및 &lt;code&gt;[{foo,bas}]&lt;/code&gt; 모두 “foo”를 포함합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigPartialOverride&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigPatternRedundancy" defaultSeverity="WARNING" displayName="중복 또는 불필요한 패턴" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
같은 스코프의 파일 또는 더 넓은 스코프를 정의하는 다른 패턴이 이미 존재하므로 불필요한 파일 패턴을 보고합니다.
예를 들어, &lt;code&gt;[{*.java,*}]&lt;/code&gt;에서 첫 번째 &lt;code&gt;*.java&lt;/code&gt; 패턴이 &lt;code&gt;*&lt;/code&gt;에 비해 더 좁은 스코프를 정의합니다.
따라서 이 패턴은 불필요하며 제거될 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigPatternRedundancy&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigShadowingOption" defaultSeverity="WARNING" displayName="프로퍼티 재정의" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
파일 내 먼저 정의된 동일한 프로퍼티를 재정의하는 프로퍼티를 보고합니다.
&lt;p&gt;예:
&lt;pre&gt;&lt;code&gt;
[*.java]
indent_size=4
[{*.java,*.js}]
indent_size=2
&lt;/code&gt;&lt;/pre&gt;
두 번째 섹션은 &lt;code&gt;[*. java]&lt;/code&gt;와 동일한 파일을 포함하지만 indent_size 값도 2로 설정합니다.
즉, 첫 번째 선언인 &lt;code&gt;indent_size=4&lt;/code&gt;는 무시됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigShadowingOption&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigUnusedDeclaration" defaultSeverity="WARNING" displayName="사용되지 않는 선언" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
사용하지 않는 선언을 보고합니다. 이러한 선언은 제거될 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigUnusedDeclaration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigKeyCorrectness" defaultSeverity="WARNING" displayName="알 수 없는 프로퍼티" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
IDE가 지원하지 않는 프로퍼티를 보고합니다. 참고: 일부 “ij” 도메인 프로퍼티는 특정 언어 플러그인을 필요로 할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigKeyCorrectness&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigPairAcceptability" defaultSeverity="ERROR" displayName="예기치 않은 키-값 쌍" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
현재 컨텍스트에서 허용되지 않는 키-값 쌍을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigPairAcceptability&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigRootDeclarationCorrectness" defaultSeverity="ERROR" displayName="예기치 않은 최상위 선언" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
예기치 않은 최상위 선언을 보고합니다. EditorConfig 파일에서 “root=true”가 아닌 최상위 선언은 허락되지 않습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigRootDeclarationCorrectness&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EditorConfigVerifyByCore" defaultSeverity="ERROR" displayName="잘못된 .editorconfig 파일" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
백킹 EditorConfig 코어 라이브러리를 사용하여 전체 파일을 검증하고 실패하는 곳이 있으면 모두 보고합니다.
실패가 어느 곳에서든 발생하면 EditorConfig 프로퍼티가 제대로 적용되지 않습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigVerifyByCore&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EditorConfigValueCorrectness" defaultSeverity="ERROR" displayName="잘못된 프로퍼티 값" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
값 제한을 충족하지 않는 프로퍼티 값을 보고합니다. 예를 들어 일부 프로퍼티는 "true" 또는 "false" 값만 포함할 수 있으며 다른 프로퍼티는 정수만을 포함할 수 있습니다. 값이 제한된 세트의 변형을 가지는 경우 모든 변형을 확인하려면 코드 완성 기능을 사용하세요.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigValueCorrectness&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigEncoding" defaultSeverity="WARNING" displayName="파일 인코딩이 EditorConfig 문자세트와 일치하지 않습니다" enabled="false" language="" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
현재 파일 인코딩이 .editorconfig 파일의 'charset' 프로퍼티에 정의된 인코딩과 일치하는지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigEncoding&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EditorConfigMissingRequiredDeclaration" defaultSeverity="ERROR" displayName="필요한 선언이 누락되었습니다" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
필수 선언이 누락된 프로퍼티를 보고합니다. 더 자세한 내용은 문서를 참고하세요.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigMissingRequiredDeclaration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigWildcardRedundancy" defaultSeverity="WARNING" displayName="중복된 와일드카드" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
“**” 와일드카드가 동일한 섹션에서 사용되므로 불필요해진 와일드카드를 보고합니다.
&lt;p&gt;
“**” 와일드카드가 다른 와일드카드보다 더 광범위한 파일 집합을 정의합니다.
때문에, 동일한 섹션의 다른 와일드카드는 영향이 없으며 제거될 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigWildcardRedundancy&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigListAcceptability" defaultSeverity="ERROR" displayName="예기치 않은 값 목록" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
list가 지원되지 않는 프로퍼티에 사용된 값 list를 보고합니다. 이 경우 한 개의 값만 지정될 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigListAcceptability&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigUnexpectedComma" defaultSeverity="ERROR" displayName="예기치 않은 쉼표" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
현재 컨텍스트에서 사용될 수 없는 쉼표를 보고합니다. 쉼표는 목록에서 값의 구분 기호로만 허용됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigUnexpectedComma&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigEmptySection" defaultSeverity="WARNING" displayName="빈 섹션" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
EditorConfig 프로퍼티를 전혀 포함하지 않는 섹션을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigEmptySection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigNumerousWildcards" defaultSeverity="WEAK WARNING" displayName="와일드카드가 너무 많음" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
너무 많은 와일드카드를 포함하는 섹션을 보고합니다. 지나친 와일드카드 사용은 성능 이슈를 가져올 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigNumerousWildcards&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EditorConfigSpaceInHeader" defaultSeverity="WEAK WARNING" displayName="파일 패턴 내 공백" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
패턴 매칭에 영향을 주는 와일드카드 패턴 내 공백 문자를 보고합니다.
이러한 문자가 의도적인 것이 아닌 경우 문자는 제거되어야 합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigSpaceInHeader&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigPatternEnumerationRedundancy" defaultSeverity="ERROR" displayName="불필요한 중괄호" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
여러 패턴이 포함된 목록(예: &lt;code&gt;{foo,bar}&lt;/code&gt;)이 아닌 하나의 패턴만 포함된 패턴 목록(예: &lt;code&gt;{foo}&lt;/code&gt;) 또는 빈 &lt;code&gt;{}&lt;/code&gt;인 패턴 목록을 보고합니다. 이 경우 중괄호는 이름의 일부로 처리됩니다. 예를 들어,
&lt;code&gt;*.{a}&lt;/code&gt; 패턴은 &lt;code&gt;my.{a}&lt;/code&gt; 파일과 일치하지만 &lt;code&gt;my.a&lt;/code&gt;와는 일치하지 않습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigPatternEnumerationRedundancy&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigShadowedOption" defaultSeverity="WARNING" displayName="재정의된 프로퍼티" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
다른 섹션에 이미 정의된 프로퍼티를 보고합니다.
&lt;p&gt;예:
&lt;pre&gt;&lt;code&gt;
[*.java]
indent_size=4
[{*.java,*.js}]
indent_size=2
&lt;/code&gt;&lt;/pre&gt;
두 번째 섹션도 모든 &lt;code&gt;*.java&lt;/code&gt; 파일을 포함하지만 indent_size도 재정의합니다.
결과적으로 2 값이 &lt;code&gt;*.java&lt;/code&gt; 파일에 사용됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigShadowedOption&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigValueUniqueness" defaultSeverity="ERROR" displayName="고유하지 않은 목록 값" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
값 list 내 중복을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigValueUniqueness&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigOptionRedundancy" defaultSeverity="WARNING" displayName="불필요한 프로퍼티" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
다른 응용 섹션이 동일한 프로퍼티 및 값을 포함하므로 불필요한 프로퍼티를 보고합니다.
&lt;p&gt;
예:
&lt;pre&gt;&lt;code&gt;
[*]
indent_size=4
[*.java]
indent_size=4
&lt;/code&gt;&lt;/pre&gt;
두 가지 모두 &lt;code&gt;*.java&lt;/code&gt; 파일에 적용 가능하며 동일한 &lt;code&gt;indent_size&lt;/code&gt; 값을 정의합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigOptionRedundancy&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigHeaderUniqueness" defaultSeverity="WARNING" displayName="EditorConfig 섹션이 고유하지 않습니다" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
다른 섹션과 동일한 파일 패턴을 정의하는 섹션을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigHeaderUniqueness&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigDeprecatedDescriptor" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 프로퍼티" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
더 이상 지원되지 않는 EditorConfig 프로퍼티를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigDeprecatedDescriptor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigReferenceCorrectness" defaultSeverity="ERROR" displayName="잘못된 참조" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
알 수 없거나 잘못된 타입을 가진 식별자를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigReferenceCorrectness&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigCharClassLetterRedundancy" defaultSeverity="WARNING" displayName="문자 클래스의 문자 중복" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
EditorConfig 섹션에서 예를 들어 &lt;code&gt;[aa]&lt;/code&gt;와 같이 문자 클래스에서 중복된 문자를 포함하는 와일드카드 패턴을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigCharClassLetterRedundancy&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigRootDeclarationUniqueness" defaultSeverity="ERROR" displayName="추가 최상위 선언" enabled="false" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="252.23892.464" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
여러 개의 최상위 선언을 보고합니다. EditorConfig 파일에 선택적 “root=true” 최상위 선언이 하나만 있을 수 있습니다.
여러 개의 최상위 선언은 허용되지 않습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EditorConfigRootDeclarationUniqueness&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring Security" path="Spring"><inspection shortName="SpringSecurityModelInspection" defaultSeverity="ERROR" displayName="잘못된 Spring Security XML 기반 애플리케이션 컨텍스트" enabled="false" language="XML" pluginId="com.intellij.spring.security" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href="https://spring.io/projects/spring-security"&gt;Spring Security&lt;/a&gt; XML 기반의 컨텍스트 관련 이슈를 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;해결되지 않은 bean 참조&lt;/li&gt;
  &lt;li&gt;필요한 태그 또는 속성 누락&lt;/li&gt;
  &lt;li&gt;잘못된 프로퍼티 타입&lt;/li&gt;
  &lt;li&gt;일관성 없는 &lt;code&gt;enum&lt;/code&gt; 프로퍼티&lt;/li&gt;
  &lt;li&gt;참조된 bean의 잘못된 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;또한 다음 이슈를 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&amp;lt;https&amp;gt; 구성 오류
    &lt;ul&gt;
      &lt;li&gt;'/**' 패턴이 있는 &amp;lt;http&amp;gt;는 마지막이어야 합니다&lt;/li&gt;
      &lt;li&gt;'pattern'이 없는 다중 &amp;lt;http&amp;gt; 요소는 허용되지 않습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&amp;lt;http&amp;gt; 구성 오류
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;security='none'&lt;/code&gt;일 경우 빈 태그&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&amp;lt;user-service&amp;gt;
    &lt;ul&gt;
      &lt;li&gt;속성 'properties' 또는 &amp;lt;user&amp;gt; 요소 목록을 포함해야 합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&amp;lt;ldap-server&amp;gt;
    &lt;ul&gt;
      &lt;li&gt;'manager-dn' 사용 시 'manager-password'가 필요합니다&lt;/li&gt;
      &lt;li&gt;'user-context-mapper-ref' 또는 'user-details-class'를 포함해야 합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt; &amp;lt;authentication-provider&amp;gt;
    &lt;ul&gt;
      &lt;li&gt;사용자 서비스의 한 종류만 허용됩니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&amp;lt;global-method-security&amp;gt;
    &lt;ul&gt;
      &lt;li&gt;&amp;lt;pre-post-annotation-handling&amp;gt;을 사용하려면 'pre-post-annotations'에 'enabled' 값이 있어야 합니다&lt;/li&gt;
      &lt;li&gt;값이 'aspectj'인 'mode'는 &amp;lt;protect-pointcut&amp;gt; 및 &amp;lt;intercept-url&amp;gt;에 사용할 수 없습니다&lt;/li&gt;
      &lt;li&gt;'requires-channel' 속성은 상위 &amp;lt;http&amp;gt;에만 허용됩니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&amp;lt;protect&amp;gt;
    &lt;ul&gt;
      &lt;li&gt;&amp;lt;protect&amp;gt;와 &amp;lt;global-method-security&amp;gt;의 혼합은 권장되지 않습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringSecurityModelInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringSecurityDebugActivatedInspection" defaultSeverity="WARNING" displayName="Spring Security 구성에서 디버그 모드가 활성화되어 있습니다" enabled="false" language="XML" pluginId="com.intellij.spring.security" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;민감한 정보를 노출할 수 있는 활성화된 &lt;strong&gt;&amp;lt;debug&amp;gt;&lt;/strong&gt;를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringSecurityDebugActivatedInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringSecurityMethodCallsInspection" defaultSeverity="WARNING" displayName="@PreFilter/@PreAuthorize/@PostFilter 자기 호출 메서드 호출" enabled="false" language="UAST" pluginId="com.intellij.spring.security" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
@PreFilter/@PostFilter/@PreAuthorize 사용: 프록시 모드(디폴트)에서는 프록시를 통해 들어오는 외부 메서드 호출만 인터셉트됩니다.
즉, 자기 호출(타깃 객체의 다른 메서드를 호출하는 타깃 객체 내의 메서드)은 호출된 메서드가 @PreFilter/@PostFilter/@PreAuthorize로 표시되어도 런타임 시 동작하지 않습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringSecurityMethodCallsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringSecurityAnnotationBeanPointersResolveInspection" defaultSeverity="ERROR" displayName="Spring Security 어노테이션에서 참조된 잘못된 Spring Bean 구성" enabled="false" language="JAVA" pluginId="com.intellij.spring.security" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href="https://spring.io/projects/spring-security"&gt;Spring Security&lt;/a&gt; 어노테이션에 참조된 Spring bean 중 해결되지 않은 bean을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;pre&gt;&lt;code&gt;@WithUserDetails(value = "admin", userDetailsServiceBeanName = "unknownUserDetailsService")
      // 'unknownUserDetailsService'가 Spring 모델에 정의되어 있지 않은 경우 "'unknownUserDetailsService' bean을 해결할 수 없습니다"라고 보고됩니다
    &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;pre&gt;&lt;code&gt;@WithUserDetails(value = "admin", userDetailsServiceBeanName = "jpaUserDetailsService")
      //"Bean은 'org.springframework.security.core.userdetails.UserDetailsService' 타입이어야 합니다"
      // 'jpaUserDetailsService' bean이 'UserDetailsService' 타입이 아닌 경우 보고됩니다
    &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringSecurityAnnotationBeanPointersResolveInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="데이터 흐름" path="JavaScript 및 TypeScript"><inspection shortName="UnnecessaryLocalVariableJS" defaultSeverity="WARNING" displayName="중복 지역 변수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
함수를 더 쉽게 이해하는 데 도움이 되지 않는 다음과 같은 불필요한 지역 변수를 보고합니다. &lt;ul&gt;
&lt;li&gt;즉시 반환되는 지역 변수&lt;/li&gt;
&lt;li&gt;다른 변수로 즉시 대입되어 더 이상 사용되지 않는 지역 변수&lt;/li&gt;
&lt;li&gt;다른 지역 변수 또는 매개변수와 항상 같은 값을 가지는 지역 변수&lt;/li&gt;&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
아래 체크박스를 사용하여 이 검사가 즉시 반환되거나 던져지는 변수를 무시하도록 하십시오.  일부 코드 스타일은 명확도와 디버그 용이성을 위해 
그러한 변수를 사용할 것을 제안합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryLocalVariableJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReuseOfLocalVariableJS" defaultSeverity="WARNING" displayName="지역 변수 재사용" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지역 변수 재사용 및 원래 변수의 사용과는 관계없는 새 값으로 해당 변수 덮어쓰기를 보고합니다.  지역 변수의 의도된 의미가 각 사용 위치에 따라 다를 수 있으므로
이러한 방식의 지역 변수 재사용은 혼란을 일으킬 수 있습니다.  또한 코드 변경으로 인해 값이 사용되고 있는 도중에 덮어쓰기되는 버그를 일으킬 수 있습니다.   변수의 수명을 가능한 한 짧게 유지하고 코드 간결성을 위해 지역 변수를 재사용하지 않는 것이 좋습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReuseOfLocalVariableJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="이식성" path="Java"><inspection shortName="UseOfJDBCDriverClass" defaultSeverity="WARNING" displayName="구체 JDBC 드라이버 클래스 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
특정한 JDBC 드라이버 클래스를 보고합니다. 이 클래스를 사용하면 프로젝트가 특정한 데이터베이스와 드라이버에 연결되어 JDBC의 목적이 무의미해지며 결과적으로 이동할 수 없습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.sql.Driver;

  abstract class Sample implements Driver {
    public void foo() {
        Sample sample;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UseOfJDBCDriverClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfSunClasses" defaultSeverity="WARNING" displayName="'sun.*' 클래스 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;sun.*&lt;/code&gt; 계층 구조에 있는 클래스의 사용을 보고합니다.
그러한 클래스는 서로 다른 JVM 간에 이식이 불가능합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UseOfSunClasses&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemGetenv" defaultSeverity="WARNING" displayName="'System.getenv()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;System.getenv()&lt;/code&gt; 호출을 보고합니다.
&lt;code&gt;System.getenv()&lt;/code&gt; 호출은 본질적으로 이식성이 없습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SystemGetenv&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfAWTPeerClass" defaultSeverity="WARNING" displayName="AWT 피어 클래스 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
AWT peer 클래스의 사용을 보고합니다. 이 클래스는 네이티브 윈도우 시스템 위젯을 나타내며, 다른 윈도우 시스템 간에 이동할 수 없습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.awt.peer.ButtonPeer;

  abstract class Sample implements ButtonPeer {
    public void foo() {
        Sample sample;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UseOfAWTPeerClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HardcodedLineSeparators" defaultSeverity="WARNING" displayName="하드코딩된 줄 구분 기호" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자열 리터럴, 문자 리터럴 또는 텍스트 블록에서 사용된 라인피드(&lt;code&gt;\n&lt;/code&gt;) 및 캐리지 반환(&lt;code&gt;\r&lt;/code&gt;) 문자 이스케이프 시퀀스를 보고합니다. 이러한 문자는 줄 구분 기호로 흔히 사용되며, 하드 코딩된 경우 이식성에 문제가 발생할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String count = "first\nsecond\rthird";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: HardcodedLineSeparators&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemExit" defaultSeverity="WARNING" displayName="'System.exit()' 또는 관련 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;System.exit()&lt;/code&gt;, &lt;code&gt;Runtime.exit()&lt;/code&gt; 및 &lt;code&gt;Runtime.halt()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  &lt;code&gt;System.exit()&lt;/code&gt; 또는 &lt;code&gt;Runtime.exit()&lt;/code&gt; 을 호출하면 셧다운 훅을 호출하고 현재 실행 중인 Java 가상 머신을 종료합니다. &lt;code&gt;Runtime.halt()&lt;/code&gt;를 강제적으로 호출하면 셧다운 훅을 시작하지 않고 JVM을 종료합니다.
  각 메서드는 매우 주의해서 사용해야 합니다. 이 메서드 호출은 호출 코드를 대부분의 애플리케이션 서버에 이동할 수 없게 합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  옵션을 사용하여 main 메서드에서 호출을 무시합니다.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SystemExit&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NativeMethods" defaultSeverity="WARNING" displayName="네이티브 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;native&lt;/code&gt;로 선언된 메서드를 보고합니다. 네이티브 메서드는 본질적으로 이식성이 없습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NativeMethods&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RuntimeExec" defaultSeverity="WARNING" displayName="'Runtime.exec()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Runtime.exec()&lt;/code&gt; 호출 또는 그 변형을 보고합니다.
&lt;code&gt;Runtime.exec()&lt;/code&gt; 호출은 본질적으로 이식성이 없습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RuntimeExec&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HardcodedFileSeparators" defaultSeverity="WARNING" displayName="하드코딩된 파일 구분 기호" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자열 또는 문자 리터럴에서 정방향 슬래시(&lt;code&gt;/&lt;/code&gt;) 또는 역슬래시(&lt;code&gt;\&lt;/code&gt;)를 보고합니다. 이러한 문자는 파일 구분 기호로 흔히 사용되며, 하드 코딩된 경우 이식성에 문제가 발생할 수 있습니다.
&lt;p&gt;
  이 검사는 이스케이프 시퀀스 내의 역슬래시와 '&amp;lt;' 문자 바로 뒤 또는 '&amp;gt;' 문자 바로 앞의 정방향 슬래시를 보고하지 않습니다. 슬래시는 종종 파일 이름이 아닌 XML 또는 HTML 태그를 나타내기 때문입니다.
  &lt;code&gt;java.util.TimeZone&lt;/code&gt; ID를 나타내는 문자열, 유효한 정규 표현식 또는 IANA 등록 MIME 미디어 유형과 동일한 문자열도 보고하지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new File("C:\\Users\\Name");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 옵션을 사용하여, 인식된 미디어 타입 집합에 &lt;code&gt;example/*&lt;/code&gt;를 포함시킵니다.
  일반적으로 example의 외부(예: &lt;code&gt;Content-Type&lt;/code&gt; 헤더 내)에서 &lt;code&gt;example/*&lt;/code&gt; MIME 미디어 타입을 사용하는 것은 오류입니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: HardcodedFileSeparators&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfProcessBuilder" defaultSeverity="WARNING" displayName="'java.lang.ProcessBuilder' 클래스 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
운영체제 간에 이식이 불가능할 수 있는 &lt;code&gt;java.lang.ProcessBuilder&lt;/code&gt; 사용을 보고합니다. 이식이 불가능한 이유는 실행 파일 경로, 환경 변수, 명령줄 인수 그리고 이러한 항목의 이스케이프 처리가 운영체제에 따라 다를 수 있기 때문입니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UseOfProcessBuilder&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="복제 문제" path="Java"><inspection shortName="CloneableImplementsClone" defaultSeverity="WARNING" displayName="'clone()' 메서드가 없는 cloneable 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;clone()&lt;/code&gt; 메서드를 재정의하지 않는 &lt;code&gt;Cloneable&lt;/code&gt; 인터페이스를 구현하는 클래스를 보고합니다.
&lt;p&gt;그러한 클래스는 &lt;code&gt;public&lt;/code&gt;이 아니라 &lt;code&gt;protected&lt;/code&gt;이며 클래스의 가변 상태를 복사하지 않는 &lt;code&gt;clone()&lt;/code&gt;의 디폴트 구현을 사용합니다.&lt;/p&gt;
&lt;p&gt;기본 &lt;code&gt;clone()&lt;/code&gt; 메서드를 생성하는 빠른 수정을 사용할 수 있습니다. 이 메서드는 &lt;code&gt;Cloneable&lt;/code&gt; 클래스에 필요한 제대로 기능하는 &lt;code&gt;clone()&lt;/code&gt; 메서드의 기초로서 사용될 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Data &lt;b&gt;implements&lt;/b&gt; Cloneable {
    &lt;b&gt;private&lt;/b&gt; String[] names;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Data &lt;b&gt;implements&lt;/b&gt; Cloneable {
    &lt;b&gt;private&lt;/b&gt; String[] names;

    @Override
    &lt;b&gt;public&lt;/b&gt; Data clone() {
      &lt;b&gt;try&lt;/b&gt; {
        Data clone = (Data) &lt;b&gt;super&lt;/b&gt;.clone();
        // TODO: 여기서 가변 상태를 복사하므로 clone이 원래 클래스의 내부를 변경하지 못합니다
        &lt;b&gt;return&lt;/b&gt; clone;
      } &lt;b&gt;catch&lt;/b&gt; (CloneNotSupportedException e) {
        &lt;b&gt;throw new&lt;/b&gt; AssertionError();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!--
Note for translators: the text of the TODO comment in the example code above comes from
community/plugins/InspectionGadgets/InspectionGadgetsAnalysis/resources/messages/InspectionGadgetsBundle.properties
property key: cloneable.class.without.clone.todo.message
--&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;code&gt;Cloneable&lt;/code&gt; 클래스를 상속받기 때문에 &lt;code&gt;Cloneable&lt;/code&gt;인 클래스를 무시하려면 &lt;b&gt;상속으로 인해 복제 가능한 클래스 무시&lt;/b&gt; 옵션을 사용하세요.&lt;/p&gt;
&lt;p&gt;상위 클래스에서 &lt;code&gt;clone()&lt;/code&gt; 메서드를 호출하기 때문에 &lt;code&gt;Cloneable&lt;/code&gt;을 구현할 것을 요구하는 클래스를 무시하려면 &lt;b&gt;상위 클래스의 clone() 메서드를 호출하는 데 Cloneable이 필요한 경우 무시&lt;/b&gt; 옵션을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CloneableImplementsClone&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonPublicClone" defaultSeverity="WARNING" displayName="'clone()' 메서드가 'public'이 아님" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;public&lt;/code&gt;이 아니라 &lt;code&gt;protected&lt;/code&gt;인 &lt;code&gt;clone()&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;의 &lt;code&gt;clone()&lt;/code&gt; 메서드를 재정의하는 경우, 패키지 외부의 하위 클래스가 아닌 객체에서 접근 가능하도록 메서드를 &lt;code&gt;public&lt;/code&gt;으로 만들어야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonPublicClone&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneDeclaresCloneNotSupported" defaultSeverity="WARNING" displayName="'clone()'이 'CloneNotSupportedException'을 선언하지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;throws CloneNotSupportedException&lt;/code&gt;을 선언하지 않는 &lt;code&gt;clone()&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;&lt;code&gt;throws CloneNotSupportedException&lt;/code&gt;이 선언되지 않은 경우, 메서드의 하위 클래스는 표준 방식의 복제를 금지할 수 없습니다. 이 검사는 &lt;code&gt;final&lt;/code&gt;을 선언한 &lt;code&gt;clone()&lt;/code&gt; 메서드 및 &lt;code&gt;final&lt;/code&gt; 클래스에 사용된 &lt;code&gt;clone()&lt;/code&gt; 메서드는 보고하지 않습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;이 검사가 &lt;code&gt;protected clone()&lt;/code&gt; 메서드에 대해서만 경고를 생성해야 함을 나타내려면 &lt;b&gt;Only warn on 'protected' clone methods('protected' 복제 메서드에 대해서만 경고)&lt;/b&gt; 옵션을 사용하세요.
&lt;i&gt;이펙티브 자바&lt;/i&gt; 책 (2판 및 3판) 에서는 &lt;code&gt;public&lt;/code&gt; 메서드에서 &lt;code&gt;CloneNotSupportedException&lt;/code&gt;을 생략할 것을 권장합니다. 이는 확인된 예외를 던지지 않는 메서드를 사용하는 것이 더 쉽기 때문입니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Example &lt;b&gt;implements&lt;/b&gt; Cloneable {
    // 메서드가 'throws CloneNotSupportedException'을 선언하지 않음
    &lt;b&gt;protected&lt;/b&gt; Object clone() {
        &lt;b&gt;try&lt;/b&gt; {
            &lt;b&gt;return&lt;/b&gt; &lt;b&gt;super&lt;/b&gt;.clone();
        } &lt;b&gt;catch&lt;/b&gt; (CloneNotSupportedException e) {
            &lt;b&gt;return&lt;/b&gt; null;
        }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: CloneDeclaresCloneNotSupported&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneReturnsClassType" defaultSeverity="WARNING" displayName="'clone()'에는 포함된 클래스와 동일한 반환 타입이 있어야 함" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
반환 타입이 자신이 위치한 클래스의 타입과 다른 &lt;code&gt;clone()&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;보통 &lt;code&gt;clone()&lt;/code&gt; 메서드의 반환 타입은 &lt;code&gt;java.lang.Object&lt;/code&gt;이며, 이는 클라이언트가 메서드를 사용하기 힘들게 만듭니다.
&lt;i&gt;Effective Java&lt;/i&gt;(2판 및 3판)에서는 &lt;code&gt;clone()&lt;/code&gt; 메서드의 반환 타입을, 반환하는 객체의 클래스 타입과 같게 만들 것을 권장합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;class&lt;/b&gt; Foo &lt;b&gt;implements&lt;/b&gt; Cloneable {
    &lt;b&gt;public&lt;/b&gt; Object clone() {
      &lt;b&gt;try&lt;/b&gt; {
        &lt;b&gt;return&lt;/b&gt; super.clone();
      } &lt;b&gt;catch&lt;/b&gt; (CloneNotSupportedException e) {
        &lt;b&gt;throw new&lt;/b&gt; AssertionError();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;class&lt;/b&gt; Foo &lt;b&gt;implements&lt;/b&gt; Cloneable {
    &lt;b&gt;public&lt;/b&gt; Foo clone() {
      &lt;b&gt;try&lt;/b&gt; {
        &lt;b&gt;return&lt;/b&gt; (Foo)super.clone();
      } &lt;b&gt;catch&lt;/b&gt; (CloneNotSupportedException e) {
        &lt;b&gt;throw new&lt;/b&gt; AssertionError();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CloneReturnsClassType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfClone" defaultSeverity="WARNING" displayName="'clone()' 또는 'Cloneable' 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;clone()&lt;/code&gt; 메서드 호출 및 구현과 &lt;code&gt;java.lang.Cloneable&lt;/code&gt; 인터페이스의 사용을 보고합니다.
&lt;p&gt;일부 코딩 표준에서는 &lt;code&gt;clone()&lt;/code&gt;의 사용을 금지하며 대신 복사 생성자 또는 &lt;code&gt;static&lt;/code&gt; factory 메서드를 사용할 것을 권장합니다.&lt;/p&gt;
&lt;p&gt;배열을 복사하기 위한 정확하고 간략한 방법이기 때문에 이 검사는 배열에서의 &lt;code&gt;clone()&lt;/code&gt; 호출을 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Copy implements Cloneable /*경고*/ {

    public Copy clone() /*경고*/ {
      try {
        return (Copy) super.clone(); // 경고
      } catch (CloneNotSupportedException e) {
        throw new AssertionError();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UseOfClone&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneInNonCloneableClass" defaultSeverity="WARNING" displayName="복제할 수 없는 클래스의 'clone()' 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;clone()&lt;/code&gt; 메서드를 재정의하지만 &lt;code&gt;Cloneable&lt;/code&gt; 인터페이스를 구현하지 않는 클래스를 보고합니다.
이러한 클래스는 보통 프로그래밍 오류를 나타냅니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;public&lt;/code&gt;이 아닌 메서드를 무시하려면 &lt;b&gt;'public' 복제 메서드에 대해서만 경고&lt;/b&gt; 옵션을 사용하세요.&lt;/p&gt;
&lt;p&gt;상속받도록 설계된 클래스의 경우 &lt;code&gt;Cloneable&lt;/code&gt; 인터페이스를 구현하지 않고 &lt;code&gt;clone()&lt;/code&gt;를 재정의하여 &lt;code&gt;protected&lt;/code&gt;로 선언하도록 선택할 수 있으며 하위 클래스에 &lt;code&gt;Cloneable&lt;/code&gt; 인터페이스를 구현할지 여부를 결정할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CloneInNonCloneableClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneCallsConstructors" defaultSeverity="WARNING" displayName="'clone()'이 생성자로 객체 인스턴스화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;clone()&lt;/code&gt; 메서드 내부의 객체 생성자 호출을 보고합니다.
&lt;p&gt;다음 서브클래싱을 위해 지원하기 위해 객체를 직접 생성하는 대신 &lt;code&gt;clone()&lt;/code&gt; 메서드 내부의 객체를 인스턴스화하는 &lt;code&gt;clone()&lt;/code&gt;을 호출하는 것이 좋은 사례로 간주됩니다.
이 검사는 &lt;code&gt;final&lt;/code&gt;로 선언된 &lt;code&gt;clone()&lt;/code&gt; 메서드 또는&lt;code&gt;final&lt;/code&gt; 클래스의 &lt;code&gt;clone()&lt;/code&gt; 메서드는 보고하지 않습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CloneCallsConstructors&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="GitLab CI/CD" path=""><inspection shortName="DuplicatedJobUsage" defaultSeverity="ERROR" displayName="중복된 잡 사용 위치" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.gitlab" pluginVersion="252.23892.515-IU" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  GitLab CI/CD 구성 파일 내에서 중복되는 잡 사용 위치를 탐지합니다.
&lt;/p&gt;
&lt;p&gt;
  잡 참조에 관한 자세한 정보는 &lt;a href="https://docs.gitlab.com/ee/ci/jobs/index.html"&gt;GitLab 문서&lt;/a&gt;를 참조하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DuplicatedJobUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UndefinedStage" defaultSeverity="ERROR" displayName="정의되지 않은 단계" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.gitlab" pluginVersion="252.23892.515-IU" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  GitLab CI/CD 구성 파일 내에서 해결되지 않은 스테이지 참조를 탐지합니다.
&lt;/p&gt;
&lt;p&gt;
  스테이지 참조에 관한 자세한 정보는 &lt;a href="https://docs.gitlab.com/ee/ci/yaml/index.html#stages"&gt;GitLab 문서&lt;/a&gt;를 참조하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UndefinedStage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UndefinedJob" defaultSeverity="ERROR" displayName="정의되지 않은 잡" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.gitlab" pluginVersion="252.23892.515-IU" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  GitLab CI/CD 구성 파일 내에서 해결되지 않은 잡 참조를 탐지합니다.
&lt;/p&gt;
&lt;p&gt;
  잡 참조에 관한 자세한 정보는 &lt;a href="https://docs.gitlab.com/ee/ci/jobs/index.html"&gt;GitLab 문서&lt;/a&gt;를 참조하세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UndefinedJob&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="TOML" path=""><inspection shortName="TomlUnresolvedReference" defaultSeverity="WARNING" displayName="해결되지 않은 참조" enabled="false" language="TOML" pluginId="org.toml.lang" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
TOML 파일 내에서 해결되지 않은 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TomlUnresolvedReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="TestNG" path="Java"><inspection shortName="DuplicatedDataProviderNames" defaultSeverity="ERROR" displayName="중복된 데이터 제공자 이름" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;org.testng.TestNGException&lt;/code&gt;가 발생한 경우 이름이 같은 &lt;code&gt;TestNG&lt;/code&gt; 데이터 공급자를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class DuplicatedDataProviders {
    @DataProvider
    public Object[][] intTestData() { // 중복 1
      return new Integer[][]{
        new Integer[]{1, 1},
      };
    }

    @DataProvider(name = "intTestData")
    public Object[][] someTestData() { // 중복 2
      return new Integer[][]{
        new Integer[]{1, 1},
      };
    }

    @Test(dataProvider = "intTestData")
    public void testIsOK(Integer key, Integer value) {
      assertEquals(key, value);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DuplicatedDataProviderNames&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertJavadoc" defaultSeverity="WARNING" displayName="TestNG Javadoc을 어노테이션으로 변환 가능" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
Javadoc 어노테이션을 사용하여 TestNG 테스트를 어셜션하고 JDK 어노테이션으로 변환합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
    * @testng.before-test
  */
  public void sample() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @BeforeTest
  public void sample() {}
&lt;/code&gt;&lt;/pre&gt;
    &lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConvertJavadoc&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="JUnitTestNG" defaultSeverity="WARNING" displayName="JUnit 테스트를 TestNG로 변환 가능" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
TestNG 기반 유닛 테스트로 변환할 수 있는 JUnit 기반 테스트 클래스를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import org.junit.Test;
import static org.junit.Assert.*;

public class ExampleTest {
  @Test
  public void testExample(){
    assertEquals(2 + 2, 4);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import org.testng.Assert;
import org.testng.annotations.Test;

public class ExampleTest {
  @Test
  public void testExample(){
    Assert.assertEquals(4, 2 + 2);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JUnitTestNG&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DataProviderReturnType" defaultSeverity="ERROR" displayName="잘못된 데이터 제공자 반환 타입" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Object[][]&lt;/code&gt; 또는 &lt;code&gt;Iterator&amp;lt;Object&amp;gt;&lt;/code&gt;를 반환하지 않는 &lt;code&gt;@DataProvider&lt;/code&gt; 어노테이션으로 표시된 메서드를 보고합니다.
다른 타입이 반환된 경우, TestNG가 예외를 던집니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class TestNgTest {
  @DataProvider(name = "Languages")
  List&amp;lt;String&amp;gt; getData() {
    return List.of("Java", "Kotlin");
  }

  @Test(dataProvider = "Languages")
  public void testData(String language) {
    System.out.println(language);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DataProviderReturnType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UndeclaredTests" defaultSeverity="WARNING" displayName="선언되지 않은 테스트" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;testing.xml&lt;/code&gt;에 등록되어 있지 않은 테스트 클래스를 보고합니다. 그러한 테스트는 실행되지 않기 때문에 이는 보통 실수입니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UndeclaredTests&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertOldAnnotations" defaultSeverity="WARNING" displayName="오래된 TestNG 어노테이션 @Configuration이 사용됨" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
TestNG &lt;code&gt;org.testng.annotations.Configuration&lt;/code&gt; 어노테이션을 보고합니다.
&lt;p&gt;최신 &lt;code&gt;@BeforeXXX&lt;/code&gt;/&lt;code&gt;@AfterXXX&lt;/code&gt; 어노테이션으로 테스트 스위트를 구성하는 것이 더 낫습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Test {
    @Configuration(beforeSuite = true, afterTest = true)
    public void afterBefore(){
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Test {
    @AfterTest()
    @BeforeSuite()
    public void afterBefore(){
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConvertOldAnnotations&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="dependsOnMethodTestNG" defaultSeverity="WARNING" displayName="'dependsOnMethods'에 잘못된 메서드 이름이 전달됨" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
&lt;code&gt;@Test&lt;/code&gt; 어노테이션 내 &lt;code&gt;dependsOnMethods&lt;/code&gt; 속성으로 전달된 잘못된 메서드 이름을 보고합니다.
&lt;p&gt;메서드 이름이 현재 클래스 또는 부모 클래스 중 하나에서 액세스 가능하며 &lt;code&gt;@Test&lt;/code&gt; 어노테이션이 추가된 유효한 메서드로 해결될 수 없는 경우 해당 메서드 이름은 잘못된 것으로 간주됩니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class SampleTest {
    @Test(dependsOnMethods = "testSpellignError")
    public void testSample() {}
    @Test
    public void testSpellingError(){}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: dependsOnMethodTestNG&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
</inspection><inspection shortName="groupsTestNG" defaultSeverity="WARNING" displayName="정의되지 않은 그룹 이름" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
&lt;code&gt;@Test&lt;/code&gt; 어노테이션 내 &lt;code&gt;dependsOnGroups&lt;/code&gt; 또는 &lt;code&gt;groups&lt;/code&gt; 속성으로 전달된 정의되지 않은 그룹 이름을 보고하세요.
&lt;p&gt;빠른 수정은 정의되지 않은 이름을 알려진 그룹 목록에 추가합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;정의된 그룹&lt;/b&gt; 필드를 사용해 쉼표로 구분된 알려진 그룹 목록을 정의하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: groupsTestNG&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="ExpectedExceptionNeverThrownTestNG" defaultSeverity="WARNING" displayName="테스트 메서드 본문에 필요한 예외가 던져지지 않음" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 본문 내부에서 절대 던져지지 않으며 TestNG 테스트 메서드에 의해 기대되는 확인된 예외를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test(expectedExceptions = Exception.class) // 경고: 기대되는 'Exception'이 던져지지 않음
  public void testEngineIsRunning() {
    assertTrue(engine.isRunning());
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExpectedExceptionNeverThrownTestNG&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MalformedDataProvider" defaultSeverity="WARNING" displayName="데이터 제공자 문제" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
존재하지 않거나 액세스할 수 없는 데이터 공급자 메서드 참조를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class InstanceDataProviderFromForeignClass {
  // 메서드 data()가 클래스 A에 존재하지 않음
  @Test(dataProvider = "data", dataProviderClass = A.class)
  public void test() {
  }
}
class A { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
//필요한 data() 메서드가 클래스 A에서 생성됨
class A {
  @DataProvider
  public Object[][] data() {
    return new Object[][]{};
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MalformedDataProvider&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Android Lint: Security" path=""><inspection shortName="AndroidLintJavascriptInterface" defaultSeverity="ERROR" displayName="Missing @JavascriptInterface on methods" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing @JavascriptInterface on methods&lt;br&gt;&lt;br&gt;As of API 17, you must annotate methods in objects registered with the &lt;code&gt;addJavascriptInterface&lt;/code&gt; method with a &lt;code&gt;@JavascriptInterface&lt;/code&gt; annotation.&lt;br&gt;&lt;br&gt;Issue id: JavascriptInterface&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface(java.lang.Object, java.lang.String)"&gt;https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface(java.lang.Object, java.lang.String)&lt;/a&gt;&lt;br&gt;&lt;a href="https://goo.gle/JavascriptInterface"&gt;https://goo.gle/JavascriptInterface&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMutableImplicitPendingIntent" defaultSeverity="ERROR" displayName="Mutable Implicit PendingIntent is disallowed" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mutable Implicit PendingIntent is disallowed&lt;br&gt;&lt;br&gt;Apps targeting Android 14 and above are not allowed to create &lt;code&gt;PendingIntents&lt;/code&gt; with &lt;code&gt;FLAG_MUTABLE&lt;/code&gt; and an implicit intent within for security reasons.&lt;br/&gt;
&lt;br/&gt;
To retrieve an existing PendingIntent, use &lt;code&gt;FLAG_NO_CREATE&lt;/code&gt;. To create a new &lt;code&gt;PendingIntent&lt;/code&gt;, either make the intent explicit, or make it immutable with &lt;code&gt;FLAG_IMMUTABLE&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: MutableImplicitPendingIntent&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGrantAllUris" defaultSeverity="WARNING" displayName="Content provider shares everything" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Content provider shares everything&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;grant-uri-permission&gt;&lt;/code&gt; element allows specific paths to be shared. This detector checks for a path URL of just '/' (everything), which is probably not what you want; you should limit access to a subset.&lt;br&gt;&lt;br&gt;Issue id: GrantAllUris&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/GrantAllUris"&gt;https://goo.gle/GrantAllUris&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSignatureOrSystemPermissions" defaultSeverity="WARNING" displayName="Declaring signatureOrSystem permissions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Declaring signatureOrSystem permissions&lt;br&gt;&lt;br&gt;The &lt;code&gt;signature&lt;/code&gt; protection level should probably be sufficient for most needs and works regardless of where applications are installed. The &lt;code&gt;signatureOrSystem&lt;/code&gt; level is used for certain situations where multiple vendors have applications built into a system image and need to share specific features explicitly because they are being built together.&lt;br&gt;&lt;br&gt;Issue id: SignatureOrSystemPermissions&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPermissionNamingConvention" defaultSeverity="WARNING" displayName="Permission name does not follow recommended convention" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission name does not follow recommended convention&lt;br&gt;&lt;br&gt;Permissions should be prefixed with an app's package name, using reverse-domain-style naming. This prefix should be followed by &lt;code&gt;.permission.&lt;/code&gt;, and then a description of the capability that the permission represents, in upper SNAKE_CASE. For example, &lt;code&gt;com.example.myapp.permission.ENGAGE_HYPERSPACE&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Following this recommendation avoids naming collisions, and helps clearly identify the owner and intention of a custom permission.&lt;br&gt;&lt;br&gt;Issue id: PermissionNamingConvention&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeletedProvider" defaultSeverity="ERROR" displayName="Using Deleted Provider" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Deleted Provider&lt;br&gt;&lt;br&gt;The &lt;code&gt;Crypto&lt;/code&gt; provider has been completely removed in Android P (and was deprecated in an earlier release). This means that the code will throw a &lt;code&gt;NoSuchProviderException&lt;/code&gt; and the app will crash. Even if the code catches that exception at a higher level, this is not secure and should not be used.&lt;br&gt;&lt;br&gt;Issue id: DeletedProvider&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html"&gt;https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html&lt;/a&gt;&lt;br&gt;&lt;a href="https://goo.gle/DeletedProvider"&gt;https://goo.gle/DeletedProvider&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeNativeCodeLocation" defaultSeverity="WARNING" displayName="Native code outside library directory" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Native code outside library directory&lt;br&gt;&lt;br&gt;In general, application native code should only be placed in the application's library directory, not in other locations such as the res or assets directories. Placing the code in the library directory provides increased assurance that the code will not be tampered with after application installation. Application developers should use the features of their development environment to place application native libraries into the lib directory of their compiled APKs. Embedding non-shared library native executables into applications should be avoided when possible.&lt;br&gt;&lt;br&gt;Issue id: UnsafeNativeCodeLocation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBadHostnameVerifier" defaultSeverity="WARNING" displayName="Insecure HostnameVerifier" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure HostnameVerifier&lt;br&gt;&lt;br&gt;This check looks for implementations of &lt;code&gt;HostnameVerifier&lt;/code&gt; whose &lt;code&gt;verify&lt;/code&gt; method always returns true (thus trusting any hostname) which could result in insecure network traffic caused by trusting arbitrary hostnames in TLS/SSL certificates presented by peers.&lt;br&gt;&lt;br&gt;Issue id: BadHostnameVerifier&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/BadHostnameVerifier"&gt;https://goo.gle/BadHostnameVerifier&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUsingHttp" defaultSeverity="WARNING" displayName="Using HTTP instead of HTTPS" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using HTTP instead of HTTPS&lt;br&gt;&lt;br&gt;The Gradle Wrapper is available both via HTTP and HTTPS. HTTPS is more secure since it protects against man-in-the-middle attacks etc. Older projects created in Android Studio used HTTP but we now default to HTTPS and recommend upgrading existing projects.&lt;br&gt;&lt;br&gt;Issue id: UsingHttp&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/UsingHttp"&gt;https://goo.gle/UsingHttp&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAcceptsUserCertificates" defaultSeverity="WARNING" displayName="Allowing User Certificates" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Allowing User Certificates&lt;br&gt;&lt;br&gt;Allowing user certificates could allow eavesdroppers to intercept data sent by your app, which could impact the privacy of your users. Consider nesting your app's &lt;code&gt;trust-anchors&lt;/code&gt; inside a &lt;code&gt;&amp;lt;debug-overrides&gt;&lt;/code&gt; element to make sure they are only available when &lt;code&gt;android:debuggable&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AcceptsUserCertificates&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/AcceptsUserCertificates"&gt;https://goo.gle/AcceptsUserCertificates&lt;/a&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/articles/security-config#TrustingDebugCa"&gt;https://developer.android.com/training/articles/security-config#TrustingDebugCa&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidPermission" defaultSeverity="ERROR" displayName="Invalid Permission Attribute" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Permission Attribute&lt;br&gt;&lt;br&gt;Not all elements support the permission attribute. If a permission is set on an invalid element, it is a no-op and ignored. Ensure that this permission attribute was set on the correct element to protect the correct component.&lt;br&gt;&lt;br&gt;Issue id: InvalidPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAuthLeak" defaultSeverity="WARNING" displayName="Code might contain an auth leak" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Code might contain an auth leak&lt;br&gt;&lt;br&gt;Strings in java apps can be discovered by decompiling apps, this lint check looks for code which looks like it may contain an url with a username and password&lt;br&gt;&lt;br&gt;Issue id: AuthLeak&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/AuthLeak"&gt;https://goo.gle/AuthLeak&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAllowAllHostnameVerifier" defaultSeverity="WARNING" displayName="Insecure HostnameVerifier" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure &lt;code&gt;HostnameVerifier&lt;/code&gt;&lt;br&gt;&lt;br&gt;This check looks for use of HostnameVerifier implementations whose &lt;code&gt;verify&lt;/code&gt; method always returns true (thus trusting any hostname) which could result in insecure network traffic caused by trusting arbitrary hostnames in TLS/SSL certificates presented by peers.&lt;br&gt;&lt;br&gt;Issue id: AllowAllHostnameVerifier&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/AllowAllHostnameVerifier"&gt;https://goo.gle/AllowAllHostnameVerifier&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWorldWriteableFiles" defaultSeverity="WARNING" displayName="openFileOutput() with MODE_WORLD_WRITEABLE" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;openFileOutput()&lt;/code&gt; with &lt;code&gt;MODE_WORLD_WRITEABLE&lt;/code&gt;&lt;br&gt;&lt;br&gt;There are cases where it is appropriate for an application to write world writeable files, but these should be reviewed carefully to ensure that they contain no private data, and that if the file is modified by a malicious application it does not trick or compromise your application.&lt;br&gt;&lt;br&gt;Issue id: WorldWriteableFiles&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/WorldWriteableFiles"&gt;https://goo.gle/WorldWriteableFiles&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeprecatedProvider" defaultSeverity="WARNING" displayName="Using BC Provider" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using BC Provider&lt;br&gt;&lt;br&gt;The &lt;code&gt;BC&lt;/code&gt; provider has been deprecated and will not be provided when &lt;code&gt;targetSdkVersion&lt;/code&gt; is P or higher.&lt;br&gt;&lt;br&gt;Issue id: DeprecatedProvider&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html"&gt;https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html&lt;/a&gt;&lt;br&gt;&lt;a href="https://goo.gle/DeprecatedProvider"&gt;https://goo.gle/DeprecatedProvider&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWorldReadableFiles" defaultSeverity="WARNING" displayName="openFileOutput() with MODE_WORLD_READABLE" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;openFileOutput()&lt;/code&gt; with &lt;code&gt;MODE_WORLD_READABLE&lt;/code&gt;&lt;br&gt;&lt;br&gt;There are cases where it is appropriate for an application to write world readable files, but these should be reviewed carefully to ensure that they contain no private data that is leaked to other applications.&lt;br&gt;&lt;br&gt;Issue id: WorldReadableFiles&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/WorldReadableFiles"&gt;https://goo.gle/WorldReadableFiles&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExportedService" defaultSeverity="WARNING" displayName="Exported service does not require permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Exported service does not require permission&lt;br&gt;&lt;br&gt;Exported services (services which either set &lt;code&gt;exported=true&lt;/code&gt; or contain an intent-filter and do not specify &lt;code&gt;exported=false&lt;/code&gt;) should define a permission that an entity must have in order to launch the service or bind to it. Without this, any application can use this service.&lt;br&gt;&lt;br&gt;Issue id: ExportedService&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/ExportedService"&gt;https://goo.gle/ExportedService&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDataExtractionRules" defaultSeverity="WARNING" displayName="Missing data extraction rules" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing data extraction rules&lt;br&gt;&lt;br&gt;Before Android 12, the attributes &lt;code&gt;android:allowBackup&lt;/code&gt; and &lt;code&gt;android:fullBackupContent&lt;/code&gt; were used to configure all forms of backup, including cloud backups, device-to-device transfers and adb backup.&lt;br/&gt;
&lt;br/&gt;
In Android 12 and higher, these attributes have been deprecated and will only apply to cloud backups. You should instead use the attribute &lt;code&gt;android:dataExtractionRules&lt;/code&gt;, specifying an &lt;code&gt;@xml&lt;/code&gt; resource that configures which files to back up, for cloud backups and for device-to-device transfers, separately. If your &lt;code&gt;minSdkVersion&lt;/code&gt; supports older versions, you'll still want to specify an &lt;code&gt;android:fullBackupContent&lt;/code&gt; resource if the default behavior is not right for your app.&lt;br&gt;&lt;br&gt;Issue id: DataExtractionRules&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/about/versions/12/backup-restore#xml-changes"&gt;https://developer.android.com/about/versions/12/backup-restore#xml-changes&lt;/a&gt;&lt;br&gt;&lt;a href="https://goo.gle/DataExtractionRules"&gt;https://goo.gle/DataExtractionRules&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRiskyLibrary" defaultSeverity="WARNING" displayName="Libraries with Privacy or Security Risks" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Libraries with Privacy or Security Risks&lt;br&gt;&lt;br&gt;Your app is using a version of a library that has been identified by the library developer as a potential source of privacy and/or security risks. This may be a violation of Google Play policies (see &lt;a href="https://play.google.com/about/monetization-ads/ads/"&gt;https://play.google.com/about/monetization-ads/ads/&lt;/a&gt;) and/or affect your app&amp;#8217;s visibility on the Play Store.&lt;br/&gt;
&lt;br/&gt;
When available, the individual error messages from lint will include details about the reasons for this advisory.&lt;br/&gt;
&lt;br/&gt;
Please try updating your app with an updated version of this library, or remove it from your app.&lt;br&gt;&lt;br&gt;Issue id: RiskyLibrary&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/distribute/sdk-index"&gt;https://developer.android.com/distribute/sdk-index&lt;/a&gt;&lt;br&gt;&lt;a href="https://goo.gle/RiskyLibrary"&gt;https://goo.gle/RiskyLibrary&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIntentFilterExportedReceiver" defaultSeverity="WARNING" displayName="Unspecified android:exported in manifest" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unspecified &lt;code&gt;android:exported&lt;/code&gt; in manifest&lt;br&gt;&lt;br&gt;Apps targeting Android 12 and higher are required to specify an explicit value for &lt;code&gt;android:exported&lt;/code&gt; when the corresponding component has an intent filter defined. Otherwise, installation will fail. Set it to &lt;code&gt;true&lt;/code&gt; to make this activity accessible to other apps, and &lt;code&gt;false&lt;/code&gt; to limit it to be used only by this app or the OS. For launch activities, this should be set to true; otherwise, the app will fail to launch.&lt;br/&gt;
&lt;br/&gt;
Previously, &lt;code&gt;android:exported&lt;/code&gt; for components without any intent filters present used to default to &lt;code&gt;false&lt;/code&gt;, and when intent filters were present, the default was &lt;code&gt;true&lt;/code&gt;. Defaults which change value based on other values are confusing and lead to apps accidentally exporting components as a side-effect of adding intent filters. This is a security risk, and we have made this change to avoid introducing accidental vulnerabilities.&lt;br/&gt;
&lt;br/&gt;
While the default without intent filters remains unchanged, it is now required to explicitly specify a value when intent filters are present. Any app failing to meet this requirement will fail to install on any Android version after Android 11.&lt;br/&gt;
&lt;br/&gt;
We recommend setting &lt;code&gt;android:exported&lt;/code&gt; to false (even on previous versions of Android prior to this requirement) unless you have a good reason to export a particular component.&lt;br&gt;&lt;br&gt;Issue id: IntentFilterExportedReceiver&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/IntentFilterExportedReceiver"&gt;https://goo.gle/IntentFilterExportedReceiver&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUsingC2DM" defaultSeverity="ERROR" displayName="Using C2DM" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using C2DM&lt;br&gt;&lt;br&gt;The C2DM library does not work on Android P or newer devices; you should migrate to Firebase Cloud Messaging to ensure reliable message delivery.&lt;br&gt;&lt;br&gt;Issue id: UsingC2DM&lt;br&gt;&lt;br&gt;&lt;a href="https://developers.google.com/cloud-messaging/c2dm"&gt;https://developers.google.com/cloud-messaging/c2dm&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPackagedPrivateKey" defaultSeverity="ERROR" displayName="Packaged private key" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Packaged private key&lt;br&gt;&lt;br&gt;In general, you should not package private key files inside your app.&lt;br&gt;&lt;br&gt;Issue id: PackagedPrivateKey&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/PackagedPrivateKey"&gt;https://goo.gle/PackagedPrivateKey&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSSLCertificateSocketFactoryGetInsecure" defaultSeverity="WARNING" displayName="Call to SSLCertificateSocketFactory.getInsecure()" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Call to &lt;code&gt;SSLCertificateSocketFactory.getInsecure()&lt;/code&gt;&lt;br&gt;&lt;br&gt;The &lt;code&gt;SSLCertificateSocketFactory.getInsecure()&lt;/code&gt; method returns an SSLSocketFactory with all TLS/SSL security checks disabled, which could result in insecure network traffic caused by trusting arbitrary TLS/SSL certificates presented by peers. This method should be avoided unless needed for a special circumstance such as debugging. Instead, &lt;code&gt;SSLCertificateSocketFactory.getDefault()&lt;/code&gt; should be used.&lt;br&gt;&lt;br&gt;Issue id: SSLCertificateSocketFactoryGetInsecure&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/SSLCertificateSocketFactoryGetInsecure"&gt;https://goo.gle/SSLCertificateSocketFactoryGetInsecure&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSystemPermissionTypo" defaultSeverity="WARNING" displayName="Permission appears to be a standard permission with a typo" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission appears to be a standard permission with a typo&lt;br&gt;&lt;br&gt;This check looks for required permissions that &lt;i&gt;look&lt;/i&gt; like well-known system permissions or permissions from the Android SDK, but aren't, and may be typos.&lt;br/&gt;
&lt;br/&gt;
Please double check the permission value you have supplied.&lt;br&gt;&lt;br&gt;Issue id: SystemPermissionTypo&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExportedContentProvider" defaultSeverity="WARNING" displayName="Content provider does not require permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Content provider does not require permission&lt;br&gt;&lt;br&gt;Content providers are exported by default and any application on the system can potentially use them to read and write data. If the content provider provides access to sensitive data, it should be protected by specifying &lt;code&gt;export=false&lt;/code&gt; in the manifest or by protecting it with a permission that can be granted to other applications.&lt;br&gt;&lt;br&gt;Issue id: ExportedContentProvider&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/ExportedContentProvider"&gt;https://goo.gle/ExportedContentProvider&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPlaySdkIndexDeprecated" defaultSeverity="ERROR" displayName="Library is marked as deprecated in SDK Index" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Library is marked as deprecated in SDK Index&lt;br&gt;&lt;br&gt;This library has been deprecated, please consider updating to an alternative SDK before publishing a new release.&lt;br&gt;&lt;br&gt;Issue id: PlaySdkIndexDeprecated&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/distribute/sdk-index"&gt;https://developer.android.com/distribute/sdk-index&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAddJavascriptInterface" defaultSeverity="WARNING" displayName="addJavascriptInterface Called" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;addJavascriptInterface&lt;/code&gt; Called&lt;br&gt;&lt;br&gt;For applications built for API levels below 17, &lt;code&gt;WebView#addJavascriptInterface&lt;/code&gt; presents a security hazard as JavaScript on the target web page has the ability to use reflection to access the injected object's public fields and thus manipulate the host application in unintended ways.&lt;br&gt;&lt;br&gt;Issue id: AddJavascriptInterface&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface(java.lang.Object,%20java.lang.String)"&gt;https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface(java.lang.Object,%20java.lang.String)&lt;/a&gt;&lt;br&gt;&lt;a href="https://support.google.com/faqs/answer/9095419?hl=en"&gt;https://support.google.com/faqs/answer/9095419?hl=en&lt;/a&gt;&lt;br&gt;&lt;a href="https://goo.gle/AddJavascriptInterface"&gt;https://goo.gle/AddJavascriptInterface&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeProtectedBroadcastReceiver" defaultSeverity="WARNING" displayName="Unsafe Protected BroadcastReceiver" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsafe Protected &lt;code&gt;BroadcastReceiver&lt;/code&gt;&lt;br&gt;&lt;br&gt;`BroadcastReceiver`s that declare an intent-filter for a protected-broadcast action string must check that the received intent's action string matches the expected value, otherwise it is possible for malicious actors to spoof intents.&lt;br&gt;&lt;br&gt;Issue id: UnsafeProtectedBroadcastReceiver&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/UnsafeProtectedBroadcastReceiver"&gt;https://goo.gle/UnsafeProtectedBroadcastReceiver&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSetWorldWritable" defaultSeverity="WARNING" displayName="File.setWritable() used to make file world-writable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;File.setWritable()&lt;/code&gt; used to make file world-writable&lt;br&gt;&lt;br&gt;Setting files world-writable is very dangerous, and likely to cause security holes in applications. It is strongly discouraged; instead, applications should use more formal mechanisms for interactions such as &lt;code&gt;ContentProvider&lt;/code&gt;, &lt;code&gt;BroadcastReceiver&lt;/code&gt;, and &lt;code&gt;Service&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: SetWorldWritable&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/SetWorldWritable"&gt;https://goo.gle/SetWorldWritable&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTileProviderPermissions" defaultSeverity="WARNING" displayName="TileProvider does not set permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TileProvider does not set permission&lt;br&gt;&lt;br&gt;TileProviders should require the &lt;code&gt;com.google.android.wearable.permission.BIND_TILE_PROVIDER&lt;/code&gt; permission to prevent arbitrary apps from binding to it.&lt;br&gt;&lt;br&gt;Issue id: TileProviderPermissions&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHardcodedDebugMode" defaultSeverity="ERROR" displayName="Hardcoded value of android:debuggable in the manifest" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardcoded value of &lt;code&gt;android:debuggable&lt;/code&gt; in the manifest&lt;br&gt;&lt;br&gt;It's best to leave out the &lt;code&gt;android:debuggable&lt;/code&gt; attribute from the manifest. If you do, then the tools will automatically insert &lt;code&gt;android:debuggable=true&lt;/code&gt; when building an APK to debug on an emulator or device. And when you perform a release build, such as Exporting APK, it will automatically set it to &lt;code&gt;false&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If on the other hand you specify a specific value in the manifest file, then the tools will always use it. This can lead to accidentally publishing your app with debug information.&lt;br&gt;&lt;br&gt;Issue id: HardcodedDebugMode&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/HardcodedDebugMode"&gt;https://goo.gle/HardcodedDebugMode&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintKnownPermissionError" defaultSeverity="ERROR" displayName="Value specified for permission is a known error" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Value specified for permission is a known error&lt;br&gt;&lt;br&gt;This check looks for values specified in component permissions that are known errors, such as &lt;code&gt;android:permission="true"&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
 Please double check the permission value you have supplied. The value is expected to be a  permission string from the system, another app, or your own, NOT a boolean.&lt;br&gt;&lt;br&gt;Issue id: KnownPermissionError&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/KnownPermissionError"&gt;https://goo.gle/KnownPermissionError&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCustomX509TrustManager" defaultSeverity="WARNING" displayName="Implements custom TLS trust manager" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implements custom TLS trust manager&lt;br&gt;&lt;br&gt;This check looks for custom &lt;code&gt;X509TrustManager&lt;/code&gt; implementations.&lt;br&gt;&lt;br&gt;Issue id: CustomX509TrustManager&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/CustomX509TrustManager"&gt;https://goo.gle/CustomX509TrustManager&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWebViewClientOnReceivedSslError" defaultSeverity="WARNING" displayName="Proceeds with the HTTPS connection despite SSL errors" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Proceeds with the HTTPS connection despite SSL errors&lt;br&gt;&lt;br&gt;This check looks for &lt;code&gt;onReceivedSslError&lt;/code&gt; implementations that invoke &lt;code&gt;SslErrorHandler#proceed&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: WebViewClientOnReceivedSslError&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/WebViewClientOnReceivedSslError"&gt;https://goo.gle/WebViewClientOnReceivedSslError&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSetJavaScriptEnabled" defaultSeverity="WARNING" displayName="Using setJavaScriptEnabled" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;setJavaScriptEnabled&lt;/code&gt;&lt;br&gt;&lt;br&gt;Your code should not invoke &lt;code&gt;setJavaScriptEnabled&lt;/code&gt; if you are not sure that your app really requires JavaScript support.&lt;br&gt;&lt;br&gt;Issue id: SetJavaScriptEnabled&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/SetJavaScriptEnabled"&gt;https://goo.gle/SetJavaScriptEnabled&lt;/a&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/articles/security-tips"&gt;https://developer.android.com/training/articles/security-tips&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseCheckPermission" defaultSeverity="WARNING" displayName="Using the result of check permission calls" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using the result of check permission calls&lt;br&gt;&lt;br&gt;You normally want to use the result of checking a permission; these methods return whether the permission is held; they do not throw an error if the permission is not granted. Code which does not do anything with the return value probably meant to be calling the enforce methods instead, e.g. rather than &lt;code&gt;Context#checkCallingPermission&lt;/code&gt; it should call &lt;code&gt;Context#enforceCallingPermission&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: UseCheckPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHardwareIds" defaultSeverity="WARNING" displayName="Hardware Id Usage" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardware Id Usage&lt;br&gt;&lt;br&gt;Using these device identifiers is not recommended other than for high value fraud prevention and advanced telephony use-cases. For advertising use-cases, use &lt;code&gt;AdvertisingIdClient$Info#getId&lt;/code&gt; and for analytics, use &lt;code&gt;InstanceId#getId&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: HardwareIds&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/articles/user-data-ids.html"&gt;https://developer.android.com/training/articles/user-data-ids.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGetInstance" defaultSeverity="WARNING" displayName="Cipher.getInstance with ECB" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Cipher.getInstance with ECB&lt;br&gt;&lt;br&gt;&lt;code&gt;Cipher#getInstance&lt;/code&gt; should not be called with ECB as the cipher mode or without setting the cipher mode because the default mode on android is ECB, which is insecure.&lt;br&gt;&lt;br&gt;Issue id: GetInstance&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/GetInstance"&gt;https://goo.gle/GetInstance&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSSLCertificateSocketFactoryCreateSocket" defaultSeverity="WARNING" displayName="Insecure call to SSLCertificateSocketFactory.createSocket()" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure call to &lt;code&gt;SSLCertificateSocketFactory.createSocket()&lt;/code&gt;&lt;br&gt;&lt;br&gt;When &lt;code&gt;SSLCertificateSocketFactory.createSocket()&lt;/code&gt; is called with an &lt;code&gt;InetAddress&lt;/code&gt; as the first parameter, TLS/SSL hostname verification is not performed, which could result in insecure network traffic caused by trusting arbitrary hostnames in TLS/SSL certificates presented by peers. In this case, developers must ensure that the &lt;code&gt;InetAddress&lt;/code&gt; is explicitly verified against the certificate through other means, such as by calling `SSLCertificateSocketFactory.getDefaultHostnameVerifier() to get a &lt;code&gt;HostnameVerifier&lt;/code&gt; and calling &lt;code&gt;HostnameVerifier.verify()&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: SSLCertificateSocketFactoryCreateSocket&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/SSLCertificateSocketFactoryCreateSocket"&gt;https://goo.gle/SSLCertificateSocketFactoryCreateSocket&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIntentWithNullActionLaunch" defaultSeverity="WARNING" displayName="Unsafe intent launched with no action set" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsafe intent launched with no action set&lt;br&gt;&lt;br&gt;Intents that have no action and do not specify a component are a potential security risk, and using them will result in a crash in an upcoming version of Android. If a specific app is being targeted (including the case where the current app is the target) then set the targeted component using &lt;code&gt;setComponent()&lt;/code&gt;, &lt;code&gt;setClass()&lt;/code&gt;, &lt;code&gt;setClassName()&lt;/code&gt;, or the Intent constructors that take a Class parameter. If the intent is not intended for a specific app then the action name should be set.&lt;br&gt;&lt;br&gt;Issue id: IntentWithNullActionLaunch&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsanitizedFilenameFromContentProvider" defaultSeverity="WARNING" displayName="Trusting ContentProvider filenames without any sanitization" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Trusting ContentProvider filenames without any sanitization&lt;br&gt;&lt;br&gt;  When communicating between applications with files, the server app can provide the client app with a maliciously constructed filename. The client app should never trust this filename and should either sanitize it or completely discard it.&lt;br&gt;&lt;br&gt;Issue id: UnsanitizedFilenameFromContentProvider&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/privacy-and-security/risks/untrustworthy-contentprovider-provided-filename"&gt;https://developer.android.com/privacy-and-security/risks/untrustworthy-contentprovider-provided-filename&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExportedPreferenceActivity" defaultSeverity="WARNING" displayName="PreferenceActivity should not be exported" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;PreferenceActivity should not be exported&lt;br&gt;&lt;br&gt;Fragment injection gives anyone who can send your &lt;code&gt;PreferenceActivity&lt;/code&gt; an intent the ability to load any fragment, with any arguments, in your process.&lt;br&gt;&lt;br&gt;Issue id: ExportedPreferenceActivity&lt;br&gt;&lt;br&gt;&lt;a href="http://securityintelligence.com/new-vulnerability-android-framework-fragment-injection"&gt;http://securityintelligence.com/new-vulnerability-android-framework-fragment-injection&lt;/a&gt;&lt;br&gt;&lt;a href="https://goo.gle/ExportedPreferenceActivity"&gt;https://goo.gle/ExportedPreferenceActivity&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSecretInSource" defaultSeverity="WARNING" displayName="Secret in source code" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Secret in source code&lt;br&gt;&lt;br&gt;Including secrets, such as API keys, in source code is a security risk. It is generally best practice to not include API keys in source code, and instead use something like the Secrets Gradle Plugin for Android.&lt;br&gt;&lt;br&gt;Issue id: SecretInSource&lt;br&gt;&lt;br&gt;&lt;a href="https://developers.google.com/maps/documentation/android-sdk/secrets-gradle-plugin"&gt;https://developers.google.com/maps/documentation/android-sdk/secrets-gradle-plugin&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExportedReceiver" defaultSeverity="WARNING" displayName="Receiver does not require permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Receiver does not require permission&lt;br&gt;&lt;br&gt;Exported receivers (receivers which either set &lt;code&gt;exported=true&lt;/code&gt; or contain an intent-filter and do not specify &lt;code&gt;exported=false&lt;/code&gt;) should define a permission that an entity must have in order to launch the receiver or bind to it. Without this, any application can use this receiver.&lt;br&gt;&lt;br&gt;Issue id: ExportedReceiver&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/ExportedReceiver"&gt;https://goo.gle/ExportedReceiver&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeDynamicallyLoadedCode" defaultSeverity="WARNING" displayName="load used to dynamically load code" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;load&lt;/code&gt; used to dynamically load code&lt;br&gt;&lt;br&gt;Dynamically loading code from locations other than the application's library directory or the Android platform's built-in library directories is dangerous, as there is an increased risk that the code could have been tampered with. Applications should use &lt;code&gt;loadLibrary&lt;/code&gt; when possible, which provides increased assurance that libraries are loaded from one of these safer locations. Application developers should use the features of their development environment to place application native libraries into the lib directory of their compiled APKs.&lt;br&gt;&lt;br&gt;Issue id: UnsafeDynamicallyLoadedCode&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInsecureBaseConfiguration" defaultSeverity="WARNING" displayName="Insecure Base Configuration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure Base Configuration&lt;br&gt;&lt;br&gt;Permitting cleartext traffic could allow eavesdroppers to intercept data sent by your app, which impacts the privacy of your users. Consider only allowing encrypted traffic by setting the &lt;code&gt;cleartextTrafficPermitted&lt;/code&gt; tag to &lt;code&gt;false&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InsecureBaseConfiguration&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/InsecureBaseConfiguration"&gt;https://goo.gle/InsecureBaseConfiguration&lt;/a&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/features/security-config.html"&gt;https://developer.android.com/preview/features/security-config.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBidiSpoofing" defaultSeverity="ERROR" displayName="Bidirectional text spoofing" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Bidirectional text spoofing&lt;br&gt;&lt;br&gt;Unicode bidirectional text characters can alter the order in which the compiler processes tokens. However, this can also be used to hide malicious code, and can be difficult to spot. This lint check audits the source code and looks for cases where it looks like bidirectional text has the potential to be misleading.&lt;br&gt;&lt;br&gt;Issue id: BidiSpoofing&lt;br&gt;&lt;br&gt;&lt;a href="https://krebsonsecurity.com/2021/11/trojan-source-bug-threatens-the-security-of-all-code/"&gt;https://krebsonsecurity.com/2021/11/trojan-source-bug-threatens-the-security-of-all-code/&lt;/a&gt;&lt;br&gt;&lt;a href="https://goo.gle/BidiSpoofing"&gt;https://goo.gle/BidiSpoofing&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintProviderReadPermissionOnly" defaultSeverity="WARNING" displayName="Provider with readPermission only and implemented write APIs" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Provider with readPermission only and implemented write APIs&lt;br&gt;&lt;br&gt;This check looks for Content Providers that only have the &lt;code&gt;readPermission&lt;/code&gt; attribute but implement write APIs.&lt;br/&gt;
&lt;br/&gt;
If &lt;code&gt;android:readPermission&lt;/code&gt; is specified and both &lt;code&gt;android:permission&lt;/code&gt; and &lt;code&gt;android:writePermission&lt;/code&gt; are omitted, other apps can access any write operations that this provider exposes with no permission check. For a quick fix, changing the existing &lt;code&gt;android:readPermission&lt;/code&gt; to &lt;code&gt;android:permission&lt;/code&gt; will protect both read and write access with the same permission. Alternatively, declaring a separate &lt;code&gt;android:writePermission&lt;/code&gt; can protect write access with a different permission.&lt;br&gt;&lt;br&gt;Issue id: ProviderReadPermissionOnly&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnspecifiedImmutableFlag" defaultSeverity="ERROR" displayName="Missing PendingIntent mutability flag" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;PendingIntent&lt;/code&gt; mutability flag&lt;br&gt;&lt;br&gt;Apps targeting Android 12 and higher must specify either &lt;code&gt;FLAG_IMMUTABLE&lt;/code&gt; or &lt;code&gt;FLAG_MUTABLE&lt;/code&gt; when constructing a &lt;code&gt;PendingIntent&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
&lt;code&gt;FLAG_IMMUTABLE&lt;/code&gt; is available since target SDK 23, and is almost always the best choice. See &lt;a href="https://developer.android.com/guide/components/intents-filters#CreateImmutablePendingIntents"&gt;https://developer.android.com/guide/components/intents-filters#CreateImmutablePendingIntents&lt;/a&gt; for a list of common exceptions to this rule.&lt;br&gt;&lt;br&gt;Issue id: UnspecifiedImmutableFlag&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/about/versions/12/behavior-changes-12#pending-intent-mutability"&gt;https://developer.android.com/about/versions/12/behavior-changes-12#pending-intent-mutability&lt;/a&gt;&lt;br&gt;&lt;a href="https://goo.gle/UnspecifiedImmutableFlag"&gt;https://goo.gle/UnspecifiedImmutableFlag&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEasterEgg" defaultSeverity="WARNING" displayName="Code contains easter egg" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Code contains easter egg&lt;br&gt;&lt;br&gt;An "easter egg" is code deliberately hidden in the code, both from potential users and even from other developers. This lint check looks for code which looks like it may be hidden from sight.&lt;br&gt;&lt;br&gt;Issue id: EasterEgg&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnprotectedSMSBroadcastReceiver" defaultSeverity="WARNING" displayName="Unprotected SMS BroadcastReceiver" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unprotected SMS &lt;code&gt;BroadcastReceiver&lt;/code&gt;&lt;br&gt;&lt;br&gt;BroadcastReceivers that declare an intent-filter for &lt;code&gt;SMS_DELIVER&lt;/code&gt; or &lt;code&gt;SMS_RECEIVED&lt;/code&gt; must ensure that the caller has the &lt;code&gt;BROADCAST_SMS&lt;/code&gt; permission, otherwise it is possible for malicious actors to spoof intents.&lt;br&gt;&lt;br&gt;Issue id: UnprotectedSMSBroadcastReceiver&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/UnprotectedSMSBroadcastReceiver"&gt;https://goo.gle/UnprotectedSMSBroadcastReceiver&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeIntentLaunch" defaultSeverity="WARNING" displayName="Launched Unsafe Intent" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Launched Unsafe Intent&lt;br&gt;&lt;br&gt;Intent that potentially could come from an untrusted source should not be launched from an unprotected component without first being sanitized. See this support FAQ for details: &lt;a href="https://support.google.com/faqs/answer/9267555"&gt;https://support.google.com/faqs/answer/9267555&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: UnsafeIntentLaunch&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTrustAllX509TrustManager" defaultSeverity="WARNING" displayName="Insecure TLS/SSL trust manager" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure TLS/SSL trust manager&lt;br&gt;&lt;br&gt;This check looks for X509TrustManager implementations whose &lt;code&gt;checkServerTrusted&lt;/code&gt; or &lt;code&gt;checkClientTrusted&lt;/code&gt; methods do nothing (thus trusting any certificate chain) which could result in insecure network traffic caused by trusting arbitrary TLS/SSL certificates presented by peers.&lt;br&gt;&lt;br&gt;Issue id: TrustAllX509TrustManager&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/TrustAllX509TrustManager"&gt;https://goo.gle/TrustAllX509TrustManager&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintProxyPassword" defaultSeverity="WARNING" displayName="Proxy Password in Cleartext" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Proxy Password in Cleartext&lt;br&gt;&lt;br&gt;Storing proxy server passwords in clear text is dangerous if this file is shared via version control. If this is deliberate or this is a truly private project, suppress this warning.&lt;br&gt;&lt;br&gt;Issue id: ProxyPassword&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeImplicitIntentLaunch" defaultSeverity="ERROR" displayName="Implicit intent matches an internal non-exported component" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implicit intent matches an internal non-exported component&lt;br&gt;&lt;br&gt;This intent matches a non-exported component within the same app. In many cases, the app developer could instead use an explicit Intent to send messages to their internal components, ensuring that the messages are safely delivered without exposure to malicious apps on the device. Using such implicit intents will result in a crash in an upcoming version of Android.&lt;br&gt;&lt;br&gt;Issue id: UnsafeImplicitIntentLaunch&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCustomPermissionTypo" defaultSeverity="WARNING" displayName="Permission appears to be a custom permission with a typo" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission appears to be a custom permission with a typo&lt;br&gt;&lt;br&gt;This check looks for required permissions that &lt;i&gt;look&lt;/i&gt; like custom permissions defined in the same manifest, but aren't, and may be typos.&lt;br/&gt;
&lt;br/&gt;
Please double check the permission value you have supplied.&lt;br&gt;&lt;br&gt;Issue id: CustomPermissionTypo&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/CustomPermissionTypo"&gt;https://goo.gle/CustomPermissionTypo&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSecureRandom" defaultSeverity="WARNING" displayName="Using a fixed seed with SecureRandom" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using a fixed seed with &lt;code&gt;SecureRandom&lt;/code&gt;&lt;br&gt;&lt;br&gt;Specifying a fixed seed will cause the instance to return a predictable sequence of numbers. This may be useful for testing but it is not appropriate for secure use.&lt;br&gt;&lt;br&gt;Issue id: SecureRandom&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/SecureRandom"&gt;https://goo.gle/SecureRandom&lt;/a&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/security/SecureRandom.html"&gt;https://developer.android.com/reference/java/security/SecureRandom.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintReservedSystemPermission" defaultSeverity="ERROR" displayName="Permission name is a reserved Android permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission name is a reserved Android permission&lt;br&gt;&lt;br&gt;This check looks for custom permission declarations whose names are reserved values for system or Android SDK permissions, or begin with the reserved string &lt;code&gt;android.&lt;/code&gt;&lt;br/&gt;
&lt;br/&gt;
Please double check the permission name you have supplied. Attempting to redeclare a system or Android SDK permission will be ignored.  Using the prefix &lt;code&gt;android.&lt;/code&gt; is a violation of the Android Compatibility Definition Document.&lt;br&gt;&lt;br&gt;Issue id: ReservedSystemPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBinderGetCallingInMainThread" defaultSeverity="ERROR" displayName="Incorrect usage of getCallingUid() or getCallingPid()" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect usage of getCallingUid() or getCallingPid()&lt;br&gt;&lt;br&gt;&lt;code&gt;Binder.getCallingUid()&lt;/code&gt; and &lt;code&gt;Binder.getCallingPid()&lt;/code&gt; will return information about the current process if called inside a thread that is not handling a binder transaction. This can cause security issues. If you still want to use your own uid/pid, use &lt;code&gt;Process.myUid()&lt;/code&gt; or &lt;code&gt;Process.myPid()&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: BinderGetCallingInMainThread&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSetWorldReadable" defaultSeverity="WARNING" displayName="File.setReadable() used to make file world-readable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;File.setReadable()&lt;/code&gt; used to make file world-readable&lt;br&gt;&lt;br&gt;Setting files world-readable is very dangerous, and likely to cause security holes in applications. It is strongly discouraged; instead, applications should use more formal mechanisms for interactions such as &lt;code&gt;ContentProvider&lt;/code&gt;, &lt;code&gt;BroadcastReceiver&lt;/code&gt;, and &lt;code&gt;Service&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: SetWorldReadable&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/SetWorldReadable"&gt;https://goo.gle/SetWorldReadable&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Android Lint: Productivity" path=""><inspection shortName="AndroidLintKtxExtensionAvailable" defaultSeverity="WEAK WARNING" displayName="KTX Extension Available" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;KTX Extension Available&lt;br&gt;&lt;br&gt;Android KTX extensions augment some libraries with support for modern Kotlin language features like extension functions, extension properties, lambdas, named parameters, coroutines, and more.&lt;br/&gt;
&lt;br/&gt;
In Kotlin projects, use the KTX version of a library by replacing the dependency in your &lt;code&gt;build.gradle&lt;/code&gt; file. For example, you can replace &lt;code&gt;androidx.fragment:fragment&lt;/code&gt; with &lt;code&gt;androidx.fragment:fragment-ktx&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: KtxExtensionAvailable&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/kotlin/ktx"&gt;https://developer.android.com/kotlin/ktx&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseKtx" defaultSeverity="WARNING" displayName="Use KTX extension function" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use KTX extension function&lt;br&gt;&lt;br&gt;The Android KTX libraries decorates the Android platform SDK as well as various libraries with more convenient extension functions available from Kotlin, allowing you to use default parameters, named parameters, and more.&lt;br&gt;&lt;br&gt;Issue id: UseKtx&lt;br&gt;&lt;br&gt;Available options:&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;remove-defaults&lt;/b&gt; (default is true):&lt;br/&gt;
Whether to skip arguments that match the defaults provided by the extension.&lt;br/&gt;
&lt;br/&gt;
Extensions often provide default values for some of the parameters. For example:
&lt;pre&gt;
fun Path.readLines(charset: Charset = Charsets.UTF_8): List&amp;lt;String&gt; { return Files.readAllLines(this, charset) }
&lt;/pre&gt;
This lint check will by default automatically omit parameters that match the default, so if your code was calling&lt;br/&gt;

&lt;pre&gt;
Files.readAllLines(file, Charset.UTF_8)
&lt;/pre&gt;
lint would replace this with
&lt;pre&gt;
file.readLines()
&lt;/pre&gt;
rather than&lt;br/&gt;

&lt;pre&gt;
file.readLines(Charset.UTF_8
&lt;/pre&gt;
You can turn this behavior off using this option.&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="UseKtx"&gt;
        &amp;lt;option name="remove-defaults" value="true" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;br/&gt;
&lt;b&gt;require-present&lt;/b&gt; (default is true):&lt;br/&gt;
Whether to only offer extensions already available.&lt;br/&gt;
&lt;br/&gt;
This option lets you only have lint suggest extension replacements if those extensions are already available on the class path (in other words, you're already depending on the library containing the extension method.)&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="UseKtx"&gt;
        &amp;lt;option name="require-present" value="true" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseTomlInstead" defaultSeverity="WARNING" displayName="Use TOML Version Catalog Instead" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use TOML Version Catalog Instead&lt;br&gt;&lt;br&gt;If your project is using a &lt;code&gt;libs.versions.toml&lt;/code&gt; file, you should place all Gradle dependencies in the TOML file. This lint check looks for version declarations outside of the TOML file and suggests moving them (and in the IDE, provides a quickfix to performing the operation automatically).&lt;br&gt;&lt;br&gt;Issue id: UseTomlInstead&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="테스트 프레임워크" path="Java"><inspection shortName="AssertWithoutMessage" defaultSeverity="WARNING" displayName="어설션에서 메시지 누락" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
오류 메시지 문자열 인수가 없는 &lt;code&gt;assertXXX()&lt;/code&gt; 또는 &lt;code&gt;fail()&lt;/code&gt; 호출을 보고합니다.
어설션 실패에 대한 오류 메시지는 테스트 케이스의 의도를 명확히 하는 데 도움이 될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertTrue(checkValid());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;assertTrue(checkValid(), "|");&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  사용하는 어셜션 프레임워크에 따라 기존 인수의 앞 또는 뒤에 메시지 인수가 추가됩니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: AssertWithoutMessage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableAssertion" defaultSeverity="WARNING" displayName="단순화 가능한 어설션" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
더 간단한 동등한 호출로 바꿀 수 있는 모든 &lt;code&gt;assert&lt;/code&gt; 호출을 보고합니다.
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;예시&lt;/th&gt;&lt;th&gt;&amp;rarr;&lt;/th&gt;&lt;th&gt;대체&lt;/th&gt;&lt;/tr&gt;

  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertEquals(&lt;b&gt;true&lt;/b&gt;, x());&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(x());&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(y() != null);&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;assertNotNull(y());&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(z == z());&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;assertSame(z, z());&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(a.equals(a()));&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;assertEquals(a, a());&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(&lt;b&gt;false&lt;/b&gt;);&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;fail();&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SimplifiableAssertion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MaskedAssertion" defaultSeverity="WARNING" displayName="어설션을 'catch'이 억제하고 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
catch 블록을 사용하여 억제되는 &lt;code&gt;assert&lt;/code&gt; 문 및 테스트 프레임워크 어설션을 보고합니다.
던져진 &lt;code&gt;AssertionError&lt;/code&gt;가 포착되어 확인 없이 무시되므로 그러한 어설션은 실패하지 않습니다.
&lt;p&gt;&lt;b&gt;예시 1:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void javaAssertion() {
    try {
      ...
      assert 1 == 2;
    } catch (AssertionError e) {
      // the assertion is silently ignored
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;예시 2:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  void testWithAssertJ() {
    try {
      ...
      assertThat(1).as("test").isEqualTo(2);
    } catch (AssertionError e) {
      // the assertion is silently ignored
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;예시 3:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  void testWithJunit() {
    try {
      ...
      assertEquals(1, 2);
    } catch (AssertionError e) {
      // the assertion is silently ignored
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MaskedAssertion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MisorderedAssertEqualsArguments" defaultSeverity="WARNING" displayName="잘못 정렬된 'assertequals()'인수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
필요한 인수 및 실제 인수의 순서가 잘못된 &lt;code&gt;assertEquals()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  JUnit 3, 4, 5에서 올바른 순서는 &lt;code&gt;(expected, actual)&lt;/code&gt;입니다.
  TestNG에서 올바른 순서는 &lt;code&gt;(actual, expected)&lt;/code&gt;입니다.
&lt;/p&gt;
&lt;p&gt;
  그러한 호출은 통과하는 어설션에 대해서는 문제 없지만 실패 시 오류 보고가 혼란스러울 수 있습니다.
  빠른 수정을 사용하여 인수의 순서를 반전시키세요.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example (JUnit):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertEquals(actual, expected)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertEquals(expected, actual)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MisorderedAssertEqualsArguments&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantAssertArgument" defaultSeverity="WARNING" displayName="상수 assert 인수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;assertTrue()&lt;/code&gt;, &lt;code&gt;assertFalse()&lt;/code&gt;, &lt;code&gt;assertNull()&lt;/code&gt;, &lt;code&gt;assertNotNull()&lt;/code&gt; 호출 내 상수 인수를 보고합니다.
&lt;p&gt;
  상수 인수를 사용한 이러한 메서드 호출은 항상 성공하거나 항상 실패합니다.
  그러한 구문은 리팩터링 후에 남겨지기 쉬우며 의도되지 않았을 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertNotNull("foo");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConstantAssertArgument&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="버전 관리" path=""><inspection shortName="IgnoreFileDuplicateEntry" defaultSeverity="WARNING" displayName="파일 중복 무시" enabled="false" language="IgnoreLang" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
무시 파일(예: .gitignore, .hgignore)의 중복 항목을 보고합니다.
이러한 파일의 중복 항목은 불필요하므로 제거할 수 있습니다.

&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    # 출력 디렉터리
    /out/
    /target/
    /out/
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IgnoreFileDuplicateEntry&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="일반" path="JavaScript 및 TypeScript"><inspection shortName="JSJoinVariableDeclarationAndAssignment" defaultSeverity="INFORMATION" displayName="변수 선언을 변수에 대한 첫 번째 대입과 병합할 수 있습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이니셜라이저 없이 선언되었으며 코드의 훨씬 뒤쪽에서 또는 1개의 중첩된 범위에서 사용된 변수를 보고합니다. 변수를 사용 위치와 가까운 곳으로 옮기고 이니셜라이저 표현식과 결합할 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSJoinVariableDeclarationAndAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WebpackConfigHighlighting" defaultSeverity="WARNING" displayName="JSON 스키마와 webpack 구성 준수" enabled="false" language="JavaScript" pluginId="intellij.webpack" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://github.com/webpack/webpack/blob/master/schemas/WebpackOptions.json"&gt;webpack 옵션 스키마&lt;/a&gt;와 비교하여 webpack 구성 파일(이름이 'webpack'으로 시작. 예: 'webpack.config.js') 내 옵션의 유효성을 검사합니다.
&lt;br/&gt;&lt;br/&gt;
이 검사를 비활성화하면 구성 객체 내부의 유효성 검사 및 코드 완성 기능이 꺼집니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: WebpackConfigHighlighting&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSXSyntaxUsed" defaultSeverity="ERROR" displayName="JSX 구문이 사용됨" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JavaScript 코드 내 JSX 태그의 사용을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSXSyntaxUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnnecessarySemicolon" defaultSeverity="WARNING" displayName="불필요한 세미콜론" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 세미콜론을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSUnnecessarySemicolon&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUndeclaredVariable" defaultSeverity="WEAK WARNING" displayName="암시적으로 선언된 전역 JavaScript 변수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
전역 변수의 묵시적 선언을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var aaa = 1; // 좋은
  bbb = 2; // 나쁨, bbb가 어딘가에서 'var'로 선언되지 않은 경우
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSUndeclaredVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSLastCommaInArrayLiteral" defaultSeverity="WARNING" displayName="배열 문자열 내 불필요한 마지막 쉼표" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열 리터럴 내 후행 쉼표의 사용 위치를 보고합니다.

&lt;p&gt;경고는 JavaScript 언어 버전이 ECMAScript 5.1로 설정된 경우에만 보고됩니다.&lt;/p&gt;

&lt;p&gt;배열 내 후행 쉼표는 사양에 의해 허용되지만 일부 브라우저에서는 후행 쉼표가 사용되는 경우 오류가 발생할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;코드 스타일&lt;/b&gt; | &lt;b&gt;JavaScript&lt;/b&gt; 또는 &lt;b&gt;TypeScript&lt;/b&gt; | &lt;b&gt;문장 부호&lt;/b&gt;에서 후행 쉼표에 대한 서식 옵션을 구성할 수 있습니다. &lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSLastCommaInArrayLiteral&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnresolvedLibraryURL" defaultSeverity="WARNING" displayName="HTTP 링크용으로 로컬에 저장된 라이브러리 누락" enabled="false" language="HTML" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
로컬에 저장되어 있는 어떤 파일과도 연결되어 있지 않은 외부 JavaScript 라이브러리의 URL을 보고합니다. 라이브러리를 다운로드할 것을 제안합니다.
그러한 연결은 IDE가 적절한 코드 완성과 탐색을 제공하는 데 도움이 됩니다. 
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSUnresolvedLibraryURL&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSAccessibilityCheck" defaultSeverity="WARNING" displayName="액세스할 수 없는 @private 및 @protected 멤버가 참조됨" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@private&lt;/code&gt;또는 &lt;code&gt;@protected&lt;/code&gt; 태그로 표시되어 있으나 이러한 태그가 의미하는 가시성 규칙에 부합하지 않는 JavaScript 멤버 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSAccessibilityCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6RedundantNestingInTemplateLiteral" defaultSeverity="WEAK WARNING" displayName="템플릿 리터럴 내 중복된 중첩" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자열 또는 템플릿 리터럴의 중첩된 인스턴스를 보고합니다. 중첩된 인스턴스를 상위 템플릿 문자열로 인라인화할 것을 제안합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;예: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
let a = 'Hello, ${'Brave ${"New"}'} ${"World"}!'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 코드는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
let a = 'Hello, Brave New World!'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ES6RedundantNestingInTemplateLiteral&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSCheckFunctionSignatures" defaultSeverity="WEAK WARNING" displayName="시그니처 불일치" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인수의 타입과 개수 등이 참조된 함수의 시그니처와 일치하지 않는 JavaScript 호출 표현식을 보고합니다.
또한 매개변수 및 반환 값 타입과 관련하여 오버로드 함수가 오버로드된 함수와 일치하지 않는 경우를 보고합니다.

&lt;p&gt;TypeScript 코드는 무시됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSCheckFunctionSignatures&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSValidateTypes" defaultSeverity="WEAK WARNING" displayName="타입 불일치" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음의 잘못된 타입을 보고합니다: 
&lt;ul&gt;
  &lt;li&gt;함수 호출 내 매개변수&lt;/li&gt;
  &lt;li&gt;반환 값&lt;/li&gt;
  &lt;li&gt;할당된 표현식&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TypeScript 코드는 무시됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSValidateTypes&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnresolvedExtXType" defaultSeverity="WARNING" displayName="해결되지 않은 Flow JS xtype" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해당 클래스를 포함하지 않는 Ext JS &lt;code&gt;xtype&lt;/code&gt; 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSUnresolvedExtXType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSFileReferences" defaultSeverity="WARNING" displayName="해결되지 않은 파일 참조" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
CommonJS 및 AMD 모듈 참조 등 JavaScript 파일 내 해결되지 않은 파일 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSFileReferences&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSReferencingMutableVariableFromClosure" defaultSeverity="WARNING" displayName="클로저에서 가변 변수 참조" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
함수에서 외부 가변 변수로의 접근을 보고합니다. 
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (var i = 1; i &amp;lt;= 3; i++) {
    setTimeout(function() {
        console.log(i); // 나쁨
    }, 0);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSReferencingMutableVariableFromClosure&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSPrimitiveTypeWrapperUsage" defaultSeverity="WARNING" displayName="기본 타입 객체 래퍼가 사용되었습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
원시 타입의 래퍼 또는 원시 타입의 프로퍼티가 변경되는 부적절한 사용 위치를 보고합니다. 원시 타입의 프로퍼티가 변경되는 경우에는 대입된 값이 손실됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSPrimitiveTypeWrapperUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSNonStrictModeUsed" defaultSeverity="WARNING" displayName="비엄격 모드가 사용되었습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;strict&lt;/code&gt; 모드가 아닌 JavaScript 파일을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSNonStrictModeUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSCommentMatchesSignature" defaultSeverity="WARNING" displayName="일치하지 않는 JSDoc 및 함수 시그니처" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JSDoc 주석 안의 매개변수 이름 및 개수와 실제 함수 매개변수 사이의 불일치를 보고합니다.
JSDoc 주석에서 매개변수를 업데이트할 것을 제안합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * @param height Height in pixels
 */
function sq(height, width) {} // 가로 길이가 문서화되어 있지 않습니다
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * @param height Height in pixels
 * @param width
 */
function sq(height, width) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JSCommentMatchesSignature&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSDeprecatedSymbols" defaultSeverity="WEAK WARNING" displayName="지원 중단되는 심볼이 사용됨" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
곧 사용할 수 없게 될 함수 변수의 사용 위치를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSDeprecatedSymbols&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSDuplicatedDeclaration" defaultSeverity="WARNING" displayName="중복 선언" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
스코프 내 여러 선언을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSDuplicatedDeclaration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnresolvedReference" defaultSeverity="WEAK WARNING" displayName="미해결 참조" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JavaScript 코드의 미해결 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSUnresolvedReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6PreferShortImport" defaultSeverity="WARNING" displayName="가져오기를 단축할 수 있습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;from&lt;/code&gt; 부분을 단축할 수 있는 ES6 import 문을 보고합니다. 상위 디렉터리를 가져오기를 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ES6PreferShortImport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSMethodCanBeStatic" defaultSeverity="INFORMATION" displayName="메서드를 'static'으로 설정할 수 있습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전하게 &lt;code&gt;static&lt;/code&gt;으로 만들 수 있는 클래스 메서드를 보고합니다.
메서드는 그 클래스의 비 static 메서드와 비 static 필드를 참조하지 않으며 하위 클래스에서 재정의되지 않는 경우에 &lt;code&gt;static&lt;/code&gt;이 될 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;private&lt;/code&gt; 메서드만을 검사하려면 아래의 첫 번째 체크박스를 사용하십시오.
&lt;p&gt;&lt;small&gt;Inspection ID: JSMethodCanBeStatic&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSXUnresolvedComponent" defaultSeverity="WEAK WARNING" displayName="해결되지 않은 JSX 구성 요소" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JSX 구성 요소에 대한 미해결 참조를 보고합니다.
참조 구성 요소가 프로젝트 또는 종속성으로 정의되어 있는 경우 누락된 import 문을 추가하거나 이 이름으로 새 구성 요소를 생성할 것을 권장합니다.
&lt;p&gt;새 구성 요소 템플릿을 '에디터 | 파일 및 템플릿'에서 수정할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSXUnresolvedComponent&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ShorthandObjectProperty" defaultSeverity="INFORMATION" displayName="프로퍼티를 축약하여 바꿀수 있습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
ES6 속기 스타일로 변환할 수 있는 객체 프로퍼티를 보고하고 변환하기 위한 빠른 수정을 제공합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var obj = {foo:foo}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 코드는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var obj = {foo}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ES6ShorthandObjectProperty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSJQueryEfficiency" defaultSeverity="WARNING" displayName="JQuery 선택자를 최적화할 수 있음" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
캐시 가능한 중복된 jQuery 선택자 또는 속성 및 의사 선택자의 사용 위치(선택 사항)를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSJQueryEfficiency&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSMismatchedCollectionQueryUpdate" defaultSeverity="WARNING" displayName="일치하지 않는 쿼리 및 컬렉션 업데이트" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
콘텐츠가 쿼리된 다음 업데이트되지 않거나 업데이트된 다음 쿼리되지 않는 필드 또는 변수의 컬렉션을 보고합니다. 그러한 일치하지 않는 쿼리와 업데이트는 의미가 없으며
불필요한 코드(dead code) 또는 오타 오류 중 하나를 나타낼 수 있습니다.
&lt;p&gt;
쿼리 메서드는 무엇인가를 반환하는지 또는 콜백이 메서드로 반환되는지를 기준으로 자동으로 탐지됩니다.
아래 테이블을 사용하여 업데이트 메서드인 메서드를 지정하세요.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSMismatchedCollectionQueryUpdate&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSClosureCompilerSyntax" defaultSeverity="WARNING" displayName="JSDoc 태그의 잘못된 사용" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@abstract&lt;/code&gt;,&lt;code&gt;@interface&lt;/code&gt;, &lt;code&gt;@implements&lt;/code&gt; 의 올바른 사용을 포함해 &lt;em&gt;Google Closure Compiler&lt;/em&gt;어노테이션이 암시하는 경고를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSClosureCompilerSyntax&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSValidateJSDoc" defaultSeverity="WARNING" displayName="JSDoc의 구문 오류 및 해결되지 않은 참조" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문서 주석 내 구문 불일치를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSValidateJSDoc&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSLastCommaInObjectLiteral" defaultSeverity="WARNING" displayName="객체 리터럴에서 마지막 쉼표가 불필요합니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
객체 리터럴 내 후행 쉼표의 사용 위치를 보고합니다.

&lt;p&gt;경고는 JavaScript 언어 버전이 ECMAScript 5.1로 설정된 경우에만 보고됩니다.&lt;/p&gt;

&lt;p&gt;객체 리터럴 내 후행 쉼표는 사양에 의해 허용되지만 일부 브라우저는 후행 쉼표가 사용된 경우 오류를 던질 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;코드 스타일&lt;/b&gt; | &lt;b&gt;JavaScript&lt;/b&gt; 또는 &lt;b&gt;TypeScript&lt;/b&gt; | &lt;b&gt;문장 부호&lt;/b&gt;에서 후행 쉼표에 대한 서식 옵션을 구성할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSLastCommaInObjectLiteral&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSAnnotator" defaultSeverity="ERROR" displayName="ECMAScript 사양을 따르지 않습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
유효하지 않은 키워드 사용, 호환되지 않는 숫자 서식 사용, 또는 getter/setter에 대한 여러 파라미터 사용 등 기본적인 구문 이슈 및 언어 사양과의 불일치를 보고합니다.
&lt;br&gt;
일반적으로 그러한 오류는 항상 보고되어야 하며 비활성화되어선 안 됩니다.
하지만 JavaScript의 동적인 성질에 의한 이슈, 아직 지원되지 않는 언어 기능 사용, IDE의 체커 내 버그와 같은 일부 경우에는 이러한 아주 기본적인 오류 보고를 비활성화하는 것이 편리할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSAnnotator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6DestructuringVariablesMerge" defaultSeverity="WEAK WARNING" displayName="동일한 키를 가진 구조 분해 프로퍼티" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
키가 같은 여러 구조 분해 프로퍼티를 보고합니다. 프로퍼티를 병합할 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ES6DestructuringVariablesMerge&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnfilteredForInLoop" defaultSeverity="WARNING" displayName="필터링되지 않은 for..in 루프" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
필터링되지 않은 &lt;code&gt;for-in&lt;/code&gt; 루프를 보고합니다.
&lt;br/&gt;&lt;br/&gt;
이 구문을 사용하면 객체의 자체 프로퍼티뿐만 아니라 해당 프로토타입의 프로퍼티까지 처리됩니다.
특정 경우에 이를 예상할 수 없을 수 있습니다(예: 모든 프로퍼티를 복사 또는 변경하는 유틸리티 메서드 내 또는 &lt;code&gt;Object&lt;/code&gt;의 프로토타입이 잘못 변경되는 경우).
예를 들어, 다음 코드는 &lt;b&gt;42&lt;/b&gt; 및 &lt;b&gt;myMethod&lt;/b&gt;를 출력합니다:
&lt;br/&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
Object.prototype.myMethod = function myMethod() {};
let a = { foo: 42 };
for (let i in a) {
  console.log(a[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;루프 전체를 &lt;code&gt;Object.keys()&lt;/code&gt;로 바꾸거나 &lt;code&gt;hasOwnProperty()&lt;/code&gt; 체크를 추가할 것을 권장합니다. 빠른 수정이 적용된 후 코드는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
for (let i in a) {
  if (a.hasOwnProperty(i)) {
    console.log(a[i]);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSUnfilteredForInLoop&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ClassMemberInitializationOrder" defaultSeverity="WARNING" displayName="정적 이니셜라이저에서 할당되지 않은 프로퍼티가 사용될 가능성이 있습니다" enabled="false" language="ECMAScript 6" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
아직 초기화되지 않았을 수 있는 끌어올려지지 않은 다른 클래스 멤버를 참조하는 클래스 멤버 이니셜라이저를 보고합니다.
&lt;br/&gt;&lt;br/&gt;
필드의 클래스 멤버 초기화는 결과적으로 실행되기 때문에 나중에 선언된 다른 필드를 참조할 수 없습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ES6ClassMemberInitializationOrder&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Oracle" path=""><inspection shortName="OraUnmatchedForwardDeclarationInspection" defaultSeverity="ERROR" displayName="정의 없는 정방향 선언" enabled="false" language="Oracle" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
코드에 구현이 누락된 프로시저 및 함수의 선언을 보고합니다.
&lt;p&gt;Oracle에서는 본문 없이 프로시저 또는 함수를 선언하고 나중에 구현을 작성할 수 있습니다. 이 검사는 구현이 없이 선언된 프로시저 및 함수의 이름을 보고합니다.&lt;/p&gt;
&lt;p&gt;예시(Oracle):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECLARE PROCEDURE foo(a int, b varchar2);
BEGIN
    NULL;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;foo&lt;/code&gt; 프로시저가 선언되어 있으나 구현이 누락되었습니다. 구현을 추가하여 오류를 제거할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECLARE PROCEDURE foo(a int, b varchar2);
  PROCEDURE foo(a int, b varchar2) IS
BEGIN
    NULL;
END;
BEGIN
    NULL;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: OraUnmatchedForwardDeclarationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OraMissingBodyInspection" defaultSeverity="WARNING" displayName="패키지/객체 타입 사양의 본문 누락" enabled="false" language="Oracle" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문 선언이 누락된 패키지 및 객체 타입 사양을 보고합니다.
&lt;p&gt;루틴 및 커서가 포함된 패키지 사양을 선언하는 패키지 사양 및 객체 타입은 루틴 및 커서가 구현된 본문을 선언해야 합니다. 본문이 없으면 프로그램 코드에서 루틴 또는 커서가 호출될 때 런타임 오류가 발생합니다.&lt;/p&gt;
&lt;p&gt;예시(Oracle):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE OR REPLACE PACKAGE ppp IS
    FUNCTION foo(a INT) RETURN INT;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: OraMissingBodyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OraOverloadInspection" defaultSeverity="WARNING" displayName="오버로드 오류" enabled="false" language="Oracle" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Oracle 내 서브프로그램의 유효하지 않은 오버로드를 보고합니다.
&lt;p&gt;예시(Oracle):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECLARE
    SUBTYPE fff IS BINARY_INTEGER;
    SUBTYPE ggg IS NATURAL;
    PROCEDURE foo (a IN ggg) IS BEGIN NULL; END;
    PROCEDURE foo (a IN fff) IS BEGIN NULL; END;
BEGIN
    NULL;
END;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;매개변수의 서브타입만 다른 서브프로그램은 오버로드할 수 없습니다. 예를 들어, 하나는 BINARY INTEGER 매개변수를 수락하고 다른 하나는 NATURAL 매개변수를 수락하는 두 프로시저를 오버로드할 수 없습니다. 프로시저 오버로드 제약에 관한 더 자세한 내용은 &lt;a href="https://docs.oracle.com/cd/B19306_01/appdev.102/b14261/subprograms.htm"&gt;docs.oracle.com에서 오버로드 제약&lt;/a&gt;을 참고하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: OraOverloadInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="패키지 문제" path="Java"><inspection shortName="PackageWithTooManyClasses" defaultSeverity="WARNING" displayName="클래스가 너무 많은 패키지" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
너무 많은 클래스를 포함하는 패키지를 보고합니다.
&lt;p&gt;과도하게 큰 패키지는 설계 명확도가 부족함을 나타냅니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;최대 클래스 수&lt;/b&gt; 필드를 사용하여 패키지의 최대 허용 클래스 수를 지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PackageWithTooManyClasses&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageInMultipleModules" defaultSeverity="WARNING" displayName="여러 모듈의 클래스가 있는 패키지" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
여러 개의 모듈에 있으며 비어 있지 않은 패키지를 보고합니다.
패키지가 여러 모듈에 포함되어 있는 경우 두 개의 모듈에 동일한 이름의 클래스가 생성되기 쉽습니다.
이러한 모듈에 종속된 모듈에서 그러한 클래스를 사용하려 하면 충돌이 발생합니다.
Java 플랫폼 모듈 시스템은 패키지가 두 개 이상의 모듈에 포함되는 것(&lt;em&gt;분할된 패키지&lt;/em&gt;라고도 함)을 허용하지 않습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PackageInMultipleModules&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassOnlyUsedInOnePackage" defaultSeverity="WARNING" displayName="다른 패키지에서만 사용되는 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
소속 패키지 내 다른 클래스에 종속되지 않고, 다른 패키지의 클래스에 종속되며, 이 다른 패키지의 클래스에만 종속되어 있는 클래스를 보고합니다.
이러한 클래스를 해당 클래스가 종속되어 있는 패키지로 이동하는 것을 고려해 보세요.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassOnlyUsedInOnePackage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassUnconnectedToPackage" defaultSeverity="WARNING" displayName="해당 패키지에의존하지 않는 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
소속 패키지 내 다른 클래스에 종속되지 않고, 다른 클래스의 종속성도 아닌 클래스를 보고합니다.
이러한 클래스는 임시 패키징 전략 또는 일관성 없는 패키징 전략을 나타내며 이동하는 것이 좋은 경우가 종종 있습니다.
패키지에서 유일한 클래스인 경우, 해당 클래스는 보고되지 않습니다.
  &lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassUnconnectedToPackage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageWithTooFewClasses" defaultSeverity="WARNING" displayName="클래스가 너무 적은 패키지" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
지정된 최솟값보다 클래스가 더 적게 포함된 패키지를 보고합니다.
&lt;p&gt;하위 패키지가 포함된 패키지는 보고되지 않습니다. 과도하게 작은 패키지는 세분화된 디자인을 나타냅니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;최소 클래스 수&lt;/b&gt; 필드를 사용하여 패키지의 최소 허용 클래스 수를 지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PackageWithTooFewClasses&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DisjointPackage" defaultSeverity="WARNING" displayName="분리 종속성 그래프가 있는 패키지" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
서로 독립적인 하위 집합으로 클래스를 분할할 수 있는 패키지를 보고합니다.
&lt;p&gt;이러한 분리 패키지는 임시 패키징 또는 개념적 응집력 부족을 뜻합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DisjointPackage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExceptionPackage" defaultSeverity="WARNING" displayName="예외 패키지" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
직접 또는 간접적으로 &lt;code&gt;java.lang.Throwable&lt;/code&gt;을 확장하는 클래스만 포함하는 패키지를 보고합니다.
  &lt;p&gt;일반적으로 예외는 구현을 위해 다른 클래스에 의존하지는 않지만, 보통은 개별적으로 사용되지 않습니다.
    예외를 사용하는 클래스와 같은 패키지에 이 예외를 배치하는 것이 더 나은 설계인 경우가 종종 있습니다.&lt;/p&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExceptionPackage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Less" path=""><inspection shortName="LessResolvedByNameOnly" defaultSeverity="WEAK WARNING" displayName="import 문 누락" enabled="false" language="LESS" pluginId="org.jetbrains.plugins.less" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 파일에 선언되어 있으나 현재 파일에 명시적으로 &lt;a href="http://lesscss.org/features/#import-atrules-feature"&gt;가져오지&lt;/a&gt; 않은 변수 또는 mixin 참조를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  margin: @var-in-other-file;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LessResolvedByNameOnly&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LessUnresolvedVariable" defaultSeverity="WARNING" displayName="해결되지 않은 변수" enabled="false" language="LESS" pluginId="org.jetbrains.plugins.less" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해결되지 않은 &lt;a href="http://lesscss.org/features/#variables-feature"&gt;Less 변수&lt;/a&gt; 참조를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  margin: @unknown-var;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LessUnresolvedVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LessUnresolvedMixin" defaultSeverity="WARNING" displayName="해결되지 않은 mixin" enabled="false" language="LESS" pluginId="org.jetbrains.plugins.less" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해결되지 않은 &lt;a href="http://lesscss.org/features/#mixins-feature"&gt;Less mixin&lt;/a&gt; 참조를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  .unknown-mixin();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LessUnresolvedMixin&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="스타일" path="Gradle"><inspection shortName="UnusedVersionCatalogEntry" defaultSeverity="WARNING" displayName="사용되지 않는 버전 카탈로그 항목" enabled="false" language="TOML" pluginId="org.jetbrains.plugins.gradle" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;버전 카탈로그의 TOML 설명자에서 사용되지 않는 키를 탐지합니다. &lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code lang="groovy"&gt;
// build.gradle
dependencies {
  implementation libs.foo.bar
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code lang="toml"&gt;
# libs.versions.toml
[libraries]
foo-bar = "com.gradle:example:1.0.0"
bar-baz = "com.gradle:example:2.0.0" # bar-baz를 강조 표시합니다
&lt;/code&gt;&lt;/pre&gt;


&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnusedVersionCatalogEntry&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="대입 이슈" path="Groovy"><inspection shortName="GroovyNestedAssignment" defaultSeverity="WARNING" displayName="중첩된 대입" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 표현식 내부에 중첩된 대입 표현식을 보고합니다.
그러한 표현식은 매우 간결하기는 하지만 혼란을 일으킬 수 있으며 지정된 구문은 정확히 한 가지 동작을 수행해야 한다는 일반적인 설계 규칙을 위반합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
a = b = 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyNestedAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAssignmentCanBeOperatorAssignment" defaultSeverity="INFORMATION" displayName="대입을 연산자 대입으로 바꿀 수 있습니다" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
연산자 대입으로 바꿀 수 있는 대입을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a = a + b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a += b
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 연산자를 무시하려면 &lt;b&gt;조건 연산자 무시&lt;/b&gt; 옵션을 사용하세요.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 연산자를 무시하려면 &lt;b&gt;모호한 연산자 무시&lt;/b&gt; 옵션을 사용하세요.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyAssignmentCanBeOperatorAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAssignmentToMethodParameter" defaultSeverity="WARNING" displayName="메서드 매개변수에 대입" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 매개변수에 대한 대입을 보고합니다.
&lt;p&gt;의도된 경우도 있으나 이러한 구문은 혼동될 수 있으며 보통 오타가 난 결과입니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def m(a, b, c) {
      a = [] // 경고
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyAssignmentToMethodParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUncheckedAssignmentOfMemberOfRawType" defaultSeverity="WARNING" displayName="원시 타입 멤버에서 검사되지 않은 대입" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;원시 타입의 멤버에서 검사되지 않은 대입을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List list = new ArrayList()
  List&amp;ltString&amp;gt a = &lt;b&gt;list.get(0)&lt;/b&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyUncheckedAssignmentOfMemberOfRawType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyResultOfAssignmentUsed" defaultSeverity="WARNING" displayName="대입 결과 사용" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대입된 값을 즉시 사용하는 다른 표현식 내에 있는 대입 표현식을 보고합니다.
&lt;p&gt;
  그러한 표현식은 혼란을 일으킬 수 있으며 지정된 구문은 정확히 한 가지 동작을 수행해야 한다는 일반적인 설계 규칙을 위반합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyResultOfAssignmentUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAssignabilityCheck" defaultSeverity="WARNING" displayName="호환되지 않는 타입 대입" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
호환하지 않는 타입을 가진 대입을 보고합니다.
&lt;p&gt;그러한 대입은 다양한 런타임 예외를 발생시킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {}
  class B {}

  // 호환되지 않는 대입
  A a = new B()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyAssignabilityCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySillyAssignment" defaultSeverity="WARNING" displayName="잘못된 대입" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
자신에게 대입된 변수를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovySillyAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAssignmentToForLoopParameter" defaultSeverity="WARNING" displayName="'for' 루프 매개변수에 대입" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;b&gt;for&lt;/b&gt; 루프 본문 내에 있는 &lt;b&gt;for&lt;/b&gt; 루프 매개변수에 대입하는 경우 이를 보고합니다.
&lt;p&gt;의도된 경우도 있으나 이러한 구문은 혼동될 수 있으며 보통 오타가 난 결과입니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (value in [1, 2, 3]) {
      value = 4 // 경고
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyAssignmentToForLoopParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="이름 생성 규칙" path="Java"><inspection shortName="PackageNamingConvention" defaultSeverity="WARNING" displayName="패키지 이름 지정 규칙" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나, 너무 길거나, 지정된 정규 표현식 패턴을 따르지 않는 패키지를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package io;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  옵션을 사용하여 패키지 이름의 최소 및 최대 길이, 유효한 패키지 이름과 일치하는 정규 표현식을 지정합니다(정규 표현식의 표준 서식은 &lt;code&gt;java.util.regex&lt;/code&gt;).
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PackageNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UpperCaseFieldNameNotConstant" defaultSeverity="WARNING" displayName="대문자 이름을 가진 상수가 아닌 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 대문자인 비 &lt;code&gt;static&lt;/code&gt; 비 &lt;code&gt;final&lt;/code&gt; 필드를 보고합니다.
&lt;p&gt;이러한 필드는 일반적인 이름 지정 규칙을 위반하여 혼란을 일으킬 수 있으며 실수로 사용된 경우가 많습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt; &lt;pre&gt;&lt;code&gt;
  public static int THE_ANSWER = 42; //여기에서 경고 발생: final 제어자가 없습니다
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러한 필드의 이름을 변경하는 빠른 수정은 에디터에서만 사용할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: UpperCaseFieldNameNotConstant&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldNamingConvention" defaultSeverity="WARNING" displayName="필드 이름 지정 규칙" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길거나 지정된 정규 표현식 패턴을 따르지 않는 필드를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt; 이 검사가 상수에 대해서 활성화되어 있으며 필드 이름의 최소 길이가 5(디폴트)로 지정되어 있는 경우, 다음 상수는 이름의 길이가 5보다 작은 3이므로 경고가 발생합니다. &lt;code&gt;public static int max(int a, int b)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;그러한 필드의 이름을 변경하는 빠른 수정은 에디터에서만 사용할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;&lt;b&gt;옵션&lt;/b&gt; 섹션의 목록을 사용하여 검사되어야 하는 필드를 지정하세요. 검사를 건너뛰려는 필드의 체크박스를 선택 해제하세요.&lt;/p&gt;
&lt;p&gt;각 필드 타입에 대해 제공된 입력 필드를 사용하여 최소 길이, 최대 길이를 비롯해 필드 이름에 필요한 정규 표현식을 지정하세요.
  관련된 검사를 건너뛰려면 길이 필드에 &lt;b&gt;0&lt;/b&gt;을 지정하세요.&lt;/p&gt;
&lt;p&gt;정규 표현식은 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 형식으로 지정되어야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: FieldNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterNameDiffersFromOverriddenParameter" defaultSeverity="WARNING" displayName="매개변수 이름이 재정의되거나 오버로드된 메서드의 매개변수와 다름" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드의 매개변수 중 재정의 또는 오버로드 대상 매개변수와 이름이 다른 매개변수를 보고합니다. Java에서는 허용되지만, 일관성 없는 이름은 혼동될 수 있으며 적절한 명명 규칙에 따른 문서화의 장점이 약화될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    Person(String fullName) {}
  }
  class Child extends Person {
    Child(String name) { super(name); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    Person(String fullName) {}
  }
  class Child extends Person {
    Child(String fullName) { super(fullName); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  옵션을 사용하여, 재정의된 매개변수 이름 중 길이가 1자이거나 라이브러리 메서드에서 비롯된 이름을 무시할지 여부를 표시합니다. 두 가지 옵션 모두 라이브러리에 사용된 모호한 이름 생성 규칙을 따르기 원치 않는 경우 유용합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ParameterNameDiffersFromOverriddenParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterNamingConvention" defaultSeverity="WARNING" displayName="메서드 매개변수 이름 지정 규칙" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길거나 지정된 정규 표현식 패턴을 따르지 않는 메서드 매개변수를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt; 매개변수 이름이 소문자로 시작하도록 되어 있는 디폴트 설정으로 검사가 활성화된 경우 &lt;code&gt;void fooBar(int X)&lt;/code&gt;가 보고됩니다.&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;옵션&lt;/b&gt; 섹션의 필드를 사용하여 최소 길이, 최대 길이를 비롯해 메서드 매개변수 이름에 필요한 정규 표현식을 지정합니다. 이름의 길이를 검사하지 않으려면 &lt;b&gt;0&lt;/b&gt;을 지정하세요.&lt;/p&gt;
&lt;p&gt;정규 표현식은 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식으로 지정되어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ParameterNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DollarSignInName" defaultSeverity="WARNING" displayName="식별자에서 '$' 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름에 달러 기호(&lt;code&gt;$&lt;/code&gt;)가 포함된 변수, 메서드 및 클래스를 보고합니다. 이러한 이름은 Java에서 유효하지만, 생성된 Java 코드 외부에서 사용하지 않는 것이 좋습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SalaryIn${}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이름 변경 빠른 수정은 에디터에서만 제안됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DollarSignInName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaParameterNamingConvention" defaultSeverity="WARNING" displayName="람다 매개변수 이름 지정 규칙" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길거나 지정된 정규 표현식 패턴을 따르지 않는 람다 매개변수를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt; 매개변수 이름이 소문자로 시작하도록 되어 있는 디폴트 설정으로 검사가 활성화된 경우 &lt;code&gt;Function&amp;lt;String, String&amp;gt; id = X -&amp;gt; X;&lt;/code&gt;가 보고됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;
&lt;b&gt;옵션&lt;/b&gt; 섹션의 필드를 사용하여 최소 길이, 최대 길이를 비롯해 람다 매개변수 이름에 필요한 정규 표현식을 지정합니다.
  이름의 길이를 검사하지 않으려면 &lt;b&gt;0&lt;/b&gt;을 지정하세요.&lt;/p&gt;
&lt;p&gt;정규 표현식은 표준 &lt;code&gt;java.util.regex&lt;/code&gt; 서식으로 지정되어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LambdaParameterNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="QuestionableName" defaultSeverity="WARNING" displayName="의심스러운 이름" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
모호하고 내용을 제대로 설명하지 않는 이름을 가진 변수, 메서드, 또는 클래스를 보고합니다.
그러한 이름은 코드를 이해하는 데 도움이 되지 않으며, 임시로 생성된 후에 방치된 항목일 가능성이 큽니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int aa = 42;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이름 변경 빠른 수정은 에디터에서만 제안됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  옵션을 사용하여 보고할 이름을 나열합니다.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: QuestionableName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalVariableNamingConvention" defaultSeverity="WARNING" displayName="지역 변수 이름 지정 규칙" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름이 너무 짧거나 너무 길거나 지정된 정규 표현식 패턴을 따르지 않는 지역 변수를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt; 변수 이름이 소문자로 시작하도록 되어 있는 디폴트 설정으로 검사가 활성화된 경우 &lt;code&gt;int X = 42;&lt;/code&gt;가 보고됩니다.&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;
&lt;b&gt;옵션&lt;/b&gt; 섹션의 필드를 사용하여 최소 길이, 최대 길이 및 지역 변수 이름에 필요한 정규 표현식을 지정합니다.
이름의 길이를 검사하지 않으려면 &lt;b&gt;0&lt;/b&gt;을 지정하세요. 정규 표현식은 표준 &lt;b&gt;java.util.regex&lt;/b&gt; 서식으로 지정되어야 합니다.
&lt;p&gt;&lt;code&gt;for&lt;/code&gt; 루프 및 &lt;code&gt;catch&lt;/code&gt; 섹션 매개변수를 무시하는 체크박스를 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LocalVariableNamingConvention&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaModuleNaming" defaultSeverity="WARNING" displayName="Java 모듈 이름의 규칙 위반" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;module-info.java&lt;/code&gt;에서 Java Platform Module System &lt;a href="http://mail.openjdk.org/pipermail/jpms-spec-experts/2017-March/000659.html"&gt;권장 사항&lt;/a&gt;에 위배되는 모듈 이름을 보고합니다. 이 권장 사항에서는 모듈 이름에 버전 정보를 인코딩하는 것을 피하기 위해 이름을 하나 이상의 숫자로 끝내지 않도록 합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
 module foo.bar2 {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  module foo.bar {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavaModuleNaming&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StandardVariableNames" defaultSeverity="WARNING" displayName="표준 변수 이름" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
타입과 일치하지 않는 '표준' 이름을 가진 변수를 보고합니다.
그러한 이름은 혼동될 수 있습니다. 특정한 타입에 대한 표준 이름은 다음과 같습니다.
&lt;ul&gt;
  &lt;li&gt;i, j, k, m, n - &lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;f - &lt;code&gt;float&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;d - &lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;b - &lt;code&gt;byte&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;c, ch - &lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;l - &lt;code&gt;long&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;s, str - &lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이름 변경 빠른 수정은 에디터에서만 제안됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  옵션을 사용하여, 바로 상위의 메서드의 매개변수 이름과 동일한 매개변수 이름을 무시합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StandardVariableNames&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="YAML" path=""><inspection shortName="YAMLRecursiveAlias" defaultSeverity="ERROR" displayName="재귀적 별칭" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
YAML 별칭의 재귀를 보고합니다.
&lt;p&gt;별칭은 재귀적일 수 없으며 해당하는 앵커로 참조된 데이터 내부에서 사용되어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  some_key: &amp;some_anchor
    sub_key1: value1
    sub_key2: *some_anchor
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: YAMLRecursiveAlias&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLDuplicatedKeys" defaultSeverity="ERROR" displayName="중복 YAML 키" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
YAML 파일의 중복 키를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  same_key: some value
  same_key: another value
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: YAMLDuplicatedKeys&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLIncompatibleTypes" defaultSeverity="WARNING" displayName="의심스러운 타입 불일치" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
YAML 파일 내의 스칼라 값 타입과 비슷한 위치에 있는 값의 타입이 일치하지 않으면 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
myElements:
  - value1
  - value2
  - false # &amp;lt;- 다른 값은 문자열이지만 이 값은 부울 값이므로 보고됩니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: YAMLIncompatibleTypes&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLSchemaValidation" defaultSeverity="WARNING" displayName="JSON 스키마로 검사" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
스키마가 지정된 경우 YAML 파일 및 JSON 스키마 간 불일치를 보고합니다.
&lt;p&gt;&lt;b&gt;스키마 예시:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  {
    "properties": {
      "SomeNumberProperty": {
        "type": "number"
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;다음은 해당하는 경고의 예시입니다.&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  SomeNumberProperty: hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: YAMLSchemaValidation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLUnusedAnchor" defaultSeverity="WARNING" displayName="사용되지 않는 앵커" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
사용되지 않는 앵커를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  some_key: &amp;some_anchor
    key1: value1
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: YAMLUnusedAnchor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLUnresolvedAlias" defaultSeverity="ERROR" displayName="해결되지 않은 별칭" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
YAML 파일의 해결되지 않은 별칭을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  some_key: *unknown_alias
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: YAMLUnresolvedAlias&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLSchemaDeprecation" defaultSeverity="WEAK WARNING" displayName="지원 중단되는 YAML 키" enabled="false" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
YAML 파일에서 지원이 중단된 키를 보고합니다.
&lt;p&gt;해당하는 YAML 파일과 연관된 JSON 스키마가 있을 경우에만 지원 중단이 검사됩니다.&lt;/p&gt;
&lt;p&gt;지원 중단 메커니즘은 아직 JSON 스키마 사양에 정의되어 있지 않으며 이 검사는 비표준 &lt;code&gt;deprecationMessage&lt;/code&gt; 확장을 사용합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;스키마 지원 중단 예시:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  {
    "properties": {
      "SomeDeprecatedProperty": {
        "deprecationMessage": "Baz",
        "description": "Foo bar"
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;다음은 해당하는 경고의 예시입니다.&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  SomeDeprecatedProperty: some value
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: YAMLSchemaDeprecation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="보안" path="JavaScript and TypeScript"><inspection shortName="NpmVulnerableApiCode" defaultSeverity="WARNING" displayName="취약한 API 사용 위치" enabled="false" language="JavaScript" pluginId="org.jetbrains.security.package-checker" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;가져온 종속성에서 취약한 API가 사용된 경우를 보고합니다.&lt;/p&gt;
&lt;p&gt;보고된 문제를 해결하면 공격자로부터 소프트웨어를 보호할 수 있습니다.&lt;/p&gt;
&lt;p&gt;문제를 해결하려면 취약성이 수정된 버전(사용 가능한 경우)으로 업데이트하거나 취약성이 없는 종속성으로 전환하면 됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NpmVulnerableApiCode&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="코드 스타일 이슈" path="CSS"><inspection shortName="CssMissingSemicolon" defaultSeverity="WARNING" displayName="세미콜론 누락" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
선언 끝의 누락된 세미콜론을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssMissingSemicolon&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssRedundantUnit" defaultSeverity="WARNING" displayName="불필요한 측정 단위" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
사양이 단위를 요구하지 않는 경우 0 값 측정 단위를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;너비: 0px&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssRedundantUnit&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="어노테이션" path="Groovy"><inspection shortName="GrPOJO" defaultSeverity="WARNING" displayName="@CompileStatic 없는 @POJO" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@groovy.transform.CompileStatic&lt;/code&gt; 없이 적용된 &lt;code&gt;@groovy.transform.stc.POJO&lt;/code&gt; 어노테이션을 보고합니다.
&lt;p&gt;어노테이션 &lt;code&gt;@POJO&lt;/code&gt;는 Groovy 클래스의 컴파일링 프로세스를 바이트코드로 변경합니다. 명시적으로 활성화된 정적 컴파일(&lt;code&gt;@CompileStatic&lt;/code&gt; 어노테이션을 통해 수행됨) 없이는 효과가 없습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @POJO // @POJO를 보고합니다
  class A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrPOJO&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrNamedVariantLabels" defaultSeverity="WARNING" displayName="@NamedVariant/@NamedParam/@NamedDelegate 해결되지 않은 라벨" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@NamedVariant&lt;/code&gt;/&lt;code&gt;@NamedParam&lt;/code&gt;/&lt;code&gt;@NamedDelegate&lt;/code&gt;로 어노테이션이 추가된 메서드 호출에서 해결되지 않은 인수 라벨을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @groovy.transform.NamedVariant
  def foo(a, b) {}

  // 해결되지 않은 'c'  라벨
  foo(a: 1, b: 2, c: 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrNamedVariantLabels&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DelegatesTo" defaultSeverity="WARNING" displayName="@DelegatesTo" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
사용되지 않는 &lt;code&gt;@DelegatesTo.Target&lt;/code&gt; 어노테이션과 해결되지 않은 &lt;code&gt;@DelegatedTo.target&lt;/code&gt; 어노테이션 속성 값을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 사용되지 않는 대상 't1'과 해결되지 않은 대상 't2'
  def m(
      @DelegatesTo.Target('t1') target,
      @DelegatesTo(target = 't2') Closure c
  ) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DelegatesTo&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrAnnotationReferencingUnknownIdentifiers" defaultSeverity="WARNING" displayName="@TupleConstructor 및 @MapConstructor" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@TupleConstructor&lt;/code&gt; 및 &lt;code&gt;@MapConstructor&lt;/code&gt;에서 해결되지 않은 식별자를 보고합니다
&lt;code&gt;includes&lt;/code&gt; 및 &lt;code&gt;excludes&lt;/code&gt; 어노테이션 속성 값입니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 해결되지 않은 'c'
  @TupleConstructor(includes = ['a', 'b', 'c'])
  class X {
      def a
      def b
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrAnnotationReferencingUnknownIdentifiers&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SingletonConstructor" defaultSeverity="ERROR" displayName="@Singleton 생성자" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;비 엄격으로 선언되지 않았으며 &lt;code&gt;@Singleton&lt;/code&gt; 어노테이션이 추가된 클래스의 생성자를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton
  class Foo{
      Foo(){
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;가능한 빠른 수정은 두 개입니다. 하나는 생성자를 제거하는 것이고 다른 하나는 &lt;code&gt;@Singleton&lt;/code&gt;을 비 엄격으로 선언하는 것입니다.&lt;/p&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton
  class Foo{
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton(&lt;b&gt;strict = false&lt;/b&gt;)
  class Foo{
      Foo(){
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SingletonConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="데이터 흐름" path="Groovy"><inspection shortName="GroovyUnusedIncOrDec" defaultSeverity="WARNING" displayName="사용되지 않는 증분 또는 감소" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;사용되지 않는 증분 또는 감소 표현식을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyUnusedIncOrDec&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyVariableNotAssigned" defaultSeverity="WARNING" displayName="변수가 대입되지 않음" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;초기화되지 않았을 수 있는 변수를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyVariableNotAssigned&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnusedAssignment" defaultSeverity="WARNING" displayName="사용되지 않는 대입" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;변수의 값이 대입된 후로 사용되지 않아 불필요한 사례를 보고합니다.&lt;/p&gt;
&lt;p&gt;변수가 사용되지 않았다면 이를 제거해 코드 길이를 줄이고 불필요한 대입을 피하기를 권장합니다.&lt;/p&gt;
&lt;p&gt;다음과 같은 경우가 보고됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;변수가 대입된 후 한 번도 읽히지 않았습니다&lt;/li&gt;
  &lt;li&gt;다음 변수가 읽히기 전에 항상 다른 대입에 의해 값이 재정의됩니다&lt;/li&gt;
  &lt;li&gt;(위의 두 가지 이유 중 하나로) 변수 이니셜라이저가 불필요합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt; 자세한 내용은 Java의 동일한 검사를 참조하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyUnusedAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMissingReturnStatement" defaultSeverity="WARNING" displayName="return 문 누락" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
반환 타입이 &lt;b&gt;void&lt;/b&gt;가 아닌 메서드의 끝에 누락된 &lt;code&gt;return&lt;/code&gt; 문을 보고합니다.
메서드의 실행 흐름에서 메서드의 끝에 도달할 수 있어야 합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
String foo(int a) {
  if (a &gt; 0) {
    return "more than zero"
  }
} // foo(-1)가 'null'을 반환합니다

int bar(int a) {
  if (a &gt; 0) {
    return a
  }
} // bar(-1)에서 런타임 예외가 발생합니다
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyMissingReturnStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyVariableCanBeFinal" defaultSeverity="WARNING" displayName="변수가 final일 수 있음" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;final 제어자가 추가되었을지 모르는 매개변수 또는 지역 변수를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def list = [1,2,3]
  return list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:
&lt;pre&gt;&lt;code&gt;
  final def list = [1,2,3]
  return list
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;자세한 내용은 Java의 동일한 검사를 참조하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyVariableCanBeFinal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="메서드 메트릭" path="Groovy"><inspection shortName="GroovyOverlyLongMethod" defaultSeverity="WARNING" displayName="지나치게 긴 메서드" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
너무 긴 메서드를 보고합니다.
&lt;p&gt;
  너무 긴 메서드는 혼동될 수 있으며 리팩터링이 필요함을 의미합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  메서드에서 허용되는 최대 비 주석 소스 구문 수를 지정하려면 &lt;b&gt;메서드당 최대 구문&lt;/b&gt; 필드를 사용하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyOverlyLongMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMethodWithMoreThanThreeNegations" defaultSeverity="WARNING" displayName="3개 이상의 부정이 있는 메서드" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
세 개 이상의 부정 연산(&lt;code&gt;!&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt;)을 포함하는 메서드를 보고합니다.
그러한 메서드는 불필요한 혼란을 일으킬 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyMethodWithMoreThanThreeNegations&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMultipleReturnPointsPerMethod" defaultSeverity="WARNING" displayName="여러 반환점이 있는 메서드" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
반환점이 너무 많은 메서드를 보고합니다. 반환점이 너무 많은 메서드는 혼란을 줄 수 있으며 리팩터링하기 어려울 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  int foo(int a) {
    if (a &gt; 0) {
      return a
    }
    if (a &amp;lt; 0) return -a
    return 0
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  메서드에서 허용되는 최대 반환 지점 갯수를 지정하려면 아래 제공한
  필드를 사용하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyMultipleReturnPointsPerMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMethodParameterCount" defaultSeverity="WARNING" displayName="매개변수가 너무 많은 메서드" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
매개변수가 너무 많은 메서드를 보고합니다. 너무 많은 매개변수를 가진 메서드는 리팩터링이 필요하다는 의미일 수 있습니다. 라이브러리 클래스에서 시그니처를 상속하는 메서드는 이 검사에서 무시됩니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;최대 매개변수 수:&lt;/b&gt; 필드를 사용하여 메서드에 포함할 수 있는 최대 매개변수 개수를 지정하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyMethodParameterCount&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOverlyNestedMethod" defaultSeverity="WARNING" displayName="지나치게 중첩된 메서드" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 너무 깊이 중첩된 메서드를 보고합니다.
&lt;p&gt;
  너무 많은 구문 중첩이 있는 메서드는 혼동될 수 있으며 리팩터링이 필요할 수 있음을 의미합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 &lt;b&gt;최대 중첩 깊이&lt;/b&gt; 필드를 사용하여 메서드에서 허용되는 최대 중첩 깊이를 지정하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyOverlyNestedMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOverlyComplexMethod" defaultSeverity="WARNING" displayName="지나치게 복잡한 메서드" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
순환 복잡도가 너무 높은 메서드를 보고합니다.
&lt;p&gt;
  순환 복잡도는 기본적으로 하나의 메서드에 몇 개의 브랜치가 있는지 측정한 것입니다. 순환 복잡도가 너무 높은 메서드는 혼란스럽거나 테스트하기 어려울 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 &lt;b&gt;메서드 복잡도 제한&lt;/b&gt; 필드를 사용하여 메서드에서 허용되는 최대 순환 복잡도를 지정하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyOverlyComplexMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="잘못된 요소" path="CSS"><inspection shortName="CssInvalidPropertyValue" defaultSeverity="ERROR" displayName="잘못된 프로퍼티 값" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
잘못된 CSS 프로퍼티 값을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssInvalidPropertyValue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssUnknownUnit" defaultSeverity="ERROR" displayName="알 수 없는 단위" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
알려지지 않은 유닛을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssUnknownUnit&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidHtmlTagReference" defaultSeverity="WARNING" displayName="잘못된 타입 선택자" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
알 수 없는 HTML 요소와 일치하는 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors"&gt;타입 선택자&lt;/a&gt;를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssInvalidHtmlTagReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssUnknownTarget" defaultSeverity="ERROR" displayName="해결되지 않은 파일 참조" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해결되지 않은 파일 참조, 예를 들어 &lt;code&gt;@import&lt;/code&gt; 문 내 잘못된 경로를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssUnknownTarget&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssUnresolvedCustomProperty" defaultSeverity="ERROR" displayName="해결되지 않은 사용자 지정 프로퍼티" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;var()&lt;/code&gt; 함수 인수 중 해결되지 않은 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/--*"&gt;사용자 지정 프로퍼티&lt;/a&gt; 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssUnresolvedCustomProperty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidCustomPropertyAtRuleDeclaration" defaultSeverity="ERROR" displayName="유효하지 않은 @property 선언" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
필수 &lt;a href="https://developer.mozilla.org/en-US/docs/web/css/@property/syntax"&gt;syntax&lt;/a&gt;, &lt;a href="https://developer.mozilla.org/en-US/docs/web/css/@property/inherits"&gt;inherits&lt;/a&gt; 또는 &lt;a href="https://developer.mozilla.org/en-US/docs/web/css/@property/initial-value"&gt;initial-value&lt;/a&gt; 프로퍼티가 사용자 지정 프로퍼티의 선언에서 누락되면 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssInvalidCustomPropertyAtRuleDeclaration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidAtRule" defaultSeverity="ERROR" displayName="알 수 없는 @규칙" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
알 수 없는 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule"&gt;CSS at-rule&lt;/a&gt;을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssInvalidAtRule&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidMediaFeature" defaultSeverity="ERROR" displayName="잘못된 미디어 기능" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
알 수 없는 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries"&gt;CSS 미디어 기능&lt;/a&gt; 또는 잘못된 미디어 기능 값을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssInvalidMediaFeature&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssUnresolvedClassInComposesRule" defaultSeverity="ERROR" displayName="‘composes' 규칙 내 해결되지 않은 클래스" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
어떠한 유효한 대상으로도 해결되지 않는 &lt;a href="https://github.com/css-modules/css-modules#composition"&gt;'composes'&lt;/a&gt; 규칙 내 CSS 클래스 참조를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  .className {/* ... */}

  .otherClassName {
    composes: className;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssUnresolvedClassInComposesRule&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssUnknownProperty" defaultSeverity="WARNING" displayName="알 수 없는 프로퍼티" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
알 수 없는 CSS 프로퍼티 또는 잘못된 컨텍스트에 사용된 프로퍼티를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;'Custom CSS properties'(사용자 지정 CSS 프로퍼티) 목록에 알 수 없는 프로퍼티를 추가하여 유효성 검사를 건너뛰세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssUnknownProperty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidImport" defaultSeverity="WARNING" displayName="잘못 배치된 @import" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
잘못 배치된 &lt;code&gt;@import&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;
  &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@import"&gt;사양&lt;/a&gt;에 따르면, &lt;code&gt;@import&lt;/code&gt; 규칙이 스타일 시트 최상단에 모든 @규칙(&lt;code&gt;@charset&lt;/code&gt; 및 &lt;code&gt;@layer&lt;/code&gt; 제외)과 스타일 선언 앞에 정의되어야 합니다. 그렇지 않은 경우 무시됩니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssInvalidImport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidCustomPropertyAtRuleName" defaultSeverity="ERROR" displayName="유효하지 않은 @property 이름" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
잘못된 사용자 지정 프로퍼티 이름을 보고합니다. 사용자 지정 프로퍼티 이름의 앞에는 두 개의 대시가 필요합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@property invalid-property-name {
  ...
}

@property --valid-property-name {
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssInvalidCustomPropertyAtRuleName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidNestedSelector" defaultSeverity="WARNING" displayName="잘못된 중첩 선택자" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
식별자 또는 함수 표기로 시작하는 중첩 선택자를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CssInvalidNestedSelector&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssNegativeValue" defaultSeverity="ERROR" displayName="음수 프로퍼티 값" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
0보다 작아서는 안 되는 CSS 프로퍼티의 음수 값을 보고합니다(예: 객체 너비 또는 높이).
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssNegativeValue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidCharsetRule" defaultSeverity="WARNING" displayName="잘못 배치되거나 잘못 사용된 @charset" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
잘못 배치된 &lt;code&gt;@charset&lt;/code&gt; at-rule 또는 잘못된 charset 값을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssInvalidCharsetRule&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidPseudoSelector" defaultSeverity="ERROR" displayName="잘못된 의사 선택자" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
잘못된 CSS &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes"&gt;pseudo-class&lt;/a&gt;
&lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements"&gt;pseudo-element&lt;/a&gt;를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssInvalidPseudoSelector&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CssInvalidFunction" defaultSeverity="ERROR" displayName="잘못된 함수" enabled="false" language="CSS" pluginId="com.intellij.css" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
알 수 없는 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions"&gt;CSS 함수&lt;/a&gt; 또는 잘못된 함수 매개변수를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CssInvalidFunction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="적절하지 않은 gRPC 요청 구성표" path=""><inspection shortName="GrpcSchemes" defaultSeverity="WEAK WARNING" displayName="대체 또는 생략 가능한 gRPC 요청 스키마" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  gRPC 요청 내에서 불필요한 'grpc' 또는 표준 'http[s]' 구성표를 보고합니다
&lt;/p&gt;
&lt;p&gt;
  요청 예시:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# 기본적으로 안전하지 않은 연결이 가정되므로 'grpc' 스키마는 누락될 수 있습니다
GRPC grpc://localhost/TestService/testRpc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
# 'http' 스키마는 생략될 수 있습니다. 안전하지 않은 연결에서는 빈 스키마가, 안전한 연결에서는 전용 'grpcs' 스키마가 선호됩니다
GRPC http://localhost/TestService/testRpc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
# 'https' 스키마는 'grpcs'로 대체되어야 합니다. 요청을 실행하려면 Transport Layer Security(TLS)가 활성화되어야 함을 표시하려는 경우 'grpcs'가 선호됩니다
GRPC https://localhost/TestService/testRpc
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  요청이 안전한 채널을 사용해야 하는 경우, 혼란을 방지하기 위해 gRPC 요청에 전용 'grpcs' 구성표를 사용하는 것이 좋습니다. 그러지 않으면 구성표가 완전히 누락될 수 있습니다
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GrpcSchemes&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="직렬화 문제" path="Java"><inspection shortName="ExternalizableWithSerializationMethods" defaultSeverity="WARNING" displayName="'readObject()' 또는 'writeObject()'가 있는 externalizable 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;readObject()&lt;/code&gt;
또는 &lt;code&gt;writeObject()&lt;/code&gt; 메서드를 정의하는 &lt;code&gt;Externalizable&lt;/code&gt; 클래스를 보고합니다. 이러한 메서드는 &lt;code&gt;Externalizable&lt;/code&gt; 객체의 직렬화를 위해 호출되지 않습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Crucial implements Externalizable {
    int value;
    private void readObject(ObjectInputStream in) {
      value = in.readInt();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExternalizableWithSerializationMethods&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReadObjectInitialization" defaultSeverity="WARNING" displayName="'readObject()'로 인스턴스 필드가 초기화되지 않을 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
객체가 &lt;code&gt;readObject()&lt;/code&gt; 메서드에 의해 역직렬화된 후 초기화가 보장되지 않는 필드를 보고합니다.
&lt;p&gt;이 검사는 transient 필드를 보고하지 않습니다.&lt;/p&gt;
&lt;p&gt;
  참고: 이 검사는 매우 보수적인 제어 흐름 알고리즘을 사용하며 필드를 초기화되지 않은 것으로 잘못 보고할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class DataObject implements Serializable {
  String s; // s가 readObject에서 초기화되지 않습니다
  int i;

  private void readObject(ObjectInputStream stream) throws IOException {
    i = stream.readInt();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ReadObjectInitialization&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableHasSerializationMethods" defaultSeverity="WARNING" displayName="'readObject()' 또는 'writeObject()'가 없는 serializable 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;readObject()&lt;/code&gt; 및 &lt;code&gt;writeObject()&lt;/code&gt; 메서드를 구현하지 않는 &lt;code&gt;Serializable&lt;/code&gt; 클래스를 보고합니다.
&lt;p&gt;
  &lt;code&gt;readObject()&lt;/code&gt; 및 &lt;code&gt;writeObject()&lt;/code&gt; 메서드가 구현되지 않은 경우 기본 직렬화 알고리즘이 사용됩니다. 이는 많은 환경에서 성능 및 호환성을 위한 차선책일 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  다음 옵션을 사용해 검사를 구성하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    이 검사에서 보고되어서는 안 되는 상속자를 가진 클래스를 나열합니다.
    이는 상위 클래스에서 &lt;code&gt;Serializable&lt;/code&gt;을 상속받지만 직렬화를 의도하지 않은 클래스를 의미합니다.
  &lt;/li&gt;
  &lt;li&gt;
    static이 아닌 필드를 포함하지 않는 &lt;code&gt;Serializable&lt;/code&gt; 클래스를 무시할지 여부를 설정합니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;Serializable&lt;/code&gt; 익명 클래스를 무시할지 여부를 설정합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SerializableHasSerializationMethods&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparatorNotSerializable" defaultSeverity="WARNING" displayName="'Comparator' 클래스가 'Serializable'로 선언되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.Comparator&lt;/code&gt;를 구현하지만 &lt;code&gt;java.io.Serializable&lt;/code&gt;을 구현하지 않는 클래스를 보고합니다.
&lt;p&gt;
  &lt;code&gt;java.util.TreeMap&lt;/code&gt; 또는 &lt;code&gt;java.util.TreeSet&lt;/code&gt;과 같은 순서가 있는 컬렉션을 생성하기 위해 직렬화할 수 없는 비교자가 사용되는 경우 컬렉션 또한 직렬화할 수 없습니다. 이는 예기치 않은 진단하기 어려운 버그를 초래할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;java.lang.Comparator&lt;/code&gt;의 하위 클래스는 보통 상태가 없으므로 간단히 직렬화 가능한 것으로 표시하는 것만으로 그러한 문제를 피할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo implements Comparator { // 경고
      @Override
      public int compare(Object o1, Object o2) {
          /* ... */
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo implements Comparator, Serializable { // 경고 없음
      @Override
      public int compare(Object o1, Object o2) {
          /* ... */
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ComparatorNotSerializable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReadObjectAndWriteObjectPrivate" defaultSeverity="WARNING" displayName="'readObject()' 또는 'writeObject()'가 'private'으로 선언되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;readObject&lt;/code&gt;
또는 &lt;code&gt;writeObject&lt;/code&gt; 메서드가 private으로 선언되지 않은 상태인 &lt;code&gt;Serializable&lt;/code&gt; 클래스를 보고합니다.
이 메서드의 가시성은 &lt;code&gt;private&lt;/code&gt;보다 높아야 할 이유가 없습니다.
&lt;p&gt;
  해당 메서드를 &lt;code&gt;private&lt;/code&gt;으로 만드는 빠른 수정이 제안됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Test implements Serializable {
    public void readObject(ObjectInputStream stream) {
      /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Test implements Serializable {
    private void readObject(ObjectInputStream stream) {
      /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReadObjectAndWriteObjectPrivate&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableInnerClassWithNonSerializableOuterClass" defaultSeverity="WARNING" displayName="직렬화할 수 없는 외부 클래스와 직렬화 가능한 &lt;0&gt;static&lt;/0&gt;이 아닌 내부 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Serializable&lt;/code&gt;을 구현하며 &lt;code&gt;Serializable&lt;/code&gt;를 구현하지 않는 클래스 내부에 선언되어 있는 static이 아닌 내부 클래스를 보고합니다.
&lt;p&gt;
  그러한 클래스는 외부 클래스에 대한 묵시적 참조로 인해 올바르게 직렬화할 가능성이 낮습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
    class Main implements Serializable {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;다음 옵션을 사용해 검사를 구성하세요.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    이 검사에서 보고되어서는 안 되는 상속자를 가진 클래스를 나열합니다.
    이는 상위 클래스에서 &lt;code&gt;Serializable&lt;/code&gt;을 상속받지만 직렬화를 의도하지 않은 클래스를 의미합니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;Serializable&lt;/code&gt; 익명 클래스를 무시할지 여부를 설정합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SerializableInnerClassWithNonSerializableOuterClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TransientFieldNotInitialized" defaultSeverity="WARNING" displayName="transient 필드는 역직렬화에서 초기화되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스에 &lt;code&gt;readObject&lt;/code&gt; 메서드가 없으나 일반 객체 생성 도중 초기화되는 &lt;code&gt;transient&lt;/code&gt; 필드를 보고합니다.
&lt;p&gt;
  &lt;code&gt;transient&lt;/code&gt; 필드는 직렬화되지 않으므로 역직렬화 도중 &lt;code&gt;readObject()&lt;/code&gt; 메서드에서 별도로 초기화되어야 합니다.
&lt;/p&gt;
&lt;p&gt;
  일반 객체 생성 도중 초기화되지 않는 모든 &lt;code&gt;transient&lt;/code&gt; 필드는 기본 초기화를 사용하는 것으로 간주되며 이 검사에서 보고되지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person implements Serializable {
    transient String name = "Default"; // 경고: 역직렬화 후 실제로 null이 될 수 있습니다
    transient String surname; // null이 디폴트 값으로 간주되며 보고되지 않습니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TransientFieldNotInitialized&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReadResolveAndWriteReplaceProtected" defaultSeverity="WARNING" displayName="'readResolve()' 또는 'writeReplace()'가 'protected'로 선언되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.io.Serializable&lt;/code&gt;을 구현하는 클래스의 &lt;code&gt;readResolve()&lt;/code&gt;
또는 &lt;code&gt;writeReplace()&lt;/code&gt; 메서드가 &lt;code&gt;protected&lt;/code&gt;로 선언되어 있지 않은 경우를 보고합니다.
&lt;p&gt;
  &lt;code&gt;readResolve()&lt;/code&gt; 및 &lt;code&gt;writeReplace()&lt;/code&gt; 메서드를 &lt;code&gt;private&lt;/code&gt;으로 선언하면 하위 클래스가 확인 없이 이 메서드를 무시할 수 있습니다. 반면 &lt;code&gt;public&lt;/code&gt;으로 선언하면 신뢰할 수 없는 코드에 의해 호출될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  포함하는 클래스가 &lt;code&gt;final&lt;/code&gt;로 선언된 경우 이 메서드를 &lt;code&gt;private&lt;/code&gt;으로 선언할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class ClassWithSerialization implements Serializable {
    public Object writeReplace() { // 경고: 'writeReplace()'가 protected로 선언되지 않았습니다
        ...
    }
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ReadResolveAndWriteReplaceProtected&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableRecordContainsIgnoredMembers" defaultSeverity="WARNING" displayName="'record'가 무시된 멤버 포함" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;record&lt;/code&gt; 클래스에 정의된 직렬화 메서드 또는 필드를 보고합니다.
직렬화 메서드에는 &lt;code&gt;writeObject()&lt;/code&gt;, &lt;code&gt;readObject()&lt;/code&gt;, &lt;code&gt;readObjectNoData()&lt;/code&gt;, &lt;code&gt;writeExternal()&lt;/code&gt;, &lt;code&gt;readExternal()&lt;/code&gt; 및 필드 &lt;code&gt;serialPersistentFields&lt;/code&gt;가 포함됩니다.
  이러한 멤버는 레코드의 직렬화 또는 비직렬화에 사용되지 않으므로 불필요합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record R1() implements Serializable {
    // 필드가 레코드 직렬화 도중 무시됩니다
    @Serial
    private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];

    // 메서드가 레코드 직렬화 도중 무시됩니다
    @Serial
    private void writeObject(ObjectOutputStream out) throws IOException {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
  record R2() implements Externalizable {
    // 메서드가 레코드 직렬화 도중 무시됩니다
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
    }

    // 메서드가 레코드 직렬화 도중 무시됩니다
    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 16부터 사용할 수 있는 Java 기능 &amp;#39;기록&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SerializableRecordContainsIgnoredMembers&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableFieldInSerializableClass" defaultSeverity="WARNING" displayName="Serializable 클래스의 비 'Serializable' 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.io.Serializable&lt;/code&gt;을 구현하는 클래스 내 직렬화할 수 없는 필드를 보고합니다. 그러한 필드는 객체가 직렬화되는 경우 런타임 예외를 발생시킵니다.
&lt;p&gt;
  &lt;code&gt;transient&lt;/code&gt; 또는 &lt;code&gt;static&lt;/code&gt;으로 선언된 필드 또는 &lt;code&gt;writeObject&lt;/code&gt; 메서드가 정의된 클래스의 필드는 보고되지 않습니다.
&lt;/p&gt;
&lt;p&gt;
  이 검사는 선언된 타입이 &lt;code&gt;Serializable&lt;/code&gt; 이외의 객체가 아닌 이상 &lt;code&gt;java.util.Collection&lt;/code&gt; 및
  &lt;code&gt;java.util.Map&lt;/code&gt; 타입의 필드는 &lt;code&gt;Serializable&lt;/code&gt;이라고 가정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class NonSerializableClass {}

  public class SerializableClass implements Serializable {
      NonSerializableClass clazz; // 경고: Serializable 클래스 내 직렬화할 수 없는 필드
      static NonSerializableClass staticClazz; // 경고 안 함
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  다음 옵션을 사용해 검사를 구성하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    이 검사에서 보고되어서는 안 되는 상속자를 가진 클래스를 나열합니다.
    이는 상위 클래스에서 &lt;code&gt;Serializable&lt;/code&gt;을 상속받지만 직렬화를 의도하지 않은 클래스를 의미합니다.
  &lt;/li&gt;
  &lt;li&gt;
    검사에서 어노테이션이 추가된 필드가 무시되도록 만들 어노테이션을 나열합니다.
  &lt;/li&gt;
  &lt;li&gt;
    익명 클래스로 초기화된 필드를 무시할지 여부를 설정합니다.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: NonSerializableFieldInSerializableClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableWithSerializationMethods" defaultSeverity="WARNING" displayName="'readObject()' 또는 'writeObject()'가 있는 비 serializable 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;readObject()&lt;/code&gt; 또는 &lt;code&gt;writeObject()&lt;/code&gt; 메서드를 정의하는 비 &lt;code&gt;Serializable&lt;/code&gt; 클래스를 보고합니다. 해당 컨텍스트에서 그러한 메서드는 보통 오류를 나타냅니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class SampleClass {
    private void readObject(ObjectInputStream str) {}
    private void writeObject(ObjectOutputStream str) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: NonSerializableWithSerializationMethods&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableWithUnconstructableAncestor" defaultSeverity="WARNING" displayName="생성할 수 없는 조상을 가진 Serializable 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
직렬화할 수 없는 가장 가까운 상위 클래스에 인수가 없는 생성자가 없는 &lt;code&gt;Serializable&lt;/code&gt; 클래스를 보고합니다. 그러한 클래스는 역직렬화할 수 없으며 &lt;code&gt;InvalidClassException&lt;/code&gt;를 발생시키며 실패합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Ancestor {
    private String name;
    Ancestor(String name) {
      this.name = name;
    }
  }

  // 상위 클래스가 직렬화 불가능하며
  // 생성자가 인수를 취하기 때문에이 클래스에 경고 발생
  class Descendant extends Ancestor implements Serializable {
    Descendant() {
      super("Bob");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SerializableWithUnconstructableAncestor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerialVersionUIDNotStaticFinal" defaultSeverity="WARNING" displayName="'serialVersionUID' 필드가 'private static final long'으로 선언되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;serialVersionUID&lt;/code&gt; 필드가 &lt;code&gt;private static final long&lt;/code&gt;으로 선언되어 있지 않은 &lt;code&gt;Serializable&lt;/code&gt; 클래스를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SampleClass implements Serializable {
    private long serialVersionUID = 1; // Serializable 클래스의 필드가 'private static final long'으로 정의되지 않았습니다

    public SampleClass() {
        System.out.println(serialVersionUID);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: SerialVersionUIDNotStaticFinal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExternalizableWithoutPublicNoArgConstructor" defaultSeverity="WARNING" displayName="'public' 비인수 생성자가 없는 'Externalizable' 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인수 없는 public 생성자가 없는 &lt;code&gt;Externalizable&lt;/code&gt; 클래스를 보고합니다.
&lt;p&gt;&lt;code&gt;Externalizable&lt;/code&gt; 객체가 재생성되면 인스턴스는 &lt;code&gt;readExternal&lt;/code&gt; 메서드가 호출되기 전에 인수 없는 public 생성자를 사용하여 생성됩니다. 인수 없는 public 생성자를 사용할 수 없는 경우, 런타임 시 &lt;code&gt;java.io.InvalidClassException&lt;/code&gt;가 던져집니다.
  &lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExternalizableWithoutPublicNoArgConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableInnerClassHasSerialVersionUIDField" defaultSeverity="WARNING" displayName="'serialVersionUID'가 없는 Serializable 비 static 내부 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.io.Serializable&lt;/code&gt;을 구현하지만 &lt;code&gt;serialVersionUID&lt;/code&gt; 필드를 정의하지 않는 static이 아닌 내부 클래스를 보고합니다.
&lt;p&gt;
  &lt;code&gt;serialVersionUID&lt;/code&gt; 필드가 없으면 클래스에 변경 적용 시 이전에 시리얼화된 버전을 읽을 수 없게 됩니다. &lt;code&gt;Serializable&lt;/code&gt; 비 static 내부 클래스에 &lt;code&gt;serialVersionUID&lt;/code&gt; 필드를 포함할 것을 강력히 권장합니다. 그러지 않으면 디폴트 직렬화 알고리즘을 사용하게 되어, 직렬화된 버전이 통합 제어자 메서드의 차이 때문에 컴파일러 간에 호환되지 않을 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  누락된 &lt;code&gt;serialVersionUID&lt;/code&gt; 필드를 추가하는 빠른 수정이 제안됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
      class Inner implements Serializable {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
      class Inner implements Serializable {
          private static final long serialVersionUID = -7004458730436243902L;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;다음 옵션을 사용해 검사를 구성하세요.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    이 검사에서 보고되어서는 안 되는 상속자를 가진 클래스를 나열합니다.
    이는 상위 클래스에서 &lt;code&gt;Serializable&lt;/code&gt;을 상속받지만 직렬화를 의도하지 않은 클래스를 의미합니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;Serializable&lt;/code&gt; 익명 클래스를 무시할지 여부를 설정합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SerializableInnerClassHasSerialVersionUIDField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TransientFieldInNonSerializableClass" defaultSeverity="WARNING" displayName="비 Serializable 클래스의 transient 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.io.Serializable&lt;/code&gt;을 구현하지 않는 클래스 내 &lt;code&gt;transient&lt;/code&gt; 필드를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class NonSerializableClass {
    private transient String password;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class NonSerializableClass {
    private String password;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: TransientFieldInNonSerializableClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerialAnnotationUsedOnWrongMember" defaultSeverity="WARNING" displayName="'@Serial' 어노테이션이 잘못된 멤버에 사용됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.io.Serial&lt;/code&gt; 어노테이션이 추가되기에 적합하지 않은 &lt;code&gt;Serializable&lt;/code&gt; 및 &lt;code&gt;Externalizable&lt;/code&gt; 클래스 내 메서드 및 필드를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Test implements Serializable {
  @Serial // 어노테이션이 추가된 필드는 final이 아니므로 직렬화 메커니즘의 일부가 아닙니다
  private static long serialVersionUID = 7874493593505141603L;

  @Serial // 어노테이션이 추가된 메서드는 private이 아니므로 직렬화 메커니즘의 일부가 아닙니다
  void writeObject(ObjectOutputStream out) throws IOException {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
class Test implements Externalizable {
  @Serial // 어노테이션이 추가된 메서드는 Externalizable 클래스 내부에 있으므로 직렬화 메커니즘의 일부가 아닙니다
  private void writeObject(ObjectOutputStream out) throws IOException {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;올바른 모든 경우에 관한 자세한 정보는 &lt;code&gt;java.io.Serial&lt;/code&gt; 클래스에 관한 Javadoc을 참조하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 14부터 사용할 수 있는 Java 기능 &amp;#39;@Serial 어노테이션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SerialAnnotationUsedOnWrongMember&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableObjectBoundToHttpSession" defaultSeverity="WARNING" displayName="비 serializable 객체가 'HttpSession'으로 바운드됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.io.Serializable&lt;/code&gt;을 구현하지 않는 클래스의 객체가 &lt;code&gt;javax.servlet.http.HttpSession.setAttribute()&lt;/code&gt; 또는 &lt;code&gt;javax.servlet.http.HttpSession.putValue()&lt;/code&gt;의 인수로 사용된 경우를 보고합니다.
&lt;p&gt;
  &lt;code&gt;HttpSession&lt;/code&gt;이 패시베이션되거나 마이그레이션되지 않은 경우 그러한 객체는 직렬화되지 않으며 진단하기 어려운 버그를 초래할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  이 검사는 타입 매개변수가 비 &lt;code&gt;Serializable&lt;/code&gt; 객체가 아닌 이상 &lt;code&gt;java.util.Collection&lt;/code&gt; 및 &lt;code&gt;java.util.Map&lt;/code&gt; 타입의 객체는 &lt;code&gt;Serializable&lt;/code&gt;이라고 가정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(HttpSession session) {
      session.setAttribute("foo", new NonSerializable());
  }
  static class NonSerializable {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: NonSerializableObjectBoundToHttpSession&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableWithSerialVersionUIDField" defaultSeverity="WARNING" displayName="'serialVersionUID'가 있는 비 serializable 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;serialVersionUID&lt;/code&gt; 필드를 정의하는 비 &lt;code&gt;Serializable&lt;/code&gt; 클래스를 보고합니다. 그러한 컨텍스트에서 &lt;code&gt;serialVersionUID&lt;/code&gt; 필드는 무시되며 클래스는 직렬화되지 않기 때문에 보통 오류를 나타냅니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class IWantToSerializeThis {
    private static final long serialVersionUID = 2669293150219020249L;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonSerializableWithSerialVersionUIDField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerialPersistentFieldsWithWrongSignature" defaultSeverity="WARNING" displayName="'serialPersistentFields' 필드가 'private static final ObjectStreamField[]'로 선언되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;serialPersistentFields&lt;/code&gt; 필드가 private static final ObjectStreamField[]&lt;/code&gt;로 선언되어 있지 않은 &lt;code&gt;Serializable&lt;/code&gt; 클래스를 보고합니다.
&lt;p&gt;
  &lt;code&gt;serialPersistentFields&lt;/code&gt; 필드가 그러한 제어자로 선언되어 있지 않은 경우, 직렬화는 필드가 전혀 선언되어 있지 않은 것과 같이 동작합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class List implements Serializable {
    private List next;

    ObjectStreamField[] serialPersistentFields = {new ObjectStreamField("next", List.class)};

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: SerialPersistentFieldsWithWrongSignature&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableObjectPassedToObjectStream" defaultSeverity="WARNING" displayName="비 serializable 객체가 'ObjectOutputStream'으로 전달됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.io.ObjectOutputStream.write()&lt;/code&gt;의 인수로 사용된 비 &lt;code&gt;Serializable&lt;/code&gt; 객체를 보고합니다. 그러한 호출은 런타임 예외를 발생시킵니다.
&lt;p&gt;
  이 검사는 선언된 타입이 비 &lt;code&gt;Serializable&lt;/code&gt; 객체가 아닌 이상 &lt;code&gt;java.util.Collection&lt;/code&gt; 및 &lt;code&gt;java.util.Map&lt;/code&gt; 타입의 객체는 &lt;code&gt;Serializable&lt;/code&gt;이라고 가정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class IWantToSerializeThis {
    public static void main(String[] args) throws IOException {
      try(var stream = new ObjectOutputStream(Files.newOutputStream(Paths.get("output")))) {
        // 경고 -- NotSerializableException이 발생하며 실패합니다
        stream.writeObject(new IWantToSerializeThis());
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonSerializableObjectPassedToObjectStream&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingSerialAnnotation" defaultSeverity="WARNING" displayName="'@Serial' 어노테이션 사용 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.io.Serial&lt;/code&gt; 어노테이션이 추가되기에 적합한 &lt;code&gt;Serializable&lt;/code&gt; 및 &lt;code&gt;Externalizable&lt;/code&gt; 클래스 내 메서드 및 필드를 보고합니다. 빠른 수정에서는 어노테이션을 추가합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Main implements Serializable {
  private static final long serialVersionUID = 7874493593505141603L;

  private void writeObject(ObjectOutputStream out) throws IOException {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Serializable {
    @Serial
    private static final long serialVersionUID = 7874493593505141603L;

    @Serial
    private void writeObject(ObjectOutputStream out) throws IOException {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Externalizable {
    protected Object readResolve() throws ObjectStreamException {
      return "SomeObject";
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Externalizable {
    @Serial
    protected Object readResolve() throws ObjectStreamException {
        return "SomeObject";
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;가능한 모든 경우에 관한 자세한 정보는 &lt;code&gt;java.io.Serial&lt;/code&gt; 클래스에 관한 Javadoc을 참조하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2020.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 14부터 사용할 수 있는 Java 기능 &amp;#39;@Serial 어노테이션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MissingSerialAnnotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableStoresNonSerializable" defaultSeverity="WARNING" displayName="'Serializable' 객체가 비 'Serializable' 객체를 묵시적으로 저장" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Serializable&lt;/code&gt; 람다, 로컬 클래스 및 익명 클래스 외부의 비 &lt;code&gt;Serializable&lt;/code&gt; 지역 변수에 대한 모든 참조를 보고합니다.
&lt;p&gt;
  익명 클래스에서 지역 변수가 참조되는 경우 그 값은 클래스의 묵시적 필드에 저장됩니다. 지역 클래스 및 람다에 대해서도 같은 동작이 발생합니다. 변수가 &lt;code&gt;Serializable&lt;/code&gt; 타입이 아닌 경우 직렬화는 실패합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface A extends Serializable {
      abstract void foo();
  }
  class B {}
  class C {
      void foo() {
          B b = new B();
          A a = new A() {
              @Override
              public void foo() {
                  System.out.println(b); // 경고
              }
          };
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: SerializableStoresNonSerializable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Compose 미리보기" path=""><inspection shortName="ComposePreviewDimensionRespectsLimit" defaultSeverity="WARNING" displayName="미리보기 크기에는 최소 및 최대 한도가 있음" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="PreviewDeviceShouldUseNewSpec" defaultSeverity="WEAK WARNING" displayName="기존 기기 사양 사용 중" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="PreviewMultipleParameterProviders" defaultSeverity="ERROR" displayName="여러 개의 @PreviewParameter는 허용되지 않습니다" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다중 @PreviewParameter 어노테이션을 탐지합니다. 여러 개의 @PreviewParameter는 허용되지 않습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PreviewMultipleParameterProviders&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComposePreviewNotSupportedInUnitTestFiles" defaultSeverity="ERROR" displayName="미리보기는 유닛 테스트 파일에서 지원되지 않습니다" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="PreviewShouldNotBeCalledRecursively" defaultSeverity="WEAK WARNING" displayName="미리보기 함수에 대한 재귀 호출" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="ComposePreviewNeedsComposableAnnotation" defaultSeverity="ERROR" displayName="미리보기가 비 Composable 함수에서 사용됨" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="PreviewPickerAnnotation" defaultSeverity="ERROR" displayName="미리보기 기기 매개변수는 문법이 유효해야 합니다" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
미리보기의 기기 매개변수의 구문이 올바른지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PreviewPickerAnnotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PreviewApiLevelMustBeValid" defaultSeverity="ERROR" displayName="미리보기 apiLevel은 반드시 지원되는 API 수준에 대응해야 합니다" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
미리보기의 &lt;code&gt;apiLevel&lt;/code&gt;이 지원되는 API 수준에 대응하는지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PreviewApiLevelMustBeValid&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComposePreviewMustBeTopLevelFunction" defaultSeverity="ERROR" displayName="미리보기가 최상위 선언이거나 디폴트 생성자가 있는 최상위 클래스에 있어야 합니다." enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="PreviewParameterProviderOnFirstParameter" defaultSeverity="ERROR" displayName="@PreviewParameter는 Composable 함수의 첫 번째 매개변수에서만 허용됩니다" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="PreviewAnnotationInFunctionWithParameters" defaultSeverity="ERROR" displayName="미리보기가 매개변수를 가진 Composable 함수에서 사용됨" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
Preview가 매개변수가 있는 Composable 함수와 사용되지 않았는지 확인합니다. 매개변수를 가진 Composable 함수는 Preview에서 지원되지 않습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PreviewAnnotationInFunctionWithParameters&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="PreviewFontScaleMustBeGreaterThanZero" defaultSeverity="ERROR" displayName="양수가 아닌 fontScale 매개변수" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
미리보기의 &lt;code&gt;fontScale&lt;/code&gt; 값이 0보다 큰지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PreviewFontScaleMustBeGreaterThanZero&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="셸 스크립트" path=""><inspection shortName="ShellCheck" defaultSeverity="ERROR" displayName="ShellCheck" enabled="false" language="Shell Script" pluginId="com.jetbrains.sh" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
통합 &lt;a href="https://github.com/koalaman/shellcheck"&gt;ShellCheck&lt;/a&gt; 정적 분석 도구에 의해 탐지된 셸 스크립트 버그를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ShellCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JavaFX" path=""><inspection shortName="JavaFxEventHandler" defaultSeverity="WARNING" displayName="이벤트 핸들러 메서드 시그니처 문제" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
호환되지 않는 인수 타입, 모호한 이벤트 핸들러 메서드 및 잘못된 반환 타입을 포함한 이벤트 핸들러 이슈를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JavaFxEventHandler&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaFxUnresolvedFxIdReference" defaultSeverity="WARNING" displayName="해결되지 않은 fx:id 속성 참조" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해결되지 않은 fx:id 참조를 보고합니다. 빠른 수정이 해당 필드를 생성합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JavaFxUnresolvedFxIdReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaFxDefaultTag" defaultSeverity="WARNING" displayName="불필요한 디폴트 태그" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
.fxml 파일 내 불필요한 태그를 보고합니다. 이러한 태그는 @DefaultProperty 클래스 어노테이션 내 선언된 클래스 프로퍼티와 일치하므로 생략될 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavaFxDefaultTag&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaFxRedundantPropertyValue" defaultSeverity="WARNING" displayName="JavaFX 불필요한 프로퍼티 값" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
디폴트 값이 있으므로 불필요한 .fxml files 내 프로퍼티(속성과 태그 모두)를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavaFxRedundantPropertyValue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaFxResourcePropertyValue" defaultSeverity="WARNING" displayName="프로퍼티 파일의 값이 속성 타입과 호환되지 않습니다" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
속성의 타입과 일치하지 않는 .properties 파일에 정의된 속성 값을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JavaFxResourcePropertyValue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaFxUnusedImports" defaultSeverity="WARNING" displayName="JavaFX 사용되지 않는 import 문" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
.fxml 파일에서 사용되지 않는 import 문을 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavaFxUnusedImports&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaFxUnresolvedStyleClassReference" defaultSeverity="WARNING" displayName="해결되지 않은 스타일 클래스 참조" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해결되지 않은 CSS 스타일 클래스를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JavaFxUnresolvedStyleClassReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaFxColorRgb" defaultSeverity="WARNING" displayName="색상 구성 요소가 범위를 벗어났습니다" enabled="false" language="XML" pluginId="org.jetbrains.plugins.javaFX" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
유효한 범위를 벗어난 RGB 색상 구성 요소를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavaFxColorRgb&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Kotlin Android" path=""><inspection shortName="IllegalIdentifier" defaultSeverity="ERROR" displayName="Illegal Android Identifier" enabled="false" language="kotlin" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Android 런타임에서 허용되지 않는 Android 프로젝트 식별자를 보고합니다.
예를 들어, 공백이 포함된 메서드 이름이 이에 해당합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
      var 'a b c' = 3
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;문제를 해결하려면 Android 런타임 요구 사항에 부합하도록 식별자 이름을 변경합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IllegalIdentifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="K2TypeParameterFindViewById" defaultSeverity="WEAK WARNING" displayName="Cast can be converted to findViewById with type parameter" enabled="false" language="kotlin" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false"></inspection></group><group name="대입 이슈" path="Java"><inspection shortName="AssignmentToSuperclassField" defaultSeverity="WARNING" displayName="생성자가 상위 클래스에 정의된 필드에 값을 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
하위 클래스 생성자 내에서 상위 클래스에 선언된 필드에 값을 대입하거나 필드를 수정하는 경우를 보고합니다.
&lt;p&gt;상위 클래스의 필드를 자신의 생성자에서 초기화하고, 하위 클래스의 해당 생성자에 위임하는 것이 바람직합니다. 이렇게 하면 생성 후 필드가 변경되지 않은 경우 이 필드를 &lt;code&gt;final&lt;/code&gt;로 선언할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    int x;
  }
  class Sub extends Super {
    Sub(int _x) {
      // Warning: x is declared in a superclass
      x = _x;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 문제를 방지하기 위해 상위 클래스 생성자를 선언하세요.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    final int x;

    Super(int _x) {
      x = _x;
    }
  }
  class Sub extends Super {
    Sub(int _x) {
      super(_x);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AssignmentToSuperclassField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToNull" defaultSeverity="WARNING" displayName="'null' 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
선언 외부에서 &lt;code&gt;null&lt;/code&gt;로 대입된 변수를 보고합니다.
&lt;p&gt;Java에서 &lt;code&gt;null&lt;/code&gt;의 주요 목적은 초기화되지 않은 참조 변수를 나타내는 것입니다. 드문 경우이지만, 변수를 명시적으로 &lt;code&gt;null&lt;/code&gt;에 대입하면 가비지 컬렉션에 도움이 될 수 있습니다. 그러나 누락, 미지정 또는 잘못된 값이나 미발견 요소를 나타내는 데 &lt;code&gt;null&lt;/code&gt;을 사용하는 것은 좋지 않은 사례로 간주되며, 코드에서 &lt;code&gt;NullPointerExceptions&lt;/code&gt;가 발생하기 쉽습니다.
  대신, 의도된 의미를 가진 sentinel 객체를 정의하는 것을 고려하거나 &lt;code&gt;Optional&lt;/code&gt; 같은 라이브러리 타입을 사용하여 값의 부재를 나타내세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer convert(String s) {
    Integer value;
    try {
      value = Integer.parseInt(s);
    } catch (NumberFormatException e) {
      // 경고: null은 '잘못된 값'을 나타내는 데 사용됩니다
      value = null;
    }
    return value;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;b&gt;필드에 대한 대입 무시&lt;/b&gt; 옵션을 사용하여 필드에 대한 대입을 무시합니다.
&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: AssignmentToNull&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncrementDecrementUsedAsExpression" defaultSeverity="WARNING" displayName="'++' 또는 '--' 결과가 사용됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 표현식 내에서 중첩된 증분 또는 감소 표현식을 보고합니다.
그러한 표현식은 혼란을 일으킬 수 있으며 모든 구문은 정확히 한 가지 작업을 수행해야 한다는 일반적인 설계 규칙을 위반합니다.
&lt;p&gt;빠른 수정에서는 증분 또는 감소 연산을 별도의 표현식 구문으로 추출합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 10;
  while (i-- &gt; 0) {
    System.out.println(i);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 10;
  while (i &gt; 0) {
    i--;
    System.out.println(i);
  }
  i--;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IncrementDecrementUsedAsExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceAssignmentWithOperatorAssignment" defaultSeverity="INFORMATION" displayName="대입을 연산자 대입으로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
연산자 대입으로 대체 가능한 대입 연산을 보고합니다.
&lt;p&gt;연산자 대입을 사용하는 코드가 더욱 간결하고 명확합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  x = x + 3;
  x = x / 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  x += 3;
  x /= 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 연산자를 무시하려면 &lt;b&gt;조건 연산자 무시&lt;/b&gt; 옵션을 사용합니다. 연산자 대입이 있는 조건 연산자는 지연 평가를 즉시 평가로 바꾸므로 표현식의 의미가 변경될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
잘 알려지지 않은 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 연산자를 무시하려면 &lt;b&gt;모호한 연산자 무시&lt;/b&gt; 옵션을 사용합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceAssignmentWithOperatorAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToStaticFieldFromInstanceMethod" defaultSeverity="WARNING" displayName="인스턴스 컨텍스트의 static 필드에 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인스턴스 메서드 내부에서 이루어진 &lt;code&gt;static&lt;/code&gt; 필드에 대한 대입 또는 수정을 보고합니다.
&lt;p&gt;이러한 대입은 허용되더라도 안전하게 실행하기가 어렵고 실수로 필드를 &lt;code&gt;static&lt;/code&gt;으로 설정하게 되는 경우가 종종 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Counter {
    private static int count = 0;

    void increment() {
      // 경고: 인스턴스 메서드에서
      // static 필드를 업데이트 중입니다
      count++;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AssignmentToStaticFieldFromInstanceMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedAssignment" defaultSeverity="WARNING" displayName="중첩된 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 표현식 내부에 중첩된 대입 표현식을 보고합니다.
&lt;p&gt;그러한 표현식은 혼란을 일으킬 수 있으며 모든 구문은 정확히 한 가지 작업을 수행해야 한다는 일반적인 설계 규칙을 위반합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String userName;
  // 경고: 'userName'에 대한 대입 결과가 사용됩니다
  String message = "Hello " + (userName = "Alice") + "!"
  System.out.println(message);
  System.out.println("Goodbye " + userName);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NestedAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToMethodParameter" defaultSeverity="WARNING" displayName="메서드 매개변수에 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 매개변수에 대한 대입 또는 수정을 보고합니다.
&lt;p&gt;의도된 경우도 있으나 이 구문은 혼동될 수 있으므로 일부 Java 프로젝트에서 금지됩니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 새로운 변수 선언을 추가합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void printTrimmed(String s) {
    s = s.trim();
    System.out.println(s);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void printTrimmed(String s) {
    String trimmed = s.trim();
    System.out.println(trimmed);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;대입이 원본 매개변수의 변형인 경우 무시&lt;/b&gt; 옵션을 사용하여 이전 값에 따라 매개변수 값을 수정하는 대입을 무시합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AssignmentToMethodParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToForLoopParameter" defaultSeverity="WARNING" displayName="'for' 루프 매개변수에 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루프 본문 내에서의 &lt;code&gt;for&lt;/code&gt; 루프 매개변수에 대한 대입 또는 수정을 보고합니다.
&lt;p&gt;의도된 경우도 있으나 이러한 구문은 혼동될 수 있으며, 오타 또는 잘못된 변수 사용으로 인해 종종 발생하기도 합니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 새로운 변수 선언을 추가합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String s : list) {
    // 경고: s가 루프 내에서 변경되었습니다
    s = s.trim();
    System.out.println("String: " + s);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String s : list) {
    String trimmed = s.trim();
    System.out.println("String: " + trimmed);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;업데이트 구문이 없는 기본 &lt;code&gt;for&lt;/code&gt; 루프의 대입은 보고되지 않습니다.
  이러한 경우 대입은 의도적일 가능성이 있고 &lt;code&gt;for&lt;/code&gt; 루프의 업데이트 부분으로 쉽게 이동할 수 없습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i = 0; i &amp;lt; list.size(); ) {
    if (element.equals(list.get(i))) {
      list.remove(i);
    } else {
      // 업데이트 구문이 없으므로 for 루프 매개변수
      // 수정은 보고되지 않습니다
      i++;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;향상된 'for' 루프 매개변수 검사&lt;/b&gt; 옵션을 사용하여 향상된 &lt;code&gt;for&lt;/code&gt; 루프 매개변수 수정도 보고해야 하는지 
  지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AssignmentToForLoopParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToLambdaParameter" defaultSeverity="WARNING" displayName="람다 매개변수에 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
람다 매개변수에 대한 대입 또는 수정을 보고합니다.
의도된 경우도 있으나 이 구문은 혼란스러울 수 있고, 오타 또는 잘못된 변수 사용으로 인해 종종 발생하기도 합니다.
&lt;p&gt;빠른 수정에서는 새로운 변수 선언을 추가합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  list.forEach(s -&gt; {
    s = s.trim();
    System.out.println("String: " + s);
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  list.forEach(s -&gt; {
    String trimmed = s.trim();
    System.out.println("String: " + trimmed);
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;대입이 원본 매개변수의 변형인 경우 무시&lt;/b&gt; 옵션을 사용하여 이전 값에 따라 매개변수 값을 수정하는 대입을 무시합니다.&lt;/p&gt;
&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;람다 식&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AssignmentToLambdaParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToCatchBlockParameter" defaultSeverity="WARNING" displayName="'catch' 블록 매개변수에 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;catch&lt;/code&gt; 블록 매개변수로의 대입을 보고합니다.
&lt;p&gt;&lt;code&gt;catch&lt;/code&gt; 블록 매개변수를 변경하면 매우 혼동될 수 있어 권장하지 않습니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 새로운 변수 선언을 추가합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void processFile(String fileName) throws Exception {
    try {
      doProcessFile(fileName);
    } catch(Exception ex) {
      if (ex instanceof UncheckedIOException) {
        // Warning: catch block parameter reassigned
        ex = ((UncheckedIOException) ex).getCause();
      }
      throw ex;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void processFile(String fileName) throws Exception {
    try {
      doProcessFile(fileName);
    } catch(Exception ex) {
      Exception unwrapped = ex;
      if (unwrapped instanceof UncheckedIOException) {
        unwrapped = ((UncheckedIOException)
          unwrapped).getCause();
      }
      throw unwrapped;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AssignmentToCatchBlockParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentUsedAsCondition" defaultSeverity="WARNING" displayName="조건으로 사용된 대입" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; 또는 &lt;code&gt;do&lt;/code&gt; 문 또는 조건식에서 조건으로 사용되는 대입을 보고합니다.
&lt;p&gt;의도된 경우도 있으나 이러한 사용은 혼란을 일으키며, 오타를 나타낼 수 있습니다(예: &lt;code&gt;==&lt;/code&gt; 대신 &lt;code&gt;=&lt;/code&gt; 사용).&lt;/p&gt;
&lt;p&gt;빠른 수정은 &lt;code&gt;=&lt;/code&gt;를 &lt;code&gt;==&lt;/code&gt;로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void update(String str, boolean empty) {
    // 경고: 'empty'가 str.isEmpty()와 비교되지 않고
    // 재대입되었습니다
    if (empty = str.isEmpty()) {
      ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void update(String str, boolean empty) {
    if (empty == str.isEmpty()) {
      ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AssignmentUsedAsCondition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="리소스 관리" path="Java"><inspection shortName="ChannelResource" defaultSeverity="WARNING" displayName="'Channel'이 열렸으나 안전하게 닫히지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
파일 또는 소켓 리소스에서 &lt;code&gt;getChannel()&lt;/code&gt;을 호출하여 생성된 모든 인스턴스를 포함하여 안전하게 닫히지 않은 &lt;code&gt;Channel&lt;/code&gt; 리소스를 보고합니다.
&lt;p&gt;
  이 검사는 기본적으로 리소스의 이름에 'close' 또는 'cleanup'이 붙는 모든 메서드에 의해 닫힐 수 있다고 가정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void send(Socket socket) throws IOException {
    SocketChannel channel = socket.getChannel(); // 경고
    channel.write(ByteBuffer.wrap("message".getBytes()));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  다음 옵션을 사용해 검사를 구성하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;Channel&lt;/code&gt; 리소스를 &lt;code&gt;try&lt;/code&gt; 블록 내부에서 여는 것을 허용할지 여부를 설정합니다. 이 스타일은 &lt;code&gt;try&lt;/code&gt; 블록 앞에서 &lt;code&gt;Channel&lt;/code&gt;을 여는 것보다 장황하기 때문에 그다지 바람직하지 않습니다.
  &lt;/li&gt;
  &lt;li&gt;
    인수로서 전달된 리소스를 메서드 호출로 닫을 수 있는지 여부를 설정합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ChannelResource&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JDBCResource" defaultSeverity="WARNING" displayName="JDBC 리소스가 열렸으나 안전하게 닫히지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전하게 닫히지 않은 JDBC 리소스를 보고합니다. 이 검사에서 보고되는 JDBC 리소스에는 &lt;code&gt;java.sql.Connection&lt;/code&gt;,
&lt;code&gt;java.sql.Statement&lt;/code&gt;, &lt;code&gt;java.sql.PreparedStatement&lt;/code&gt;,
&lt;code&gt;java.sql.CallableStatement&lt;/code&gt;, &lt;code&gt;java.sql.ResultSet&lt;/code&gt;이 포함됩니다.
&lt;p&gt;
  이 검사는 기본적으로 리소스의 이름에 'close' 또는 'cleanup'이 붙는 모든 메서드에 의해 닫힐 수 있다고 가정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ResultSet findAllElements(Connection connection) throws SQLException {
    PreparedStatement statement = connection.prepareStatement("SELECT * FROM TABLE"); // 구문이 닫히지 않았습니다
    statement.execute();
    return statement.getResultSet();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  다음 옵션을 사용해 검사를 구성하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    JDBC 리소스를 &lt;code&gt;try&lt;/code&gt; 블록 내부에서 여는 것을 허용할지 여부를 설정합니다. 이 스타일은 &lt;code&gt;try&lt;/code&gt; 블록 앞에서 리소스를 여는 것보다 장황하기 때문에 그다지 바람직하지 않습니다.
  &lt;/li&gt;
  &lt;li&gt;
    인수로서 전달된 리소스를 메서드 호출로 닫을 수 있는지 여부를 설정합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JDBCResource&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JNDIResource" defaultSeverity="WARNING" displayName="JNDI 리소스가 열렸으나 안전하게 닫히지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전하게 닫히지 않은 JNDI 리소스를 보고합니다. 이 검사에서 보고되는 JNDI 리소스에는 &lt;code&gt;javax.naming.InitialContext&lt;/code&gt;, &lt;code&gt;javax.naming.NamingEnumeration&lt;/code&gt;이 포함됩니다.
&lt;p&gt;
  이 검사는 기본적으로 리소스의 이름에 'close' 또는 'cleanup'이 붙는 모든 메서드에 의해 닫힐 수 있다고 가정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object findObject(Properties properties, String name) throws NamingException {
    Context context = new InitialContext(properties); // 컨텍스트가 닫히지 않았습니다
    return context.lookup(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  다음 옵션을 사용해 검사를 구성하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    JNDI 리소스를 &lt;code&gt;try&lt;/code&gt; 블록 내부에서 여는 것을 허용할지 여부를 설정합니다.
    이 스타일은 &lt;code&gt;try&lt;/code&gt; 블록 앞에서 리소스를 여는 것보다 장황하기 때문에 그다지 바람직하지 않습니다.
  &lt;/li&gt;
  &lt;li&gt;
    인수로서 전달된 리소스를 메서드 호출로 닫을 수 있는지 여부를 설정합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JNDIResource&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HibernateResource" defaultSeverity="WARNING" displayName="Hibernate 리소스가 열렸으나 안전하게 닫히지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
반환된 &lt;code&gt;org.hibernate.Session&lt;/code&gt; 리소스가 안전하게 닫히지 않은 경우 &lt;code&gt;openSession()&lt;/code&gt; 메서드 호출을 보고합니다.
&lt;p&gt;
  이 검사는 기본적으로 리소스의 이름에 'close' 또는 'cleanup'이 붙는 모든 메서드에 의해 닫힐 수 있다고 가정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doHibernateQuery(SessionFactory factory) {
    Session session = factory.openSession(); // 경고
    session.createQuery("...");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  다음 옵션을 사용해 검사를 구성하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;org.hibernate.Session&lt;/code&gt; 리소스를 &lt;code&gt;try&lt;/code&gt; 블록 내부에서 여는 것을 허용할지 여부를 설정합니다. 이 스타일은 &lt;code&gt;try&lt;/code&gt; 블록 앞에서 리소스를 여는 것보다 장황하기 때문에 그다지 바람직하지 않습니다.
  &lt;/li&gt;
  &lt;li&gt;
    인수로서 전달된 리소스를 메서드 호출로 닫을 수 있는지 여부를 설정합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: HibernateResource&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SocketResource" defaultSeverity="WARNING" displayName="소켓이 열렸으나 안전하게 닫히지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전하게 닫히지 않은 소켓 리소스를 보고합니다. 이 검사에서 보고되는 소켓 리소스에는 &lt;code&gt;java.net.Socket&lt;/code&gt;,
&lt;code&gt;java.net.DatagramSocket&lt;/code&gt;, &lt;code&gt;java.net.ServerSocket&lt;/code&gt;이 포함됩니다.
&lt;p&gt;
  이 검사는 기본적으로 리소스의 이름에 'close' 또는 'cleanup'이 붙는 모든 메서드에 의해 닫힐 수 있다고 가정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  byte[] getMessage(ServerSocket socket) throws IOException {
    Socket client = socket.accept(); // 소켓이 닫히지 않았습니다 
    return client.getInputStream().readAllBytes();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  다음 옵션을 사용해 검사를 구성하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;try&lt;/code&gt; 블록 내에서 소켓 열기 허용 여부.
    이 스타일은 &lt;code&gt;try&lt;/code&gt; 블록 앞에서 리소스를 여는 것보다 장황하기 때문에 그다지 바람직하지 않습니다.
  &lt;/li&gt;
  &lt;li&gt;
    인수로서 전달된 리소스를 메서드 호출로 닫을 수 있는지 여부를 설정합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SocketResource&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IOResource" defaultSeverity="WARNING" displayName="I/O 리소스가 열렸으나 안전하게 닫히지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전하게 닫히지 않은 I/O 리소스를 보고합니다. 이 검사에서 검사되는 I/O 리소스에는 &lt;code&gt;java.io.InputStream&lt;/code&gt;,
&lt;code&gt;java.io.OutputStream&lt;/code&gt;, &lt;code&gt;java.io.Reader&lt;/code&gt;,
&lt;code&gt;java.io.Writer&lt;/code&gt;, &lt;code&gt;java.util.zip.ZipFile&lt;/code&gt;, &lt;code&gt;java.io.Closeable&lt;/code&gt;, &lt;code&gt;java.io.RandomAccessFile&lt;/code&gt;이 포함됩니다.
&lt;p&gt;
  래핑된 리소스는 래핑하는 리소스에 의해 닫히기 때문에 다른 I/O 리소스로 래핑된 I/O 리소스는 보고되지 않습니다.
&lt;/p&gt;
&lt;p&gt;
  이 검사는 기본적으로 리소스의 이름에 'close' 또는 'cleanup'이 붙는 모든 메서드에 의해 닫힐 수 있다고 가정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void save() throws IOException {
    FileWriter writer = new FileWriter("filename.txt"); // 경고
    writer.write("sample");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  다음 옵션을 사용해 검사를 구성하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;닫을 필요 없으며 이 검사에서 무시되어야 하는 I/O 리소스 클래스를 나열합니다.&lt;/li&gt;
  &lt;li&gt;
    I/O 리소스를 &lt;code&gt;try&lt;/code&gt; 블록 내부에서 여는 것을 허용할지 여부를 설정합니다.
    이 스타일은 &lt;code&gt;try&lt;/code&gt; 블록 앞에서 리소스를 여는 것보다 장황하기 때문에 그다지 바람직하지 않습니다.
  &lt;/li&gt;
  &lt;li&gt;
    인수로서 전달된 리소스를 메서드 호출로 닫을 수 있는지 여부를 설정합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IOResource&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AutoCloseableResource" defaultSeverity="WARNING" displayName="AutoCloseable을 'try'-with-resources 없이 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
try-with-resources 문에서 사용되지 않은 &lt;code&gt;AutoCloseable&lt;/code&gt; 인스턴스(&lt;i&gt;자동 리소스 관리&lt;/i&gt;라고도 불림)를 보고합니다.
&lt;p&gt;
  try-with-resources가 사용되기 이전에 사용되던 '&lt;code&gt;try&lt;/code&gt; 앞/내에서 리소스를 열고, &lt;code&gt;finally&lt;/code&gt; 내에서 닫기' 스타일 또한 보고됩니다.
  이 검사는 Java 7 이후 버전에서 개발 시 &lt;i&gt;열렸으나 안전하게 닫히지 않은&lt;/i&gt; 모든 검사를 바꾸는 것을 목적으로 합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private static void foo() throws IOException {
    InputStream profile = Thread.currentThread().getContextClassLoader().getResourceAsStream("/someFile");
    System.out.println(profile.read());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  다음 옵션을 사용해 검사를 구성하세요.
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    닫을 필요가 없으며 이 검사에서 무시되어야 하는 &lt;code&gt;AutoCloseable&lt;/code&gt;의 하위 클래스를 나열합니다.
    &lt;br/&gt;
    &lt;b&gt;참고&lt;/b&gt;: 이 검사는 &lt;code&gt;java.util.stream.Stream&lt;/code&gt;이 무시되어야 할 목록에 포함된 경우에도&lt;code&gt;java.nio.file.Files&lt;/code&gt; 메서드인 &lt;code&gt;lines()&lt;/code&gt;, &lt;code&gt;walk()&lt;/code&gt;, &lt;code&gt;list()&lt;/code&gt;, &lt;code&gt;find()&lt;/code&gt;에서 반환된 스트림을 보고합니다.
    이러한 스트림은 닫을 필요가 없는 관련 I/O 리소스를 포함합니다.
  &lt;/li&gt;
  &lt;li&gt;
    호출 시 무시되어야 하는 &lt;code&gt;AutoCloseable&lt;/code&gt;를 반환하는 메서드를 나열합니다.
  &lt;/li&gt;
  &lt;li&gt;
    메서드 호출의 결과인 경우 &lt;code&gt;AutoCloseable&lt;/code&gt;을 무시할지 여부를 설정합니다.
    이 옵션을 활성화하면 factory 메서드의 결과 또한 무시됩니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;AutoCloseable&lt;/code&gt; 인스턴스가 메서드 호출 인수로 전달된 경우 검사에서 보고되어야 하는지 여부를 설정합니다.
    이 옵션을 활성화하면 검사는 리소스가 호출된 메서드에서 닫힌 것으로 가정합니다.
    이름에 'close'를 포함하며 &lt;code&gt; AutoCloseable &lt;/code&gt; 인수를 사용하는 &lt;code&gt; finally&lt;/code&gt; 블록 내부의 메서드 호출은 무시되지 않습니다.
  &lt;/li&gt;
  &lt;li&gt;
    리소스 클래스의 생성자에 대한 메서드 참조를 무시할지 여부를 설정합니다.
  &lt;/li&gt;
  &lt;li&gt;
    리소스를 반환하며 이름이 'get'으로 시작하는 메서드를 무시할지 여부를 설정합니다.
    대부분의 getter가 리소스의 소유권을 전달하지 않으며 호출 지점에서 리소스를 닫아야 할 책임이 없으므로 이렇게 하면 거짓 양성을 줄일 수 있습니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 검사는 Java 7부터 사용할 수 있는 Java 기능 &amp;#39;Try-with-resources&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AutoCloseableResource&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DriverManagerGetConnection" defaultSeverity="WARNING" displayName="JDBC 연결을 얻기 위한 'DriverManager' 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JDBC 연결을 얻기 위한 &lt;code&gt;java.sql.DriverManager&lt;/code&gt; 사용을 보고합니다. 
&lt;p&gt;
  &lt;code&gt;java.sql.DriverManager&lt;/code&gt;는 연결 풀링 및 기타 최적화를 허용하는 &lt;code&gt;javax.sql.Datasource&lt;/code&gt;로 대체되었습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Connection conn = DriverManager.getConnection(url, username, password);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DriverManagerGetConnection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="발생할 수 있는 버그" path="Gradle"><inspection shortName="MultipleRepositoryUrls" defaultSeverity="WARNING" displayName="여러 저장소 URL" enabled="false" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
저장소 (maven 또는 ivy) 블록 당 여러 개의 URL이 사용된 사례를 보고합니다.
이 경우 문제는 저장소 당 한 개의 URL만 선택될 수 있으며 다른 URL은 무시되는 것입니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MultipleRepositoryUrls&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForeignDelegate" defaultSeverity="WEAK WARNING" displayName="Gradle 메서드 호출의 위치가 잘못되었을 수 있음" enabled="false" language="UAST" pluginId="org.jetbrains.plugins.gradle" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못 배치되었을 가능성이 있는 Gradle 메서드 호출을 탐지합니다.&lt;/p&gt;
  Gradle buildscripts는 중첩 클로저가 많이 있어서 코드 구조가 마크업 언어와 비슷합니다.
  DSL 언어의 동작으로 인해 외부 클로저에서 작성할 수 있는 메서드는 내부 클로저에서도 사용할 수 있습니다.
  이런 메서드는 범위 밖에서 작성되면 의미가 없을 수 있습니다. &lt;br&gt;
  때로는 이러한 상황을 탐지하기 어려울 수 있습니다.
  이 검사의 목표는 그런 메서드를 탐지하는 것입니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
repositories {
  // 'repositories'의 위임자는 'exclusiveContent' 메서드를 갖고 있으며, 여기에 작성될 수 있습니다
  maven {
    // 'maven'의 위임자는 'content' 메서드를 갖고 있으며, 여기에 작성될 수 있습니다
    // 그러나 'exclusiveContent'도 쓸 수 있습니다
    exclusiveContent {} // 'exclusiveContent'를 보고합니다
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ForeignDelegate&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BintrayPublishingPlugin" defaultSeverity="WARNING" displayName="Bintray 퍼블리싱 플러그인은 2021년 5월 1일에 중지될 수 있습니다" enabled="false" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;com.jfrog.bintray&lt;/code&gt; Gradle 플러그인 사용을 감지합니다.
  이 플러그인은 빌드 결과를 Bintray로 발행하기 위해 사용됩니다.
  &lt;a href="https://www.jfrog.com/confluence/display/BT/Welcome+to+JFrog+Bintray"&gt;Bintray&lt;/a&gt; 서비스로의 발행은 사용 중지되었습니다.
  &lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: BintrayPublishingPlugin&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JCenterRepository" defaultSeverity="WARNING" displayName="2022년 2월 1일 이후에는 빌드에서 JCenter의 아티팩트를 해결할 수 없습니다" enabled="false" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
종속성을 해결하기 위한 JCenter 저장소의 사용을 감지합니다.
2022년 2월 1일 이후 빌드에서는 더 이상 JCenter에서 아티팩트를 해결할 수 없습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JCenterRepository&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DependencyNotationArgument" defaultSeverity="WARNING" displayName="인식되지 않는 종속성 표기" enabled="false" language="UAST" pluginId="org.jetbrains.plugins.gradle" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 종속성 표기를 탐지합니다. &lt;/p&gt;
  다음 타입/형식은 Gradle에서 지원됩니다.
  &lt;ul&gt;
  &lt;li&gt; &lt;code&gt;Dependency&lt;/code&gt;의 인스턴스 &lt;/li&gt;
  &lt;li&gt; &lt;code&gt;String&lt;/code&gt; 또는 &lt;code&gt;CharSequence&lt;/code&gt; (예: &lt;code&gt;'org.gradle:gradle-core:1.0'&lt;/code&gt;) &lt;/li&gt;
  &lt;li&gt; Maps(예: &lt;code&gt;[group: 'org.gradle', name: 'gradle-core', version: '1.0']&lt;/code&gt;) &lt;/li&gt;
  &lt;li&gt; FileCollections(예: &lt;code&gt;files('some.jar', 'someOther.jar')&lt;/code&gt;) &lt;/li&gt;
  &lt;li&gt; Projects(예: &lt;code&gt;project(':some:project:path')&lt;/code&gt;) &lt;/li&gt;
  &lt;li&gt; &lt;code&gt;ClassPathNotation&lt;/code&gt;(예: &lt;code&gt;gradleApi()&lt;/code&gt;) &lt;/li&gt;
  &lt;li&gt; 종속성 표기의 목록(예: &lt;code&gt;['org.gradle:gradle-core:1.0']&lt;/code&gt;) &lt;/li&gt;
  &lt;li&gt; (Gradle 7.0+) &lt;a href="https://docs.gradle.org/current/userguide/platforms.html"&gt;버전 카탈로그 접근자&lt;/a&gt;(예: &lt;code&gt;libs.groovy.core&lt;/code&gt;) &lt;/li&gt;
&lt;/ul&gt;
  &lt;a href="https://docs.gradle.org/current/userguide/declaring_dependencies.html#sec:dependency-types"&gt;Gradle 문서 참조&lt;/a&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
dependencies {
  implementation(1) // reports '1'
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DependencyNotationArgument&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="유효성 문제" path="Groovy"><inspection shortName="GroovyUnreachableStatement" defaultSeverity="WARNING" displayName="도달할 수 없는 구문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;도달할 수 없는 구문을 보고합니다. 이는 구문이 무한 루프인 &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; 문 뒤에 올 때 발생합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo (int n) {
      if (n &lt; 1) {
          return
          &lt;b&gt;print('This statement is unreachable')&lt;/b&gt;
      }
      while (true){
          print ('Hello, world!')
      }
      &lt;b&gt;print('This statement is unreachable too')&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyUnreachableStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDuplicateSwitchBranch" defaultSeverity="WARNING" displayName="switch case 중복" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;switch&lt;/code&gt; 문의 &lt;code&gt;case&lt;/code&gt; 라벨에서 중복된 표현식을
보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
switch (n) {
  case 1: //중복
    break
  case 1: //중복
    System.out.println("2")
    break
  default:
    System.out.println("default");
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyDuplicateSwitchBranch&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="선언 중복성" path="Groovy"><inspection shortName="GroovyUnusedDeclaration" defaultSeverity="WARNING" displayName="사용되지 않는 선언" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;사용되지 않는 클래스, 메서드 및 필드를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Department {
      private Organization myOrganization;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 &lt;code&gt;Department&lt;/code&gt;는 명시적으로 &lt;code&gt;Organization&lt;/code&gt;을 참조하지만 &lt;code&gt;Department&lt;/code&gt; 클래스 자체가 사용되지 않으면
검사에서 두 클래스를 모두 보고합니다. 

&lt;p&gt;
또한 이 검사는 메서드 및 모든 메서드 구현/재정의에서 사용되지 않는 매개변수와 선언되었지만 사용되지 않는 지역 변수를 보고합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;자세한 내용은 Java의 동일한 검사를 참조하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: GroovyUnusedDeclaration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Gradle" path="Kotlin/ 마이그레이션"><inspection shortName="KotlinOptionsToCompilerOptions" defaultSeverity="WARNING" displayName="지원 중단된 'kotlinOptions' DSL의 사용" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Gradle &lt;code&gt;.kts&lt;/code&gt; 빌드 스크립트 내에서 지원이 중단된 &lt;code&gt;kotlinOptions&lt;/code&gt; DSL이 사용된 위치를 보고합니다.
&lt;p&gt;
    &lt;code&gt;kotlinOptions&lt;/code&gt; DSL은 Kotlin 2.0에서 지원이 중단되었습니다.
    이 검사는 &lt;code&gt;kotlinOptions&lt;/code&gt;에서 &lt;code&gt;compilerOptions&lt;/code&gt;로 마이그레이션할 때 유용합니다.
    또한, &lt;code&gt;String&lt;/code&gt; 타입 대신 &lt;a href="https://kotl.in/types-for-kgp-compiler-options"&gt;새로운 타입을 사용하는 몇몇 옵션&lt;/a&gt;의 타입도 변경합니다.
&lt;/p&gt;
&lt;p&gt;
    &lt;code&gt;KotlinCompile&lt;/code&gt; 작업의 예:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
val compileKotlin: KotlinCompile by tasks
compileKotlin.kotlinOptions {
    jvmTarget = "1.8"
    freeCompilerArgs = listOf("-module-name", "my_module_name")
    apiVersion = "1.9"
}

//OR

tasks.withType&lt;KotlinCompile&gt; {
    kotlinOptions {
        freeCompilerArgs += listOf("-module-name", "my_module_name")
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 검사는 변경된 타입이 있는 옵션에 import를 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import org.jetbrains.kotlin.gradle.dsl.JvmTarget
import org.jetbrains.kotlin.gradle.dsl.KotlinVersion

...

val compileKotlin: KotlinCompile by tasks
compileKotlin.compilerOptions {
    jvmTarget.set(JvmTarget.JVM_1_8)
    freeCompilerArgs.set(listOf("-module-name", "my_module_name"))
    apiVersion.set(KotlinVersion.KOTLIN_1_9)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
    &lt;code&gt;Kotlin2JsCompile&lt;/code&gt; 작업의 예:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
val compileKotlin: Kotlin2JsCompile by tasks
compileKotlin.kotlinOptions {
    moduleKind = "commonjs"
    sourceMapEmbedSources = "inlining"
    sourceMapNamesPolicy = "fully-qualified-names"
    main = "noCall"
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;검사 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import org.jetbrains.kotlin.gradle.dsl.JsMainFunctionExecutionMode
import org.jetbrains.kotlin.gradle.dsl.JsModuleKind
import org.jetbrains.kotlin.gradle.dsl.JsSourceMapEmbedMode
import org.jetbrains.kotlin.gradle.dsl.JsSourceMapNamesPolicy

...

val compileKotlin: Kotlin2JsCompile by tasks
compileKotlin.compilerOptions {
    moduleKind.set(JsModuleKind.MODULE_COMMONJS)
    sourceMapEmbedSources.set(JsSourceMapEmbedMode.SOURCE_MAP_SOURCE_CONTENT_INLINING)
    sourceMapNamesPolicy.set(JsSourceMapNamesPolicy.SOURCE_MAP_NAMES_POLICY_FQ_NAMES)
    main.set(JsMainFunctionExecutionMode.NO_CALL)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KotlinOptionsToCompilerOptions&lt;/small&gt;&lt;/p&gt;</inspection><inspection shortName="GradleKotlinxCoroutinesDeprecation" defaultSeverity="ERROR" displayName="Gradle에서 호환되지 않는 kotlinx.coroutines 종속성이 Kotlin 1.3 이상에서 사용" enabled="false" language="Groovy" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kotlin 1.3 또는 이후 버전과 호환성을 위해 업데이트해야 하는 Gradle의 &lt;code&gt;kotlinx.coroutines&lt;/code&gt;라이브러리 종속성을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
      implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.0.1'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 라이브러리 버전을 Kotlin 1.3과 호환 가능한 버전으로 변경합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
      implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.27.0-eap13'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GradleKotlinxCoroutinesDeprecation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="국제화" path=""><inspection shortName="LossyEncoding" defaultSeverity="WARNING" displayName="손실 인코딩" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;

현재 문서 인코딩으로 인해 표시할 수 없는 문자를 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;US-ASCII&lt;/b&gt; 문자 집합이 있는 문서에 국제 문자를 입력하면 저장 시 일부 문자가 손실됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;ISO-8859-1&lt;/b&gt; 1바이트 문자 집합을 사용하여 &lt;b&gt;UTF-8&lt;/b&gt; 인코딩 파일을 로드하면 일부 문자가 잘못 표시됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 문제를 해결하려면 파일에 직접 인코딩을 지정(예: XML 파일의 XML prolog에서 &lt;code&gt;encoding=&lt;/code&gt; 속성을 편집)하거나 &lt;b&gt;Settings(설정) | Editor(에디터) | File Encodings(파일 인코딩)&lt;/b&gt;에서 해당 옵션을 변경하여 파일 인코딩을 변경하면 됩니다.&lt;/p&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LossyEncoding&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonAsciiCharacters" defaultSeverity="WARNING" displayName="비 ASCII 문자" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
특이한 컨텍스트에서 ASCII가 아닌 기호를 사용하는 코드 요소를 보고합니다.

&lt;p&gt;예:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;식별자, 문자열 또는 주석에 사용되는 ASCII가 아닌 문자입니다.&lt;/li&gt;
  &lt;li&gt;예를 들어 Cyrillic로 작성된 문자 &lt;code&gt;&lt;b&gt;C&lt;/b&gt;&lt;/code&gt;가 &lt;code&gt;my&lt;b&gt;C&lt;/b&gt;ollection&lt;/code&gt;에 있는 경우처럼 다양한 언어로 작성된 식별자가 이에 해당합니다.&lt;/li&gt;
  &lt;li&gt;긴 대시 및 화살표와 같은 유니코드 기호를 포함하는 주석 또는 문자열입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NonAsciiCharacters&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Glance Preview" path=""><inspection shortName="GlancePreviewNeedsComposableAnnotation" defaultSeverity="ERROR" displayName="Glance Preview used on a non-Composable function" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="GlancePreviewNotSupportedInUnitTestFiles" defaultSeverity="ERROR" displayName="Glance Preview is not supported in unit test files" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="GlancePreviewMustBeTopLevelFunction" defaultSeverity="ERROR" displayName="Glance Preview must be a top level declaration or in a top level class with a default constructor." enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection><inspection shortName="GlancePreviewDimensionRespectsLimit" defaultSeverity="WARNING" displayName="Preview dimension has a minimum and a maximum limit" enabled="false" language="kotlin" pluginId="com.android.tools.design" pluginVersion="252.23892.458" isGlobalTool="false"></inspection></group><group name="Markdown" path=""><inspection shortName="MarkdownLinkDestinationWithSpaces" defaultSeverity="WARNING" displayName="링크에 공백 포함 불가" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
서로 다른 도구 간에 일관성을 보장하기 위해 파일 링크에는 공백이 포함되지 않아야 합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [Some file link](some file.md)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 공백을 URL로 인코딩된 동등한 요소로 바꿉니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [Some file link](some%20file.md)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MarkdownLinkDestinationWithSpaces&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MarkdownOutdatedTableOfContents" defaultSeverity="WARNING" displayName="콘텐츠 섹션의 오래된 테이블" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
특정 목차가 실제 문서 구조에 대응하는지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MarkdownOutdatedTableOfContents&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MarkdownIncorrectlyNumberedListItem" defaultSeverity="WARNING" displayName="번호가 잘못 매겨진 목록 항목" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;정렬된 목록 항목은 1부터 번호가 지정되어야 합니다.&lt;/p&gt;
&lt;p&gt;이 검사는 Markdown 프로세서가 정렬된 목록의 번호 지정을 무시하는 경우가 많기 때문에 사용됩니다. 프로세서는 목록에 대한 &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt; 요소를 생성하며 1부터 계속해서 항목의 번호를 매깁니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MarkdownIncorrectlyNumberedListItem&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MarkdownUnresolvedLinkLabel" defaultSeverity="WARNING" displayName="해결되지 않은 링크 라벨" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Markdown 파일 내 미해결 링크 라벨을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MarkdownUnresolvedLinkLabel&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MarkdownUnresolvedHeaderReference" defaultSeverity="WARNING" displayName="해결되지 않은 헤더 참조" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Markdown 파일 내 미해결 헤더 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MarkdownUnresolvedHeaderReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MarkdownUnresolvedFileReference" defaultSeverity="WARNING" displayName="해결되지 않은 파일 참조" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Markdown 파일의 해결되지 않은 파일 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MarkdownUnresolvedFileReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MarkdownNoTableBorders" defaultSeverity="WARNING" displayName="테이블에 측면 테두리가 없습니다" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
테이블의 측면 테두리가 올바른지 확인합니다.
호환성을 위해 모든 테이블 행에는 시작과 끝에 테두리(파이프 기호)가 있어야 합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MarkdownNoTableBorders&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MarkdownIncorrectTableFormatting" defaultSeverity="WEAK WARNING" displayName="올바르지 않은 테이블 서식" enabled="false" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
테이블 형식이 올바른지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MarkdownIncorrectTableFormatting&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="초기화" path="Java"><inspection shortName="StaticVariableUninitializedUse" defaultSeverity="WARNING" displayName="초기화 전에 사용된 static 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
초기화 전에 읽어들인 &lt;code&gt;static&lt;/code&gt; 변수를 보고합니다.
&lt;p&gt;이 검사는 &lt;code&gt;null&lt;/code&gt;을 통한 상등 검사를 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public static int bar;

    public static void main(String[] args) {
      System.out.println(bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 검사는 매우 보수적인 데이터 흐름 알고리즘을 사용하므로 &lt;code&gt;static&lt;/code&gt; 변수를 초기화되지 않은 것으로 잘못 보고할 수 있습니다. 초기화된 것으로 보고된 변수는 항상 초기화됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;기본 필드 무시&lt;/b&gt; 옵션을 사용하여, 초기화되지 않은 기본 필드를 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StaticVariableUninitializedUse&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OverriddenMethodCallDuringObjectConstruction" defaultSeverity="WARNING" displayName="객체 생성 중에 재정의된 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
객체 생성 중 현재 클래스의 재정의된 메서드에 대한 호출을 보고합니다.
이는 객체가 다음 항목의 내부에서 생성되는 경우에 발생합니다.
&lt;ul&gt;
  &lt;li&gt;생성자&lt;/li&gt;
  &lt;li&gt;비 static 인스턴스 이니셜라이저&lt;/li&gt;
  &lt;li&gt;비 static 필드 이니셜라이저&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;clone()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObject()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObjectNoData()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 호출이 있으면, 메서드 호출이 발생하기 전에 객체 초기화가 보장되지 않으므로 버그가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Parent {
    void someMethod() { }
  }

  class Child extends Parent {
    Child() {
      someMethod();
    }

    @Override
    void someMethod() { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 다음 검사와 기능을 공유합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;객체 생성 중에 호출된 추상 메서드&lt;/b&gt; 검사&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;객체 생성 중에 호출된 재정의 가능한 메서드&lt;/b&gt; 검사&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;중복 경고를 방지하기 위해 동시에 한 개의 검사만을 활성화해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: OverriddenMethodCallDuringObjectConstruction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalStaticVariableUsedInClassInitialization" defaultSeverity="WARNING" displayName="클래스 초기화 중에 비 final static 필드가 사용됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스 초기화 중에 &lt;code&gt;final&lt;/code&gt;이 아닌 &lt;code&gt;static&lt;/code&gt; 변수 사용을 보고합니다.
&lt;p&gt;이러한 경우, 코드 의미는 클래스 생성 순서에 따라 달라질 수 있습니다. 또한 이러한 경우, 변수가 초기화되기 전에 사용될 수 있어, 파악하기 어렵고 혼란스러운 오류가 보통 발생합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public static int bar = 0;

    static {
      System.out.println(bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonFinalStaticVariableUsedInClassInitialization&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractMethodCallInConstructor" defaultSeverity="WARNING" displayName="객체 생성 중에 추상 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
객체 생성 중에 현재 클래스의 &lt;code&gt;abstract&lt;/code&gt; 메서드 호출을 보고합니다.
&lt;p&gt;메서드가 다음 내부에 있는 경우 객체 생성 중에 호출됩니다.
&lt;ul&gt;
  &lt;li&gt;생성자&lt;/li&gt;
  &lt;li&gt;비 static 인스턴스 이니셜라이저&lt;/li&gt;
  &lt;li&gt;비 static 필드 이니셜라이저&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;clone()&lt;/code&gt; 메서드&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObject()&lt;/code&gt; 메서드&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObjectNoData()&lt;/code&gt; 메서드&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;객체 초기화가 메서드 호출 전에 발생할 수 있으므로 이러한 호출로 인해 탐지하기 어려운 버그가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Parent {
    abstract void abstractMethod();
  }

  class Child extends Parent {
    Child() {
      abstractMethod();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 다음 검사와 기능을 공유합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;객체 생성 중에 호출된 재정의 가능한 메서드&lt;/li&gt;
  &lt;li&gt;객체 생성 중에 호출된 재정의된 메서드&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;경고 중복을 피하기 위해 한 번에 하나의 검사만 활성화해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AbstractMethodCallInConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThisEscapedInConstructor" defaultSeverity="WARNING" displayName="객체 생성에서 'this' 참조 이스케이프" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
객체 초기화 도중 발생 가능한 &lt;code&gt;this&lt;/code&gt;의 이스케이프를 보고합니다. 이 이스케이프는 &lt;code&gt;this&lt;/code&gt;가 생성자나 이니셜라이저에서 메서드 인수 또는 대입의 객체로 사용될 때 발생합니다. 초기화가 보장되지 않은 컨텍스트에서 객체를 사용할 수 있게 되므로 그러한 이스케이프는 탐지하기 어려운 버그를 초래할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    {
      System.out.println(this);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThisEscapedInConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DoubleBraceInitialization" defaultSeverity="INFORMATION" displayName="이중 중괄호 초기화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://www.c2.com/cgi/wiki?DoubleBraceInitialization"&gt;이중 중괄호 초기화&lt;/a&gt;를 보고합니다.
&lt;p&gt;이중 중괄호 초기화 시 추가 클래스를 로드해야 하므로 일반 초기화보다 성능이 저하됩니다.&lt;/p&gt;
&lt;p&gt;또한 &lt;code&gt;equals()&lt;/code&gt; 메서드가 매개변수로 하위 클래스를 허용하지 않을 경우 &lt;code&gt;equals()&lt;/code&gt; 비교가 실패할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이중 중괄호 초기화는 static이 아닌 컨텍스트에서는 메모리 누수를 일으킬 수 있습니다. Java 18보다 오래된 버전의 javac으로 컴파일링할 경우, 이러한 초기화가 자신을 둘러싼 객체를 참조하는 익명 클래스를 생성하기 때문입니다.&lt;/p&gt;
&lt;p&gt;또한 Java 9 이전 버전에서 이중 중괄호 초기화는 익명 클래스와 호환되지 않아 다이아몬드 연산자와 결합할 수 없었습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;() {{
    add(1);
    add(2);
  }};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
  list.add(1);
  list.add(2);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DoubleBraceInitialization&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverridableMethodCallDuringObjectConstruction" defaultSeverity="WARNING" displayName="객체 생성 중에 재정의 가능한 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
객체 생성 중 현재 클래스의 재정의 가능한 메서드 호출을 보고합니다.
&lt;p&gt;메서드가 다음 내부에 있는 경우 객체 생성 중에 호출됩니다.
&lt;ul&gt;
  &lt;li&gt;생성자&lt;/li&gt;
  &lt;li&gt;비 static 인스턴스 이니셜라이저&lt;/li&gt;
  &lt;li&gt;비 static 필드 이니셜라이저&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;clone()&lt;/code&gt; 메서드&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObject()&lt;/code&gt; 메서드&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObjectNoData()&lt;/code&gt; 메서드&lt;/li&gt;
&lt;p&gt;메서드는 &lt;code&gt;final&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt; 또는 &lt;code&gt;private&lt;/code&gt;으로 선언되지 않은 경우 재정의할 수 있습니다.
  package-local 메서드는 재정의 가능할지라도 안전한 것으로 간주됩니다. 객체 초기화가 메서드 호출 전에 발생할 수 있으므로 이러한 호출로 인해 탐지하기 어려운 버그가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    void someMethod() { }
  }

  class Child extends Parent {
    Child() {
      someMethod();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
  &lt;p&gt;이 검사는 다음 검사와 기능을 공유합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;객체 생성 중에 호출된 추상 메서드&lt;/li&gt;
  &lt;li&gt;객체 생성 중에 호출된 재정의된 메서드&lt;/li&gt;
&lt;/ul&gt;
  &lt;p&gt;경고 중복을 피하기 위해 한 번에 하나의 검사만 활성화해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: OverridableMethodCallDuringObjectConstruction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceVariableUninitializedUse" defaultSeverity="WARNING" displayName="초기화 전에 사용된 인스턴스 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
초기화 전에 읽어들인 인스턴스 변수를 보고합니다.
&lt;p&gt;이 검사는 &lt;code&gt;null&lt;/code&gt;을 통한 상등 검사를 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int bar;

    Foo() {
      System.out.println(bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 검사는 매우 보수적인 데이터 흐름 알고리즘을 사용하므로 인스턴스 변수를 초기화되지 않은 것으로 잘못 보고할 수 있습니다. 초기화된 것으로 보고된 변수는 항상 초기화됩니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;특수 어노테이션을 지정하려면 &lt;b&gt;다음으로 어노테이션이 추가된 경우 무시&lt;/b&gt; 옵션을 사용합니다. 이 검사는 해당 어노테이션 중 하나가 추가된 필드를 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;기본 필드 무시&lt;/b&gt; 옵션을 사용하여, 초기화되지 않은 기본 필드를 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InstanceVariableUninitializedUse&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StaticVariableInitialization" defaultSeverity="WARNING" displayName="static 필드가 초기화되지 않을 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스 초기화 시 초기화할 수 없는 &lt;code&gt;static&lt;/code&gt; 변수를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public static int bar;

    static { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 검사는 매우 보수적인 데이터 흐름 알고리즘을 사용하므로 &lt;code&gt;static&lt;/code&gt; 변수를 초기화되지 않은 것으로 잘못 보고할 수 있습니다. 초기화된 것으로 보고된 변수는 항상 초기화됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;기본 필드 무시&lt;/b&gt; 옵션을 사용하여, 초기화되지 않은 기본 필드를 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StaticVariableInitialization&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonThreadSafeLazyInitialization" defaultSeverity="WARNING" displayName="'static' 필드의 안전하지 않은 지연 초기화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
비 스레드 안전 방식으로 초기화가 지연되는 &lt;code&gt;static&lt;/code&gt; 변수를 보고합니다.
&lt;p&gt;&lt;code&gt;static&lt;/code&gt; 변수의 지연된 초기화는 서로 다른 스레드가 충돌하는 초기화를 수행하지 못하게 방지하기 위해 적절한 동기화 구성을 사용하여 수행해야 합니다.&lt;/p&gt;
&lt;p&gt;해당되는 경우, &lt;a href="https://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom"&gt;지연 초기화 holder 클래스 이디엄&lt;/a&gt;을 삽입하는 빠른 수정을 사용하는 것이 좋습니다.
  이 관용구는 클래스가 사용되기 전에 초기화되지 않도록 JVM이 보장한다는 사실을 이용합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
    private static List&amp;lt;String&amp;gt; list;

    public List&amp;lt;String&amp;gt; getList() {
      if (list == null) {
        list = List.of("one", "two", "tree");
      }
      return list;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
    private static final class ListHolder {
      static final List&amp;lt;String&amp;gt; list = List.of("one", "two", "tree");
    }

    public List&amp;lt;String&amp;gt; getList() {
      return ListHolder.list;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonThreadSafeLazyInitialization&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceVariableInitialization" defaultSeverity="WARNING" displayName="인스턴스 필드가 초기화되지 않을 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
객체 초기화 시 초기화할 수 없는 인스턴스 변수를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public int bar;

    static { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 검사는 매우 보수적인 데이터 흐름 알고리즘을 사용하므로 인스턴스 변수를 초기화되지 않은 것으로 잘못 보고할 수 있습니다. 초기화된 것으로 보고된 변수는 항상 초기화됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;기본 필드 무시&lt;/b&gt; 옵션을 사용하여, 초기화되지 않은 기본 필드를 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InstanceVariableInitialization&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="HTTP 클라이언트" path=""><inspection shortName="HttpRequestRequestSeparatorYamlBodyInspection" defaultSeverity="WEAK WARNING" displayName="YAML 본문에 요청 구분자가 누락됨" enabled="false" language="yaml" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
요청 구분자 &lt;code&gt;###&lt;/code&gt;이 누락되어 있는 삽입된 YAML 본문의 잠재적인 요청을 보고합니다. 
빠른 수정에서는 요청 앞에 구분 기호 &lt;code&gt;###&lt;/code&gt;을 추가하도록 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpRequestRequestSeparatorYamlBodyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpClientUnresolvedAuthId" defaultSeverity="ERROR" displayName="해결되지 않은 인증 식별자" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
존재하지 않는 인증 구성이 참조되면 강조 표시합니다. 현재 환경에서 새로 생성하도록 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpClientUnresolvedAuthId&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpRequestAmbiguityEncoding" defaultSeverity="WEAK WARNING" displayName="모호한 인코딩 검사" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  인코딩된 쿼리 문자열 내 '+'를 탐지합니다. +를 공백으로 인코딩해야 할지 '+' 문자로 인코딩해야 할지 모호합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  GET https://example.com/api?name=John+Doe%40example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  GET https://example.com/api?name=John%20Doe%40example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpRequestAmbiguityEncoding&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpClientInappropriateProtocolUsageInspection" defaultSeverity="WEAK WARNING" displayName="부적절한 HTTP 프로토콜 사용 위치" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;HTTP/2&lt;/code&gt;와 같이 비 HTTP 메서드 요청을 사용하는 HTTP 프로토콜 키워드의 부적절한 사용을 보고합니다. 이러한 사용은 무시됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpClientInappropriateProtocolUsageInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpRequestEnvironmentAuthConfigurationValidationInspection" defaultSeverity="WARNING" displayName="인증 구성 검증" enabled="false" language="JSON" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
HTTP 클라이언트 환경 파일에서 다음의 인증 구성 문제를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;
    인증 구성 내 누락된 프로퍼티
  &lt;/li&gt;
  &lt;li&gt;
    비공개 환경 파일에 있는 인증/보안 구성
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpRequestEnvironmentAuthConfigurationValidationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpRequestWhitespaceInsideRequestTargetPath" defaultSeverity="WEAK WARNING" displayName="요청의 URL에 있는 공백" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
URL 경로 세그먼트 내의 공백을 강조 표시합니다. HTTP 클라이언트가 무시합니다. 구성 개선을 위해 '줄 분할' 액션을 사용하세요.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpRequestWhitespaceInsideRequestTargetPath&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpClientDuplicateImportInspection" defaultSeverity="WEAK WARNING" displayName="중복 가져오기" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이미 정의된 import를 강조 표시합니다. 
중복된 import 선언을 제거할 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpClientDuplicateImportInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpRequestJsonBodyInspection" defaultSeverity="WARNING" displayName="변수는 큰따옴표로 감싸야 함" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
json 본문에서 큰따옴표로 묶여야 하는 변수를 보고합니다.
빠른 수정에서는 변수를 큰따옴표로 둘러싸도록 제안합니다(&lt;code&gt;"{{variable}}"&lt;/code&gt;).
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpRequestJsonBodyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpRequestContentLengthIsIgnored" defaultSeverity="WARNING" displayName="불필요한 'Content-Length'" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명시적으로 설정된 &lt;code&gt;Content-Length&lt;/code&gt; 헤더를 보고합니다. HTTP 클라이언트가 실제 요청 본문 길이를 사용하기 때문에 헤더가 불필요합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpRequestContentLengthIsIgnored&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpRequestPlaceholder" defaultSeverity="WARNING" displayName="HTTP 요청 내 '$placeholder'" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
요청 내부의 &lt;code&gt;$placeholder&lt;/code&gt;를 보고합니다. 
&lt;p&gt;도구가 요청의 일부를 인식하지 못하는 경우 사용자에 의해 교체될 &lt;code&gt;$placeholder&lt;/code&gt;가 자동으로 생성됩니다. 예를 들어, 요청 매핑 &lt;code&gt;/aaaa/*/bbb&lt;/code&gt;가 &lt;code&gt;GET localhost/aaaa/{{$placeholder}}/bbb&lt;/code&gt;로 생성됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpRequestPlaceholder&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpRequestRequestSeparatorXmlBodyInspection" defaultSeverity="WEAK WARNING" displayName="HTML/XML 본문에 요청 구분자가 누락됨" enabled="false" language="XML" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
삽입된 XML/HTML 본문에서 요청 구분자 &lt;code&gt;###&lt;/code&gt;이 누락된 잠재적인 요청을 보고합니다. 
빠른 수정에서는 요청 앞에 구분 기호 &lt;code&gt;###&lt;/code&gt;을 추가하도록 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpRequestRequestSeparatorXmlBodyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpClientUnresolvedVariable" defaultSeverity="WARNING" displayName="해결되지 않은 환경 변수" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;현재 환경에서 선언되지 않은 HTTP 클라이언트 변수를 보고합니다.&lt;/p&gt;
&lt;p&gt;
  선언되지 않은 변수가 있는 요청을 실행하면 실패할 수 있습니다.
  환경에 변수를 추가하거나 이 변수가 있는 환경을 선택해보세요.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;요청 본문에 있는 변수는 본문의 유효한 구문일 수도 있기 때문에 검사에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;
  일부 변수는 &lt;code&gt;client.global.set&lt;/code&gt; 또는 &lt;code&gt;request.variables.set&lt;/code&gt; 함수 호출을 통해 응답 또는 사전 요청 핸들러 스크립트에서 선언되기 때문에 미해결로 보고되지 않을 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: HttpClientUnresolvedVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpRequestRequestSeparatorJsonBodyInspection" defaultSeverity="WEAK WARNING" displayName="JSON 본문에 요청 구분자가 누락됨" enabled="false" language="JSON" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
요청 구분자 &lt;code&gt;###&lt;/code&gt;이 누락되어 있는 삽입된 JSON 본문의 잠재적인 요청을 보고합니다. 
빠른 수정에서는 요청 앞에 구분 기호 &lt;code&gt;###&lt;/code&gt;을 추가하도록 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpRequestRequestSeparatorJsonBodyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncorrectHttpHeaderInspection" defaultSeverity="WARNING" displayName="올바르지 않은 HTTP 헤더" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  어떤 &lt;a href="https://www.iana.org/assignments/message-headers/message-headers.xml"&gt;공개적으로 알려진 헤더&lt;/a&gt;와도 일치하지 않는 알 수 없는 HTTP 헤더를 보고합니다. 빠른 수정은 &lt;b&gt;사용자 지정 HTTP 헤더 사용&lt;/b&gt; 옵션이 활성화되어 있는 경우 사용자 지정 헤더 목록에 헤더를 추가할 것을 제안합니다. 사용자 지정 헤더 목록에 포함된 HTTP 헤더는 이 검사를 촉발하지 않습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IncorrectHttpHeaderInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpRequestCustomHttpMethodInspection" defaultSeverity="WARNING" displayName="알 수 없는 HTTP 메서드" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
가능한 사용자 지정 HTTP 메서드를 보고합니다. 
빠른 수정에서는 프로젝트 설정에 사용자 지정 HTTP 메서드를 추가하도록 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpRequestCustomHttpMethodInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HttpClientRunRequestNameInspection" defaultSeverity="WEAK WARNING" displayName="가능한 요청 이름" enabled="false" language="HTTP Request" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지정된 import 파일이 없는 실행 블록의 요청 이름을 강조 표시합니다. 
이러한 기명 요청을 포함하는 파일에 import를 추가하도록 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpClientRunRequestNameInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring MVC" path="Spring"><inspection shortName="MVCPathVariableInspection" defaultSeverity="WARNING" displayName="@PathVariable 선언 및 사용 불일치" enabled="false" language="UAST" pluginId="com.intellij.spring.mvc" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;메서드 시그니처에 선언되어 있으나 URL 경로에 누락되었거나 URL 경로에 있으나 메서드 시그니처에 선언되어 있지 않은 &lt;code&gt;@PathVariable&lt;/code&gt; 매개변수를 보고합니다.
  빠른 수정에서는 누락된 매개변수를 추가합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @RequestMapping("/path/{myVariable}/")
  public String handler(@PathVariable String name_is_not_equal_to_myVariable) {
    return "...";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 결과는 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @RequestMapping("/path/{myVariable}/")
  public String handler(@PathVariable String myVariable) {
    return "...";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MVCPathVariableInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringMVCViewInspection" defaultSeverity="WARNING" displayName="해결되지 않은 뷰 참조" enabled="false" language="UAST" pluginId="com.intellij.spring.mvc" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;해결되지 않은 Spring MVC View 참조를 보고합니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @RequestMapping
  public String viewHandler() {
    return "viewName"; // 'viewName'을 가진 뷰를 찾을 수 없는 경우 강조 표시됩니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringMVCViewInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringMVCInitBinder" defaultSeverity="ERROR" displayName="void가 아닌 @InitBinder 메서드" enabled="false" language="JAVA" pluginId="com.intellij.spring.mvc" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;void&lt;/code&gt;로 선언되지 않은 &lt;code&gt;@InitBinder&lt;/code&gt; 어노테이션이 추가된 Spring MVC 컨트롤러 메서드를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/InitBinder.html&gt;사양&lt;/a&gt;에 따르면 init-binder 메서드는 &lt;code&gt;void&lt;/code&gt;로 선언되어야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringMVCInitBinder&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="보안" path=""><inspection shortName="JvmTaintAnalysis" defaultSeverity="WARNING" displayName="테인트 분석" enabled="false" language="JVM" pluginId="com.intellij.jvm.dfa.analysis" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;이 검사는 잠재적으로 신뢰할 수 없는 소스에서 획득된 데이터가 보안 위험이 있는 연산에서 사용되는 취약할 수 있는 코드 섹션을 식별하도록 설계되었습니다.&lt;/p&gt;

&lt;p&gt;데이터 흐름 추적:&lt;/p&gt;

&lt;p&gt;이 검사는 데이터가 소스에서 이동되어 중요한 연산에 사용될 때까지의 흐름을 추적합니다.
  메서드, 객체 및 변수를 통한 데이터 전송도 분석됩니다.&lt;/p&gt;

&lt;p&gt;사용자의 입력이 적절히 전처리되지 않고 SQL 쿼리에 바로 사용되는 예시를 생각해 보겠습니다.
  이때 이 검사는 잠재적인 SQL 삽입에 관한 경고를 표시합니다.&lt;/p&gt;
&lt;pre&gt;
String userInput = getUserInput();
String sqlQuery = "SELECT * FROM users WHERE username = '" + userInput + "'";
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JvmTaintAnalysis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VulnerableLibrariesGlobal" defaultSeverity="WARNING" displayName="취약한 가져온 종속성" enabled="false" language="" pluginId="org.jetbrains.security.package-checker" pluginVersion="252.23892.464" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;프로젝트에 가져온 Gradle 및 Maven 종속성의 취약성을 보고합니다.
  Gradle 및 Maven 종속성의 전체 목록은 외부 라이브러리의 프로젝트 도구 창에 표시됩니다.&lt;/p&gt;
&lt;p&gt;보고된 문제를 해결하면 공격자로부터 소프트웨어를 보호할 수 있습니다.&lt;/p&gt;
&lt;p&gt;문제를 해결하려면 취약성이 수정된 버전(사용 가능한 경우)으로 업데이트하거나 취약성이 없는 종속성으로 전환하면 됩니다.&lt;/p&gt;
&lt;p&gt;제공된 빠른 수정에서는 안전한 버전으로 업데이트하거나 웹사이트에 방문해 특정 취약점에 관해 자세히 알아볼 것을 제안할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: VulnerableLibrariesGlobal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="VulnerableCodeUsages" defaultSeverity="WARNING" displayName="취약한 API 사용 위치" enabled="false" language="UAST" pluginId="org.jetbrains.security.package-checker" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;가져온 종속성에서 취약한 API가 사용된 경우를 보고합니다.&lt;/p&gt;
&lt;p&gt;보고된 문제를 해결하면 공격자로부터 소프트웨어를 보호할 수 있습니다.&lt;/p&gt;
&lt;p&gt;문제를 해결하려면 취약성이 수정된 버전(사용 가능한 경우)으로 업데이트하거나 취약성이 없는 종속성으로 전환하면 됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: VulnerableCodeUsages&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MaliciousLibrariesLocal" defaultSeverity="WARNING" displayName="악의적인 종속성" enabled="false" language="" pluginId="org.jetbrains.security.package-checker" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;프로젝트에서 선언된 악의적인 NPM 및 PyPI 종속성을 보고합니다.&lt;/p&gt;
&lt;p&gt;보고된 문제를 해결하면 공격자로부터 소프트웨어를 보호할 수 있습니다.&lt;/p&gt;
&lt;p&gt;문제를 해결하려면 악의적인 패키지를 제거하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MaliciousLibrariesLocal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="VulnerableLibrariesLocal" defaultSeverity="WARNING" displayName="취약한 선언된 종속성" enabled="false" language="" pluginId="org.jetbrains.security.package-checker" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;프로젝트에서 선언된 Gradle, Maven, NPM, PyPl 및 Go 종속성의 취약성을 보고합니다.
  Gradle 및 Maven 종속성의 전체 목록은 외부 라이브러리의 프로젝트 도구 창에 표시됩니다.&lt;/p&gt;
&lt;p&gt;보고된 문제를 해결하면 공격자로부터 소프트웨어를 보호할 수 있습니다.&lt;/p&gt;
&lt;p&gt;문제를 해결하려면 취약성이 수정된 버전(사용 가능한 경우)으로 업데이트하거나 취약성이 없는 종속성으로 전환하면 됩니다.&lt;/p&gt;
&lt;p&gt;제공된 빠른 수정에서는 안전한 버전으로 업데이트하거나 웹사이트에 방문해 특정 취약점에 관해 자세히 알아볼 것을 제안할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: VulnerableLibrariesLocal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="HttpUrlsUsage" defaultSeverity="WEAK WARNING" displayName="암호화되지 않은 프로토콜이 있는 링크" enabled="false" pluginId="com.jetbrains.restClient" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;데이터를 중간자 공격에 노출시킬 수 있는 암호화되지 않은 프로토콜(예: HTTP)을 사용하는 링크를 보고합니다. 이러한 공격은 일반적으로 위험하며 아티팩트 저장소에 특히 유해할 수 있습니다. 대신 HTTPS와 같은 암호화를 갖춘 프로토콜을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/HTTPS#Difference_from_HTTP"&gt;HTTPS: HTTP와의 차이(wikipedia.org)&lt;/a&gt;를 참고하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HttpUrlsUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Vue" path=""><inspection shortName="VueMissingComponentImportInspection" defaultSeverity="WARNING" displayName="구성 요소 가져오기 누락" enabled="false" language="Vue" pluginId="org.jetbrains.plugins.vue" pluginVersion="252.23892.449" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Vue 템플릿에서 가져와야 하는 Vue 구성 요소를 보고합니다. 누락된 가져오기를 추가하는 빠른 수정을 제공합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VueMissingComponentImportInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VueUnrecognizedSlot" defaultSeverity="WEAK WARNING" displayName="인식되지 않는 슬롯" enabled="false" language="Vue" pluginId="org.jetbrains.plugins.vue" pluginVersion="252.23892.449" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인식되지 않는 Vue 슬롯을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VueUnrecognizedSlot&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VueDeprecatedSymbol" defaultSeverity="WARNING" displayName="지원 중단된 심볼" enabled="false" language="Vue" pluginId="org.jetbrains.plugins.vue" pluginVersion="252.23892.449" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지원 중단된 Vue 심볼을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VueDeprecatedSymbol&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VueUnrecognizedDirective" defaultSeverity="WARNING" displayName="인식되지 않는 지시문" enabled="false" language="Vue" pluginId="org.jetbrains.plugins.vue" pluginVersion="252.23892.449" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인식되지 않는 Vue 지시문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VueUnrecognizedDirective&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VueDataFunction" defaultSeverity="WARNING" displayName="데이터 함수" enabled="false" language="Vue" pluginId="org.jetbrains.plugins.vue" pluginVersion="252.23892.449" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
함수가 아닌 Vue 구성 요소 &lt;a href="https://vuejs.org/v2/api/#data"&gt;data&lt;/a&gt; 프로퍼티를 보고합니다. 객체 리터럴을 함수로 래핑할 것을 제안합니다.
&lt;p&gt;수많은 인스턴스 생성 시 같은 정의가 사용되므로 구성 요소를 정의할 때 &lt;code&gt;data&lt;/code&gt;는 초기 데이터 객체를 반환하는 함수로 정의해야 합니다. 일반 객체가 아직 &lt;code&gt;data&lt;/code&gt;에 사용되고 있는 경우, 바로 그 객체가 생성된 모든 인스턴스의 참조에 의해 공유됩니다! 새 인스턴스가 생성될 때마다 &lt;code&gt;data&lt;/code&gt; 함수를 간단히 호출하여 초기 데이터의 새로운 복사본을 반환할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VueDataFunction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VueDuplicateTag" defaultSeverity="WARNING" displayName="중복 템플릿/스크립트 태그" enabled="false" language="Vue" pluginId="org.jetbrains.plugins.vue" pluginVersion="252.23892.449" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Vue 파일 내 &lt;code&gt;template&lt;/code&gt; 또는 &lt;code&gt;script&lt;/code&gt; 태그의 여러 사용 위치를 보고합니다.
  &lt;p&gt;&lt;a href="https://vue-loader.vuejs.org/spec.html"&gt;Vue 구성 요소 사양&lt;/a&gt;은 각각의 &lt;code&gt;*.vue&lt;/code&gt; 파일이 한 번에 최대 하나의 &lt;code&gt;template&lt;/code&gt; 또는 &lt;code&gt;script&lt;/code&gt;를 포함할 수 있다는 것을 나타냅니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VueDuplicateTag&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="ES2015 마이그레이션 지원" path="JavaScript 및 TypeScript"><inspection shortName="JSFunctionExpressionToArrowFunction" defaultSeverity="INFORMATION" displayName="화살표 함수 대신 함수 표현식이 사용됩니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function"&gt;함수&lt;/a&gt; 표현식을 보고합니다.
&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"&gt;화살표 함수&lt;/a&gt;로 변환하는 것을 제안합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arr.map(function(el) {return el + 1})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 코드는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arr.map(el =&gt; el + 1)&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSFunctionExpressionToArrowFunction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSStringConcatenationToES6Template" defaultSeverity="INFORMATION" displayName="템플릿 리터럴 대신 문자열 연결이 사용됩니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자열 연결을 보고합니다. &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals"&gt;템플릿 리터럴&lt;/a&gt;로 바꿀 것을 제안합니다.
&lt;p&gt;예시&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; "result: " + a + "." &lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;빠른 수정이 적용된 후 코드는 다음과 같습니다:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt; '결과: ${a}.' &lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSStringConcatenationToES6Template&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ConvertLetToConst" defaultSeverity="INFORMATION" displayName="'const' 대신 'let'이 사용됩니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;const&lt;/code&gt;로 만들 수 있는 &lt;code&gt;let&lt;/code&gt; 선언을 보고합니다.&lt;br/&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ES6ConvertLetToConst&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ConvertRequireIntoImport" defaultSeverity="INFORMATION" displayName="'import' 대신 'require()'이 사용됩니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;require()&lt;/code&gt; 문을 보고합니다. &lt;code&gt;require()&lt;/code&gt; 호출을 &lt;code&gt;import&lt;/code&gt; 문으로 바꿀 것을 제안합니다.
&lt;br/&gt;&lt;br/&gt;
'모든 작업 수정을 통해 내부 스코프 안에서 require() 변환'을 활성화하여 '모든 수정' 액션 사용 시 중첩된 함수와 구문 내 모든 &lt;code&gt;require()&lt;/code&gt; 호출을 변환하십시오.
&lt;br/&gt;&lt;br/&gt;
내부 스코프 안에서 &lt;code&gt;require()&lt;/code&gt; 문을 &lt;code&gt;import&lt;/code&gt; 문으로 변환하면 코드의 의미가 달라질 수 있습니다.
import 문은 정적 모듈 종속성이며, 호이스팅되어
현재 모듈의 최상위로 이동되었습니다. &lt;code&gt;require()&lt;/code&gt; 호출은 모듈을 동적으로 불러옵니다.
이는 조건적으로 실행될 수 있으며, 스코프는 사용된 표현식에 의해 정의됩니다.
&lt;br/&gt;'모든 작업 수정을 통해 내부 스코프 안에서 require() 변환' 체크박스를 끄고 '모두 수정' 액션 사용 시 이러한 복합 사례 내의 변경을 막으세요.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ES6ConvertRequireIntoImport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ConvertIndexedForToForOf" defaultSeverity="INFORMATION" displayName="'for..of' 대신 색인 생성된 'for'가 사용됩니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열을 대상으로 사용된 색인화된 &lt;code&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for"&gt;for&lt;/a&gt;&lt;/code&gt; 루프를 보고합니다. &lt;code&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"&gt;for..of&lt;/a&gt;&lt;/code&gt; 루프로 바꿀 것을 제안합니다.
&lt;br/&gt;&lt;code&gt;for..of&lt;/code&gt; 루프는 ECMAScript 6에 도입되었으며 &lt;code&gt;iterable&lt;/code&gt; 객체를 반복합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ES6ConvertIndexedForToForOf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ConvertModuleExportToExport" defaultSeverity="INFORMATION" displayName=" 'export' 대신 'module.export'가 사용됩니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;module.export&lt;/code&gt; 문을 보고합니다. &lt;code&gt;export&lt;/code&gt; 또는 &lt;code&gt;export default&lt;/code&gt; 문으로 바꿀 것을 제안합니다.
&lt;br/&gt;&lt;br/&gt;
&lt;code&gt;export&lt;/code&gt; 문은 모듈의 최상위에만 있을 수 있기 때문에 &lt;code&gt;module.export&lt;/code&gt;를 &lt;code&gt;export&lt;/code&gt;로 변환하기 위한 빠른 수정은 함수 또는 구문 내부의 &lt;code&gt;module.export&lt;/code&gt;에 사용할 수 없습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ES6ConvertModuleExportToExport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ConvertVarToLetConst" defaultSeverity="WEAK WARNING" displayName="'let' 또는 'const' 대신 'var'가 사용됩니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 대신 사용된 &lt;code&gt;var&lt;/code&gt; 선언을 보고합니다.&lt;br/&gt;
&lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt;는 모두 블록 스코프이며 더욱 엄격하게 동작합니다.
&lt;br/&gt;&lt;br/&gt;
특정 값의 의미에 따라 모든 &lt;code&gt;var&lt;/code&gt;선언을 &lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 선언으로 바꿀 것을 제안합니다.
참조 오류를 피하기 위해 선언을 함수의 최상위로 이동하거나 변수가 처음 사용되는 위치보다 앞에 배치할 수 있습니다.
&lt;br/&gt; '모든 작업 수정을 통해 var을 보수적으로 변환' 옵션을 켜서 '모두 수정' 액션 사용 시 이러한 복합 케이스가 변경되지 않도록 하십시오.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ES6ConvertVarToLetConst&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6ConvertToForOf" defaultSeverity="INFORMATION" displayName="'for..of' 대신 'for..in'이 사용됩니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열을 대상으로 &lt;code&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in"&gt;for..in&lt;/a&gt;&lt;/code&gt; 루프를 사용한 위치를 보고합니다. &lt;code&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"&gt;for..of&lt;/a&gt;&lt;/code&gt; 루프로 바꿀 것을 제안합니다.
&lt;br/&gt;ECMAScript 6에 도입된 &lt;code&gt;for..of&lt;/code&gt; 루프는 &lt;code&gt;iterable&lt;/code&gt; 객체를 반복합니다.
배열의 경우, 이 구조는 배열 객체의 속성과는 다르게 배열의 값과만 동작하기 때문에 &lt;code&gt;for..in&lt;/code&gt;보다 선호됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ES6ConvertToForOf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="교정" path=""><inspection shortName="GrazieInspection" defaultSeverity="GRAMMAR_ERROR" displayName="문법" enabled="false" language="" pluginId="tanvd.grazi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html lang="ko"&gt;&lt;body&gt;
텍스트 내 문법 오류를 보고합니다. 이 검사는 &lt;a href="settings://reference.settingsdialog.project.grazie"&gt;설정 | 에디터 | 자연어 | 문법 및 스타일&lt;/a&gt;에서 구성할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrazieInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
</inspection><inspection shortName="AiaStyle" defaultSeverity="TYPO" displayName="스타일" enabled="false" language="" pluginId="com.intellij.ml.llm" pluginVersion="252.23892.530" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음에 정의된 작성 스타일을 확인하세요.
&lt;ul&gt;
    &lt;li&gt;
        이 프로젝트 또는 특정 하위 디렉터리를 위한 Grazie 규칙 파일(예: 영어의 경우 &lt;code&gt;.grazie.en.yaml&lt;/code&gt;).
        이 파일을 만들려면 프로젝트의 디렉터리(예: 루트)에서 &lt;b&gt;새로 만들기&lt;/b&gt; 메뉴를 호출하세요.
    &lt;/li&gt;
    &lt;li&gt;
        &lt;i&gt;에디터 | 자연어 | 규칙&lt;/i&gt; 설정의 &lt;i&gt;스타일&lt;/i&gt; 규칙
    &lt;/li&gt;
&lt;/ul&gt;

이 검사는 &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행...&lt;/b&gt; 또는 오프라인 분석을 통해서만 결과를 반환합니다.
에디터의 스타일 문제 강조 표시는 이 검사의 설정과 독립적으로 수행됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AiaStyle&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpellCheckingInspection" defaultSeverity="TYPO" displayName="오타" enabled="false" language="" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;&lt;body&gt;코드, 주석 및 리터럴에 있는 오타를 보고하고 클릭 한 번으로 이를 수정합니다.&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpellCheckingInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
</inspection><inspection shortName="LanguageDetectionInspection" defaultSeverity="WEAK WARNING" displayName="자연어 탐지" enabled="false" language="" pluginId="tanvd.grazi" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html lang="ko"&gt;&lt;body&gt;자연어를 탐지하고 해당 언어의 맞춤법 검사를 활성화하도록 제안합니다.&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LanguageDetectionInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
</inspection></group><group name="Sass/SCSS" path=""><inspection shortName="SassScssUnresolvedVariable" defaultSeverity="WARNING" displayName="해결되지 않은 변수" enabled="false" language="SCSS" pluginId="org.jetbrains.plugins.sass" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해결되지 않은 &lt;a href="https://sass-lang.com/documentation/variables"&gt;Sass/SCSS 변수&lt;/a&gt;참조를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  margin: $unknown-var;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SassScssUnresolvedVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SassScssUnresolvedMixin" defaultSeverity="WARNING" displayName="해결되지 않은 mixin" enabled="false" language="SCSS" pluginId="org.jetbrains.plugins.sass" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해결되지 않은 &lt;a href="https://sass-lang.com/documentation/at-rules/mixin"&gt;Sass/SCSS mixin &lt;/a&gt;참조를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  @include unknown-mixin;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SassScssUnresolvedMixin&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SassScssUnresolvedPlaceholderSelector" defaultSeverity="WARNING" displayName="해결되지 않은 자리표시자 선택자" enabled="false" language="SCSS" pluginId="org.jetbrains.plugins.sass" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해결되지 않은 &lt;a href="https://sass-lang.com/documentation/variables"&gt;Sass/SCSS placeholder selector&lt;/a&gt; 참조를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  @extend %unknown-placeholder-selector;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SassScssUnresolvedPlaceholderSelector&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SassScssResolvedByNameOnly" defaultSeverity="WEAK WARNING" displayName="import 문 누락" enabled="false" language="CSS" pluginId="org.jetbrains.plugins.sass" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 파일에 선언되어 있으나 이 파일이 현재 파일에 명시적으로 &lt;a href="https://sass-lang.com/documentation/at-rules/import"&gt;import&lt;/a&gt;되지 않은 변수, mixin, 또는 함수 참조를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* {
  margin: $var-in-other-file;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SassScssResolvedByNameOnly&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="코드 구문이 혼동될 수 있음" path="JavaScript 및 TypeScript"><inspection shortName="ConfusingFloatingPointLiteralJS" defaultSeverity="WARNING" displayName="혼동되는 부동소수점 리터럴" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/ConfusingFloatingPointLiteral.html --&gt;
&lt;html&gt;
&lt;body&gt;
소수점이 없거나 소수점 앞에 숫자가 없거나 소수점 뒤에 숫자가 없는 부동소수점 수를 보고합니다. 그러한 리터럴은 혼란을 일으킬 수 있으며 몇 가지 코딩 표준을 위반합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ConfusingFloatingPointLiteralJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DynamicallyGeneratedCodeJS" defaultSeverity="WARNING" displayName="동적으로 생성된 코드 실행" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;eval()&lt;/code&gt;, &lt;code&gt;setTimeout()&lt;/code&gt;, 또는 &lt;code&gt;setInterval()&lt;/code&gt;함수의 호출 또는 &lt;code&gt;Function&lt;/code&gt; 객체의 할당을 보고합니다.  이러한 함수는 JavaScript 텍스트 내 임의의 문자열을 실행하는데 사용되며 보통 동적으로 생성됩니다.  이는 혼란을 일으킬 수 있으며 보안상에 위험이 따를 수 있습니다.
&lt;br/&gt;&lt;br/&gt;
 코드를 생성하지 않고 콜백 함수가 이러한 메서드에 정적으로 제공되는 경우는 무시됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DynamicallyGeneratedCodeJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegatedConditionalExpressionJS" defaultSeverity="WARNING" displayName="부정된 조건식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/NegatedConditional.html --&gt;
&lt;html&gt;
&lt;body&gt;
조건이 부정된 조건식을 보고합니다.
조건식의 브랜치 순서를 반전시켜 구문의 명확도를 높일 것을 제안합니다.
예: &lt;code&gt;!condition ? 2 : 1&lt;/code&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NegatedConditionalExpressionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallerJS" defaultSeverity="WARNING" displayName="'caller' 프로퍼티 사용" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JavaScript 함수 내 &lt;code&gt;caller&lt;/code&gt; 프로퍼티의 사용 위치를 보고합니다.
이 프로퍼티를 사용하여 호출 메서드의 스택 프레임에 액세스하는 것은 혼란을 일으킬 가능성이 매우 크며 미묘한 버그를 초래할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CallerJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BlockStatementJS" defaultSeverity="WARNING" displayName="불필요한 block 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, 또는 &lt;code&gt;try&lt;/code&gt; 문의 본문, 또는 함수 선언의 본문으로 사용되고 있지 않는 블록 구문을 보고합니다. ECMAScript 6 이후 버전부터 JavaScript 블록은 &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt;변수에 새로운 스코프를 도입하지만 &lt;code&gt;var&lt;/code&gt;변수와 함께 사용 시 독립된 블록 구문은 혼란을 일으킬 수 있으며 미묘한 버그를 초래할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: BlockStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegatedIfStatementJS" defaultSeverity="WARNING" displayName="부정된 'if' 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;b&gt;else&lt;/b&gt; 브랜치 및 부정된 조건을 포함하는 &lt;b&gt;if&lt;/b&gt; 문을 보고합니다.
&lt;b&gt;if&lt;/b&gt; 및 &lt;b&gt;else&lt;/b&gt; 브랜치의 순서를 반전시키면 보통 그러한 구문의 명확도가 높아집니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NegatedIfStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PointlessArithmeticExpressionJS" defaultSeverity="WARNING" displayName="무의미한 산술 표현식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
0으로 더하기 또는 빼기, 0 또는 1로 곱하기, 1로 나누기, 0으로 시프트 연산을 포함하는 산술 표현식을 보고합니다. 그러한 표현식은 완전히 완료되지 않은 자동 리팩토링으로 인해 발생할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PointlessArithmeticExpressionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncrementDecrementResultUsedJS" defaultSeverity="WARNING" displayName="사용된 증분 또는 감소의 결과" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대입의 결과가 상위 표현식에서 사용되는 증분(&lt;code&gt;++&lt;/code&gt;) 
또는 감소(&lt;code&gt;--&lt;/code&gt;) 표현식을 보고합니다. 그러한 대입은 예기치 못한 방식으로 외부 표현식에 영향을 미칠 수 있기 때문에 연산 순서로 인해 혼란이 발생할 수 있습니다. 예: &lt;code&gt;var a = b++&lt;/code&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IncrementDecrementResultUsedJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyComplexArithmeticExpressionJS" defaultSeverity="WARNING" displayName="지나치게 복잡한 산술 표현식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/OverlyComplexArithmeticExpression.html --&gt;
&lt;html&gt;
&lt;body&gt;
항이 너무 많은 산술 표현식을 보고합니다. 그러한 표현식은 혼동을 일으키고 버그가 발생하기 쉽습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 필드를 사용해 산술 표현식에 허용된 최대 항 개수를 지정하십시오.
&lt;p&gt;&lt;small&gt;Inspection ID: OverlyComplexArithmeticExpressionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyStatementBodyJS" defaultSeverity="WARNING" displayName="본문이 비어 있는 구문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 빈 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, 또는 &lt;code&gt;with&lt;/code&gt; 문을 보고합니다. 그러한 구문은 보통 오타로 발생하며 혼동을 일으킬 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 체크박스를 사용하여 빈 블록 구문을 본문으로 포함하는 구문이 보고되어야 하는지 여부를 지정하십시오.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EmptyStatementBodyJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyComplexBooleanExpressionJS" defaultSeverity="WARNING" displayName="지나치게 복잡한 부울 표현식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/OverlyComplexBooleanExpression.html --&gt;
&lt;html&gt;
&lt;body&gt;
항이 너무 많은 bool 표현식을 보고합니다. 그러한 표현식은 혼동을 일으키고 버그가 발생하기 쉽습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 필드를 사용해 산술 표현식에 허용된 최대 항 개수를 지정하십시오.
&lt;p&gt;&lt;small&gt;Inspection ID: OverlyComplexBooleanExpressionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedConditionalExpressionJS" defaultSeverity="WARNING" displayName="중첩된 조건식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 삼항 조건을 포함하는 삼항 조건식을 보고합니다.
그러한 중첩 조건은 혼란을 일으킬 가능성이 매우 크며 더욱 명시적인 조건 로직으로 대체하는 것이 최선입니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NestedConditionalExpressionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConfusingPlusesOrMinusesJS" defaultSeverity="WARNING" displayName="혼동되는 '+' 또는 '-'의 시퀀스" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JavaScript 코드 내 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 문자의 의심스러운 조합을 보고합니다(예: &lt;code&gt;a+++b&lt;/code&gt;).  그러한 시퀀스는 혼란을 일으킬 수 있으며 
공백 내 변경을 통해 의미가 달라질 수 있습니다
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ConfusingPlusesOrMinusesJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MagicNumberJS" defaultSeverity="WARNING" displayName="매직 넘버" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/MagicNumber.html --&gt;
&lt;html&gt;
&lt;body&gt;
상수 선언에서 이름이 지정되지 않고 사용되고 있는 숫자 리터럴의 '매직 넘버'를 보고합니다.
매직 넘버는 코드의 의도를 불명확하게 만들 수 있으므로, 한 코드 위치에서 변경되고 다른 곳에서는 변경되지 않을 경우 오류가 발생할 수 있습니다. 숫자 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100, 1000,
0.0, 1.0은 무시됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MagicNumberJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedFunctionJS" defaultSeverity="WARNING" displayName="중첩된 함수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 함수 내부에 중첩된 함수를 보고합니다.
JavaScript는 함수 중첩을 허용하나 그러한 구문은 혼란을 일으킬 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래 체크박스를 사용해 익명 중첩 함수를 무시하십시오.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NestedFunctionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 상호운용성 문제" path="Kotlin"><inspection shortName="PackageDirectoryMismatch" defaultSeverity="WEAK WARNING" displayName="패키지 이름이 포함하는 디렉터리와 일치하지 않음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
파일 위치와 일치하지 않는 &lt;code&gt;패키지&lt;/code&gt; 지시문을 보고합니다.
&lt;p&gt;
    수정을 적용한 경우, 변경된 선언의 사용 위치를 업데이트하기 위해 '이동 리팩터링'의 디폴트 값이 다음과 같이 사용됩니다.
&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;'주석 및 문자열에서 검색'&lt;/li&gt;
    &lt;li&gt;'찾은 텍스트 항목 검색'&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PackageDirectoryMismatch&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaDefaultMethodsNotOverriddenByDelegation" defaultSeverity="WARNING" displayName="위임으로 재정의되지 않은 Java 디폴트 메서드" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
    위임 객체가 재정의하는 클래스의 인스턴스이거나(&lt;code&gt;final&lt;/code&gt;및 &lt;code&gt;sealed&lt;/code&gt;의 클래스의 경우) 혹은 재정의할 수 있는 Java 기본 메서드인(&lt;code&gt;open&lt;/code&gt; 및 &lt;code&gt;abstract&lt;/code&gt; 클래스의 경우) 위임을 보고합니다.
&lt;/p&gt;
&lt;p&gt;
    특히 상속 계층 구조가 깊은 경우에 까다로운 버그를 일으킬 수 있어 Kotlin 위임은 Java 기본 메서드를 재정의하지 않도록 설계되었습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
// Base.java:
public interface Base {
  default void print() {
    System.out.println("Base");
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="kotlin"&gt;
// BaseImpl.kt:
class BaseImpl : Base {
  override fun print() {
    println("BaseImpl")
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="kotlin"&gt;
// Main.kt:
fun main() {
  val inherited = BaseImpl()
  val delegated = object : Base by inherited {}
  inherited.print() // Outputs: BaseImpl
  delegated.print() // Outputs: Base
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
    개발자들은 일반적으로 위임자에서 재정의된 기본 메서드를 포함한 모든 메서드가 포워드되기를 기대합니다. 그러나 Java 기본 메서드가 호출되고, 예기치 않은 결과를 야기할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
    빠른 수정 중 하나는 Java 기본 메서드의 구현을 위임 객체로 위임하여 재정의합니다.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
// Main.kt:
fun main() {
  val inherited = BaseImpl()
  val delegated = object : Base by inherited {
    override fun print() {
      inherited.print()
    }
  }
  inherited.print() // 출력: BaseImpl
  delegated.print() // 출력: BaseImpl
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
    다른 빠른 수정은 명시적으로 Java 기본 메서드의 구현을 상위 클래스에 위임하여 재정의합니다.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
// Main.kt:
fun main() {
  val inherited = BaseImpl()
  val delegated = object : Base by inherited {
    override fun print() {
      super.print()
    }
  }
  inherited.print() // Outputs: BaseImpl
  delegated.print() // Outputs: Base
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2025.1에서 추가&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavaDefaultMethodsNotOverriddenByDelegation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HasPlatformType" defaultSeverity="WEAK WARNING" displayName="함수 또는 프로퍼티에 플랫폼 타입이 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
플랫폼 타입을 포함하는 함수와 프로퍼티를 보고합니다.
&lt;p&gt;예상하지 못한 오류를 방지하려면 타입을 명시적으로 선언해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() = java.lang.String.valueOf(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 통해 반환 타입을 지정할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): String = java.lang.String.valueOf(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HasPlatformType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaCollectionWithNullableTypeArgument" defaultSeverity="WARNING" displayName="null을 지원하지 않는 Java 컬렉션 내에 null이 가능한 타입 인수가 있습니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
null을 허용하지 않는 Java 컬렉션에 null 허용 타입 인수를 제공하는 경우를 보고합니다.
&lt;p&gt;
    Java 표준 라이브러리에 포함된 일부 Java 컬렉션은 null 요소, 키 또는 값을 지원하지 않습니다.
    이러한 컬렉션의 타입 인수를 null 허용 타입으로 인스턴스화해서는 안 됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
val map = ConcurrentHashMap&amp;lt;String, String?&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
val map = ConcurrentHashMap&amp;lt;String, String&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JavaCollectionWithNullableTypeArgument&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="테스트 프레임워크" path="JVM 언어"><inspection shortName="TestInProductSource" defaultSeverity="WARNING" displayName="제품 소스 내 테스트" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
프로덕션 소스 트리에 있는 테스트 클래스 및 테스트 메서드를 보고합니다.
이는 실수일 가능성이 높으며 테스트 코드가 프로덕션으로 그대로 옮겨질 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TestInProductSource&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestCaseWithNoTestMethods" defaultSeverity="WARNING" displayName="테스트가 없는 테스트 클래스" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
테스트 메서드를 사용하지 않는 비 &lt;code&gt;abstract&lt;/code&gt; 테스트 사례를 보고합니다. 일반적으로 그러한 테스트 케이스는 완성되지 않은 코드를 나타내거나 제거해야 하는 리팩터링 잔여물일 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class CrucialTest {
    @Before
    public void setUp() {
      System.out.println("setting up");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TestCaseWithNoTestMethods&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestOnlyProblems" defaultSeverity="WARNING" displayName="프로덕션 코드 내 테스트 전용 사용 위치" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@TestOnly&lt;/code&gt; 및 &lt;code&gt;@VisibleForTesting&lt;/code&gt; 어노테이션이 추가된 메서드 및 클래스가 프로덕션 코드에서 사용된 경우를 보고합니다. 또한 &lt;code&gt;@TestOnly&lt;/code&gt; 및 &lt;code&gt;@VisibleForTesting&lt;/code&gt;를 동일한 요소에 적용하는 경우도 보고합니다.

&lt;p&gt;그러한 메서드 또는 클래스가 다음에서 참조되는 경우에는 문제가 보고되지 않습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;Test Sources&lt;/b&gt; 폴더에 있는 코드
  &lt;li&gt;테스트 클래스(JUnit/TestNG)
  &lt;li&gt;&lt;code&gt;@TestOnly&lt;/code&gt; 어노테이션이 추가된 다른 메서드
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;예(프로덕션 코드):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="kotlin"&gt;
  @TestOnly
  fun foo() { ... }

  fun main () {
    foo()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TestOnlyProblems&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AssertBetweenInconvertibleTypes" defaultSeverity="WARNING" displayName="변환할 수 없는 타입의 객체 간의 'assertequals()'" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
'필요한' 인수와 '실제' 인수의 타입이 호환되지 않는 어설션 메서드에 대한 호출을 보고합니다.
&lt;p&gt;그러한 호출은 보통 테스트에 버그가 있음을 나타냅니다.
  이 검사는 관련 JUnit, TestNG, AssertJ 메서드를 확인합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  assertEquals("1", 1);
  assertNotSame(new int[0], 0);

  // 약한 경고. equals() 컨트랙트만 테스트할 수 있습니다
  assertThat(foo).as("user type").isNotEqualTo(bar);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AssertBetweenInconvertibleTypes&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TestMethodWithoutAssertion" defaultSeverity="WARNING" displayName="어설션이 없는 테스트 메서드" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
어설션을 포함하지 않는 테스트 메서드를 보고합니다. 그러한 메서드는 불완전하거나 취약한 테스트 사례를 나타낼 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  &lt;b&gt;public class&lt;/b&gt; ExtensiveTest {

    @Test
    &lt;b&gt;public void&lt;/b&gt; testAlive() {
      System.out.println("nothing");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 구성:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
      테이블을 사용하여 어설션으로 한정하는 완전히 정규화된 클래스 이름과 메서드 이름의 정규 표현식의 조합을 명시합니다. 클래스 이름은 하위 클래스와도 일치합니다.
  &lt;/li&gt;
  &lt;li&gt;
      &lt;b&gt;'assert' 키워드를 어설션으로 간주&lt;/b&gt; 옵션을 사용하여, &lt;code&gt;assert&lt;/code&gt; 키워드를 사용하는 Java &lt;code&gt;assert&lt;/code&gt; 문을 어설션으로 간주해야 하는지 지정합니다.
  &lt;/li&gt;
  &lt;li&gt;
      &lt;b&gt;예외를 선언하는 테스트 메서드 무시&lt;/b&gt; 옵션을 사용하여 예외를 선언하는 테스트 메서드를 무시합니다.
      이는 실패 시 예외를 던지므로 어설션이 필요하지 않은 테스트가 있는 경우에 유용할 수 있습니다.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: TestMethodWithoutAssertion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestCaseWithConstructor" defaultSeverity="WARNING" displayName="사소하지 않은 생성자가 있는 TestCase" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
생성자에 초기화 로직을 포함하는 테스트 케이스를 보고합니다.
생성자가 실패하면 &lt;code&gt;@After&lt;/code&gt; 어노테이션이 추가된 메서드 또는 &lt;code&gt;tearDown()&lt;/code&gt; 메서드가 호출되지 않습니다.
그러면 테스트 환경이 부분적으로 초기화될 수 있으며 이는 다른 테스트에 부정적인 영향을 미칠 수 있습니다.
대신 테스트 케이스의 초기화는 &lt;code&gt;setUp()&lt;/code&gt; 메서드 또는 &lt;code&gt;@Before&lt;/code&gt; 어노테이션이 추가된 메서드에서 실행되어야 합니다.
&lt;p&gt;나쁜 예:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class ImportantTest {
    private File file;

    public ImportantTest() throws IOException {
      file = File.createTempFile("xyz", ".tmp");
    }

    // ... tests go here
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TestCaseWithConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestFailedLine" defaultSeverity="WARNING" displayName="테스트에서 실패한 줄" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;테스트에서 실패한 메서드 호출 또는 어설션을 보고합니다. 이 보고를 통해 코드에서 실패한 줄을 더 빨리 탐지하고 디버그를 즉시 시작할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="kotlin"&gt;
  @Test
  fun foo() {
    assertEquals(1, 0) // 강조 표시됨
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TestFailedLine&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="종속성 문제" path="Java"><inspection shortName="ClassWithTooManyTransitiveDependents" defaultSeverity="WARNING" displayName="이행적 종속자가 너무 많은 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
너무 많은 다른 클래스가 직접 또는 간접적으로 종속되어 있는 클래스를 보고합니다.
&lt;p&gt;이러한 클래스를 수정하려면 다른 많은 클래스를 변경해야 하므로 리소스 소비가 클 수 있습니다.&lt;/p&gt;
&lt;p&gt;최상위 클래스만 보고됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;최대 이행적 종속성의 수&lt;/b&gt; 필드를 사용하여 클래스에 허용되는 최대 간접 또는 직접 종속성의 수를 지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ClassWithTooManyTransitiveDependents&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CyclicClassDependency" defaultSeverity="WARNING" displayName="순환 클래스 종속성" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
다른 클래스에 서로 또는 주기적으로 종속된 클래스를 보고합니다.
&lt;p&gt;그러한 순환 종속성이 사용되면 코드가 취약해지고 유지 관리가 어려워집니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CyclicClassDependency&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CyclicPackageDependency" defaultSeverity="WARNING" displayName="순환 패키지 종속성" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
다른 패키지에 서로 또는 주기적으로 종속된 패키지를 보고합니다.
&lt;p&gt;그러한 순환 종속성이 사용되면 코드가 취약해지고 유지 관리가 어려워집니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CyclicPackageDependency&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithTooManyTransitiveDependencies" defaultSeverity="WARNING" displayName="이행적 종속성이 너무 많은 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
너무 많은 다른 클래스에 직접 또는 간접적으로 종속된 클래스를 보고합니다.
&lt;p&gt;이러한 클래스의 종속성을 수정하려면 클래스를 변경해야 하므로 불안정해지기 쉽습니다.&lt;/p&gt;
&lt;p&gt;최상위 클래스만 보고됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;최대 이행적 종속성의 수&lt;/b&gt; 필드를 사용하여 클래스에 허용되는 최대 간접 또는 직접 종속성의 수를 지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassWithTooManyTransitiveDependencies&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithTooManyDependents" defaultSeverity="WARNING" displayName="종속자가 너무 많은 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
너무 많은 다른 클래스가 직접 종속되어 있는 클래스를 보고합니다.
&lt;p&gt;이러한 클래스를 수정하려면 다른 많은 클래스를 변경해야 하므로 리소스 소비가 클 수 있습니다.&lt;/p&gt;
&lt;p&gt;최상위 클래스만 보고됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;아래 필드를 사용하여 클래스에 허용되는 최대 종속성의 수를 지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassWithTooManyDependents&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithTooManyDependencies" defaultSeverity="WARNING" displayName="종속성이 너무 많은 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
프로젝트에서 너무 많은 다른 클래스에 직접적으로 종속된 클래스를 보고합니다.
&lt;p&gt;이러한 클래스의 종속성을 수정하려면 클래스를 변경해야 하므로 불안정해지기 쉽습니다.&lt;/p&gt;
&lt;p&gt;최상위 클래스만 보고됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;최대 종속성의 수&lt;/b&gt; 필드를 사용하여 클래스에 허용되는 최대 종속성의 수를 지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassWithTooManyDependencies&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Correctness" path=""><inspection shortName="AndroidLintSoonBlockedPrivateApi" defaultSeverity="ERROR" displayName="Using Soon-to-Be Blocked Private API" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Soon-to-Be Blocked Private API&lt;br&gt;&lt;br&gt;Usage of restricted non-SDK interface will throw an exception at runtime. Accessing non-SDK methods or fields through reflection has a high likelihood to break your app between versions, and is being restricted to facilitate future app compatibility.&lt;br&gt;&lt;br&gt;Issue id: SoonBlockedPrivateApi&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces"&gt;https://developer.android.com/preview/restrictions-non-sdk-interfaces&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongConstant" defaultSeverity="ERROR" displayName="Incorrect constant" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect constant&lt;br&gt;&lt;br&gt;Ensures that when parameter in a method only allows a specific set of constants, calls obey those rules.&lt;br&gt;&lt;br&gt;Issue id: WrongConstant&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleCompatible" defaultSeverity="ERROR" displayName="Incompatible Gradle Versions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incompatible Gradle Versions&lt;br&gt;&lt;br&gt;There are some combinations of libraries, or tools and libraries, that are incompatible, or can lead to bugs. One such incompatibility is compiling with a version of the Android support libraries that is not the latest version (or in particular, a version lower than your &lt;code&gt;targetSdkVersion&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: GradleCompatible&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintXmlEscapeNeeded" defaultSeverity="ERROR" displayName="Missing XML Escape" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing XML Escape&lt;br&gt;&lt;br&gt;When a string contains characters that have special usage in XML, you must escape the characters.&lt;br&gt;&lt;br&gt;Issue id: XmlEscapeNeeded&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPinSetExpiry" defaultSeverity="WARNING" displayName="Validate &lt;pin-set&gt; expiration attribute" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Validate &lt;code&gt;&amp;lt;pin-set&gt;&lt;/code&gt; expiration attribute&lt;br&gt;&lt;br&gt;Ensures that the &lt;code&gt;expiration&lt;/code&gt; attribute of the &lt;code&gt;&amp;lt;pin-set&gt;&lt;/code&gt; element is valid and has not already expired or is expiring soon&lt;br&gt;&lt;br&gt;Issue id: PinSetExpiry&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/features/security-config.html"&gt;https://developer.android.com/preview/features/security-config.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInlinedApi" defaultSeverity="WARNING" displayName="Using inlined constants on older versions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using inlined constants on older versions&lt;br&gt;&lt;br&gt;This check scans through all the Android API field references in the application and flags certain constants, such as static final integers and Strings, which were introduced in later versions. These will actually be copied into the class files rather than being referenced, which means that the value is available even when running on older devices. In some cases that's fine, and in other cases it can result in a runtime crash or incorrect behavior. It depends on the context, so consider the code carefully and decide whether it's safe and can be suppressed or whether the code needs to be guarded.&lt;br/&gt;
&lt;br/&gt;
If you really want to use this API and don't need to support older devices just set the &lt;code&gt;minSdkVersion&lt;/code&gt; in your &lt;code&gt;build.gradle&lt;/code&gt; or &lt;code&gt;AndroidManifest.xml&lt;/code&gt; files.&lt;br/&gt;
&lt;br/&gt;
If your code is &lt;b&gt;deliberately&lt;/b&gt; accessing newer APIs, and you have ensured (e.g. with conditional execution) that this code will only ever be called on a supported platform, then you can annotate your class or method with the &lt;code&gt;@TargetApi&lt;/code&gt; annotation specifying the local minimum SDK to apply, such as &lt;code&gt;@TargetApi(11)&lt;/code&gt;, such that this check considers 11 rather than your manifest file's minimum SDK as the required API level.&lt;br&gt;&lt;br&gt;Issue id: InlinedApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintValidFragment" defaultSeverity="ERROR" displayName="Fragment not instantiatable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Fragment not instantiatable&lt;br&gt;&lt;br&gt;From the Fragment documentation:&lt;br/&gt;
&lt;b&gt;Every&lt;/b&gt; fragment must have an empty constructor, so it can be instantiated when restoring its activity's state. It is strongly recommended that subclasses do not have other constructors with parameters, since these constructors will not be called when the fragment is re-instantiated; instead, arguments can be supplied by the caller with &lt;code&gt;setArguments(Bundle)&lt;/code&gt; and later retrieved by the Fragment with &lt;code&gt;getArguments()&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Note that this is no longer true when you are using &lt;code&gt;androidx.fragment.app.Fragment&lt;/code&gt;; with the &lt;code&gt;FragmentFactory&lt;/code&gt; you can supply any arguments you want (as of version androidx version 1.1).&lt;br&gt;&lt;br&gt;Issue id: ValidFragment&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/app/Fragment.html#Fragment()"&gt;https://developer.android.com/reference/android/app/Fragment.html#Fragment()&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppLinkSplitToWebAndCustom" defaultSeverity="ERROR" displayName="Android App links should only use http(s) schemes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Android App links should only use http(s) schemes&lt;br&gt;&lt;br&gt;In order for Android App Links to open in your app, Android must perform domain verification. However, Android only sends domain verification requests for `&amp;lt;intent-filter&gt;&lt;code&gt;s that only contain http(s) schemes.&lt;br/&gt;
&lt;br/&gt;
To ensure correct behavior, please split your http(s) schemes and other schemes into two different &lt;/code&gt;&amp;lt;intent-filter&gt;`s.&lt;br&gt;&lt;br&gt;Issue id: AppLinkSplitToWebAndCustom&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/app-links/verify-android-applinks#add-intent-filters"&gt;https://developer.android.com/training/app-links/verify-android-applinks#add-intent-filters&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMutatingSharedPrefs" defaultSeverity="WARNING" displayName="Mutating an Immutable SharedPrefs Set" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mutating an Immutable SharedPrefs Set&lt;br&gt;&lt;br&gt;As stated in the docs for &lt;code&gt;SharedPreferences.getStringSet&lt;/code&gt;, you must not modify the set returned by &lt;code&gt;getStringSet&lt;/code&gt;:&lt;br/&gt;
&lt;br/&gt;
  "Note that you &amp;lt;em&gt;must not&amp;lt;/em&gt; modify the set instance returned    by this call.  The consistency of the stored data is not guaranteed    if you do, nor is your ability to modify the instance at all."&lt;br&gt;&lt;br&gt;Issue id: MutatingSharedPrefs&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInternalInsetResource" defaultSeverity="WARNING" displayName="Using internal inset dimension resource" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using internal inset dimension resource&lt;br&gt;&lt;br&gt;The internal inset dimension resources are not a supported way to retrieve the relevant insets for your application. The insets are dynamic values that can change while your app is visible, and your app's window may not intersect with the system UI. To get the relevant value for your app and listen to updates, use &lt;code&gt;androidx.core.view.WindowInsetsCompat&lt;/code&gt; and related APIs.&lt;br&gt;&lt;br&gt;Issue id: InternalInsetResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMergeMarker" defaultSeverity="ERROR" displayName="Code contains merge marker" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Code contains merge marker&lt;br&gt;&lt;br&gt;Many version control systems leave unmerged files with markers such as &amp;lt;&amp;lt;&amp;lt; in the source code. This check looks for these markers, which are sometimes accidentally left in, particularly in resource files where they don't break compilation.&lt;br&gt;&lt;br&gt;Issue id: MergeMarker&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleDeprecated" defaultSeverity="WARNING" displayName="Deprecated Gradle Construct" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Deprecated Gradle Construct&lt;br&gt;&lt;br&gt;This detector looks for deprecated Gradle constructs which currently work but will likely stop working in a future update.&lt;br&gt;&lt;br&gt;Issue id: GradleDeprecated&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnlocalizedSms" defaultSeverity="WARNING" displayName="SMS phone number missing country code" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;SMS phone number missing country code&lt;br&gt;&lt;br&gt;SMS destination numbers must start with a country code or the application code must ensure that the SMS is only sent when the user is in the same country as the receiver.&lt;br&gt;&lt;br&gt;Issue id: UnlocalizedSms&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsupportedChromeOsHardware" defaultSeverity="ERROR" displayName="Unsupported Chrome OS Hardware Feature" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsupported Chrome OS Hardware Feature&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-feature&gt;&lt;/code&gt; element should not require this unsupported large screen hardware feature. Any &amp;lt;uses-feature&gt; not explicitly marked with &lt;code&gt;required="false"&lt;/code&gt; is necessary on the device to be installed on. Ensure that any features that might prevent it from being installed on a ChromeOS, large screen, or foldable device are reviewed and marked as not required in the manifest.&lt;br&gt;&lt;br&gt;Issue id: UnsupportedChromeOsHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/arc/manifest.html#incompat-entries"&gt;https://developer.android.com/topic/arc/manifest.html#incompat-entries&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotInterpolated" defaultSeverity="ERROR" displayName="Incorrect Interpolation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect Interpolation&lt;br&gt;&lt;br&gt;To insert the value of a variable, you can use &lt;code&gt;${variable}&lt;/code&gt; inside a string literal, but &lt;b&gt;only&lt;/b&gt; if you are using double quotes!&lt;br&gt;&lt;br&gt;Issue id: NotInterpolated&lt;br&gt;&lt;br&gt;&lt;a href="https://www.groovy-lang.org/syntax.html#_string_interpolation"&gt;https://www.groovy-lang.org/syntax.html#_string_interpolation&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPendingBindings" defaultSeverity="ERROR" displayName="Missing Pending Bindings" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Pending Bindings&lt;br&gt;&lt;br&gt;When using a &lt;code&gt;ViewDataBinding&lt;/code&gt; in a &lt;code&gt;onBindViewHolder&lt;/code&gt; method, you &lt;b&gt;must&lt;/b&gt; call &lt;code&gt;executePendingBindings()&lt;/code&gt; before the method exits; otherwise the data binding runtime will update the UI in the next animation frame causing a delayed update and potential jumps if the item resizes.&lt;br&gt;&lt;br&gt;Issue id: PendingBindings&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCredentialManagerSignInWithGoogle" defaultSeverity="WARNING" displayName="Misuse of Sign in with Google API" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Misuse of Sign in with Google API&lt;br&gt;&lt;br&gt;When using &lt;code&gt;:googleid&lt;/code&gt; classes like &lt;code&gt;GetGoogleIdOption&lt;/code&gt; and &lt;code&gt;GetSignInWithGoogleOption&lt;/code&gt;, you must handle the response using &lt;code&gt;GoogleIdTokenCredential.createFrom&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
This check reports all uses of these &lt;code&gt;:googleid&lt;/code&gt; classes if there are no references to &lt;code&gt;GoogleIdTokenCredential[.Companion].createFrom&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: CredentialManagerSignInWithGoogle&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/identity/sign-in/credential-manager-siwg#create-sign"&gt;https://developer.android.com/identity/sign-in/credential-manager-siwg#create-sign&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintJcenterRepositoryObsolete" defaultSeverity="WARNING" displayName="JCenter Maven repository is read-only" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;JCenter Maven repository is read-only&lt;br&gt;&lt;br&gt;The JCenter Maven repository is no longer accepting submissions of Maven artifacts since 31st March 2021.  Ensure that the project is configured to search in repositories with the latest versions of its dependencies.&lt;br&gt;&lt;br&gt;Issue id: JcenterRepositoryObsolete&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/r/tools/jcenter-end-of-service"&gt;https://developer.android.com/r/tools/jcenter-end-of-service&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidNavigation" defaultSeverity="WARNING" displayName="No start destination specified" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;No start destination specified&lt;br&gt;&lt;br&gt;All &lt;code&gt;&amp;lt;navigation&gt;&lt;/code&gt; elements must have a start destination specified, and it must be a direct child of that &lt;code&gt;&amp;lt;navigation&gt;&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidNavigation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCutPasteId" defaultSeverity="WARNING" displayName="Likely cut &amp; paste mistakes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Likely cut &amp;amp; paste mistakes&lt;br&gt;&lt;br&gt;This lint check looks for cases where you have cut &amp;amp; pasted calls to &lt;code&gt;findViewById&lt;/code&gt; but have forgotten to update the R.id field. It's possible that your code is simply (redundantly) looking up the field repeatedly, but lint cannot distinguish that from a case where you for example want to initialize fields &lt;code&gt;prev&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; and you cut &amp;amp; pasted &lt;code&gt;findViewById(R.id.prev)&lt;/code&gt; and forgot to update the second initialization to &lt;code&gt;R.id.next&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: CutPasteId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotificationPermission" defaultSeverity="ERROR" displayName="Notifications Without Permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notifications Without Permission&lt;br&gt;&lt;br&gt;When targeting Android 13 and higher, posting permissions requires holding the runtime permission &lt;code&gt;android.permission.POST_NOTIFICATIONS&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: NotificationPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInconsistentLayout" defaultSeverity="WARNING" displayName="Inconsistent Layouts" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Inconsistent Layouts&lt;br&gt;&lt;br&gt;This check ensures that a layout resource which is defined in multiple resource folders, specifies the same set of widgets.&lt;br/&gt;
&lt;br/&gt;
This finds cases where you have accidentally forgotten to add a widget to all variations of the layout, which could result in a runtime crash for some resource configurations when a &lt;code&gt;findViewById()&lt;/code&gt; fails.&lt;br/&gt;
&lt;br/&gt;
There &lt;b&gt;are&lt;/b&gt; cases where this is intentional. For example, you may have a dedicated large tablet layout which adds some extra widgets that are not present in the phone version of the layout. As long as the code accessing the layout resource is careful to handle this properly, it is valid. In that case, you can suppress this lint check for the given extra or missing views, or the whole layout&lt;br&gt;&lt;br&gt;Issue id: InconsistentLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotificationId0" defaultSeverity="ERROR" displayName="Notification Id is 0" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notification Id is 0&lt;br&gt;&lt;br&gt;The notification id &lt;b&gt;cannot&lt;/b&gt; be 0; using 0 here can make the service not run in the foreground.&lt;br&gt;&lt;br&gt;Issue id: NotificationId0&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingInflatedId" defaultSeverity="ERROR" displayName="ID not found in inflated resource" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;ID not found in inflated resource&lt;br&gt;&lt;br&gt;Checks calls to layout inflation and makes sure that the referenced ids are found in the corresponding layout (or at least one of them, if the layout has multiple configurations.)&lt;br&gt;&lt;br&gt;Issue id: MissingInflatedId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAligned16KB" defaultSeverity="WARNING" displayName="Native library dependency not 16 KB aligned" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Native library dependency not 16 KB aligned&lt;br&gt;&lt;br&gt;Android has traditionally used 4 KB memory page sizes. However, to support future devices that only work with 16 KB aligned libraries apps containing native libraries need to be built with 16 KB alignment.&lt;br/&gt;
&lt;br/&gt;
Apps with 4 KB aligned native libraries may not work correctly on devices requiring 16 KB alignment. To ensure compatibility and future-proof your app, it is strongly recommended that your native libraries are aligned to 16 KB boundaries.&lt;br/&gt;
&lt;br/&gt;
If your app uses any NDK libraries, directly or indirectly through an SDK, you should rebuild your app to meet this recommendation. Make sure all native libraries within your application, including those from dependencies, are built with 16 KB page alignment.&lt;br/&gt;
&lt;br/&gt;
This lint check looks at all native libraries that your app depends on. If any are found to be aligned to 4 KB instead of 16 KB, you will need to address this.&lt;br/&gt;
&lt;br/&gt;
When a library is flagged, first try to update to a newer version that supports 16 KB alignment. If an updated version is not available, contact the library vendor to ask about their plans for 16 KB support and request a compatible version. Updating your libraries proactively will help ensure your app works properly on a wider range of devices.&lt;br&gt;&lt;br&gt;Issue id: Aligned16KB&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/practices/page-sizes"&gt;https://developer.android.com/guide/practices/page-sizes&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInOrMmUsage" defaultSeverity="WARNING" displayName="Using mm or in dimensions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;mm&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; dimensions&lt;br&gt;&lt;br&gt;Avoid using &lt;code&gt;mm&lt;/code&gt; (millimeters) or &lt;code&gt;in&lt;/code&gt; (inches) as the unit for dimensions.&lt;br/&gt;
&lt;br/&gt;
While it should work in principle, unfortunately many devices do not report the correct true physical density, which means that the dimension calculations won't work correctly. You are better off using &lt;code&gt;dp&lt;/code&gt; (and for font sizes, &lt;code&gt;sp&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: InOrMmUsage&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintValidRestrictions" defaultSeverity="ERROR" displayName="Invalid Restrictions Descriptor" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Restrictions Descriptor&lt;br&gt;&lt;br&gt;Ensures that an applications restrictions XML file is properly formed&lt;br&gt;&lt;br&gt;Issue id: ValidRestrictions&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/content/RestrictionsManager.html"&gt;https://developer.android.com/reference/android/content/RestrictionsManager.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingClass" defaultSeverity="ERROR" displayName="Missing registered class" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing registered class&lt;br&gt;&lt;br&gt;If a class is referenced in the manifest or in a layout file, it must also exist in the project (or in one of the libraries included by the project. This check helps uncover typos in registration names, or attempts to rename or move classes without updating the XML references properly.&lt;br&gt;&lt;br&gt;Issue id: MissingClass&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/manifest-intro.html"&gt;https://developer.android.com/guide/topics/manifest/manifest-intro.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWebViewLayout" defaultSeverity="ERROR" displayName="WebViews in wrap_content parents" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WebViews in wrap_content parents&lt;br&gt;&lt;br&gt;The WebView implementation has certain performance optimizations which will not work correctly if the parent view is using &lt;code&gt;wrap_content&lt;/code&gt; rather than &lt;code&gt;match_parent&lt;/code&gt;. This can lead to subtle UI bugs.&lt;br&gt;&lt;br&gt;Issue id: WebViewLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnclosedTrace" defaultSeverity="WARNING" displayName="Incorrect trace section usage" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect trace section usage&lt;br&gt;&lt;br&gt;Calls to begin trace sections must be followed by corresponding calls to end those trace sections. Care must be taken to ensure that begin-section / end-section pairs are properly nested, and that functions do not return when there are still unclosed trace sections. The easiest way to ensure begin-section / end-section pairs are properly closed is to use a try-finally block as follows:&lt;br/&gt;

&lt;pre&gt;
try {
  Trace.beginSection("OK")
  return true
} finally {
  Trace.endSection()
}
&lt;/pre&gt;
&lt;br/&gt;
This lint check may result in false-positives if trace sections are guarded by conditionals. For example, it may erroneously say the following has unclosed trace sections:&lt;br/&gt;

&lt;pre&gt;
try {
  Trace.beginSection("Wrong")
  if (a == b) {
    Trace.beginSection("OK")
    blockingCall()
  }
} finally {
  // Even though this is technically correct, the lint check isn't capable of detecting
  // that the two conditionals are the same
  if (a == b) Trace.endSection()
  Trace.endSection()
}
&lt;/pre&gt;
&lt;br/&gt;
To fix the code snippet above, you could add a nested try-finally as follows:&lt;br/&gt;

&lt;pre&gt;
try {
  Trace.beginSection("OK")
  if (a == b) {
    try {
      Trace.beginSection("OK")
      blockingCall()
    } finally {
      Trace.endSection()
    }
  }
} finally {
  Trace.endSection()
}
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;Issue id: UnclosedTrace&lt;br&gt;&lt;br&gt;Available options:&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;strict&lt;/b&gt; (default is false):&lt;br/&gt;
Whether to assume any method call could throw an exception.&lt;br/&gt;
&lt;br/&gt;
In strict mode, this check assumes that any method call in between begin-section and end-section pairs could potentially throw an exception. Strict mode is useful for situations where unchecked Java exceptions are caught and do not necessarily result in a crash.&lt;br/&gt;
&lt;br/&gt;
If strict mode is off, this check will still consider the flow of exceptions in Kotlin, but it will ignore unchecked exceptions (&lt;code&gt;RuntimeException&lt;/code&gt; and its subclasses) in Java unless the method declares explicitly that it &lt;code&gt;throws&lt;/code&gt; them. If strict mode is enabled, all Java method calls need to be guarded using a finally block so ensure the trace is always ended.&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="UnclosedTrace"&gt;
        &amp;lt;option name="strict" value="false" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnspecifiedRegisterReceiverFlag" defaultSeverity="ERROR" displayName="Missing registerReceiver() exported flag" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;registerReceiver()&lt;/code&gt; exported flag&lt;br&gt;&lt;br&gt;In Android U, all receivers registering for non-system broadcasts are required to include a flag indicating the receiver's exported state. Apps registering for non-system broadcasts should use the &lt;code&gt;ContextCompat#registerReceiver&lt;/code&gt; APIs with flags set to either &lt;code&gt;RECEIVER_EXPORTED&lt;/code&gt; or &lt;code&gt;RECEIVER_NOT_EXPORTED&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If you are not expecting broadcasts from other apps on the device, register your receiver with &lt;code&gt;RECEIVER_NOT_EXPORTED&lt;/code&gt; to protect your receiver on all platform releases.&lt;br&gt;&lt;br&gt;Issue id: UnspecifiedRegisterReceiverFlag&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/androidx/core/content/ContextCompat#registerReceiver(android.content.Context,android.content.BroadcastReceiver,android.content.IntentFilter,int)"&gt;https://developer.android.com/reference/androidx/core/content/ContextCompat#registerReceiver(android.content.Context,android.content.BroadcastReceiver,android.content.IntentFilter,int)&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongCommentType" defaultSeverity="WARNING" displayName="Wrong Comment Type" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Comment Type&lt;br&gt;&lt;br&gt;This check flags any block comments which look like they had been intended to be KDoc or javadoc comments instead.&lt;br/&gt;
&lt;br/&gt;
If you really want to use Javadoc-like constructs in a block comment, there's a convention you can use: include &lt;code&gt;(non-Javadoc)&lt;/code&gt; somewhere in the comment, e.g.
&lt;pre&gt;
  /* (non-Javadoc)
   * @see org.xml.sax.helpers.DefaultHandler#setDocumentLocator(org.xml.sax.Locator)
   */
  @Override
  public void setDocumentLocator(Locator locator) {
&lt;/pre&gt;
(see &lt;a href="https://stackoverflow.com/questions/5172841/non-javadoc-meaning"&gt;https://stackoverflow.com/questions/5172841/non-javadoc-meaning&lt;/a&gt;)&lt;br&gt;&lt;br&gt;Issue id: WrongCommentType&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongRegion" defaultSeverity="WARNING" displayName="Suspicious Language/Region Combination" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious Language/Region Combination&lt;br&gt;&lt;br&gt;Android uses the letter codes ISO 639-1 for languages, and the letter codes ISO 3166-1 for the region codes. In many cases, the language code and the country where the language is spoken is the same, but it is also often not the case. For example, while 'se' refers to Sweden, where Swedish is spoken, the language code for Swedish is &lt;b&gt;not&lt;/b&gt; &lt;code&gt;se&lt;/code&gt; (which refers to the Northern Sami language), the language code is &lt;code&gt;sv&lt;/code&gt;. And similarly the region code for &lt;code&gt;sv&lt;/code&gt; is El Salvador.&lt;br/&gt;
&lt;br/&gt;
This lint check looks for suspicious language and region combinations, to help catch cases where you've accidentally used the wrong language or region code. Lint knows about the most common regions where a language is spoken, and if a folder combination is not one of these, it is flagged as suspicious.&lt;br/&gt;
&lt;br/&gt;
Note however that it may not be an error: you can theoretically have speakers of any language in any region and want to target that with your resources, so this check is aimed at tracking down likely mistakes, not to enforce a specific set of region and language combinations.&lt;br&gt;&lt;br&gt;Issue id: WrongRegion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSetAndClearCommunicationDevice" defaultSeverity="WARNING" displayName="Clearing communication device" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Clearing communication device&lt;br&gt;&lt;br&gt;After selecting the audio device for communication use cases using &lt;code&gt;setCommunicationDevice(AudioDeviceInfo device)&lt;/code&gt;, the selection is active as long as the requesting application process lives, until &lt;code&gt;clearCommunicationDevice()&lt;/code&gt; is called or until the device is disconnected. It is therefore important to clear the request when a call ends or the requesting activity or service is stopped or destroyed.&lt;br&gt;&lt;br&gt;Issue id: SetAndClearCommunicationDevice&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTranslucentOrientation" defaultSeverity="WARNING" displayName="Mixing screenOrientation and translucency" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mixing screenOrientation and translucency&lt;br&gt;&lt;br&gt;Specifying a fixed screen orientation with a translucent theme isn't supported on apps with &lt;code&gt;targetSdkVersion&lt;/code&gt; O or greater since there can be an another activity visible behind your activity with a conflicting request.&lt;br/&gt;
&lt;br/&gt;
For example, your activity requests landscape and the visible activity behind your translucent activity request portrait. In this case the system can only honor one of the requests and currently prefers to honor the request from non-translucent activities since there is nothing visible behind them.&lt;br/&gt;
&lt;br/&gt;
Devices running platform version O or greater will throw an exception in your app if this state is detected.&lt;br&gt;&lt;br&gt;Issue id: TranslucentOrientation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOpenForTesting" defaultSeverity="ERROR" displayName="Extending API only allowed from tests" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Extending API only allowed from tests&lt;br&gt;&lt;br&gt;Classes or methods annotated with &lt;code&gt;@OpenForTesting&lt;/code&gt; are only allowed to be subclassed or overridden from unit tests.&lt;br&gt;&lt;br&gt;Issue id: OpenForTesting&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidWakeLockTag" defaultSeverity="ERROR" displayName="Invalid Wake Lock Tag" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Wake Lock Tag&lt;br&gt;&lt;br&gt;Wake Lock tags must follow the naming conventions defined in the`PowerManager` documentation.&lt;br&gt;&lt;br&gt;Issue id: InvalidWakeLockTag&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/os/PowerManager.html"&gt;https://developer.android.com/reference/android/os/PowerManager.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResourceCycle" defaultSeverity="ERROR" displayName="Cycle in resource definitions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Cycle in resource definitions&lt;br&gt;&lt;br&gt;There should be no cycles in resource definitions as this can lead to runtime exceptions.&lt;br&gt;&lt;br&gt;Issue id: ResourceCycle&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPublicKeyCredential" defaultSeverity="WARNING" displayName="Creating public key credential" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Creating public key credential&lt;br&gt;&lt;br&gt;Credential Manager API supports creating public key credential (Passkeys) starting Android 9 or higher. Please check for the Android version before calling the method.&lt;br&gt;&lt;br&gt;Issue id: PublicKeyCredential&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintVectorRaster" defaultSeverity="WARNING" displayName="Vector Image Generation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Vector Image Generation&lt;br&gt;&lt;br&gt;Vector icons require API 21 or API 24 depending on used features, but when &lt;code&gt;minSdkVersion&lt;/code&gt; is less than 21 or 24 and Android Gradle plugin 1.4 or higher is used, a vector drawable placed in the &lt;code&gt;drawable&lt;/code&gt; folder is automatically moved to &lt;code&gt;drawable-anydpi-v21&lt;/code&gt; or &lt;code&gt;drawable-anydpi-v24&lt;/code&gt; and bitmap images are generated for different screen resolutions for backwards compatibility.&lt;br/&gt;
&lt;br/&gt;
However, there are some limitations to this raster image generation, and this lint check flags elements and attributes that are not fully supported. You should manually check whether the generated output is acceptable for those older devices.&lt;br&gt;&lt;br&gt;Issue id: VectorRaster&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResAuto" defaultSeverity="ERROR" displayName="Hardcoded Package in Namespace" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardcoded Package in Namespace&lt;br&gt;&lt;br&gt;In Gradle projects, the actual package used in the final APK can vary; for example,you can add a &lt;code&gt;.debug&lt;/code&gt; package suffix in one version and not the other. Therefore, you should &lt;b&gt;not&lt;/b&gt; hardcode the application package in the resource; instead, use the special namespace &lt;code&gt;http://schemas.android.com/apk/res-auto&lt;/code&gt; which will cause the tools to figure out the right namespace for the resource regardless of the actual package used during the build.&lt;br&gt;&lt;br&gt;Issue id: ResAuto&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintChromeOsOnConfigurationChanged" defaultSeverity="WARNING" displayName="Poor performance with APIs inside onConfigurationChanged()" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Poor performance with APIs inside &lt;code&gt;onConfigurationChanged()&lt;/code&gt;&lt;br&gt;&lt;br&gt;When users resize the Android emulator in Android 13 and Chrome OS, an &lt;code&gt;onConfigurationChanged()&lt;/code&gt; API call occurs. If your &lt;code&gt;onConfigurationChanged()&lt;/code&gt; method contains any code that can cause a redraw, your app might take a performance hit on large screens. To fix the issue, ensure your &lt;code&gt;onConfigurationChanged()&lt;/code&gt; method does not contain any calls to UI redraw logic for specific elements.&lt;br&gt;&lt;br&gt;Issue id: ChromeOsOnConfigurationChanged&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintManifestOrder" defaultSeverity="WARNING" displayName="Incorrect order of elements in manifest" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect order of elements in manifest&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;application&gt;&lt;/code&gt; tag should appear after the elements which declare which version you need, which features you need, which libraries you need, and so on. In the past there have been subtle bugs (such as themes not getting applied correctly) when the &lt;code&gt;&amp;lt;application&gt;&lt;/code&gt; tag appears before some of these other elements, so it's best to order your manifest in the logical dependency order.&lt;br&gt;&lt;br&gt;Issue id: ManifestOrder&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseRequiresApi" defaultSeverity="WARNING" displayName="Use @RequiresApi instead of @TargetApi" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use &lt;code&gt;@RequiresApi&lt;/code&gt; instead of &lt;code&gt;@TargetApi&lt;/code&gt;&lt;br&gt;&lt;br&gt;The &lt;code&gt;@TargetApi&lt;/code&gt; annotation only &lt;i&gt;suppresses&lt;/i&gt; API warnings locally. &lt;code&gt;@RequiresApi&lt;/code&gt; on the other hand will propagate the requirement out to any &lt;i&gt;callers&lt;/i&gt; of this API, making sure that they either perform API level checks (using for example &lt;code&gt;SDK_INT&lt;/code&gt;), or defining &lt;code&gt;@RequiresApi&lt;/code&gt; annotations themselves.&lt;br/&gt;
&lt;br/&gt;
(The &lt;code&gt;@TargetApi&lt;/code&gt; annotation predates &lt;code&gt;@RequiresApi&lt;/code&gt;, and was introduced as an early way to &lt;i&gt;suppress&lt;/i&gt; lint API warnings for a particular API level. Accidentally using &lt;code&gt;@TargetApi&lt;/code&gt; can lead to crashes since there is no check that other calls to this method actually check that the call is safe.)&lt;br&gt;&lt;br&gt;Issue id: UseRequiresApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicatePlatformClasses" defaultSeverity="ERROR" displayName="Duplicate Platform Classes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate Platform Classes&lt;br&gt;&lt;br&gt;There are a number of libraries that duplicate not just functionality of the Android platform but using the exact same class names as the ones provided in Android -- for example the apache http classes. This can lead to unexpected crashes.&lt;br/&gt;
&lt;br/&gt;
To solve this, you need to either find a newer version of the library which no longer has this problem, or to repackage the library (and all of its dependencies) using something like the &lt;code&gt;jarjar&lt;/code&gt; tool, or finally, rewriting the code to use different APIs (for example, for http code, consider using &lt;code&gt;HttpUrlConnection&lt;/code&gt; or a library like &lt;code&gt;okhttp&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: DuplicatePlatformClasses&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCheckResult" defaultSeverity="WARNING" displayName="Ignoring results" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Ignoring results&lt;br&gt;&lt;br&gt;Some methods have no side effects, and calling them without doing something with the result is suspicious.&lt;br&gt;&lt;br&gt;Issue id: CheckResult&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingIntentFilterForMediaSearch" defaultSeverity="ERROR" displayName="Missing MEDIA_PLAY_FROM_SEARCH intent-filter" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing MEDIA_PLAY_FROM_SEARCH intent-filter&lt;br&gt;&lt;br&gt;To support voice searches on Android Auto, you should also register an &lt;code&gt;intent-filter&lt;/code&gt; for the action &lt;code&gt;android.media.action.MEDIA_PLAY_FROM_SEARCH&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
To do this, add
&lt;pre&gt;
`&amp;lt;intent-filter&gt;`
    `&amp;lt;action android:name="android.media.action.MEDIA_PLAY_FROM_SEARCH" /&gt;`
`&amp;lt;/intent-filter&gt;`
&lt;/pre&gt;
to your &lt;code&gt;&amp;lt;activity&gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;service&gt;&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: MissingIntentFilterForMediaSearch&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/auto/audio/index.html#support_voice"&gt;https://developer.android.com/training/auto/audio/index.html#support_voice&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppBundleLocaleChanges" defaultSeverity="WARNING" displayName="App Bundle handling of runtime locale changes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;App Bundle handling of runtime locale changes&lt;br&gt;&lt;br&gt;When changing locales at runtime (e.g. to provide an in-app language switcher), the Android App Bundle must be configured to not split by locale or the Play Core library must be used to download additional locales at runtime.&lt;br&gt;&lt;br&gt;Issue id: AppBundleLocaleChanges&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/app-bundle/configure-base#handling_language_changes"&gt;https://developer.android.com/guide/app-bundle/configure-base#handling_language_changes&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStopShip" defaultSeverity="ERROR" displayName="Code contains STOPSHIP marker" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Code contains &lt;code&gt;STOPSHIP&lt;/code&gt; marker&lt;br&gt;&lt;br&gt;Using the comment &lt;code&gt;// STOPSHIP&lt;/code&gt; can be used to flag code that is incomplete but checked in. This comment marker can be used to indicate that the code should not be shipped until the issue is addressed, and lint will look for these. In Gradle projects, this is only checked for non-debug (release) builds.&lt;br/&gt;
&lt;br/&gt;
In Kotlin, the &lt;code&gt;TODO()&lt;/code&gt; method is also treated as a stop ship marker; you can use it to make incomplete code compile, but it will throw an exception at runtime and therefore should be fixed before shipping releases.&lt;br&gt;&lt;br&gt;Issue id: StopShip&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExifInterface" defaultSeverity="WARNING" displayName="Using android.media.ExifInterface" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;android.media.ExifInterface&lt;/code&gt;&lt;br&gt;&lt;br&gt;The &lt;code&gt;android.media.ExifInterface&lt;/code&gt; implementation has some known security bugs in older versions of Android. There is a new implementation available of this library in the support library, which is preferable.&lt;br&gt;&lt;br&gt;Issue id: ExifInterface&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCustomViewStyleable" defaultSeverity="WARNING" displayName="Mismatched Styleable/Custom View Name" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mismatched Styleable/Custom View Name&lt;br&gt;&lt;br&gt;The convention for custom views is to use a &lt;code&gt;declare-styleable&lt;/code&gt; whose name matches the custom view class name. The IDE relies on this convention such that for example code completion can be offered for attributes in a custom view in layout XML resource files.&lt;br/&gt;
&lt;br/&gt;
(Similarly, layout parameter classes should use the suffix &lt;code&gt;_Layout&lt;/code&gt;.)&lt;br&gt;&lt;br&gt;Issue id: CustomViewStyleable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExactAlarm" defaultSeverity="ERROR" displayName="Invalid Usage of Exact Alarms" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Usage of Exact Alarms&lt;br&gt;&lt;br&gt;The &lt;code&gt;USE_EXACT_ALARM&lt;/code&gt; permission is only available when targeting API level 33 and above. Also, note that this permission is only permitted for apps whose core functionality requires precisely-timed actions for user facing features.&lt;br&gt;&lt;br&gt;Issue id: ExactAlarm&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/scheduling/alarms"&gt;https://developer.android.com/training/scheduling/alarms&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingBackupPin" defaultSeverity="WARNING" displayName="Missing Backup Pin" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Backup Pin&lt;br&gt;&lt;br&gt;It is highly recommended to declare a backup &lt;code&gt;&amp;lt;pin&gt;&lt;/code&gt; element. Not having a second pin defined can cause connection failures when the particular site certificate is rotated and the app has not yet been updated.&lt;br&gt;&lt;br&gt;Issue id: MissingBackupPin&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/features/security-config.html"&gt;https://developer.android.com/preview/features/security-config.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAnnotateVersionCheck" defaultSeverity="WARNING" displayName="Annotate SDK_INT checks" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Annotate SDK_INT checks&lt;br&gt;&lt;br&gt;Methods which perform &lt;code&gt;SDK_INT&lt;/code&gt; version checks (or field constants which reflect the result of a version check) in libraries should be annotated with &lt;code&gt;@ChecksSdkIntAtLeast&lt;/code&gt;. This makes it possible for lint to correctly check calls into the library later to correctly understand that problematic code which is wrapped within a call into this library is safe after all.&lt;br&gt;&lt;br&gt;Issue id: AnnotateVersionCheck&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintReturnThis" defaultSeverity="ERROR" displayName="Method must return this" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Method must return &lt;code&gt;this&lt;/code&gt;&lt;br&gt;&lt;br&gt;Methods annotated with &lt;code&gt;@ReturnThis&lt;/code&gt; (usually in the super method that this method is overriding) should also &lt;code&gt;return this&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: ReturnThis&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintParcelCreator" defaultSeverity="ERROR" displayName="Missing Parcelable CREATOR field" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Parcelable &lt;code&gt;CREATOR&lt;/code&gt; field&lt;br&gt;&lt;br&gt;According to the &lt;code&gt;Parcelable&lt;/code&gt; interface documentation, "Classes implementing the Parcelable interface must also have a static field called &lt;code&gt;CREATOR&lt;/code&gt;, which is an object implementing the &lt;code&gt;Parcelable.Creator&lt;/code&gt; interface."&lt;br&gt;&lt;br&gt;Issue id: ParcelCreator&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/os/Parcelable.html"&gt;https://developer.android.com/reference/android/os/Parcelable.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSimilarGradleDependency" defaultSeverity="WEAK WARNING" displayName="Multiple Versions Gradle Dependency" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Multiple Versions Gradle Dependency&lt;br&gt;&lt;br&gt;This detector looks for usages of libraries when name and group are the same but versions are different. Using multiple versions in big project is fine, and there are cases where you deliberately want to stick with such approach. However, you may simply not be aware that this situation happens, and that is what this lint check helps find.&lt;br&gt;&lt;br&gt;Issue id: SimilarGradleDependency&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPrivateResource" defaultSeverity="WARNING" displayName="Using private resources" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using private resources&lt;br&gt;&lt;br&gt;Private resources should not be referenced; the may not be present everywhere, and even where they are they may disappear without notice.&lt;br/&gt;
&lt;br/&gt;
To fix this, copy the resource into your own project instead.&lt;br&gt;&lt;br&gt;Issue id: PrivateResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRequiresFeature" defaultSeverity="WARNING" displayName="Requires Feature" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Requires Feature&lt;br&gt;&lt;br&gt;Some APIs require optional features to be present. This check makes sure that calls to these APIs are surrounded by a check which enforces this.&lt;br&gt;&lt;br&gt;Issue id: RequiresFeature&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearableConfigurationAction" defaultSeverity="WARNING" displayName="Wear configuration action metadata must match an activity" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wear configuration action metadata must match an activity&lt;br&gt;&lt;br&gt;Only when a watch face service defines &lt;code&gt;wearableConfigurationAction&lt;/code&gt; metadata, with the value &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt;, there should be an activity in the same package, which has an intent filter for &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt; (with &lt;code&gt;com.google.android.wearable.watchface.category.WEARABLE_CONFIGURATION&lt;/code&gt; if &lt;code&gt;minSdkVersion&lt;/code&gt; is less than 30).&lt;br&gt;&lt;br&gt;Issue id: WearableConfigurationAction&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/watch-faces/configuration"&gt;https://developer.android.com/training/wearables/watch-faces/configuration&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEditedTargetSdkVersion" defaultSeverity="ERROR" displayName="Manually Edited TargetSdkVersion" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Manually Edited TargetSdkVersion&lt;br&gt;&lt;br&gt;Updating the &lt;code&gt;targetSdkVersion&lt;/code&gt; of an app is seemingly easy: just increment the &lt;code&gt;targetSdkVersion&lt;/code&gt; number in the manifest file!&lt;br/&gt;
&lt;br/&gt;
But that's not actually safe. The &lt;code&gt;targetSdkVersion&lt;/code&gt; controls a wide range of behaviors that change from release to release, and to update, you should carefully consult the documentation to see what has changed, how your app may need to adjust, and then of course, carefully test everything.&lt;br/&gt;
&lt;br/&gt;
In new versions of Android Studio, there is a special migration assistant, available from the tools menu (and as a quickfix from this lint warning) which analyzes your specific app and filters the set of applicable migration steps to those needed for your app.&lt;br/&gt;
&lt;br/&gt;
This lint check does something very simple: it just detects whether it looks like you've manually edited the targetSdkVersion field in a build.gradle file. Obviously, as part of doing the above careful steps, you may end up editing the value, which would trigger the check -- and it's safe to ignore it; this lint check &lt;i&gt;only&lt;/i&gt; runs in the IDE, not from the command line; it's sole purpose to bring &lt;i&gt;awareness&lt;/i&gt; to the (many) developers who haven't been aware of this issue and have just bumped the targetSdkVersion, recompiled, and uploaded their updated app to the Google Play Store, sometimes leading to crashes or other problems on newer devices.&lt;br&gt;&lt;br&gt;Issue id: EditedTargetSdkVersion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleDynamicVersion" defaultSeverity="WARNING" displayName="Gradle Dynamic Version" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Gradle Dynamic Version&lt;br&gt;&lt;br&gt;Using &lt;code&gt;+&lt;/code&gt; in dependencies lets you automatically pick up the latest available version rather than a specific, named version. However, this is not recommended; your builds are not repeatable; you may have tested with a slightly different version than what the build server used. (Using a dynamic version as the major version number is more problematic than using it in the minor version position.)&lt;br&gt;&lt;br&gt;Issue id: GradleDynamicVersion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDefaultLocale" defaultSeverity="WARNING" displayName="Implied default locale in case conversion" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implied default locale in case conversion&lt;br&gt;&lt;br&gt;Calling &lt;code&gt;String#toLowerCase()&lt;/code&gt; or &lt;code&gt;#toUpperCase()&lt;/code&gt; &lt;b&gt;without specifying an explicit locale&lt;/b&gt; is a common source of bugs. The reason for that is that those methods will use the current locale on the user's device, and even though the code appears to work correctly when you are developing the app, it will fail in some locales. For example, in the Turkish locale, the uppercase replacement for &lt;code&gt;i&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; &lt;code&gt;I&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If you want the methods to just perform ASCII replacement, for example to convert an enum name, call &lt;code&gt;String#toUpperCase(Locale.ROOT)&lt;/code&gt; instead. If you really want to use the current locale, call &lt;code&gt;String#toUpperCase(Locale.getDefault())&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: DefaultLocale&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/util/Locale.html#default_locale"&gt;https://developer.android.com/reference/java/util/Locale.html#default_locale&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingSuperCall" defaultSeverity="ERROR" displayName="Missing Super Call" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Super Call&lt;br&gt;&lt;br&gt;Some methods, such as &lt;code&gt;View#onDetachedFromWindow&lt;/code&gt;, require that you also call the super implementation as part of your method.&lt;br&gt;&lt;br&gt;Issue id: MissingSuperCall&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEllipsizeMaxLines" defaultSeverity="ERROR" displayName="Combining Ellipsize and Maxlines" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Combining Ellipsize and Maxlines&lt;br&gt;&lt;br&gt;Combining &lt;code&gt;ellipsize&lt;/code&gt; and &lt;code&gt;maxLines=1&lt;/code&gt; can lead to crashes on some devices. Earlier versions of lint recommended replacing &lt;code&gt;singleLine=true&lt;/code&gt; with &lt;code&gt;maxLines=1&lt;/code&gt; but that should not be done when using &lt;code&gt;ellipsize&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: EllipsizeMaxLines&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/issues/36950033"&gt;https://issuetracker.google.com/issues/36950033&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIllegalResourceRef" defaultSeverity="WARNING" displayName="Name and version must be integer or string, not resource" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Name and version must be integer or string, not resource&lt;br&gt;&lt;br&gt;For the &lt;code&gt;versionCode&lt;/code&gt; attribute, you have to specify an actual integer literal; you cannot use an indirection with a &lt;code&gt;@dimen/name&lt;/code&gt; resource. Similarly, the &lt;code&gt;versionName&lt;/code&gt; attribute should be an actual string, not a string resource url.&lt;br&gt;&lt;br&gt;Issue id: IllegalResourceRef&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMinSdkTooLow" defaultSeverity="WARNING" displayName="API Version Too Low" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;API Version Too Low&lt;br&gt;&lt;br&gt;The value of the &lt;code&gt;minSdkVersion&lt;/code&gt; property is too low and can be incremented without noticeably reducing the number of supported devices.&lt;br&gt;&lt;br&gt;Issue id: MinSdkTooLow&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCredentialManagerMisuse" defaultSeverity="WARNING" displayName="Misuse of Credential Manager API" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Misuse of Credential Manager API&lt;br&gt;&lt;br&gt;When calling &lt;code&gt;CredentialManager.getCredential&lt;/code&gt; or &lt;code&gt;CredentialManager.getCredentialAsync&lt;/code&gt;, you should handle &lt;code&gt;NoCredentialException&lt;/code&gt; somewhere in your project.&lt;br&gt;&lt;br&gt;Issue id: CredentialManagerMisuse&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/identity/sign-in/credential-manager#handle-exceptions"&gt;https://developer.android.com/identity/sign-in/credential-manager#handle-exceptions&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppIndexingService" defaultSeverity="WARNING" displayName="App Indexing Background Services" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;App Indexing Background Services&lt;br&gt;&lt;br&gt;Apps targeting Android 8.0 or higher can no longer rely on background services while listening for updates to the on-device index. Use a &lt;code&gt;BroadcastReceiver&lt;/code&gt; for the &lt;code&gt;UPDATE_INDEX&lt;/code&gt; intent to continue supporting indexing in your app.&lt;br&gt;&lt;br&gt;Issue id: AppIndexingService&lt;br&gt;&lt;br&gt;&lt;a href="https://firebase.google.com/docs/app-indexing/android/personal-content#add-a-broadcast-receiver-to-your-app"&gt;https://firebase.google.com/docs/app-indexing/android/personal-content#add-a-broadcast-receiver-to-your-app&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLeanbackUsesWifi" defaultSeverity="WARNING" displayName="Using android.hardware.wifi on TV" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using android.hardware.wifi on TV&lt;br&gt;&lt;br&gt;WiFi is not required for Android TV and many devices connect to the internet via alternative methods e.g. Ethernet.&lt;br/&gt;
&lt;br/&gt;
If your app is not focused specifically on WiFi functionality and only wishes to connect to the internet, please modify your Manifest to contain: &lt;code&gt;&amp;lt;uses-feature android:name="android.hardware.wifi" android:required="false" /&gt;&lt;/code&gt;&lt;br/&gt;
&lt;br/&gt;
Un-metered or non-roaming connections can be detected in software using &lt;code&gt;NetworkCapabilities#NET_CAPABILITY_NOT_METERED&lt;/code&gt; and &lt;code&gt;NetworkCapabilities#NET_CAPABILITY_NOT_ROAMING.&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: LeanbackUsesWifi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateActivity" defaultSeverity="ERROR" displayName="Activity registered more than once" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Activity registered more than once&lt;br&gt;&lt;br&gt;An activity should only be registered once in the manifest. If it is accidentally registered more than once, then subtle errors can occur, since attribute declarations from the two elements are not merged, so you may accidentally remove previous declarations.&lt;br&gt;&lt;br&gt;Issue id: DuplicateActivity&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintQueryPermissionsNeeded" defaultSeverity="WARNING" displayName="Using APIs affected by query permissions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using APIs affected by query permissions&lt;br&gt;&lt;br&gt;Apps that target Android 11 cannot query or interact with other installed apps by default. If you need to query or interact with other installed apps, you may need to add a &lt;code&gt;&amp;lt;queries&gt;&lt;/code&gt; declaration in your manifest.&lt;br/&gt;
&lt;br/&gt;
As a corollary, the methods &lt;code&gt;PackageManager#getInstalledPackages&lt;/code&gt; and &lt;code&gt;PackageManager#getInstalledApplications&lt;/code&gt; will no longer return information about all installed apps. To query specific apps or types of apps, you can use methods like &lt;code&gt;PackageManager#getPackageInfo&lt;/code&gt; or &lt;code&gt;PackageManager#queryIntentActivities&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: QueryPermissionsNeeded&lt;br&gt;&lt;br&gt;&lt;a href="https://g.co/dev/packagevisibility"&gt;https://g.co/dev/packagevisibility&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNoOp" defaultSeverity="WARNING" displayName="NoOp Code" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;NoOp Code&lt;br&gt;&lt;br&gt;This check looks for code which looks like it's a no-op -- usually leftover expressions from interactive debugging, but in some cases bugs where you had intended to do something with the expression such as assign it to a field.&lt;br&gt;&lt;br&gt;Issue id: NoOp&lt;br&gt;&lt;br&gt;Available options:&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;pure-getters&lt;/b&gt; (default is false):&lt;br/&gt;
Whether to assume methods with getter-names have no side effects.&lt;br/&gt;
&lt;br/&gt;
Getter methods (where names start with &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;is&lt;/code&gt;, and have non-void return types, and no arguments) should not have side effects. With this option turned on, lint will assume that is the case and will list any getter calls whose results are ignored as suspicious code.&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="NoOp"&gt;
        &amp;lt;option name="pure-getters" value="false" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateUsesFeature" defaultSeverity="WARNING" displayName="Feature declared more than once" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Feature declared more than once&lt;br&gt;&lt;br&gt;A given feature should only be declared once in the manifest.&lt;br&gt;&lt;br&gt;Issue id: DuplicateUsesFeature&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintScheduleExactAlarm" defaultSeverity="ERROR" displayName="Scheduling Exact Alarms Without Required Permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Scheduling Exact Alarms Without Required Permission&lt;br&gt;&lt;br&gt;Applications looking to schedule exact alarms should ensure that the &lt;code&gt;SCHEDULE_EXACT_ALARM&lt;/code&gt; permission is granted by calling the &lt;code&gt;AlarmManager#canScheduleExactAlarms&lt;/code&gt; API before attempting to set an exact alarm. If the permission is not granted to your application, please consider requesting it from the user by starting the &lt;code&gt;ACTION_REQUEST_SCHEDULE_EXACT_ALARM&lt;/code&gt; intent or gracefully falling back to another option.&lt;br&gt;&lt;br&gt;Issue id: ScheduleExactAlarm&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/scheduling/alarms#exact"&gt;https://developer.android.com/training/scheduling/alarms#exact&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSelectedPhotoAccess" defaultSeverity="WARNING" displayName="Behavior change when requesting photo library access" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Behavior change when requesting photo library access&lt;br&gt;&lt;br&gt;Selected Photo Access is a new ability for users to share partial access to their photo library when apps request access to their device storage on Android 14+.&lt;br/&gt;
&lt;br/&gt;
Instead of letting the system manage the selection lifecycle, we recommend you adapt your app to handle partial access to the photo library.&lt;br&gt;&lt;br&gt;Issue id: SelectedPhotoAccess&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/about/versions/14/changes/partial-photo-video-access"&gt;https://developer.android.com/about/versions/14/changes/partial-photo-video-access&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAndroidGradlePluginVersion" defaultSeverity="WARNING" displayName="Obsolete Android Gradle Plugin Version" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete Android Gradle Plugin Version&lt;br&gt;&lt;br&gt;This detector looks for usage of the Android Gradle Plugin where the version you are using is not the current stable release. Using older versions is fine, and there are cases where you deliberately want to stick with an older version. However, you may simply not be aware that a more recent version is available, and that is what this lint check helps find.&lt;br&gt;&lt;br&gt;Issue id: AndroidGradlePluginVersion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUniquePermission" defaultSeverity="ERROR" displayName="Permission names are not unique" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission names are not unique&lt;br&gt;&lt;br&gt;The unqualified names or your permissions must be unique. The reason for this is that at build time, the &lt;code&gt;aapt&lt;/code&gt; tool will generate a class named &lt;code&gt;Manifest&lt;/code&gt; which contains a field for each of your permissions. These fields are named using your permission unqualified names (i.e. the name portion after the last dot).&lt;br/&gt;
&lt;br/&gt;
If more than one permission maps to the same field name, that field will arbitrarily name just one of them.&lt;br&gt;&lt;br&gt;Issue id: UniquePermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingTranslation" defaultSeverity="ERROR" displayName="Incomplete translation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incomplete translation&lt;br&gt;&lt;br&gt;If an application has more than one locale, then all the strings declared in one language should also be translated in all other languages.&lt;br/&gt;
&lt;br/&gt;
If the string should &lt;b&gt;not&lt;/b&gt; be translated, you can add the attribute &lt;code&gt;translatable="false"&lt;/code&gt; on the &lt;code&gt;&amp;lt;string&gt;&lt;/code&gt; element, or you can define all your non-translatable strings in a resource file called &lt;code&gt;donottranslate.xml&lt;/code&gt;. Or, you can ignore the issue with a &lt;code&gt;tools:ignore="MissingTranslation"&lt;/code&gt; attribute.&lt;br/&gt;
&lt;br/&gt;
You can tell lint (and other tools) which language is the default language in your &lt;code&gt;res/values/&lt;/code&gt; folder by specifying &lt;code&gt;tools:locale="languageCode"&lt;/code&gt; for the root &lt;code&gt;&amp;lt;resources&gt;&lt;/code&gt; element in your resource file. (The &lt;code&gt;tools&lt;/code&gt; prefix refers to the namespace declaration &lt;code&gt;http://schemas.android.com/tools&lt;/code&gt;.)&lt;br&gt;&lt;br&gt;Issue id: MissingTranslation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIncompatibleMediaBrowserServiceCompatVersion" defaultSeverity="WARNING" displayName="Obsolete version of MediaBrowserServiceCompat" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete version of MediaBrowserServiceCompat&lt;br&gt;&lt;br&gt;&lt;code&gt;MediaBrowserServiceCompat&lt;/code&gt; from version 23.2.0 to 23.4.0 of the Support v4 Library used private APIs and will not be compatible with future versions of Android beyond Android N. Please upgrade to version 24.0.0 or higher of the Support Library.&lt;br&gt;&lt;br&gt;Issue id: IncompatibleMediaBrowserServiceCompatVersion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCoreLibDesugaringV1" defaultSeverity="ERROR" displayName="Android 15 requires desugar_jdk_libs 2.+" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Android 15 requires &lt;code&gt;desugar_jdk_libs&lt;/code&gt; 2.+&lt;br&gt;&lt;br&gt;Core library desugaring with &lt;code&gt;compileSdk&lt;/code&gt; 35 or later (Android 15) requires using version 2.+ of the core library desugaring libraries. The code may compile successfully, but can crash at runtime.&lt;br&gt;&lt;br&gt;Issue id: CoreLibDesugaringV1&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNetworkSecurityConfig" defaultSeverity="ERROR" displayName="Valid Network Security Config File" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Valid Network Security Config File&lt;br&gt;&lt;br&gt;Ensures that a &lt;code&gt;&amp;lt;network-security-config&gt;&lt;/code&gt; file, which is pointed to by an &lt;code&gt;android:networkSecurityConfig&lt;/code&gt; attribute in the manifest file, is valid&lt;br&gt;&lt;br&gt;Issue id: NetworkSecurityConfig&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/features/security-config.html"&gt;https://developer.android.com/preview/features/security-config.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFileEndsWithExt" defaultSeverity="WARNING" displayName="File endsWith on file extensions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;File endsWith on file extensions&lt;br&gt;&lt;br&gt;The Kotlin extension method &lt;code&gt;File.endsWith(suffix)&lt;/code&gt; checks whole path components, not just string suffixes. This means that &lt;code&gt;File("foo.txt").endsWith(".txt")&lt;/code&gt; will return false. Instead you might have intended &lt;code&gt;file.path.endsWith&lt;/code&gt; or &lt;code&gt;file.extension.equals&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: FileEndsWithExt&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintParcelClassLoader" defaultSeverity="WARNING" displayName="Default Parcel Class Loader" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Default Parcel Class Loader&lt;br&gt;&lt;br&gt;The documentation for &lt;code&gt;Parcel#readParcelable(ClassLoader)&lt;/code&gt; (and its variations) says that you can pass in &lt;code&gt;null&lt;/code&gt; to pick up the default class loader. However, that ClassLoader is a system class loader and is not able to find classes in your own application.&lt;br/&gt;
&lt;br/&gt;
If you are writing your own classes into the &lt;code&gt;Parcel&lt;/code&gt; (not just SDK classes like &lt;code&gt;String&lt;/code&gt; and so on), then you should supply a &lt;code&gt;ClassLoader&lt;/code&gt; for your application instead; a simple way to obtain one is to just call &lt;code&gt;getClass().getClassLoader()&lt;/code&gt; from your own class.&lt;br&gt;&lt;br&gt;Issue id: ParcelClassLoader&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/os/Parcel.html"&gt;https://developer.android.com/reference/android/os/Parcel.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPictureInPictureIssue" defaultSeverity="WARNING" displayName="Picture In Picture best practices not followed" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Picture In Picture best practices not followed&lt;br&gt;&lt;br&gt;Starting in Android 12, the recommended approach for enabling picture-in-picture (PiP) has changed. If your app does not use the new approach, your app's transition animations will be of poor quality compared to other apps. The new approach requires calling &lt;code&gt;setAutoEnterEnabled(true)&lt;/code&gt; and &lt;code&gt;setSourceRectHint(...)&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: PictureInPictureIssue&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/develop/ui/views/picture-in-picture#smoother-transition"&gt;https://developer.android.com/develop/ui/views/picture-in-picture#smoother-transition&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintVectorDrawableCompat" defaultSeverity="ERROR" displayName="Using VectorDrawableCompat" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using VectorDrawableCompat&lt;br&gt;&lt;br&gt;To use VectorDrawableCompat, you need to make two modifications to your project. First, set &lt;code&gt;android.defaultConfig.vectorDrawables.useSupportLibrary = true&lt;/code&gt; in your &lt;code&gt;build.gradle&lt;/code&gt; file, and second, use &lt;code&gt;app:srcCompat&lt;/code&gt; instead of &lt;code&gt;android:src&lt;/code&gt; to refer to vector drawables.&lt;br&gt;&lt;br&gt;Issue id: VectorDrawableCompat&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/graphics/vector-drawable-resources"&gt;https://developer.android.com/guide/topics/graphics/vector-drawable-resources&lt;/a&gt;&lt;br&gt;&lt;a href="https://medium.com/androiddevelopers/using-vector-assets-in-android-apps-4318fd662eb9"&gt;https://medium.com/androiddevelopers/using-vector-assets-in-android-apps-4318fd662eb9&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateIds" defaultSeverity="ERROR" displayName="Duplicate ids within a single layout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate ids within a single layout&lt;br&gt;&lt;br&gt;Within a layout, id's should be unique since otherwise &lt;code&gt;findViewById()&lt;/code&gt; can return an unexpected view.&lt;br&gt;&lt;br&gt;Issue id: DuplicateIds&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCredManMissingDal" defaultSeverity="ERROR" displayName="Missing Digital Asset Link for Credential Manager" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Digital Asset Link for Credential Manager&lt;br&gt;&lt;br&gt;When using password sign-in through Credential Manager, an asset statements string resource file that includes the &lt;code&gt;assetlinks.json&lt;/code&gt; files to load must be declared in the manifest using a &lt;code&gt;&amp;lt;meta-data&gt;&lt;/code&gt; element.&lt;br&gt;&lt;br&gt;Issue id: CredManMissingDal&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/identity/sign-in/credential-manager#add-support-dal"&gt;https://developer.android.com/identity/sign-in/credential-manager#add-support-dal&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRemoteViewLayout" defaultSeverity="ERROR" displayName="Unsupported View in RemoteView" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsupported View in RemoteView&lt;br&gt;&lt;br&gt;In a &lt;code&gt;RemoteView&lt;/code&gt;, only some layouts and views are allowed.&lt;br&gt;&lt;br&gt;Issue id: RemoteViewLayout&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/widget/RemoteViews"&gt;https://developer.android.com/reference/android/widget/RemoteViews&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWebViewApiAvailability" defaultSeverity="WARNING" displayName="WebView API Availability" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WebView API Availability&lt;br&gt;&lt;br&gt;The &lt;code&gt;androidx.webkit&lt;/code&gt; library is a static library you can add to your Android application allowing you to use new APIs on older platform versions, targeting more devices.&lt;br&gt;&lt;br&gt;Issue id: WebViewApiAvailability&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/androidx/webkit/package-summary"&gt;https://developer.android.com/reference/androidx/webkit/package-summary&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBuildListAdds" defaultSeverity="WARNING" displayName="Missing add call in buildList" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;add&lt;/code&gt; call in &lt;code&gt;buildList&lt;/code&gt;&lt;br&gt;&lt;br&gt;The &lt;code&gt;buildList { }&lt;/code&gt; standard library function is a convenient way to build lists, but you need to actually call &lt;code&gt;add&lt;/code&gt; on the items.&lt;br&gt;&lt;br&gt;Issue id: BuildListAdds&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUniqueConstants" defaultSeverity="ERROR" displayName="Overlapping Enumeration Constants" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Overlapping Enumeration Constants&lt;br&gt;&lt;br&gt;The &lt;code&gt;@IntDef&lt;/code&gt; annotation allows you to create a light-weight "enum" or type definition. However, it's possible to accidentally specify the same value for two or more of the values, which can lead to hard-to-detect bugs. This check looks for this scenario and flags any repeated constants.&lt;br/&gt;
&lt;br/&gt;
In some cases, the repeated constant is intentional (for example, renaming a constant to a more intuitive name, and leaving the old name in place for compatibility purposes).  In that case, simply suppress this check by adding a &lt;code&gt;@SuppressLint("UniqueConstants")&lt;/code&gt; annotation.&lt;br&gt;&lt;br&gt;Issue id: UniqueConstants&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPermissionImpliesUnsupportedHardware" defaultSeverity="WARNING" displayName="Permission Implies Unsupported Hardware" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission Implies Unsupported Hardware&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-permission&gt;&lt;/code&gt; element should not require a permission that implies an unsupported TV hardware feature. Google Play assumes that certain hardware related permissions indicate that the underlying hardware features are required by default. To fix the issue, consider declaring the corresponding &lt;code&gt;uses-feature&lt;/code&gt; element with &lt;code&gt;required="false"&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: PermissionImpliesUnsupportedHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions"&gt;https://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRequiresWindowSdk" defaultSeverity="ERROR" displayName="API requires a WindowSdkExtensions.extensionVersion check" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;API requires a &lt;code&gt;WindowSdkExtensions.extensionVersion&lt;/code&gt; check&lt;br&gt;&lt;br&gt;Some methods in the window library require explicit checks of the &lt;code&gt;extensionVersion&lt;/code&gt; level:
&lt;pre&gt;
if (WindowSdkExtensions.getInstance().extensionVersion &gt;= n) {
    val supportedPostures = windowInfoTracker.supportedPostures
    ...
&lt;/pre&gt;
This lint check looks for scenarios where you're calling these methods without checking the extension version level, or annotating the calling method with a sufficient &lt;code&gt;@RequiresWindowSdkExtension&lt;/code&gt; annotation.&lt;br/&gt;
&lt;br/&gt;
(This lint check does not tackle more advanced ways of version checks, such as extracting the checks into utility methods or constants. Use a direct &lt;code&gt;if&lt;/code&gt; check as shown above.)&lt;br&gt;&lt;br&gt;Issue id: RequiresWindowSdk&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingConstraints" defaultSeverity="ERROR" displayName="Missing Constraints in ConstraintLayout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Constraints in ConstraintLayout&lt;br&gt;&lt;br&gt;The layout editor allows you to place widgets anywhere on the canvas, and it records the current position with designtime attributes (such as &lt;code&gt;layout_editor_absoluteX&lt;/code&gt;). These attributes are &lt;b&gt;not&lt;/b&gt; applied at runtime, so if you push your layout on a device, the widgets may appear in a different location than shown in the editor. To fix this, make sure a widget has both horizontal and vertical constraints by dragging from the edge connections.&lt;br&gt;&lt;br&gt;Issue id: MissingConstraints&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSwitchIntDef" defaultSeverity="WARNING" displayName="Missing @IntDef in Switch" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing @IntDef in Switch&lt;br&gt;&lt;br&gt;This check warns if a &lt;code&gt;switch&lt;/code&gt; statement does not explicitly include all the values declared by the typedef &lt;code&gt;@IntDef&lt;/code&gt; declaration.&lt;br&gt;&lt;br&gt;Issue id: SwitchIntDef&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOnClick" defaultSeverity="ERROR" displayName="onClick method does not exist" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;onClick&lt;/code&gt; method does not exist&lt;br&gt;&lt;br&gt;The &lt;code&gt;onClick&lt;/code&gt; attribute value should be the name of a method in this View's context to invoke when the view is clicked. This name must correspond to a public method that takes exactly one parameter of type &lt;code&gt;View&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Must be a string value, using '\;' to escape characters such as '\n' or '\uxxxx' for a unicode character.&lt;br&gt;&lt;br&gt;Issue id: OnClick&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMultipleUsesSdk" defaultSeverity="ERROR" displayName="Multiple &lt;uses-sdk&gt; elements in the manifest" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Multiple &lt;code&gt;&amp;lt;uses-sdk&gt;&lt;/code&gt; elements in the manifest&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-sdk&gt;&lt;/code&gt; element should appear just once; the tools will &lt;b&gt;not&lt;/b&gt; merge the contents of all the elements so if you split up the attributes across multiple elements, only one of them will take effect. To fix this, just merge all the attributes from the various elements into a single &amp;lt;uses-sdk&gt; element.&lt;br&gt;&lt;br&gt;Issue id: MultipleUsesSdk&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html"&gt;https://developer.android.com/guide/topics/manifest/uses-sdk-element.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInnerclassSeparator" defaultSeverity="WARNING" displayName="Inner classes should use $ rather than ." enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Inner classes should use &lt;code&gt;$&lt;/code&gt; rather than &lt;code&gt;.&lt;/code&gt;&lt;br&gt;&lt;br&gt;When you reference an inner class in a manifest file, you must use '$' instead of '.' as the separator character, i.e. Outer$Inner instead of Outer.Inner.&lt;br/&gt;
&lt;br/&gt;
(If you get this warning for a class which is not actually an inner class, it's because you are using uppercase characters in your package name, which is not conventional.)&lt;br&gt;&lt;br&gt;Issue id: InnerclassSeparator&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingLeanbackSupport" defaultSeverity="ERROR" displayName="Missing Leanback Support" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Leanback Support&lt;br&gt;&lt;br&gt;The manifest should declare the use of the Leanback user interface required by Android TV.&lt;br/&gt;
&lt;br/&gt;
To fix this, add
&lt;pre&gt;
`&amp;lt;uses-feature android:name="android.software.leanback"
               android:required="false" /&gt;`
&lt;/pre&gt;
to your manifest.&lt;br&gt;&lt;br&gt;Issue id: MissingLeanbackSupport&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/tv/start/start.html#leanback-req"&gt;https://developer.android.com/training/tv/start/start.html#leanback-req&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppCompatCustomView" defaultSeverity="ERROR" displayName="Appcompat Custom Widgets" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Appcompat Custom Widgets&lt;br&gt;&lt;br&gt;In order to support features such as tinting, the appcompat library will automatically load special appcompat replacements for the builtin widgets. However, this does not work for your own custom views.&lt;br/&gt;
&lt;br/&gt;
Instead of extending the &lt;code&gt;android.widget&lt;/code&gt; classes directly, you should instead extend one of the delegate classes in &lt;code&gt;androidx.appcompat.widget.AppCompatTextView&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AppCompatCustomView&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingQuantity" defaultSeverity="ERROR" displayName="Missing quantity translation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing quantity translation&lt;br&gt;&lt;br&gt;Different languages have different rules for grammatical agreement with quantity. In English, for example, the quantity 1 is a special case. We write "1 book", but for any other quantity we'd write "n books". This distinction between singular and plural is very common, but other languages make finer distinctions.&lt;br/&gt;
&lt;br/&gt;
This lint check looks at each translation of a &lt;code&gt;&amp;lt;plural&gt;&lt;/code&gt; and makes sure that all the quantity strings considered by the given language are provided by this translation.&lt;br/&gt;
&lt;br/&gt;
For example, an English translation must provide a string for &lt;code&gt;quantity="one"&lt;/code&gt;. Similarly, a Czech translation must provide a string for &lt;code&gt;quantity="few"&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: MissingQuantity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html#Plurals"&gt;https://developer.android.com/guide/topics/resources/string-resource.html#Plurals&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeviceAdmin" defaultSeverity="WARNING" displayName="Malformed Device Admin" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Malformed Device Admin&lt;br&gt;&lt;br&gt;If you register a broadcast receiver which acts as a device admin, you must also register an &lt;code&gt;&amp;lt;intent-filter&gt;&lt;/code&gt; for the action &lt;code&gt;android.app.action.DEVICE_ADMIN_ENABLED&lt;/code&gt;, without any &lt;code&gt;&amp;lt;data&gt;&lt;/code&gt;, such that the device admin can be activated/deactivated.&lt;br/&gt;
&lt;br/&gt;
To do this, add
&lt;pre&gt;
`&amp;lt;intent-filter&gt;`
    `&amp;lt;action android:name="android.app.action.DEVICE_ADMIN_ENABLED" /&gt;`
`&amp;lt;/intent-filter&gt;`
&lt;/pre&gt;
to your &lt;code&gt;&amp;lt;receiver&gt;&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: DeviceAdmin&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintManifestResource" defaultSeverity="ERROR" displayName="Manifest Resource References" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Manifest Resource References&lt;br&gt;&lt;br&gt;Elements in the manifest can reference resources, but those resources cannot vary across configurations (except as a special case, by version, and except for a few specific package attributes such as the application title and icon).&lt;br&gt;&lt;br&gt;Issue id: ManifestResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongSdkInt" defaultSeverity="ERROR" displayName="Mismatched SDK_INT or SDK_INT_FULL" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mismatched SDK_INT or SDK_INT_FULL&lt;br&gt;&lt;br&gt;The &lt;code&gt;SDK_INT&lt;/code&gt; constant can be used to check what the current API level is. The &lt;code&gt;SDK_INT_FULL&lt;/code&gt; constant also contains this information, but it also carries additional information about minor versions between major releases, and cannot be compared directly with the normal API levels.&lt;br/&gt;
&lt;br/&gt;
You should typically compare &lt;code&gt;SDK_INT&lt;/code&gt; with the constants in &lt;code&gt;Build.VERSION_CODES&lt;/code&gt;, and &lt;code&gt;SDK_INT_FULL&lt;/code&gt; with the constants in &lt;code&gt;Build.VERSION_CODES_FULL&lt;/code&gt;. This lint check flags suspicious combinations of these comparisons.&lt;br&gt;&lt;br&gt;Issue id: WrongSdkInt&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintChildInNonViewGroup" defaultSeverity="ERROR" displayName="Only view groups can have children" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Only view groups can have children&lt;br&gt;&lt;br&gt;Only classes inheriting from &lt;code&gt;ViewGroup&lt;/code&gt; can have children.&lt;br&gt;&lt;br&gt;Issue id: ChildInNonViewGroup&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidAnalyticsName" defaultSeverity="ERROR" displayName="Invalid Analytics Name" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Analytics Name&lt;br&gt;&lt;br&gt;Event names and parameters must follow the naming conventions defined in the`FirebaseAnalytics#logEvent()` documentation.&lt;br&gt;&lt;br&gt;Issue id: InvalidAnalyticsName&lt;br&gt;&lt;br&gt;&lt;a href="https://firebase.google.com/docs/reference/android/com/google/firebase/analytics/FirebaseAnalytics#logEvent(java.lang.String,%20android.os.Bundle)"&gt;https://firebase.google.com/docs/reference/android/com/google/firebase/analytics/FirebaseAnalytics#logEvent(java.lang.String,%20android.os.Bundle)&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSimpleDateFormat" defaultSeverity="WARNING" displayName="Implied locale in date format" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implied locale in date format&lt;br&gt;&lt;br&gt;Almost all callers should use &lt;code&gt;getDateInstance()&lt;/code&gt;, &lt;code&gt;getDateTimeInstance()&lt;/code&gt;, or &lt;code&gt;getTimeInstance()&lt;/code&gt; to get a ready-made instance of SimpleDateFormat suitable for the user's locale. The main reason you'd create an instance this class directly is because you need to format/parse a specific machine-readable format, in which case you almost certainly want to explicitly ask for US to ensure that you get ASCII digits (rather than, say, Arabic digits).&lt;br/&gt;
&lt;br/&gt;
Therefore, you should either use the form of the SimpleDateFormat constructor where you pass in an explicit locale, such as Locale.US, or use one of the get instance methods, or suppress this error if really know what you are doing.&lt;br&gt;&lt;br&gt;Issue id: SimpleDateFormat&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/text/SimpleDateFormat.html"&gt;https://developer.android.com/reference/java/text/SimpleDateFormat.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintProtectedPermissions" defaultSeverity="ERROR" displayName="Using system app permission" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using system app permission&lt;br&gt;&lt;br&gt;Permissions with the protection level &lt;code&gt;signature&lt;/code&gt;, &lt;code&gt;privileged&lt;/code&gt; or &lt;code&gt;signatureOrSystem&lt;/code&gt; are only granted to system apps (unless they also include &lt;code&gt;appop&lt;/code&gt;). If an app is a regular non-system app, it will never be able to use these permissions.&lt;br&gt;&lt;br&gt;Issue id: ProtectedPermissions&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIntentReset" defaultSeverity="WARNING" displayName="Suspicious mix of setType and setData" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious mix of &lt;code&gt;setType&lt;/code&gt; and &lt;code&gt;setData&lt;/code&gt;&lt;br&gt;&lt;br&gt;Intent provides the following APIs: &lt;code&gt;setData(Uri)&lt;/code&gt; and &lt;code&gt;setType(String)&lt;/code&gt;. Unfortunately, setting one clears the other. If you want to set both, you should call &lt;code&gt;setDataAndType(Uri, String)&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: IntentReset&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintReferenceType" defaultSeverity="ERROR" displayName="Incorrect reference types" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect reference types&lt;br&gt;&lt;br&gt;When you generate a resource alias, the resource you are pointing to must be of the same type as the alias&lt;br&gt;&lt;br&gt;Issue id: ReferenceType&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingMediaBrowserServiceIntentFilter" defaultSeverity="ERROR" displayName="Missing MediaBrowserService intent-filter" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing MediaBrowserService intent-filter&lt;br&gt;&lt;br&gt;An Automotive Media App requires an exported service that extends &lt;code&gt;android.service.media.MediaBrowserService&lt;/code&gt; with an &lt;code&gt;intent-filter&lt;/code&gt; for the action &lt;code&gt;android.media.browse.MediaBrowserService&lt;/code&gt; to be able to browse and play media.&lt;br/&gt;
&lt;br/&gt;
To do this, add
&lt;pre&gt;
`&amp;lt;intent-filter&gt;`
    `&amp;lt;action android:name="android.media.browse.MediaBrowserService" /&gt;`
`&amp;lt;/intent-filter&gt;`
&lt;/pre&gt;
to the service that extends &lt;code&gt;android.service.media.MediaBrowserService&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: MissingMediaBrowserServiceIntentFilter&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/auto/audio/index.html#config_manifest"&gt;https://developer.android.com/training/auto/audio/index.html#config_manifest&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidResourceFolder" defaultSeverity="ERROR" displayName="Invalid Resource Folder" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Resource Folder&lt;br&gt;&lt;br&gt;This lint check looks for a folder name that is not a valid resource folder name; these will be ignored and not packaged by the Android Gradle build plugin.&lt;br/&gt;
&lt;br/&gt;
Note that the order of resources is very important; for example, you can't specify a language before a network code.&lt;br/&gt;
&lt;br/&gt;
Similarly, note that to use 3 letter region codes, you have to use a special BCP 47 syntax: the prefix b+ followed by the BCP 47 language tag but with &lt;code&gt;+&lt;/code&gt; as the individual separators instead of &lt;code&gt;-&lt;/code&gt;. Therefore, for the BCP 47 language tag &lt;code&gt;nl-ABW&lt;/code&gt; you have to use &lt;code&gt;b+nl+ABW&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidResourceFolder&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/providing-resources.html"&gt;https://developer.android.com/guide/topics/resources/providing-resources.html&lt;/a&gt;&lt;br&gt;&lt;a href="https://tools.ietf.org/html/bcp47"&gt;https://tools.ietf.org/html/bcp47&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeprecated" defaultSeverity="WARNING" displayName="Using deprecated resources" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using deprecated resources&lt;br&gt;&lt;br&gt;Deprecated views, attributes and so on are deprecated because there is a better way to do something. Do it that new way. You've been warned.&lt;br&gt;&lt;br&gt;Issue id: Deprecated&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDiscouragedPrivateApi" defaultSeverity="WARNING" displayName="Using Discouraged Private API" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Discouraged Private API&lt;br&gt;&lt;br&gt;Usage of restricted non-SDK interface may throw an exception at runtime. Accessing non-SDK methods or fields through reflection has a high likelihood to break your app between versions, and is being restricted to facilitate future app compatibility.&lt;br&gt;&lt;br&gt;Issue id: DiscouragedPrivateApi&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces"&gt;https://developer.android.com/preview/restrictions-non-sdk-interfaces&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintProguardSplit" defaultSeverity="WARNING" displayName="Proguard.cfg file contains generic Android rules" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Proguard.cfg file contains generic Android rules&lt;br&gt;&lt;br&gt;Earlier versions of the Android tools bundled a single &lt;code&gt;proguard.cfg&lt;/code&gt; file containing a ProGuard configuration file suitable for Android shrinking and obfuscation. However, that version was copied into new projects, which means that it does not continue to get updated as we improve the default ProGuard rules for Android.&lt;br/&gt;
&lt;br/&gt;
In the new version of the tools, we have split the ProGuard configuration into two halves:&lt;br/&gt;
* A simple configuration file containing only project-specific flags, in your project&lt;br/&gt;
* A generic configuration file containing the recommended set of ProGuard options for Android projects. This generic file lives in the SDK install directory which means that it gets updated along with the tools.&lt;br/&gt;
&lt;br/&gt;
In order for this to work, the proguard.config property in the &lt;code&gt;project.properties&lt;/code&gt; file now refers to a path, so you can reference both the generic file as well as your own (and any additional files too).&lt;br/&gt;
&lt;br/&gt;
To migrate your project to the new setup, create a new &lt;code&gt;proguard-project.txt&lt;/code&gt; file in your project containing any project specific ProGuard flags as well as any customizations you have made, then update your project.properties file to contain:&lt;br/&gt;
&lt;code&gt;proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: ProguardSplit&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingOnPlayFromSearch" defaultSeverity="ERROR" displayName="Missing onPlayFromSearch" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;onPlayFromSearch&lt;/code&gt;&lt;br&gt;&lt;br&gt;To support voice searches on Android Auto, in addition to adding an &lt;code&gt;intent-filter&lt;/code&gt; for the action &lt;code&gt;onPlayFromSearch&lt;/code&gt;, you also need to override and implement &lt;code&gt;onPlayFromSearch(String query, Bundle bundle)&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: MissingOnPlayFromSearch&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/auto/audio/index.html#support_voice"&gt;https://developer.android.com/training/auto/audio/index.html#support_voice&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotificationIconCompatibility" defaultSeverity="WARNING" displayName="Notification Icon Compatibility" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notification Icon Compatibility&lt;br&gt;&lt;br&gt;Notification icons should define a raster image to support Android versions below 5.0 (API 21). Note that the way Lint decides whether an icon is a notification icon is based on the filename prefix &lt;code&gt;ic_stat_&lt;/code&gt;. This corresponds to the naming convention documented in &lt;a href="https://d.android.com/r/studio-ui/designer/material/iconography"&gt;https://d.android.com/r/studio-ui/designer/material/iconography&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: NotificationIconCompatibility&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidUsesTagAttribute" defaultSeverity="ERROR" displayName="Invalid name attribute for uses element" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid &lt;code&gt;name&lt;/code&gt; attribute for &lt;code&gt;uses&lt;/code&gt; element&lt;br&gt;&lt;br&gt;The &amp;lt;uses&gt; element in &lt;code&gt;&amp;lt;automotiveApp&gt;&lt;/code&gt; should contain a valid value for the &lt;code&gt;name&lt;/code&gt; attribute. Valid values are &lt;code&gt;media&lt;/code&gt;, &lt;code&gt;notification&lt;/code&gt;, or &lt;code&gt;sms&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidUsesTagAttribute&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/auto/start/index.html#auto-metadata"&gt;https://developer.android.com/training/auto/start/index.html#auto-metadata&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEmptySuperCall" defaultSeverity="WARNING" displayName="Calling an empty super method" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Calling an empty super method&lt;br&gt;&lt;br&gt;For methods annotated with &lt;code&gt;@EmptySuper&lt;/code&gt;, overriding methods should not also call the super implementation, either because it is empty, or perhaps it contains code not intended to be run when the method is overridden.&lt;br&gt;&lt;br&gt;Issue id: EmptySuperCall&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsupportedChromeOsCameraSystemFeature" defaultSeverity="WARNING" displayName="Looking for Rear Camera only feature" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Looking for Rear Camera only feature&lt;br&gt;&lt;br&gt;You should look for the &lt;code&gt;FEATURE_CAMERA_ANY&lt;/code&gt; features to include all possible cameras that may be on the device. Looking for &lt;code&gt;FEATURE_CAMERA&lt;/code&gt; only looks for a rear facing camera, which certain large screen devices don't have, as well as newer device configurations and modes may place the device in a state where the rear camera is not available. To fix the issue, look for &lt;code&gt;FEATURE_CAMERA_ANY&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: UnsupportedChromeOsCameraSystemFeature&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/large-screens/large-screen-cookbook#chromebook_camera_support"&gt;https://developer.android.com/guide/topics/large-screens/large-screen-cookbook#chromebook_camera_support&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLocalSuppress" defaultSeverity="ERROR" displayName="@SuppressLint on invalid element" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;@SuppressLint on invalid element&lt;br&gt;&lt;br&gt;The &lt;code&gt;@SuppressAnnotation&lt;/code&gt; is used to suppress Lint warnings in Java files. However, while many lint checks analyzes the Java source code, where they can find annotations on (for example) local variables, some checks are analyzing the &lt;code&gt;.class&lt;/code&gt; files. And in class files, annotations only appear on classes, fields and methods. Annotations placed on local variables disappear. If you attempt to suppress a lint error for a class-file based lint check, the suppress annotation not work. You must move the annotation out to the surrounding method.&lt;br&gt;&lt;br&gt;Issue id: LocalSuppress&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCustomSplashScreen" defaultSeverity="WARNING" displayName="Application-defined Launch Screen" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Application-defined Launch Screen&lt;br&gt;&lt;br&gt;Starting in Android 12 (API 31+), the application's Launch Screen is provided by the system and the application should not create its own, otherwise the user will see two splashscreens. Please check the &lt;code&gt;SplashScreen&lt;/code&gt; class to check how the Splash Screen can be controlled and customized.&lt;br&gt;&lt;br&gt;Issue id: CustomSplashScreen&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/splash-screen"&gt;https://developer.android.com/guide/topics/ui/splash-screen&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongFolder" defaultSeverity="ERROR" displayName="Resource file in the wrong res folder" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Resource file in the wrong &lt;code&gt;res&lt;/code&gt; folder&lt;br&gt;&lt;br&gt;Resource files are sometimes placed in the wrong folder, and it can lead to subtle bugs that are hard to understand. This check looks for problems in this area, such as attempting to place a layout "alias" file in a &lt;code&gt;layout/&lt;/code&gt; folder rather than the &lt;code&gt;values/&lt;/code&gt; folder where it belongs.&lt;br&gt;&lt;br&gt;Issue id: WrongFolder&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInflateParams" defaultSeverity="WARNING" displayName="Layout Inflation without a Parent" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Layout Inflation without a Parent&lt;br&gt;&lt;br&gt;When inflating a layout, avoid passing in null as the parent view, since otherwise any layout parameters on the root of the inflated layout will be ignored.&lt;br&gt;&lt;br&gt;Issue id: InflateParams&lt;br&gt;&lt;br&gt;&lt;a href="https://www.bignerdranch.com/blog/understanding-androids-layoutinflater-inflate/"&gt;https://www.bignerdranch.com/blog/understanding-androids-layoutinflater-inflate/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintKotlinNullnessAnnotation" defaultSeverity="ERROR" displayName="Kotlin nullability annotation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Kotlin nullability annotation&lt;br&gt;&lt;br&gt;In Kotlin, nullness is part of the type system; &lt;code&gt;s: String&lt;/code&gt; is &lt;b&gt;never&lt;/b&gt; null and &lt;code&gt;s: String?&lt;/code&gt; is sometimes null, whether or not you add in additional annotations stating &lt;code&gt;@NonNull&lt;/code&gt; or &lt;code&gt;@Nullable&lt;/code&gt;. These are likely copy/paste mistakes, and are misleading.&lt;br&gt;&lt;br&gt;Issue id: KotlinNullnessAnnotation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAccidentalOctal" defaultSeverity="ERROR" displayName="Accidental Octal" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Accidental Octal&lt;br&gt;&lt;br&gt;In Groovy, an integer literal that starts with a leading 0 will be interpreted as an octal number. That is usually (always?) an accident and can lead to subtle bugs, for example when used in the &lt;code&gt;versionCode&lt;/code&gt; of an app.&lt;br&gt;&lt;br&gt;Issue id: AccidentalOctal&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintApplySharedPref" defaultSeverity="WARNING" displayName="Use apply() on SharedPreferences" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use &lt;code&gt;apply()&lt;/code&gt; on &lt;code&gt;SharedPreferences&lt;/code&gt;&lt;br&gt;&lt;br&gt;Consider using &lt;code&gt;apply()&lt;/code&gt; instead of &lt;code&gt;commit&lt;/code&gt; on shared preferences. Whereas &lt;code&gt;commit&lt;/code&gt; blocks and writes its data to persistent storage immediately, &lt;code&gt;apply&lt;/code&gt; will handle it in the background.&lt;br&gt;&lt;br&gt;Issue id: ApplySharedPref&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWatchFaceFormatDeclaresHasNoCode" defaultSeverity="ERROR" displayName="The hasCode attribute should be set to false" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;The &lt;code&gt;hasCode&lt;/code&gt; attribute should be set to &lt;code&gt;false&lt;/code&gt;&lt;br&gt;&lt;br&gt;Watch Face Format is a resource-only format, so the &lt;code&gt;hasCode&lt;/code&gt; attribute should be set to &lt;code&gt;false&lt;/code&gt; to reflect this.&lt;br&gt;&lt;br&gt;Issue id: WatchFaceFormatDeclaresHasNoCode&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/wff/setup#declare-wff-use"&gt;https://developer.android.com/training/wearables/wff/setup#declare-wff-use&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidWearFeatureAttribute" defaultSeverity="ERROR" displayName="Invalid attribute for Wear uses-feature" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid attribute for Wear uses-feature&lt;br&gt;&lt;br&gt;For the &lt;code&gt;android.hardware.type.watch&lt;/code&gt; uses-feature, android:required="false" is disallowed. A single APK for Wear and non-Wear devices is not supported.&lt;br&gt;&lt;br&gt;Issue id: InvalidWearFeatureAttribute&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/apps/packaging.html"&gt;https://developer.android.com/training/wearables/apps/packaging.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResourceAsColor" defaultSeverity="ERROR" displayName="Should pass resolved color instead of resource id" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Should pass resolved color instead of resource id&lt;br&gt;&lt;br&gt;Methods that take a color in the form of an integer should be passed an RGB triple, not the actual color resource id. You must call &lt;code&gt;getResources().getColor(resource)&lt;/code&gt; to resolve the actual color value first.&lt;br/&gt;
&lt;br/&gt;
Similarly, methods that take a dimension integer should be passed an actual dimension (call &lt;code&gt;getResources().getDimension(resource)&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: ResourceAsColor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRequiredSize" defaultSeverity="ERROR" displayName="Missing layout_width or layout_height attributes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;layout_width&lt;/code&gt; or &lt;code&gt;layout_height&lt;/code&gt; attributes&lt;br&gt;&lt;br&gt;All views must specify an explicit &lt;code&gt;layout_width&lt;/code&gt; and &lt;code&gt;layout_height&lt;/code&gt; attribute. There is a runtime check for this, so if you fail to specify a size, an exception is thrown at runtime.&lt;br/&gt;
&lt;br/&gt;
It's possible to specify these widths via styles as well. GridLayout, as a special case, does not require you to specify a size.&lt;br&gt;&lt;br&gt;Issue id: RequiredSize&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRegistered" defaultSeverity="WARNING" displayName="Class is not registered in the manifest" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Class is not registered in the manifest&lt;br&gt;&lt;br&gt;Activities, services and content providers should be registered in the &lt;code&gt;AndroidManifest.xml&lt;/code&gt; file using &lt;code&gt;&amp;lt;activity&gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;service&gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;provider&gt;&lt;/code&gt; tags.&lt;br/&gt;
&lt;br/&gt;
If your activity is simply a parent class intended to be subclassed by other "real" activities, make it an abstract class.&lt;br&gt;&lt;br&gt;Issue id: Registered&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/manifest-intro.html"&gt;https://developer.android.com/guide/topics/manifest/manifest-intro.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBlockedPrivateApi" defaultSeverity="ERROR" displayName="Using Blocked Private API" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Blocked Private API&lt;br&gt;&lt;br&gt;Usage of restricted non-SDK interface is forbidden for this targetSDK. Accessing non-SDK methods or fields through reflection has a high likelihood to break your app between versions, and is being restricted to facilitate future app compatibility.&lt;br&gt;&lt;br&gt;Issue id: BlockedPrivateApi&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces"&gt;https://developer.android.com/preview/restrictions-non-sdk-interfaces&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWatchFaceFormatMissingVersion" defaultSeverity="ERROR" displayName="The Watch Face Format version is missing" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;The Watch Face Format version is missing&lt;br&gt;&lt;br&gt;When creating a watch face using the Watch Face Format, you need to add the "com.google.wear.watchface.format.version" application property. This property specifies which feature version the Watch Face Format is using.&lt;br/&gt;
&lt;br/&gt;
Add the property to your application element:
&lt;pre&gt;
&amp;lt;property android:name="com.google.wear.watchface.format.version"
          android:value="1" /&gt;
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;Issue id: WatchFaceFormatMissingVersion&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/wff/setup#declare-wff-use"&gt;https://developer.android.com/training/wearables/wff/setup#declare-wff-use&lt;/a&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/wff/features"&gt;https://developer.android.com/training/wearables/wff/features&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradlePluginVersion" defaultSeverity="ERROR" displayName="Incompatible Android Gradle Plugin" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incompatible Android Gradle Plugin&lt;br&gt;&lt;br&gt;Not all versions of the Android Gradle plugin are compatible with all versions of the SDK. If you update your tools, or if you are trying to open a project that was built with an old version of the tools, you may need to update your plugin version number.&lt;br&gt;&lt;br&gt;Issue id: GradlePluginVersion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintImpliedTouchscreenHardware" defaultSeverity="ERROR" displayName="Touchscreen not optional" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Touchscreen not optional&lt;br&gt;&lt;br&gt;Apps require the &lt;code&gt;android.hardware.touchscreen&lt;/code&gt; feature by default. If you want your app to be available on TV, you must also explicitly declare that a touchscreen is not required as follows:&lt;br/&gt;
&lt;code&gt;&amp;lt;uses-feature android:name="android.hardware.touchscreen" android:required="false"/&gt;&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: ImpliedTouchscreenHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/uses-feature-element.html"&gt;https://developer.android.com/guide/topics/manifest/uses-feature-element.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCanvasSize" defaultSeverity="WARNING" displayName="Wrong Canvas Size" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Canvas Size&lt;br&gt;&lt;br&gt;In a custom view's draw implementation, you should normally call &lt;code&gt;getWidth&lt;/code&gt; and &lt;code&gt;getHeight&lt;/code&gt; on the custom view itself, not on the &lt;code&gt;canvas&lt;/code&gt; instance.&lt;br/&gt;
&lt;br/&gt;
Canvas width and height are the width and height of the &lt;code&gt;Canvas&lt;/code&gt;, which is not always the same as size of the view.&lt;br/&gt;
&lt;br/&gt;
In the hardware accelerated path the width and height of the canvas typically always match that of the &lt;code&gt;View&lt;/code&gt; because every view goes to its own recorded &lt;code&gt;DisplayList&lt;/code&gt;. But in software rendering there's just one canvas that is clipped and transformed as it makes its way through the &lt;code&gt;View&lt;/code&gt; tree, and otherwise remains the same &lt;code&gt;Canvas&lt;/code&gt; object for every View's draw method.&lt;br/&gt;
&lt;br/&gt;
You should only use Canvas state to adjust how much you draw, such as a quick-reject for early work avoidance if it's going to be clipped away, but not what you draw.&lt;br&gt;&lt;br&gt;Issue id: CanvasSize&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidImeActionId" defaultSeverity="ERROR" displayName="Invalid imeActionId declaration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid imeActionId declaration&lt;br&gt;&lt;br&gt;&lt;code&gt;android:imeActionId&lt;/code&gt; should not be a resource ID such as &lt;code&gt;@+id/resName&lt;/code&gt;. It must be an integer constant, or an integer resource reference, as defined in &lt;code&gt;EditorInfo&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidImeActionId&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/view/inputmethod/EditorInfo.html"&gt;https://developer.android.com/reference/android/view/inputmethod/EditorInfo.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringFormatCount" defaultSeverity="WARNING" displayName="Formatting argument types incomplete or inconsistent" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Formatting argument types incomplete or inconsistent&lt;br&gt;&lt;br&gt;When a formatted string takes arguments, it usually needs to reference the same arguments in all translations (or all arguments if there are no translations.&lt;br/&gt;
&lt;br/&gt;
There are cases where this is not the case, so this issue is a warning rather than an error by default. However, this usually happens when a language is not translated or updated correctly.&lt;br&gt;&lt;br&gt;Issue id: StringFormatCount&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintImplicitSamInstance" defaultSeverity="WARNING" displayName="Implicit SAM Instances" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implicit SAM Instances&lt;br&gt;&lt;br&gt;Kotlin's support for SAM (single abstract method) interfaces lets you pass a lambda to the interface. This will create a new instance on the fly even though there is no explicit constructor call. If you pass one of these lambdas or method references into a method which (for example) stores or compares the object identity, unexpected results may happen.&lt;br/&gt;
&lt;br/&gt;
In particular, passing a lambda variable in as a listener, and then later attempting to remove the listener will not work because a different instance is passed in.&lt;br&gt;&lt;br&gt;Issue id: ImplicitSamInstance&lt;br&gt;&lt;br&gt;&lt;a href="https://kotlinlang.org/docs/fun-interfaces.html#sam-conversions"&gt;https://kotlinlang.org/docs/fun-interfaces.html#sam-conversions&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNestedScrolling" defaultSeverity="WARNING" displayName="Nested scrolling widgets" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Nested scrolling widgets&lt;br&gt;&lt;br&gt;A scrolling widget such as a &lt;code&gt;ScrollView&lt;/code&gt; should not contain any nested scrolling widgets since this has various usability issues&lt;br&gt;&lt;br&gt;Issue id: NestedScrolling&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAdapterViewChildren" defaultSeverity="WARNING" displayName="AdapterView cannot have children in XML" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;AdapterView&lt;/code&gt; cannot have children in XML&lt;br&gt;&lt;br&gt;An &lt;code&gt;AdapterView&lt;/code&gt; such as a `ListView`s must be configured with data from Java code, such as a &lt;code&gt;ListAdapter&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AdapterViewChildren&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/widget/AdapterView.html"&gt;https://developer.android.com/reference/android/widget/AdapterView.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseAlpha2" defaultSeverity="WARNING" displayName="Using 3-letter Codes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using 3-letter Codes&lt;br&gt;&lt;br&gt;For compatibility with earlier devices, you should only use 3-letter language and region codes when there is no corresponding 2 letter code.&lt;br&gt;&lt;br&gt;Issue id: UseAlpha2&lt;br&gt;&lt;br&gt;&lt;a href="https://tools.ietf.org/html/bcp47"&gt;https://tools.ietf.org/html/bcp47&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingResourcesProperties" defaultSeverity="WARNING" displayName="Missing resources.properties file" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing resources.properties file&lt;br&gt;&lt;br&gt;When &lt;code&gt;generateLocaleConfig&lt;/code&gt; is turned on, the default locale must be specified in a resources.properties file.&lt;br&gt;&lt;br&gt;Issue id: MissingResourcesProperties&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/r/studio-ui/build/automatic-per-app-languages"&gt;https://developer.android.com/r/studio-ui/build/automatic-per-app-languages&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnknownIdInLayout" defaultSeverity="WARNING" displayName="Reference to an id that is not in the current layout" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Reference to an id that is not in the current layout&lt;br&gt;&lt;br&gt;The &lt;code&gt;@+id/&lt;/code&gt; syntax refers to an existing id, or creates a new one if it has not already been defined elsewhere. However, this means that if you have a typo in your reference, or if the referred view no longer exists, you do not get a warning since the id will be created on demand.&lt;br/&gt;
&lt;br/&gt;
This is sometimes intentional, for example where you are referring to a view which is provided in a different layout via an include. However, it is usually an accident where you have a typo or you have renamed a view without updating all the references to it.&lt;br&gt;&lt;br&gt;Issue id: UnknownIdInLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppLinksAutoVerify" defaultSeverity="ERROR" displayName="App Links Auto Verification Failure" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;App Links Auto Verification Failure&lt;br&gt;&lt;br&gt;Ensures that app links are correctly set and associated with website.&lt;br&gt;&lt;br&gt;Issue id: AppLinksAutoVerify&lt;br&gt;&lt;br&gt;&lt;a href="https://g.co/appindexing/applinks"&gt;https://g.co/appindexing/applinks&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeprecatedSinceApi" defaultSeverity="WARNING" displayName="Using a method deprecated in earlier SDK" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using a method deprecated in earlier SDK&lt;br&gt;&lt;br&gt;Some backport methods are only necessary until a specific version of Android. These have been annotated with &lt;code&gt;@DeprecatedSinceApi&lt;/code&gt;, specifying the relevant API level and replacement suggestions. Calling these methods when the &lt;code&gt;minSdkVersion&lt;/code&gt; is already at the deprecated API level or above is unnecessary.&lt;br&gt;&lt;br&gt;Issue id: DeprecatedSinceApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSlices" defaultSeverity="WARNING" displayName="Slices" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Slices&lt;br&gt;&lt;br&gt;This check analyzes usages of the Slices API and offers suggestions based on best practices.&lt;br&gt;&lt;br&gt;Issue id: Slices&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringEscaping" defaultSeverity="ERROR" displayName="Invalid string escapes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid string escapes&lt;br&gt;&lt;br&gt;Apostrophes (') must always be escaped (with a \\), unless they appear in a string which is itself escaped in double quotes (").&lt;br&gt;&lt;br&gt;Issue id: StringEscaping&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintViewBindingType" defaultSeverity="ERROR" displayName="tools:viewBindingType issues" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;tools:viewBindingType&lt;/code&gt; issues&lt;br&gt;&lt;br&gt;All issues related to using the View Binding &lt;code&gt;tools:viewBindingType&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: ViewBindingType&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearableActionDuplicate" defaultSeverity="WARNING" displayName="Duplicate watch face configuration activities found" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate watch face configuration activities found&lt;br&gt;&lt;br&gt;If and only if a watch face service defines &lt;code&gt;wearableConfigurationAction&lt;/code&gt; metadata, with the value &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt;, there should be an activity in the same package, which has an intent filter for &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt; (with com.google.android.wearable.watchface.category.WEARABLE_CONFIGURATION if minSdkVersion is less than 30).&lt;br&gt;&lt;br&gt;Issue id: WearableActionDuplicate&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/watch-faces/configuration"&gt;https://developer.android.com/training/wearables/watch-faces/configuration&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppLinkWarning" defaultSeverity="WARNING" displayName="App Link warning" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;App Link warning&lt;br&gt;&lt;br&gt;From Android 12, intent filters that use the HTTP and HTTPS schemes will no longer               bring the user to your app when the user clicks a link, unless the intent filter is               an Android App Link. Such intent filters must include certain elements, and at least               one Android App Link for each domain must have &lt;code&gt;android:autoVerify="true"&lt;/code&gt; to verify               ownership of the domain. We recommend adding &lt;code&gt;android:autoVerify="true"&lt;/code&gt; to any intent               filter that is intended to be an App Link, in case the other App Links are modified.&lt;br&gt;&lt;br&gt;Issue id: AppLinkWarning&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/app-links"&gt;https://developer.android.com/training/app-links&lt;/a&gt;&lt;br&gt;&lt;a href="https://g.co/AppIndexing/AndroidStudio"&gt;https://g.co/AppIndexing/AndroidStudio&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAaptCrash" defaultSeverity="ERROR" displayName="Potential AAPT crash" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Potential AAPT crash&lt;br&gt;&lt;br&gt;Defining a style which sets &lt;code&gt;android:id&lt;/code&gt; to a dynamically generated id can cause many versions of &lt;code&gt;aapt&lt;/code&gt;, the resource packaging tool, to crash. To work around this, declare the id explicitly with &lt;code&gt;&amp;lt;item type="id" name="..." /&gt;&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: AaptCrash&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMemberExtensionConflict" defaultSeverity="WARNING" displayName="Conflict applicable candidates of member and extension" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Conflict applicable candidates of member and extension&lt;br&gt;&lt;br&gt;When both member and extension declarations are applicable, the resolution takes the member. This also implies that, if an extension existed first, but then a member is added later, the same call-site may end up with different call resolutions depending on target environment. This results in a potential runtime exception if the generated binary (library or app) targets earlier environment (i.e., without the new member, but only extension). More concrete example is found at: &lt;a href="https://issuetracker.google.com/issues/350432371"&gt;https://issuetracker.google.com/issues/350432371&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: MemberExtensionConflict&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFullBackupContent" defaultSeverity="ERROR" displayName="Valid Full Backup Content File" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Valid Full Backup Content File&lt;br&gt;&lt;br&gt;Ensures that &lt;code&gt;&amp;lt;data-extraction-rules&lt;/code&gt;&gt; and &lt;code&gt;&amp;lt;full-backup-content&gt;&lt;/code&gt; files, which configure backup options, are valid.&lt;br&gt;&lt;br&gt;Issue id: FullBackupContent&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2015/07/auto-backup-for-apps-made-simple.html"&gt;https://android-developers.googleblog.com/2015/07/auto-backup-for-apps-made-simple.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingTvBanner" defaultSeverity="ERROR" displayName="TV Missing Banner" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TV Missing Banner&lt;br&gt;&lt;br&gt;A TV application must provide a home screen banner for each localization if it includes a Leanback launcher intent filter. The banner is the app launch point that appears on the home screen in the apps and games rows.&lt;br&gt;&lt;br&gt;Issue id: MissingTvBanner&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/tv/start/start.html#banner"&gt;https://developer.android.com/training/tv/start/start.html#banner&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSuspicious0dp" defaultSeverity="ERROR" displayName="Suspicious 0dp dimension" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious 0dp dimension&lt;br&gt;&lt;br&gt;Using 0dp as the width in a horizontal &lt;code&gt;LinearLayout&lt;/code&gt; with weights is a useful trick to ensure that only the weights (and not the intrinsic sizes) are used when sizing the children.&lt;br/&gt;
&lt;br/&gt;
However, if you use 0dp for the opposite dimension, the view will be invisible. This can happen if you change the orientation of a layout without also flipping the &lt;code&gt;0dp&lt;/code&gt; dimension in all the children.&lt;br&gt;&lt;br&gt;Issue id: Suspicious0dp&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintScrollViewCount" defaultSeverity="WARNING" displayName="ScrollView can have only one child" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;ScrollView&lt;/code&gt; can have only one child&lt;br&gt;&lt;br&gt;A &lt;code&gt;ScrollView&lt;/code&gt; can only have one child widget. If you want more children, wrap them in a container layout.&lt;br&gt;&lt;br&gt;Issue id: ScrollViewCount&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongThreadInterprocedural" defaultSeverity="ERROR" displayName="Wrong Thread (Interprocedural)" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Thread (Interprocedural)&lt;br&gt;&lt;br&gt;Searches for interprocedural call paths that violate thread annotations in the program. Tracks the flow of instantiated types and lambda expressions to increase accuracy across method boundaries.&lt;br&gt;&lt;br&gt;Issue id: WrongThreadInterprocedural&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/processes-and-threads.html#Threads"&gt;https://developer.android.com/guide/components/processes-and-threads.html#Threads&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintForegroundServicePermission" defaultSeverity="ERROR" displayName="Missing permissions required by foregroundServiceType" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing permissions required by foregroundServiceType&lt;br&gt;&lt;br&gt;For targetSdkVersion &gt;= 34, each &lt;code&gt;foregroundServiceType&lt;/code&gt; listed in the &lt;code&gt;&amp;lt;service&gt;&lt;/code&gt; element requires specific sets of permissions to be declared in the manifest. If permissions are missing, then when the foreground service is started with a &lt;code&gt;foregroundServiceType&lt;/code&gt; that has missing permissions, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.&lt;br&gt;&lt;br&gt;Issue id: ForegroundServicePermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotSibling" defaultSeverity="ERROR" displayName="Invalid Constraints" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Constraints&lt;br&gt;&lt;br&gt;Layout constraints in a given &lt;code&gt;ConstraintLayout&lt;/code&gt; or &lt;code&gt;RelativeLayout&lt;/code&gt; should reference other views within the same relative layout (but not itself!)&lt;br&gt;&lt;br&gt;Issue id: NotSibling&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotConstructor" defaultSeverity="WARNING" displayName="Not a Constructor" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Not a Constructor&lt;br&gt;&lt;br&gt;This check catches methods that look like they were intended to be constructors, but aren't.&lt;br&gt;&lt;br&gt;Issue id: NotConstructor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleDeprecatedConfiguration" defaultSeverity="WARNING" displayName="Deprecated Gradle Configuration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Deprecated Gradle Configuration&lt;br&gt;&lt;br&gt;Some Gradle configurations have been deprecated since Android Gradle Plugin 3.0.0 and will be removed in a future version of the Android Gradle Plugin.&lt;br&gt;&lt;br&gt;Issue id: GradleDeprecatedConfiguration&lt;br&gt;&lt;br&gt;&lt;a href="https://d.android.com/r/tools/update-dependency-configurations"&gt;https://d.android.com/r/tools/update-dependency-configurations&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWatchFaceEditor" defaultSeverity="WARNING" displayName="Watch face editor must use launchMode=&quot;standard&quot;" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Watch face editor must use launchMode="standard"&lt;br&gt;&lt;br&gt;Watch face editor activities must be able to launch in the Wear OS companion app activity task in order to work correctly. Thus only &lt;code&gt;launchMode="standard"&lt;/code&gt; is allowed. The watch face will not be shown on the watch if it does not satisfy this requirement.&lt;br&gt;&lt;br&gt;Issue id: WatchFaceEditor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedTranslation" defaultSeverity="WARNING" displayName="Unused Translation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unused Translation&lt;br&gt;&lt;br&gt;If an application defines a translation for a language which is not included in the app's &lt;code&gt;localeConfig&lt;/code&gt; file (when declared in the manifest), that language will be "unused"; it will not be presented to the user. Usually this means you have forgotten to include it in the locale config file.&lt;br&gt;&lt;br&gt;Issue id: UnusedTranslation&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/about/versions/13/features/app-languages"&gt;https://developer.android.com/about/versions/13/features/app-languages&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIntentFilterUniqueDataAttributes" defaultSeverity="WARNING" displayName="Data tags should only declare unique attributes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Data tags should only declare unique attributes&lt;br&gt;&lt;br&gt;&lt;code&gt;&amp;lt;intent-filter&gt;&lt;/code&gt; &lt;code&gt;&amp;lt;data&gt;&lt;/code&gt; tags should only declare a single unique attribute (i.e. scheme OR host, but not both). This better matches the runtime behavior of intent filters, as they combine all of the declared data attributes into a single matcher which is allowed to handle any combination across attribute types.&lt;br/&gt;
&lt;br/&gt;
For example, the following two &lt;code&gt;&amp;lt;intent-filter&gt;&lt;/code&gt; declarations are the same:
&lt;pre&gt;
&amp;lt;intent-filter&gt;
    &amp;lt;data android:scheme="http" android:host="example.com" /&gt;
    &amp;lt;data android:scheme="https" android:host="example.org" /&gt;
&amp;lt;/intent-filter&gt;
&lt;/pre&gt;

&lt;pre&gt;
&amp;lt;intent-filter&gt;
    &amp;lt;data android:scheme="http"/&gt;
    &amp;lt;data android:scheme="https"/&gt;
    &amp;lt;data android:host="example.com" /&gt;
    &amp;lt;data android:host="example.org" /&gt;
&amp;lt;/intent-filter&gt;
&lt;/pre&gt;
&lt;br/&gt;
They both handle all of the following:&lt;br/&gt;
* &lt;a href="http://example.com"&gt;http://example.com&lt;/a&gt;&lt;br/&gt;
* &lt;a href="https://example.com"&gt;https://example.com&lt;/a&gt;&lt;br/&gt;
* &lt;a href="http://example.org"&gt;http://example.org&lt;/a&gt;&lt;br/&gt;
* &lt;a href="https://example.org"&gt;https://example.org&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
The second one better communicates the combining behavior and is clearer to an external reader that one should not rely on the scheme/host being self contained. It is not obvious in the first that &lt;a href="http://example.org"&gt;http://example.org&lt;/a&gt; is also matched, which can lead to confusion (or incorrect behavior) with a more complex set of schemes/hosts.&lt;br/&gt;
&lt;br/&gt;
Note that this does not apply to host + port, as those must be declared in the same &lt;code&gt;&amp;lt;data&gt;&lt;/code&gt; tag and are only associated with each other.&lt;br&gt;&lt;br&gt;Issue id: IntentFilterUniqueDataAttributes&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/intents-filters"&gt;https://developer.android.com/guide/components/intents-filters&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleIdeError" defaultSeverity="ERROR" displayName="Gradle IDE Support Issues" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Gradle IDE Support Issues&lt;br&gt;&lt;br&gt;Gradle is highly flexible, and there are things you can do in Gradle files which can make it hard or impossible for IDEs to properly handle the project. This lint check looks for constructs that potentially break IDE support.&lt;br&gt;&lt;br&gt;Issue id: GradleIdeError&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNewApi" defaultSeverity="ERROR" displayName="Calling new methods on older versions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Calling new methods on older versions&lt;br&gt;&lt;br&gt;This check scans through all the Android API calls in the application and warns about any calls that are not available on &lt;b&gt;all&lt;/b&gt; versions targeted by this application (according to its minimum SDK attribute in the manifest).&lt;br/&gt;
&lt;br/&gt;
If you really want to use this API and don't need to support older devices just set the &lt;code&gt;minSdkVersion&lt;/code&gt; in your &lt;code&gt;build.gradle&lt;/code&gt; or &lt;code&gt;AndroidManifest.xml&lt;/code&gt; files.&lt;br/&gt;
&lt;br/&gt;
If your code is &lt;b&gt;deliberately&lt;/b&gt; accessing newer APIs, and you have ensured (e.g. with conditional execution) that this code will only ever be called on a supported platform, then you can annotate your class or method with the &lt;code&gt;@TargetApi&lt;/code&gt; annotation specifying the local minimum SDK to apply, such as &lt;code&gt;@TargetApi(11)&lt;/code&gt;, such that this check considers 11 rather than your manifest file's minimum SDK as the required API level.&lt;br/&gt;
&lt;br/&gt;
If you are deliberately setting &lt;code&gt;android:&lt;/code&gt; attributes in style definitions, make sure you place this in a &lt;code&gt;values-v&lt;/code&gt;&lt;i&gt;NN&lt;/i&gt; folder in order to avoid running into runtime conflicts on certain devices where manufacturers have added custom attributes whose ids conflict with the new ones on later platforms.&lt;br/&gt;
&lt;br/&gt;
Similarly, you can use tools:targetApi="11" in an XML file to indicate that the element will only be inflated in an adequate context.&lt;br&gt;&lt;br&gt;Issue id: NewApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIncludeLayoutParam" defaultSeverity="ERROR" displayName="Ignored layout params on include" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Ignored layout params on include&lt;br&gt;&lt;br&gt;Layout parameters specified on an &lt;code&gt;&amp;lt;include&gt;&lt;/code&gt; tag will only be used if you also override &lt;code&gt;layout_width&lt;/code&gt; and &lt;code&gt;layout_height&lt;/code&gt; on the &lt;code&gt;&amp;lt;include&gt;&lt;/code&gt; tag; otherwise they will be ignored.&lt;br&gt;&lt;br&gt;Issue id: IncludeLayoutParam&lt;br&gt;&lt;br&gt;&lt;a href="https://stackoverflow.com/questions/2631614/does-android-xml-layouts-include-tag-really-work"&gt;https://stackoverflow.com/questions/2631614/does-android-xml-layouts-include-tag-really-work&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResourceType" defaultSeverity="ERROR" displayName="Wrong Resource Type" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Resource Type&lt;br&gt;&lt;br&gt;Ensures that resource id's passed to APIs are of the right type; for example, calling &lt;code&gt;Resources.getColor(R.string.name)&lt;/code&gt; is wrong.&lt;br&gt;&lt;br&gt;Issue id: ResourceType&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBrokenIterator" defaultSeverity="WARNING" displayName="Broken Iterator" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Broken Iterator&lt;br&gt;&lt;br&gt;&lt;b&gt;For LinkedHashMap:&lt;/b&gt;&lt;br/&gt;
&lt;br/&gt;
The spliterators returned by &lt;code&gt;LinkedHashMap&lt;/code&gt; in Android Nougat (API levels 24 and 25) use the wrong order (inconsistent with the iterators, which use the correct order), despite reporting &lt;code&gt;Spliterator.ORDERED&lt;/code&gt;. You may use the following code fragments to obtain a correctly ordered &lt;code&gt;Spliterator&lt;/code&gt; on API level 24 and 25:&lt;br/&gt;
&lt;br/&gt;
For a Collection view &lt;code&gt;c = lhm.entrySet()&lt;/code&gt;, &lt;code&gt;c = lhm.keySet()&lt;/code&gt; or &lt;code&gt;c = lhm.values()&lt;/code&gt;, use &lt;code&gt;java.util.Spliterators.spliterator(c, c.spliterator().characteristics())&lt;/code&gt; instead of &lt;code&gt;c.spliterator()&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Instead of &lt;code&gt;c.stream()&lt;/code&gt; or &lt;code&gt;c.parallelStream()&lt;/code&gt;, use &lt;code&gt;java.util.stream.StreamSupport.stream(spliterator, false)&lt;/code&gt; to construct a (nonparallel) Stream from such a &lt;code&gt;Spliterator&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;For Vector:&lt;/b&gt;&lt;br/&gt;
&lt;br/&gt;
The &lt;code&gt;listIterator()&lt;/code&gt; returned for a &lt;code&gt;Vector&lt;/code&gt; has a broken &lt;code&gt;add()&lt;/code&gt; implementation on Android N (API level 24). Consider switching to &lt;code&gt;ArrayList&lt;/code&gt; and if necessary adding synchronization.&lt;br&gt;&lt;br&gt;Issue id: BrokenIterator&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/util/LinkedHashMap"&gt;https://developer.android.com/reference/java/util/LinkedHashMap&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLogTagMismatch" defaultSeverity="ERROR" displayName="Mismatched Log Tags" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mismatched Log Tags&lt;br&gt;&lt;br&gt;When guarding a &lt;code&gt;Log.v(tag, ...)&lt;/code&gt; call with &lt;code&gt;Log.isLoggable(tag)&lt;/code&gt;, the tag passed to both calls should be the same. Similarly, the level passed in to &lt;code&gt;Log.isLoggable&lt;/code&gt; should typically match the type of &lt;code&gt;Log&lt;/code&gt; call, e.g. if checking level &lt;code&gt;Log.DEBUG&lt;/code&gt;, the corresponding &lt;code&gt;Log&lt;/code&gt; call should be &lt;code&gt;Log.d&lt;/code&gt;, not &lt;code&gt;Log.i&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: LogTagMismatch&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPrivacySandboxBlockedCall" defaultSeverity="WARNING" displayName="Call is blocked in the Privacy Sandbox" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Call is blocked in the Privacy Sandbox&lt;br&gt;&lt;br&gt;Many APIs are unavailable in the Privacy Sandbox, depending on the &lt;code&gt;targetSdk&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If your code is designed to run in the sandbox (and never outside the sandbox) then you should remove the blocked calls to avoid exceptions at runtime.&lt;br/&gt;
&lt;br/&gt;
If your code is part of a library that can be executed both inside and outside the sandbox, surround the code with &lt;code&gt;if (!Process.isSdkSandbox()) { ... }&lt;/code&gt; (or use your own field or method annotated with &lt;code&gt;@ChecksRestrictedEnvironment&lt;/code&gt;) to avoid executing blocked calls when in the sandbox. Or, add the &lt;code&gt;@RestrictedForEnvironment&lt;/code&gt; annotation to the containing method if the entire method should not be called when in the sandbox.&lt;br/&gt;
&lt;br/&gt;
This check is disabled by default, and should only be enabled in modules that may execute in the Privacy Sandbox.&lt;br&gt;&lt;br&gt;Issue id: PrivacySandboxBlockedCall&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateDefinition" defaultSeverity="ERROR" displayName="Duplicate definitions of resources" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate definitions of resources&lt;br&gt;&lt;br&gt;You can define a resource multiple times in different resource folders; that's how string translations are done, for example. However, defining the same resource more than once in the same resource folder is likely an error, for example attempting to add a new resource without realizing that the name is already used, and so on.&lt;br&gt;&lt;br&gt;Issue id: DuplicateDefinition&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringShouldBeInt" defaultSeverity="ERROR" displayName="String should be int" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;String should be int&lt;br&gt;&lt;br&gt;The properties &lt;code&gt;compileSdkVersion&lt;/code&gt;, &lt;code&gt;minSdkVersion&lt;/code&gt; and &lt;code&gt;targetSdkVersion&lt;/code&gt; are usually numbers, but can be strings when you are using an add-on (in the case of &lt;code&gt;compileSdkVersion&lt;/code&gt;) or a preview platform (for the other two properties).&lt;br/&gt;
&lt;br/&gt;
However, you can not use a number as a string (e.g. "19" instead of 19); that will result in a platform not found error message at build/sync time.&lt;br&gt;&lt;br&gt;Issue id: StringShouldBeInt&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDefaultUncaughtExceptionDelegation" defaultSeverity="WARNING" displayName="Missing default uncaught exception handler delegation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing default uncaught exception handler delegation&lt;br&gt;&lt;br&gt;A default uncaught exception handler should usually call the existing (previously set) default uncaught exception handler. This is especially true on Android, which uses a default uncaught exception handler to handle crashes. This lint check reports calls to &lt;code&gt;setDefaultUncaughtExceptionHandler&lt;/code&gt; unless we can also see a call to &lt;code&gt;getDefaultUncaughtExceptionHandler&lt;/code&gt; (to get the existing handler) in the same module. Make sure you also call &lt;code&gt;existingHandler.uncaughtException(thread, throwable)&lt;/code&gt; from your new handler.&lt;br&gt;&lt;br&gt;Issue id: DefaultUncaughtExceptionDelegation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleDependency" defaultSeverity="WARNING" displayName="Obsolete Gradle Dependency" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete Gradle Dependency&lt;br&gt;&lt;br&gt;This detector looks for usages of libraries where the version you are using is not the current stable release. Using older versions is fine, and there are cases where you deliberately want to stick with an older version. However, you may simply not be aware that a more recent version is available, and that is what this lint check helps find.&lt;br&gt;&lt;br&gt;Issue id: GradleDependency&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResourceName" defaultSeverity="ERROR" displayName="Resource with Wrong Prefix" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Resource with Wrong Prefix&lt;br&gt;&lt;br&gt;In Gradle projects you can specify a resource prefix that all resources in the project must conform to. This makes it easier to ensure that you don't accidentally combine resources from different libraries, since they all end up in the same shared app namespace.&lt;br&gt;&lt;br&gt;Issue id: ResourceName&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWifiManagerPotentialLeak" defaultSeverity="WARNING" displayName="WifiManager Potential Leak" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WifiManager Potential Leak&lt;br&gt;&lt;br&gt;On versions prior to Android N (24), initializing the &lt;code&gt;WifiManager&lt;/code&gt; via &lt;code&gt;Context#getSystemService&lt;/code&gt; can cause a memory leak if the context is not the application context.&lt;br/&gt;
&lt;br/&gt;
In many cases, it's not obvious from the code where the &lt;code&gt;Context&lt;/code&gt; is coming from (e.g. it might be a parameter to a method, or a field initialized from various method calls). It's possible that the context being passed in is the application context, but to be on the safe side, you should consider changing &lt;code&gt;context.getSystemService(...)&lt;/code&gt; to &lt;code&gt;context.getApplicationContext().getSystemService(...)&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: WifiManagerPotentialLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHalfFloat" defaultSeverity="ERROR" displayName="Incorrect Half Float" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect Half Float&lt;br&gt;&lt;br&gt;Half-precision floating point are stored in a short data type, and should be manipulated using the &lt;code&gt;android.util.Half&lt;/code&gt; class. This check flags usages where it appears that these values are used incorrectly.&lt;br&gt;&lt;br&gt;Issue id: HalfFloat&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOverrideAbstract" defaultSeverity="ERROR" displayName="Not overriding abstract methods on older platforms" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Not overriding abstract methods on older platforms&lt;br&gt;&lt;br&gt;To improve the usability of some APIs, some methods that used to be &lt;code&gt;abstract&lt;/code&gt; have been made concrete by adding default implementations. This means that when compiling with new versions of the SDK, your code does not have to override these methods.&lt;br/&gt;
&lt;br/&gt;
However, if your code is also targeting older versions of the platform where these methods were still &lt;code&gt;abstract&lt;/code&gt;, the code will crash. You must override all methods that used to be abstract in any versions targeted by your application's &lt;code&gt;minSdkVersion&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: OverrideAbstract&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEnqueueWork" defaultSeverity="WARNING" displayName="WorkManager Enqueue" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WorkManager Enqueue&lt;br&gt;&lt;br&gt;&lt;code&gt;WorkContinuations&lt;/code&gt; cannot be enqueued automatically.  You must call &lt;code&gt;enqueue()&lt;/code&gt; on a &lt;code&gt;WorkContinuation&lt;/code&gt; to have it and its parent continuations enqueued inside &lt;code&gt;WorkManager&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: EnqueueWork&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFontValidation" defaultSeverity="ERROR" displayName="Validation of font files" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Validation of font files&lt;br&gt;&lt;br&gt;Look for problems in various font files.&lt;br&gt;&lt;br&gt;Issue id: FontValidation&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/text/downloadable-fonts.html"&gt;https://developer.android.com/guide/topics/text/downloadable-fonts.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSuspiciousImport" defaultSeverity="WARNING" displayName="'import android.R' statement" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;'&lt;code&gt;import android.R&lt;/code&gt;' statement&lt;br&gt;&lt;br&gt;Importing &lt;code&gt;android.R&lt;/code&gt; is usually not intentional; it sometimes happens when you use an IDE and ask it to automatically add imports at a time when your project's R class it not present.&lt;br/&gt;
&lt;br/&gt;
Once the import is there you might get a lot of "confusing" error messages because of course the fields available on &lt;code&gt;android.R&lt;/code&gt; are not the ones you'd expect from just looking at your own &lt;code&gt;R&lt;/code&gt; class.&lt;br&gt;&lt;br&gt;Issue id: SuspiciousImport&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNonConstantResourceId" defaultSeverity="WARNING" displayName="Checks use of resource IDs in places requiring constants" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Checks use of resource IDs in places requiring constants&lt;br&gt;&lt;br&gt;Avoid the usage of resource IDs where constant expressions are required.&lt;br/&gt;
&lt;br/&gt;
A future version of the Android Gradle Plugin will generate R classes with non-constant IDs in order to improve the performance of incremental compilation.&lt;br&gt;&lt;br&gt;Issue id: NonConstantResourceId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintProguard" defaultSeverity="ERROR" displayName="Using obsolete ProGuard configuration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using obsolete ProGuard configuration&lt;br&gt;&lt;br&gt;Using &lt;code&gt;-keepclasseswithmembernames&lt;/code&gt; in a proguard config file is not correct; it can cause some symbols to be renamed which should not be.&lt;br/&gt;
&lt;br/&gt;
Earlier versions of ADT used to create proguard.cfg files with the wrong format. Instead of &lt;code&gt;-keepclasseswithmembernames&lt;/code&gt; use &lt;code&gt;-keepclasseswithmembers&lt;/code&gt;, since the old flags also implies "allow shrinking" which means symbols only referred to from XML and not Java (such as possibly CustomViews) can get deleted.&lt;br&gt;&lt;br&gt;Issue id: Proguard&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/36928077"&gt;https://issuetracker.google.com/36928077&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintValidActionsXml" defaultSeverity="ERROR" displayName="Invalid Action Descriptor" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Action Descriptor&lt;br&gt;&lt;br&gt;Ensures that an actions XML file is properly formed&lt;br&gt;&lt;br&gt;Issue id: ValidActionsXml&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingLeanbackLauncher" defaultSeverity="ERROR" displayName="Missing Leanback Launcher Intent Filter" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Leanback Launcher Intent Filter&lt;br&gt;&lt;br&gt;An application intended to run on TV devices must declare a launcher activity for TV in its manifest using a &lt;code&gt;android.intent.category.LEANBACK_LAUNCHER&lt;/code&gt; intent filter.&lt;br&gt;&lt;br&gt;Issue id: MissingLeanbackLauncher&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/tv/start/start.html#tv-activity"&gt;https://developer.android.com/training/tv/start/start.html#tv-activity&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDiffUtilEquals" defaultSeverity="ERROR" displayName="Suspicious DiffUtil Equality" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious DiffUtil Equality&lt;br&gt;&lt;br&gt;&lt;code&gt;areContentsTheSame&lt;/code&gt; is used by &lt;code&gt;DiffUtil&lt;/code&gt; to produce diffs. If the method is implemented incorrectly, such as using identity equals instead of equals, or calling equals on a class that has not implemented it, weird visual artifacts can occur.&lt;br&gt;&lt;br&gt;Issue id: DiffUtilEquals&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/116789824"&gt;https://issuetracker.google.com/116789824&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPrivateApi" defaultSeverity="WARNING" displayName="Using Private APIs" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Private APIs&lt;br&gt;&lt;br&gt;Using reflection to access hidden/private Android APIs is not safe; it will often not work on devices from other vendors, and it may suddenly stop working (if the API is removed) or crash spectacularly (if the API behavior changes, since there are no guarantees for compatibility).&lt;br&gt;&lt;br&gt;Issue id: PrivateApi&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces"&gt;https://developer.android.com/preview/restrictions-non-sdk-interfaces&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWifiManagerLeak" defaultSeverity="ERROR" displayName="WifiManager Leak" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WifiManager Leak&lt;br&gt;&lt;br&gt;On versions prior to Android N (24), initializing the &lt;code&gt;WifiManager&lt;/code&gt; via &lt;code&gt;Context#getSystemService&lt;/code&gt; can cause a memory leak if the context is not the application context. Change &lt;code&gt;context.getSystemService(...)&lt;/code&gt; to &lt;code&gt;context.getApplicationContext().getSystemService(...)&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: WifiManagerLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintScrollViewSize" defaultSeverity="WARNING" displayName="ScrollView size validation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;ScrollView size validation&lt;br&gt;&lt;br&gt;ScrollView children must set their &lt;code&gt;layout_width&lt;/code&gt; or &lt;code&gt;layout_height&lt;/code&gt; attributes to &lt;code&gt;wrap_content&lt;/code&gt; rather than &lt;code&gt;fill_parent&lt;/code&gt; or &lt;code&gt;match_parent&lt;/code&gt; in the scrolling dimension.&lt;br&gt;&lt;br&gt;Issue id: ScrollViewSize&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintShiftFlags" defaultSeverity="WARNING" displayName="Dangerous Flag Constant Declaration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Dangerous Flag Constant Declaration&lt;br&gt;&lt;br&gt;When defining multiple constants for use in flags, the recommended style is to use the form &lt;code&gt;1 &amp;lt;&amp;lt; 2&lt;/code&gt;, &lt;code&gt;1 &amp;lt;&amp;lt; 3&lt;/code&gt;, &lt;code&gt;1 &amp;lt;&amp;lt; 4&lt;/code&gt; and so on to ensure that the constants are unique and non-overlapping.&lt;br&gt;&lt;br&gt;Issue id: ShiftFlags&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStateListReachable" defaultSeverity="WARNING" displayName="Unreachable state in a &lt;selector&gt;" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unreachable state in a &lt;code&gt;&amp;lt;selector&gt;&lt;/code&gt;&lt;br&gt;&lt;br&gt;In a selector, only the last child in the state list should omit a state qualifier. If not, all subsequent items in the list will be ignored since the given item will match all.&lt;br&gt;&lt;br&gt;Issue id: StateListReachable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateIncludedIds" defaultSeverity="WARNING" displayName="Duplicate ids across layouts combined with include tags" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate ids across layouts combined with include tags&lt;br&gt;&lt;br&gt;It's okay for two independent layouts to use the same ids. However, if layouts are combined with include tags, then the id's need to be unique within any chain of included layouts, or &lt;code&gt;Activity#findViewById()&lt;/code&gt; can return an unexpected view.&lt;br&gt;&lt;br&gt;Issue id: DuplicateIncludedIds&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCommitPrefEdits" defaultSeverity="WARNING" displayName="Missing commit() on SharedPreference editor" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;commit()&lt;/code&gt; on &lt;code&gt;SharedPreference&lt;/code&gt; editor&lt;br&gt;&lt;br&gt;After calling &lt;code&gt;edit()&lt;/code&gt; on a &lt;code&gt;SharedPreference&lt;/code&gt;, you must call &lt;code&gt;commit()&lt;/code&gt; or &lt;code&gt;apply()&lt;/code&gt; on the editor to save the results.&lt;br&gt;&lt;br&gt;Issue id: CommitPrefEdits&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintImpliedQuantity" defaultSeverity="ERROR" displayName="Implied Quantities" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implied Quantities&lt;br&gt;&lt;br&gt;Plural strings should generally include a &lt;code&gt;%s&lt;/code&gt; or &lt;code&gt;%d&lt;/code&gt; formatting argument. In locales like English, the &lt;code&gt;one&lt;/code&gt; quantity only applies to a single value, 1, but that's not true everywhere. For example, in Slovene, the &lt;code&gt;one&lt;/code&gt; quantity will apply to 1, 101, 201, 301, and so on. Similarly, there are locales where multiple values match the &lt;code&gt;zero&lt;/code&gt; and &lt;code&gt;two&lt;/code&gt; quantities.&lt;br/&gt;
&lt;br/&gt;
In these locales, it is usually an error to have a message which does not include a formatting argument (such as '%d'), since it will not be clear from the grammar what quantity the quantity string is describing.&lt;br&gt;&lt;br&gt;Issue id: ImpliedQuantity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html#Plurals"&gt;https://developer.android.com/guide/topics/resources/string-resource.html#Plurals&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGestureBackNavigation" defaultSeverity="WARNING" displayName="Usage of KeyEvent.KEYCODE_BACK" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Usage of KeyEvent.KEYCODE_BACK&lt;br&gt;&lt;br&gt;For apps targeting and running on Android 16+ (API 36+), predictive back animations are enabled by default. A back gesture does not trigger &lt;code&gt;{Activity,Dialog}.onBackPressed&lt;/code&gt;, and does not dispatch &lt;code&gt;KeyEvent.KEYCODE_BACK&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Apps should migrate to AndroidX's backward compatible &lt;code&gt;OnBackPressedDispatcher&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
This lint check does not consider per-activity opt-in/opt-out, so you may need to suppress or baseline reported incidents if migrating per-activity.&lt;br&gt;&lt;br&gt;Issue id: GestureBackNavigation&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/navigation/custom-back/predictive-back-gesture"&gt;https://developer.android.com/guide/navigation/custom-back/predictive-back-gesture&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCredentialDependency" defaultSeverity="WARNING" displayName="credentials-play-services-auth is Required" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;credentials-play-services-auth&lt;/code&gt; is Required&lt;br&gt;&lt;br&gt;The dependency &lt;code&gt;androidx.credentials:credentials-play-services-auth&lt;/code&gt; is required for Android 13 and below to get support from Play services for the Credential Manager API (&lt;code&gt;androidx.credentials:credentials&lt;/code&gt;) to work. For Android 14 and above, this is optional. Please check release notes for the latest version.&lt;br&gt;&lt;br&gt;Issue id: CredentialDependency&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/jetpack/androidx/releases/credentials"&gt;https://developer.android.com/jetpack/androidx/releases/credentials&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNewerVersionAvailable" defaultSeverity="WARNING" displayName="Newer Library Versions Available" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Newer Library Versions Available&lt;br&gt;&lt;br&gt;This detector checks with a central repository to see if there are newer versions available for the dependencies used by this project. This is similar to the &lt;code&gt;GradleDependency&lt;/code&gt; check, which checks for newer versions available in the Android SDK tools and libraries, but this works with any MavenCentral dependency, and connects to the library every time, which makes it more flexible but also &lt;b&gt;much&lt;/b&gt; slower.&lt;br&gt;&lt;br&gt;Issue id: NewerVersionAvailable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnknownId" defaultSeverity="ERROR" displayName="Reference to an unknown id" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Reference to an unknown id&lt;br&gt;&lt;br&gt;The &lt;code&gt;@+id/&lt;/code&gt; syntax refers to an existing id, or creates a new one if it has not already been defined elsewhere. However, this means that if you have a typo in your reference, or if the referred view no longer exists, you do not get a warning since the id will be created on demand. This check catches errors where you have renamed an id without updating all of the references to it.&lt;br&gt;&lt;br&gt;Issue id: UnknownId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleOverrides" defaultSeverity="WARNING" displayName="Value overridden by Gradle build script" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Value overridden by Gradle build script&lt;br&gt;&lt;br&gt;The value of (for example) &lt;code&gt;minSdkVersion&lt;/code&gt; is only used if it is not specified in the &lt;code&gt;build.gradle&lt;/code&gt; build scripts. When specified in the Gradle build scripts, the manifest value is ignored and can be misleading, so should be removed to avoid ambiguity.&lt;br&gt;&lt;br&gt;Issue id: GradleOverrides&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongThread" defaultSeverity="ERROR" displayName="Wrong Thread" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Thread&lt;br&gt;&lt;br&gt;Ensures that a method which expects to be called on a specific thread, is actually called from that thread. For example, calls on methods in widgets should always be made on the UI thread.&lt;br&gt;&lt;br&gt;Issue id: WrongThread&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/processes-and-threads.html#Threads"&gt;https://developer.android.com/guide/components/processes-and-threads.html#Threads&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingDefaultResource" defaultSeverity="ERROR" displayName="Missing Default" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Default&lt;br&gt;&lt;br&gt;If a resource is only defined in folders with qualifiers like &lt;code&gt;-land&lt;/code&gt; or &lt;code&gt;-en&lt;/code&gt;, and there is no default declaration in the base folder (&lt;code&gt;layout&lt;/code&gt; or &lt;code&gt;values&lt;/code&gt; etc), then the app will crash if that resource is accessed on a device where the device is in a configuration missing the given qualifier.&lt;br/&gt;
&lt;br/&gt;
As a special case, drawables do not have to be specified in the base folder; if there is a match in a density folder (such as &lt;code&gt;drawable-mdpi&lt;/code&gt;) that image will be used and scaled. Note however that if you  only specify a drawable in a folder like &lt;code&gt;drawable-en-hdpi&lt;/code&gt;, the app will crash in non-English locales.&lt;br/&gt;
&lt;br/&gt;
There may be scenarios where you have a resource, such as a &lt;code&gt;-fr&lt;/code&gt; drawable, which is only referenced from some other resource with the same qualifiers (such as a &lt;code&gt;-fr&lt;/code&gt; style), which itself has safe fallbacks. However, this still makes it possible for somebody to accidentally reference the drawable and crash, so it is safer to create a default fallback in the base folder. Alternatively, you can suppress the issue by adding &lt;code&gt;tools:ignore="MissingDefaultResource"&lt;/code&gt; on the element.&lt;br/&gt;
&lt;br/&gt;
(This scenario frequently happens with string translations, where you might delete code and the corresponding resources, but forget to delete a translation. There is a dedicated issue id for that scenario, with the id &lt;code&gt;ExtraTranslation&lt;/code&gt;.)&lt;br&gt;&lt;br&gt;Issue id: MissingDefaultResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppLinkUrlError" defaultSeverity="ERROR" displayName="URI invalid" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;URI invalid&lt;br&gt;&lt;br&gt;Ensure your intent filter has the documented elements for deep links, web links, or Android App Links.&lt;br&gt;&lt;br&gt;Issue id: AppLinkUrlError&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/app-links"&gt;https://developer.android.com/training/app-links&lt;/a&gt;&lt;br&gt;&lt;a href="https://g.co/AppIndexing/AndroidStudio"&gt;https://g.co/AppIndexing/AndroidStudio&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMotionLayoutInvalidSceneFileReference" defaultSeverity="ERROR" displayName="layoutDescription must specify a scene file" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;layoutDescription must specify a scene file&lt;br&gt;&lt;br&gt;A motion scene file specifies the animations used in a &lt;code&gt;MotionLayout&lt;/code&gt;. The &lt;code&gt;layoutDescription&lt;/code&gt; is required to specify a valid motion scene file.&lt;br&gt;&lt;br&gt;Issue id: MotionLayoutInvalidSceneFileReference&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHighSamplingRate" defaultSeverity="WARNING" displayName="High sensor sampling rate" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;High sensor sampling rate&lt;br&gt;&lt;br&gt;Most apps don't need access to high sensor sampling rate. Double check your use case to ensure your app absolutely needs access to sensor sampling rate &gt; 200Hz. Be prepared for your app to be rejected from listing on Play Store until your use case for high sensor sampling rate has been reviewed and validated by the policy team.&lt;br&gt;&lt;br&gt;Issue id: HighSamplingRate&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOldTargetApi" defaultSeverity="WARNING" displayName="Target SDK attribute is not targeting latest version" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Target SDK attribute is not targeting latest version&lt;br&gt;&lt;br&gt;When your application or sdk runs on a version of Android that is more recent than your &lt;code&gt;targetSdkVersion&lt;/code&gt; specifies that it has been tested with, various compatibility modes kick in. This ensures that your application continues to work, but it may look out of place. For example, if the &lt;code&gt;targetSdkVersion&lt;/code&gt; is less than 14, your app may get an option button in the UI.&lt;br/&gt;
&lt;br/&gt;
To fix this issue, set the &lt;code&gt;targetSdkVersion&lt;/code&gt; to the highest available value. Then test your app to make sure everything works correctly. You may want to consult the compatibility notes to see what changes apply to each version you are adding support for: &lt;a href="https://developer.android.com/reference/android/os/Build.VERSION_CODES.html"&gt;https://developer.android.com/reference/android/os/Build.VERSION_CODES.html&lt;/a&gt; as well as follow this guide:&lt;br/&gt;
&lt;a href="https://developer.android.com/distribute/best-practices/develop/target-sdk.html"&gt;https://developer.android.com/distribute/best-practices/develop/target-sdk.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: OldTargetApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSourceLockedOrientationActivity" defaultSeverity="WARNING" displayName="Incompatible setRequestedOrientation value" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incompatible setRequestedOrientation value&lt;br&gt;&lt;br&gt;The &lt;code&gt;Activity&lt;/code&gt; should not be locked to a portrait orientation so that users can take advantage of the multi-window environments and larger landscape-first screens that Android runs on such as ChromeOS, tablets, and foldables. To fix the issue, consider calling &lt;code&gt;setRequestedOrientation&lt;/code&gt; with the &lt;code&gt;ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR&lt;/code&gt; or &lt;code&gt;ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED&lt;/code&gt; options or removing the call all together.&lt;br&gt;&lt;br&gt;Issue id: SourceLockedOrientationActivity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/large-screens/large-screen-cookbook#restricted_app_orientation"&gt;https://developer.android.com/guide/topics/large-screens/large-screen-cookbook#restricted_app_orientation&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInconsistentArrays" defaultSeverity="WARNING" displayName="Inconsistencies in array element counts" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Inconsistencies in array element counts&lt;br&gt;&lt;br&gt;When an array is translated in a different locale, it should normally have the same number of elements as the original array. When adding or removing elements to an array, it is easy to forget to update all the locales, and this lint warning finds inconsistencies like these.&lt;br/&gt;
&lt;br/&gt;
Note however that there may be cases where you really want to declare a different number of array items in each configuration (for example where the array represents available options, and those options differ for different layout orientations and so on), so use your own judgment to decide if this is really an error.&lt;br/&gt;
&lt;br/&gt;
You can suppress this error type if it finds false errors in your project.&lt;br&gt;&lt;br&gt;Issue id: InconsistentArrays&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOrientation" defaultSeverity="ERROR" displayName="Missing explicit orientation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing explicit orientation&lt;br&gt;&lt;br&gt;The default orientation of a &lt;code&gt;LinearLayout&lt;/code&gt; is horizontal. It's pretty easy to believe that the layout is vertical, add multiple children to it, and wonder why only the first child is visible (when the subsequent children are off screen to the right). This lint rule helps pinpoint this issue by warning whenever a &lt;code&gt;LinearLayout&lt;/code&gt; is used with an implicit orientation and multiple children.&lt;br/&gt;
&lt;br/&gt;
It also checks for empty LinearLayouts without an &lt;code&gt;orientation&lt;/code&gt; attribute that also defines an &lt;code&gt;id&lt;/code&gt; attribute. This catches the scenarios where children will be added to the &lt;code&gt;LinearLayout&lt;/code&gt; dynamically. &lt;br&gt;&lt;br&gt;Issue id: Orientation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingFirebaseInstanceTokenRefresh" defaultSeverity="WARNING" displayName="Missing Firebase Messaging Callback" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Firebase Messaging Callback&lt;br&gt;&lt;br&gt;Apps that use Firebase Cloud Messaging should implement the &lt;code&gt;FirebaseMessagingService#onNewToken()&lt;/code&gt; callback in order to observe token changes.&lt;br&gt;&lt;br&gt;Issue id: MissingFirebaseInstanceTokenRefresh&lt;br&gt;&lt;br&gt;&lt;a href="https://firebase.google.com/docs/cloud-messaging/android/client#monitor-token-generation"&gt;https://firebase.google.com/docs/cloud-messaging/android/client#monitor-token-generation&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintServiceCast" defaultSeverity="ERROR" displayName="Wrong system service casts" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong system service casts&lt;br&gt;&lt;br&gt;When you call &lt;code&gt;Context#getSystemService()&lt;/code&gt;, the result is typically cast to a specific interface. This lint check ensures that the cast is compatible with the expected type of the return value.&lt;br&gt;&lt;br&gt;Issue id: ServiceCast&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInstantiatable" defaultSeverity="ERROR" displayName="Registered class is not instantiatable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Registered class is not instantiatable&lt;br&gt;&lt;br&gt;Activities, services, broadcast receivers etc. registered in the manifest file (or for custom views, in a layout file) must be "instantiatable" by the system, which means that the class must be public, it must have an empty public constructor, and if it's an inner class, it must be a static inner class.&lt;br/&gt;
&lt;br/&gt;
If you use a custom &lt;code&gt;AppComponentFactory&lt;/code&gt; to instantiate app components yourself, consider disabling this Lint issue in order to avoid false positives.&lt;br&gt;&lt;br&gt;Issue id: Instantiatable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongViewCast" defaultSeverity="ERROR" displayName="Mismatched view type" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mismatched view type&lt;br&gt;&lt;br&gt;Keeps track of the view types associated with ids and if it finds a usage of the id in the Java code it ensures that it is treated as the same type.&lt;br&gt;&lt;br&gt;Issue id: WrongViewCast&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPropertyEscape" defaultSeverity="ERROR" displayName="Incorrect property escapes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect property escapes&lt;br&gt;&lt;br&gt;All backslashes and colons in .property files must be escaped with a backslash (). This means that when writing a Windows path, you must escape the file separators, so the path MyFiles should be written as &lt;code&gt;key=\\My\\Files.&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: PropertyEscape&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBomWithoutPlatform" defaultSeverity="WARNING" displayName="Using a BOM without platform call" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using a BOM without platform call&lt;br&gt;&lt;br&gt;When including a BOM, the dependency's coordinates must be wrapped in a call to &lt;code&gt;platform()&lt;/code&gt; for Gradle to interpret it correctly.&lt;br&gt;&lt;br&gt;Issue id: BomWithoutPlatform&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/r/tools/gradle-bom-docs"&gt;https://developer.android.com/r/tools/gradle-bom-docs&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingPermission" defaultSeverity="ERROR" displayName="Missing Permissions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Permissions&lt;br&gt;&lt;br&gt;This check scans through your code and libraries and looks at the APIs being used, and checks this against the set of permissions required to access those APIs. If the code using those APIs is called at runtime, then the program will crash.&lt;br/&gt;
&lt;br/&gt;
Furthermore, for permissions that are revocable (with &lt;code&gt;targetSdkVersion&lt;/code&gt; 23), client code must also be prepared to handle the calls throwing an exception if the user rejects the request for permission at runtime.&lt;br&gt;&lt;br&gt;Issue id: MissingPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLibraryCustomView" defaultSeverity="ERROR" displayName="Custom views in libraries should use res-auto-namespace" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Custom views in libraries should use res-auto-namespace&lt;br&gt;&lt;br&gt;When using a custom view with custom attributes in a library project, the layout must use the special namespace &lt;a href="http://schemas.android.com/apk/res-auto"&gt;http://schemas.android.com/apk/res-auto&lt;/a&gt; instead of a URI which includes the library project's own package. This will be used to automatically adjust the namespace of the attributes when the library resources are merged into the application project.&lt;br&gt;&lt;br&gt;Issue id: LibraryCustomView&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradlePath" defaultSeverity="WARNING" displayName="Gradle Path Issues" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Gradle Path Issues&lt;br&gt;&lt;br&gt;Gradle build scripts are meant to be cross platform, so file paths use Unix-style path separators (a forward slash) rather than Windows path separators (a backslash). Similarly, to keep projects portable and repeatable, avoid using absolute paths on the system; keep files within the project instead. To share code between projects, consider creating an android-library and an AAR dependency&lt;br&gt;&lt;br&gt;Issue id: GradlePath&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExtraText" defaultSeverity="ERROR" displayName="Extraneous text in resource files" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Extraneous text in resource files&lt;br&gt;&lt;br&gt;Non-value resource files should only contain elements and attributes. Any XML text content found in the file is likely accidental (and potentially dangerous if the text resembles XML and the developer believes the text to be functional).&lt;br&gt;&lt;br&gt;Issue id: ExtraText&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHighAppVersionCode" defaultSeverity="ERROR" displayName="VersionCode too high" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;VersionCode too high&lt;br&gt;&lt;br&gt;The declared &lt;code&gt;versionCode&lt;/code&gt; is an Integer. Ensure that the version number is not close to the limit. It is recommended to monotonically increase this number each minor or major release of the app. Note that updating an app with a versionCode over &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; is not possible.&lt;br&gt;&lt;br&gt;Issue id: HighAppVersionCode&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/studio/publish/versioning.html"&gt;https://developer.android.com/studio/publish/versioning.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseSdkSuppress" defaultSeverity="ERROR" displayName="Using @SdkSuppress instead of @RequiresApi" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;@SdkSuppress&lt;/code&gt; instead of &lt;code&gt;@RequiresApi&lt;/code&gt;&lt;br&gt;&lt;br&gt;In tests, you should be using &lt;code&gt;@SdkSuppress&lt;/code&gt; instead of &lt;code&gt;@RequiresApi&lt;/code&gt;. The &lt;code&gt;@RequiresApi&lt;/code&gt; annotation is used to propagate a version requirement out to the caller of the API -- but the testing framework is only looking for &lt;code&gt;@SdkSuppress&lt;/code&gt;, which it uses to skip tests that are intended for newer versions.&lt;br&gt;&lt;br&gt;Issue id: UseSdkSuppress&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUntranslatable" defaultSeverity="WARNING" displayName="Translated Untranslatable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Translated Untranslatable&lt;br&gt;&lt;br&gt;Strings can be marked with &lt;code&gt;translatable=false&lt;/code&gt; to indicate that they are not intended to be translated, but are present in the resource file for other purposes (for example for non-display strings that should vary by some other configuration qualifier such as screen size or API level).&lt;br/&gt;
&lt;br/&gt;
There are cases where translators accidentally translate these strings anyway, and lint will flag these occurrences with this lint check.&lt;br&gt;&lt;br&gt;Issue id: Untranslatable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppCompatResource" defaultSeverity="ERROR" displayName="Menu namespace" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Menu namespace&lt;br&gt;&lt;br&gt;When using the appcompat library, menu resources should refer to the &lt;code&gt;showAsAction&lt;/code&gt; (or &lt;code&gt;actionViewClass&lt;/code&gt;, or &lt;code&gt;actionProviderClass&lt;/code&gt;) in the &lt;code&gt;app:&lt;/code&gt; namespace, not the &lt;code&gt;android:&lt;/code&gt; namespace.&lt;br/&gt;
&lt;br/&gt;
Similarly, when &lt;b&gt;not&lt;/b&gt; using the appcompat library, you should be using the &lt;code&gt;android:showAsAction&lt;/code&gt; (or &lt;code&gt;actionViewClass&lt;/code&gt;, or &lt;code&gt;actionProviderClass&lt;/code&gt;) attribute.&lt;br&gt;&lt;br&gt;Issue id: AppCompatResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingVersion" defaultSeverity="WARNING" displayName="Missing application name/version" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing application name/version&lt;br&gt;&lt;br&gt;You should define the version information for your application.&lt;br/&gt;
&lt;br/&gt;
&lt;code&gt;android:versionCode&lt;/code&gt;: An integer value that represents the version of the application code, relative to other versions.&lt;br/&gt;
&lt;br/&gt;
&lt;code&gt;android:versionName&lt;/code&gt;: A string value that represents the release version of the application code, as it should be shown to users.&lt;br&gt;&lt;br&gt;Issue id: MissingVersion&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/studio/publish/versioning#appversioning"&gt;https://developer.android.com/studio/publish/versioning#appversioning&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExtraTranslation" defaultSeverity="ERROR" displayName="Extra translation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Extra translation&lt;br&gt;&lt;br&gt;If a string appears in a specific language translation file, but there is no corresponding string in the default locale, then this string is probably unused. (It's technically possible that your application is only intended to run in a specific locale, but it's still a good idea to provide a fallback.)&lt;br/&gt;
&lt;br/&gt;
Note that these strings can lead to crashes if the string is looked up on any locale not providing a translation, so it's important to clean them up.&lt;br&gt;&lt;br&gt;Issue id: ExtraTranslation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGetLocales" defaultSeverity="ERROR" displayName="Locale crash" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Locale crash&lt;br&gt;&lt;br&gt;This check looks for usage of Lollipop-style locale folders (e.g. 3 letter language codes, or BCP 47 qualifiers) combined with an &lt;code&gt;AssetManager#getLocales()&lt;/code&gt; call. This leads to crashes&lt;br&gt;&lt;br&gt;Issue id: GetLocales&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTrimLambda" defaultSeverity="WEAK WARNING" displayName="Unnecessary lambda with trim()" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unnecessary lambda with &lt;code&gt;trim()&lt;/code&gt;&lt;br&gt;&lt;br&gt;The Kotlin standard library &lt;code&gt;trim()&lt;/code&gt; call takes an optional lambda to specify which characters are considered whitespace.&lt;br/&gt;
&lt;br/&gt;
When converting Java code to Kotlin code, the converter will convert calls for Java's &lt;code&gt;s.trim()&lt;/code&gt; into &lt;code&gt;s.trim() { it &amp;lt;= ' ' }&lt;/code&gt;. This preserves the exact semantics of the Java code, but is likely not what you want: the default in Kotlin uses a better definition of what constitutes a whitespace character (&lt;code&gt;Char::isWhitespace&lt;/code&gt;) and also results in less bytecode at the call-site.&lt;br&gt;&lt;br&gt;Issue id: TrimLambda&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCommitTransaction" defaultSeverity="WARNING" displayName="Missing commit() calls" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;commit()&lt;/code&gt; calls&lt;br&gt;&lt;br&gt;After creating a &lt;code&gt;FragmentTransaction&lt;/code&gt;, you typically need to commit it as well&lt;br&gt;&lt;br&gt;Issue id: CommitTransaction&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintJobSchedulerService" defaultSeverity="WARNING" displayName="JobScheduler problems" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;JobScheduler problems&lt;br&gt;&lt;br&gt;This check looks for various common mistakes in using the JobScheduler API: the service class must extend &lt;code&gt;JobService&lt;/code&gt;, the service must be registered in the manifest and the registration must require the permission &lt;code&gt;android.permission.BIND_JOB_SERVICE&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: JobSchedulerService&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/performance/scheduling.html"&gt;https://developer.android.com/topic/performance/scheduling.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidVectorPath" defaultSeverity="ERROR" displayName="Invalid vector paths" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid vector paths&lt;br&gt;&lt;br&gt;This check ensures that vector paths are valid. For example, it makes sure that the numbers are not using scientific notation (such as 1.0e3) which can lead to runtime crashes on older devices. As another example, it flags numbers like &lt;code&gt;.5&lt;/code&gt; which should be written as &lt;code&gt;0.5&lt;/code&gt; instead to avoid crashes on some pre-Marshmallow devices.&lt;br&gt;&lt;br&gt;Issue id: InvalidVectorPath&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/37008268"&gt;https://issuetracker.google.com/37008268&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMotionSceneFileValidationError" defaultSeverity="ERROR" displayName="Validation errors in MotionScene files" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Validation errors in &lt;code&gt;MotionScene&lt;/code&gt; files&lt;br&gt;&lt;br&gt;A motion scene file specifies the animations used in a &lt;code&gt;MotionLayout&lt;/code&gt;. This check performs various serious correctness checks in a motion scene file.&lt;br&gt;&lt;br&gt;Issue id: MotionSceneFileValidationError&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWatchFaceForAndroidX" defaultSeverity="WARNING" displayName="AndroidX watch faces must use action WATCH_FACE_EDITOR" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;AndroidX watch faces must use action &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt;&lt;br&gt;&lt;br&gt;If the package depends on &lt;code&gt;androidx.wear:wear-watchface&lt;/code&gt;, and an AndroidX watch face declares the &lt;code&gt;wearableConfigurationAction&lt;/code&gt; metadata, its value should be &lt;code&gt;androidx.wear.watchface.editor.action.WATCH_FACE_EDITOR&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: WatchFaceForAndroidX&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/watch-faces/configuration"&gt;https://developer.android.com/training/wearables/watch-faces/configuration&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearMaterialTheme" defaultSeverity="ERROR" displayName="Using not non-Wear MaterialTheme in a Wear OS project" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using not non-Wear &lt;code&gt;MaterialTheme&lt;/code&gt; in a Wear OS project&lt;br&gt;&lt;br&gt;Wear projects should use &lt;code&gt;androidx.wear.compose.material.MaterialTheme&lt;/code&gt; instead of &lt;code&gt;androidx.compose.material.MaterialTheme&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: WearMaterialTheme&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPluralsCandidate" defaultSeverity="WARNING" displayName="Potential Plurals" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Potential Plurals&lt;br&gt;&lt;br&gt;This lint check looks for potential errors in internationalization where you have translated a message which involves a quantity and it looks like other parts of the string may need grammatical changes.&lt;br/&gt;
&lt;br/&gt;
For example, rather than something like this:
&lt;pre&gt;
  &amp;lt;string name="try_again"&gt;Try again in %d seconds.&amp;lt;/string&gt;
&lt;/pre&gt;
you should be using a plural:
&lt;pre&gt;
   &amp;lt;plurals name="try_again"&gt;
        &amp;lt;item quantity="one"&gt;Try again in %d second&amp;lt;/item&gt;
        &amp;lt;item quantity="other"&gt;Try again in %d seconds&amp;lt;/item&gt;
    &amp;lt;/plurals&gt;
&lt;/pre&gt;
This will ensure that in other languages the right set of translations are provided for the different quantity classes.&lt;br/&gt;
&lt;br/&gt;
(This check depends on some heuristics, so it may not accurately determine whether a string really should be a quantity. You can use tools:ignore to filter out false positives.&lt;br&gt;&lt;br&gt;Issue id: PluralsCandidate&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html#Plurals"&gt;https://developer.android.com/guide/topics/resources/string-resource.html#Plurals&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingPrefix" defaultSeverity="ERROR" displayName="Missing Android XML namespace" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Android XML namespace&lt;br&gt;&lt;br&gt;Most Android views have attributes in the Android namespace. When referencing these attributes you &lt;b&gt;must&lt;/b&gt; include the namespace prefix, or your attribute will be interpreted by &lt;code&gt;aapt&lt;/code&gt; as just a custom attribute.&lt;br/&gt;
&lt;br/&gt;
Similarly, in manifest files, nearly all attributes should be in the &lt;code&gt;android:&lt;/code&gt; namespace.&lt;br&gt;&lt;br&gt;Issue id: MissingPrefix&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSuspiciousIndentation" defaultSeverity="ERROR" displayName="Suspicious indentation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious indentation&lt;br&gt;&lt;br&gt;This check looks for cases where the indentation suggests a grouping that isn't actually there in the code. A common example of this would be something like
&lt;pre&gt;
if (column &gt; width)
    line++
    column = 0
&lt;/pre&gt;
Here, the &lt;code&gt;column = 0&lt;/code&gt; line will be executed every single time, not just if the condition is true.&lt;br&gt;&lt;br&gt;Issue id: SuspiciousIndentation&lt;br&gt;&lt;br&gt;Available options:&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;always-run&lt;/b&gt; (default is false):&lt;br/&gt;
Whether this check should be included while editing.&lt;br/&gt;
&lt;br/&gt;
While you're editing, it's common to have a temporary situation where you have suspicious indentation scenarios -- e.g. you start typing an &lt;code&gt;if&lt;/code&gt; statement on the line above something you want to make conditional, and you haven't indented it yet. It can be distracting and misleading to suddenly have both statements light up as errors. Therefore, lint will avoid including this check when running on the fly in the editor, unless it looks like the file has not been recently edited. With this option, you can turn it on in all cases.&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="SuspiciousIndentation"&gt;
        &amp;lt;option name="always-run" value="false" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNfcTechWhitespace" defaultSeverity="ERROR" displayName="Whitespace in NFC tech lists" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Whitespace in NFC tech lists&lt;br&gt;&lt;br&gt;In a &lt;code&gt;&amp;lt;tech-list&gt;&lt;/code&gt;, there can be whitespace around the &lt;code&gt;&amp;lt;tech&gt;&lt;/code&gt; elements,but not inside them. This is because the code which reads in the tech list is currently very strict and will include the whitespace as part of the name.&lt;br/&gt;
&lt;br/&gt;
In other words, use &lt;code&gt;&amp;lt;tech&gt;name&amp;lt;/tech&gt;&lt;/code&gt;, not &lt;code&gt;&amp;lt;tech&gt; name &amp;lt;/tech&gt;&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: NfcTechWhitespace&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/36988969"&gt;https://issuetracker.google.com/36988969&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPermissionImpliesUnsupportedChromeOsHardware" defaultSeverity="ERROR" displayName="Permission Implies Unsupported Chrome OS Hardware" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission Implies Unsupported Chrome OS Hardware&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-permission&gt;&lt;/code&gt; element should not require a permission that implies an unsupported large screen hardware feature. Google Play assumes that certain hardware related permissions indicate that the underlying hardware features are required by default. To fix the issue, consider declaring the corresponding &amp;lt;uses-feature&gt; element with &lt;code&gt;required="false"&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: PermissionImpliesUnsupportedChromeOsHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/arc/manifest.html#implied-features"&gt;https://developer.android.com/topic/arc/manifest.html#implied-features&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRecyclerView" defaultSeverity="ERROR" displayName="RecyclerView Problems" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;RecyclerView Problems&lt;br&gt;&lt;br&gt;&lt;code&gt;RecyclerView&lt;/code&gt; will &lt;b&gt;not&lt;/b&gt; call &lt;code&gt;onBindViewHolder&lt;/code&gt; again when the position of the item changes in the data set unless the item itself is invalidated or the new position cannot be determined.&lt;br/&gt;
&lt;br/&gt;
For this reason, you should &lt;b&gt;only&lt;/b&gt; use the position parameter while acquiring the related data item inside this method, and should &lt;b&gt;not&lt;/b&gt; keep a copy of it.&lt;br/&gt;
&lt;br/&gt;
If you need the position of an item later on (e.g. in a click listener), use &lt;code&gt;getAdapterPosition()&lt;/code&gt; which will have the updated adapter position.&lt;br&gt;&lt;br&gt;Issue id: RecyclerView&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPxUsage" defaultSeverity="WARNING" displayName="Using 'px' dimension" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using 'px' dimension&lt;br&gt;&lt;br&gt;For performance reasons and to keep the code simpler, the Android system uses pixels as the standard unit for expressing dimension or coordinate values. That means that the dimensions of a view are always expressed in the code using pixels, but always based on the current screen density. For instance, if &lt;code&gt;myView.getWidth()&lt;/code&gt; returns 10, the view is 10 pixels wide on the current screen, but on a device with a higher density screen, the value returned might be 15. If you use pixel values in your application code to work with bitmaps that are not pre-scaled for the current screen density, you might need to scale the pixel values that you use in your code to match the un-scaled bitmap source.&lt;br&gt;&lt;br&gt;Issue id: PxUsage&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/practices/screens_support.html#screen-independence"&gt;https://developer.android.com/guide/practices/screens_support.html#screen-independence&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppCompatMethod" defaultSeverity="WARNING" displayName="Using Wrong AppCompat Method" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Wrong AppCompat Method&lt;br&gt;&lt;br&gt;When using the appcompat library, there are some methods you should be calling instead of the normal ones; for example, &lt;code&gt;getSupportActionBar()&lt;/code&gt; instead of &lt;code&gt;getActionBar()&lt;/code&gt;. This lint check looks for calls to the wrong method.&lt;br&gt;&lt;br&gt;Issue id: AppCompatMethod&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/libraries/support-library/"&gt;https://developer.android.com/topic/libraries/support-library/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRestrictedApi" defaultSeverity="ERROR" displayName="Restricted API" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Restricted API&lt;br&gt;&lt;br&gt;This API has been flagged with a restriction that has not been met.&lt;br/&gt;
&lt;br/&gt;
Examples of API restrictions:&lt;br/&gt;
* Method can only be invoked by a subclass&lt;br/&gt;
* Method can only be accessed from within the same library (defined by the Gradle library group id)&lt;br/&gt;
* Method can only be accessed from tests.&lt;br/&gt;
&lt;br/&gt;
You can add your own API restrictions with the &lt;code&gt;@RestrictTo&lt;/code&gt; annotation.&lt;br&gt;&lt;br&gt;Issue id: RestrictedApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleGetter" defaultSeverity="ERROR" displayName="Gradle Implicit Getter Call" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Gradle Implicit Getter Call&lt;br&gt;&lt;br&gt;Gradle will let you replace specific constants in your build scripts with method calls, so you can for example dynamically compute a version string based on your current version control revision number, rather than hardcoding a number.&lt;br/&gt;
&lt;br/&gt;
When computing a version name, it's tempting to for example call the method to do that &lt;code&gt;getVersionName&lt;/code&gt;. However, when you put that method call inside the &lt;code&gt;defaultConfig&lt;/code&gt; block, you will actually be calling the Groovy getter for the &lt;code&gt;versionName&lt;/code&gt; property instead. Therefore, you need to name your method something which does not conflict with the existing implicit getters. Consider using &lt;code&gt;compute&lt;/code&gt; as a prefix instead of &lt;code&gt;get&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: GradleGetter&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRange" defaultSeverity="ERROR" displayName="Outside Range" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Outside Range&lt;br&gt;&lt;br&gt;Some parameters are required to be in a particular numerical range; this check makes sure that arguments passed fall within the range. For arrays, Strings and collections this refers to the size or length.&lt;br&gt;&lt;br&gt;Issue id: Range&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintShortAlarm" defaultSeverity="WARNING" displayName="Short or Frequent Alarm" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Short or Frequent Alarm&lt;br&gt;&lt;br&gt;Frequent alarms are bad for battery life. As of API 22, the &lt;code&gt;AlarmManager&lt;/code&gt; will override near-future and high-frequency alarm requests, delaying the alarm at least 5 seconds into the future and ensuring that the repeat interval is at least 60 seconds.&lt;br/&gt;
&lt;br/&gt;
If you really need to do work sooner than 5 seconds, post a delayed message or runnable to a Handler.&lt;br&gt;&lt;br&gt;Issue id: ShortAlarm&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearStandaloneAppFlag" defaultSeverity="ERROR" displayName="Invalid or missing Wear standalone app flag" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid or missing Wear standalone app flag&lt;br&gt;&lt;br&gt;Wearable apps should specify whether they can work standalone, without a phone app. Add a valid meta-data entry for &lt;code&gt;com.google.android.wearable.standalone&lt;/code&gt; to your application element and set the value to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.
&lt;pre&gt;
&amp;lt;meta-data android:name="com.google.android.wearable.standalone"
           android:value="true"/&gt;`
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;Issue id: WearStandaloneAppFlag&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/apps/packaging.html"&gt;https://developer.android.com/training/wearables/apps/packaging.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongCase" defaultSeverity="ERROR" displayName="Wrong case for view tag" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong case for view tag&lt;br&gt;&lt;br&gt;Most layout tags, such as &lt;code&gt;&amp;lt;Button&gt;&lt;/code&gt;, refer to actual view classes and are therefore capitalized. However, there are exceptions such as &lt;code&gt;&amp;lt;fragment&gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;include&gt;&lt;/code&gt;. This lint check looks for incorrect capitalizations.&lt;br&gt;&lt;br&gt;Issue id: WrongCase&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/fragments.html"&gt;https://developer.android.com/guide/components/fragments.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLockedOrientationActivity" defaultSeverity="WARNING" displayName="Incompatible screenOrientation value" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incompatible screenOrientation value&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;activity&gt;&lt;/code&gt; element should not be locked to any orientation so that users can take advantage of the multi-window environments and larger screens available on Android. To fix the issue, consider declaring the corresponding activity element with `screenOrientation="unspecified"`or &lt;code&gt;fullSensor&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: LockedOrientationActivity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/arc/window-management"&gt;https://developer.android.com/topic/arc/window-management&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSdCardPath" defaultSeverity="WARNING" displayName="Hardcoded reference to /sdcard" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardcoded reference to &lt;code&gt;/sdcard&lt;/code&gt;&lt;br&gt;&lt;br&gt;Your code should not reference the &lt;code&gt;/sdcard&lt;/code&gt; path directly; instead use &lt;code&gt;Environment.getExternalStorageDirectory().getPath()&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Similarly, do not reference the &lt;code&gt;/data/data/&lt;/code&gt; path directly; it can vary in multi-user scenarios. Instead, use &lt;code&gt;Context.getFilesDir().getPath()&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: SdCardPath&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/data-storage#filesExternal"&gt;https://developer.android.com/training/data-storage#filesExternal&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSQLiteString" defaultSeverity="WARNING" displayName="Using STRING instead of TEXT" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using STRING instead of TEXT&lt;br&gt;&lt;br&gt;In SQLite, any column can store any data type; the declared type for a column is more of a hint as to what the data should be cast to when stored.&lt;br/&gt;
&lt;br/&gt;
There are many ways to store a string. &lt;code&gt;TEXT&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;, &lt;code&gt;CHARACTER&lt;/code&gt; and &lt;code&gt;CLOB&lt;/code&gt; are string types, &lt;b&gt;but `STRING` is not&lt;/b&gt;. Columns defined as STRING are actually numeric.&lt;br/&gt;
&lt;br/&gt;
If you try to store a value in a numeric column, SQLite will try to cast it to a float or an integer before storing. If it can't, it will just store it as a string.&lt;br/&gt;
&lt;br/&gt;
This can lead to some subtle bugs. For example, when SQLite encounters a string like &lt;code&gt;1234567e1234&lt;/code&gt;, it will parse it as a float, but the result will be out of range for floating point numbers, so &lt;code&gt;Inf&lt;/code&gt; will be stored! Similarly, strings that look like integers will lose leading zeroes.&lt;br/&gt;
&lt;br/&gt;
To fix this, you can change your schema to use a &lt;code&gt;TEXT&lt;/code&gt; type instead.&lt;br&gt;&lt;br&gt;Issue id: SQLiteString&lt;br&gt;&lt;br&gt;&lt;a href="https://www.sqlite.org/datatype3.html"&gt;https://www.sqlite.org/datatype3.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFindViewByIdCast" defaultSeverity="WARNING" displayName="Add Explicit Cast" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Add Explicit Cast&lt;br&gt;&lt;br&gt;In Android O, the &lt;code&gt;findViewById&lt;/code&gt; signature switched to using generics, which means that most of the time you can leave out explicit casts and just assign the result of the &lt;code&gt;findViewById&lt;/code&gt; call to variables of specific view classes.&lt;br/&gt;
&lt;br/&gt;
However, due to language changes between Java 7 and 8, this change may cause code to not compile without explicit casts. This lint check looks for these scenarios and suggests casts to be added now such that the code will continue to compile if the language level is updated to 1.8.&lt;br&gt;&lt;br&gt;Issue id: FindViewByIdCast&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringFormatInvalid" defaultSeverity="ERROR" displayName="Invalid format string" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid format string&lt;br&gt;&lt;br&gt;If a string contains a '%' character, then the string may be a formatting string which will be passed to &lt;code&gt;String.format&lt;/code&gt; from Java code to replace each '%' occurrence with specific values.&lt;br/&gt;
&lt;br/&gt;
This lint warning checks for two related problems:&lt;br/&gt;
(1) Formatting strings that are invalid, meaning that &lt;code&gt;String.format&lt;/code&gt; will throw exceptions at runtime when attempting to use the format string.&lt;br/&gt;
(2) Strings containing '%' that are not formatting strings getting passed to a &lt;code&gt;String.format&lt;/code&gt; call. In this case the '%' will need to be escaped as '%%'.&lt;br/&gt;
&lt;br/&gt;
NOTE: Not all Strings which look like formatting strings are intended for use by &lt;code&gt;String.format&lt;/code&gt;; for example, they may contain date formats intended for &lt;code&gt;android.text.format.Time#format()&lt;/code&gt;. Lint cannot always figure out that a String is a date format, so you may get false warnings in those scenarios. See the suppress help topic for information on how to suppress errors in that case.&lt;br&gt;&lt;br&gt;Issue id: StringFormatInvalid&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintShowToast" defaultSeverity="WARNING" displayName="Toast created but not shown" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Toast created but not shown&lt;br&gt;&lt;br&gt;&lt;code&gt;Toast.makeText()&lt;/code&gt; creates a &lt;code&gt;Toast&lt;/code&gt; but does &lt;b&gt;not&lt;/b&gt; show it. You must call &lt;code&gt;show()&lt;/code&gt; on the resulting object to actually make the &lt;code&gt;Toast&lt;/code&gt; appear.&lt;br&gt;&lt;br&gt;Issue id: ShowToast&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintObjectAnimatorBinding" defaultSeverity="ERROR" displayName="Incorrect ObjectAnimator Property" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect ObjectAnimator Property&lt;br&gt;&lt;br&gt;This check cross references properties referenced by String from &lt;code&gt;ObjectAnimator&lt;/code&gt; and &lt;code&gt;PropertyValuesHolder&lt;/code&gt; method calls and ensures that the corresponding setter methods exist and have the right signatures.&lt;br&gt;&lt;br&gt;Issue id: ObjectAnimatorBinding&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCoarseFineLocation" defaultSeverity="ERROR" displayName="Cannot use ACCESS_FINE_LOCATION without ACCESS_COARSE_LOCATION" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Cannot use &lt;code&gt;ACCESS_FINE_LOCATION&lt;/code&gt; without &lt;code&gt;ACCESS_COARSE_LOCATION&lt;/code&gt;&lt;br&gt;&lt;br&gt;If your app requires access to FINE location, on Android 12 and higher you must now request both FINE and COARSE. Users will have the option to grant only COARSE location. Ensure your app can work with just COARSE location.&lt;br&gt;&lt;br&gt;Issue id: CoarseFineLocation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedQuantity" defaultSeverity="WARNING" displayName="Unused quantity translations" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unused quantity translations&lt;br&gt;&lt;br&gt;Android defines a number of different quantity strings, such as &lt;code&gt;zero&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;few&lt;/code&gt; and &lt;code&gt;many&lt;/code&gt;. However, many languages do not distinguish grammatically between all these different quantities.&lt;br/&gt;
&lt;br/&gt;
This lint check looks at the quantity strings defined for each translation and flags any quantity strings that are unused (because the language does not make that quantity distinction, and Android will therefore not look it up).&lt;br/&gt;
&lt;br/&gt;
For example, in Chinese, only the &lt;code&gt;other&lt;/code&gt; quantity is used, so even if you provide translations for &lt;code&gt;zero&lt;/code&gt; and &lt;code&gt;one&lt;/code&gt;, these strings will &lt;b&gt;not&lt;/b&gt; be returned when &lt;code&gt;getQuantityString()&lt;/code&gt; is called, even with &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: UnusedQuantity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html#Plurals"&gt;https://developer.android.com/guide/topics/resources/string-resource.html#Plurals&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintForegroundServiceType" defaultSeverity="ERROR" displayName="Missing foregroundServiceType attribute in manifest" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;foregroundServiceType&lt;/code&gt; attribute in manifest&lt;br&gt;&lt;br&gt;For &lt;code&gt;targetSdkVersion&lt;/code&gt; &gt;= 34, to call &lt;code&gt;Service.startForeground()&lt;/code&gt;, the &amp;lt;service&gt; element in the manifest file must have the &lt;code&gt;foregroundServiceType&lt;/code&gt; attribute specified.&lt;br&gt;&lt;br&gt;Issue id: ForegroundServiceType&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLongLogTag" defaultSeverity="ERROR" displayName="Too Long Log Tags" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Too Long Log Tags&lt;br&gt;&lt;br&gt;Log tags are only allowed to be at most 23 tag characters long.&lt;br&gt;&lt;br&gt;Issue id: LongLogTag&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBottomAppBar" defaultSeverity="ERROR" displayName="BottomAppBar Problems" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;BottomAppBar Problems&lt;br&gt;&lt;br&gt;The &lt;code&gt;BottomAppBar&lt;/code&gt; widget must be placed within a &lt;code&gt;CoordinatorLayout&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: BottomAppBar&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintChromeOsAbiSupport" defaultSeverity="WARNING" displayName="Missing ABI Support for ChromeOS" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing ABI Support for ChromeOS&lt;br&gt;&lt;br&gt;To properly support ChromeOS, your Android application should have an x86 and/or x86_64 binary as part of the build configuration. To fix the issue, ensure your files are properly optimized for ARM; the binary translator will then ensure compatibility with x86. Alternatively, add an &lt;code&gt;abiSplit&lt;/code&gt; for x86 within your &lt;code&gt;build.gradle&lt;/code&gt; file and create the required x86 dependencies.&lt;br&gt;&lt;br&gt;Issue id: ChromeOsAbiSupport&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/ndk/guides/abis"&gt;https://developer.android.com/ndk/guides/abis&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRedundantLabel" defaultSeverity="WARNING" displayName="Redundant label on activity" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Redundant label on activity&lt;br&gt;&lt;br&gt;When an activity does not have a label attribute, it will use the one from the application tag. Since the application has already specified the same label, the label on this activity can be omitted.&lt;br&gt;&lt;br&gt;Issue id: RedundantLabel&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTextViewEdits" defaultSeverity="WARNING" displayName="TextView should probably be an EditText instead" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TextView should probably be an EditText instead&lt;br&gt;&lt;br&gt;Using a &lt;code&gt;&amp;lt;TextView&gt;&lt;/code&gt; to input text is generally an error, you should be using &lt;code&gt;&amp;lt;EditText&gt;&lt;/code&gt; instead.  &lt;code&gt;EditText&lt;/code&gt; is a subclass of &lt;code&gt;TextView&lt;/code&gt;, and some of the editing support is provided by &lt;code&gt;TextView&lt;/code&gt;, so it's possible to set some input-related properties on a &lt;code&gt;TextView&lt;/code&gt;. However, using a &lt;code&gt;TextView&lt;/code&gt; along with input attributes is usually a cut &amp;amp; paste error. To input text you should be using &lt;code&gt;&amp;lt;EditText&gt;&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
This check also checks subclasses of &lt;code&gt;TextView&lt;/code&gt;, such as &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;CheckBox&lt;/code&gt;, since these have the same issue: they should not be used with editable attributes.&lt;br&gt;&lt;br&gt;Issue id: TextViewEdits&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongCall" defaultSeverity="ERROR" displayName="Using wrong draw/layout method" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using wrong draw/layout method&lt;br&gt;&lt;br&gt;Custom views typically need to call &lt;code&gt;measure()&lt;/code&gt; on their children, not &lt;code&gt;onMeasure&lt;/code&gt;. Ditto for onDraw, onLayout, etc.&lt;br&gt;&lt;br&gt;Issue id: WrongCall&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypos" defaultSeverity="WARNING" displayName="Spelling error" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Spelling error&lt;br&gt;&lt;br&gt;This check looks through the string definitions, and if it finds any words that look like likely misspellings, they are flagged.&lt;br&gt;&lt;br&gt;Issue id: Typos&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLocaleFolder" defaultSeverity="WARNING" displayName="Wrong locale name" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong locale name&lt;br&gt;&lt;br&gt;From the &lt;code&gt;java.util.Locale&lt;/code&gt; documentation:&lt;br/&gt;
"Note that Java uses several deprecated two-letter codes. The Hebrew ("he") language code is rewritten as "iw", Indonesian ("id") as "in", and Yiddish ("yi") as "ji". This rewriting happens even if you construct your own Locale object, not just for instances returned by the various lookup methods.&lt;br/&gt;
&lt;br/&gt;
Because of this, if you add your localized resources in for example &lt;code&gt;values-he&lt;/code&gt; they will not be used, since the system will look for &lt;code&gt;values-iw&lt;/code&gt; instead.&lt;br/&gt;
&lt;br/&gt;
To work around this, place your resources in a &lt;code&gt;values&lt;/code&gt; folder using the deprecated language code instead.&lt;br&gt;&lt;br&gt;Issue id: LocaleFolder&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/util/Locale.html"&gt;https://developer.android.com/reference/java/util/Locale.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSpUsage" defaultSeverity="WARNING" displayName="Using dp instead of sp for text sizes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;dp&lt;/code&gt; instead of &lt;code&gt;sp&lt;/code&gt; for text sizes&lt;br&gt;&lt;br&gt;When setting text sizes, you should normally use &lt;code&gt;sp&lt;/code&gt;, or "scale-independent pixels". This is like the &lt;code&gt;dp&lt;/code&gt; unit, but it is also scaled by the user's font size preference. It is recommend you use this unit when specifying font sizes, so they will be adjusted for both the screen density and the user's preference.&lt;br/&gt;
&lt;br/&gt;
There &lt;b&gt;are&lt;/b&gt; cases where you might need to use &lt;code&gt;dp&lt;/code&gt;; typically this happens when the text is in a container with a specific dp-size. This will prevent the text from spilling outside the container. Note however that this means that the user's font size settings are not respected, so consider adjusting the layout itself to be more flexible.&lt;br&gt;&lt;br&gt;Issue id: SpUsage&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/multiscreen/screendensities.html"&gt;https://developer.android.com/training/multiscreen/screendensities.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNioDesugaring" defaultSeverity="ERROR" displayName="Unsupported java.nio operations" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsupported &lt;code&gt;java.nio&lt;/code&gt; operations&lt;br&gt;&lt;br&gt;Core library desugaring handles most of the &lt;code&gt;java.nio&lt;/code&gt; APIs, but prior to API level 26, a handful of APIs are not fully supported.&lt;br/&gt;
&lt;br/&gt;
This is detailed in the documentation at &lt;a href="https://developer.android.com/studio/write/java11-nio-support-table#java-nio-customizations"&gt;https://developer.android.com/studio/write/java11-nio-support-table#java-nio-customizations&lt;/a&gt; .&lt;br&gt;&lt;br&gt;Issue id: NioDesugaring&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTestAppLink" defaultSeverity="ERROR" displayName="Unmatched URLs" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unmatched URLs&lt;br&gt;&lt;br&gt;Using one or more &lt;code&gt;tools:validation testUrl="some url"/&gt;&lt;/code&gt; elements in your manifest allows the link attributes in your intent filter to be checked for matches.&lt;br&gt;&lt;br&gt;Issue id: TestAppLink&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGridLayout" defaultSeverity="ERROR" displayName="GridLayout validation" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;GridLayout validation&lt;br&gt;&lt;br&gt;Declaring a layout_row or layout_column that falls outside the declared size of a GridLayout's &lt;code&gt;rowCount&lt;/code&gt; or &lt;code&gt;columnCount&lt;/code&gt; is usually an unintentional error.&lt;br&gt;&lt;br&gt;Issue id: GridLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintScopedStorage" defaultSeverity="WARNING" displayName="Affected by scoped storage" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Affected by scoped storage&lt;br&gt;&lt;br&gt;Scoped storage is enforced on Android 10+ (or Android 11+ if using &lt;code&gt;requestLegacyExternalStorage&lt;/code&gt;). In particular, &lt;code&gt;WRITE_EXTERNAL_STORAGE&lt;/code&gt; will no longer provide write access to all files; it will provide the equivalent of &lt;code&gt;READ_EXTERNAL_STORAGE&lt;/code&gt; instead.&lt;br/&gt;
&lt;br/&gt;
As of Android 13, if you need to query or interact with MediaStore or media files on the shared storage, you should be using instead one or more new storage permissions:&lt;br/&gt;
* &lt;code&gt;android.permission.READ_MEDIA_IMAGES&lt;/code&gt;&lt;br/&gt;
* &lt;code&gt;android.permission.READ_MEDIA_VIDEO&lt;/code&gt;&lt;br/&gt;
* &lt;code&gt;android.permission.READ_MEDIA_AUDIO&lt;/code&gt;&lt;br/&gt;
&lt;br/&gt;
and then add &lt;code&gt;maxSdkVersion="33"&lt;/code&gt; to the older permission. See the developer guide for how to do this: &lt;a href="https://developer.android.com/about/versions/13/behavior-changes-13#granular-media-permissions"&gt;https://developer.android.com/about/versions/13/behavior-changes-13#granular-media-permissions&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
The &lt;code&gt;MANAGE_EXTERNAL_STORAGE&lt;/code&gt; permission can be used to manage all files, but it is rarely necessary and most apps on Google Play are not allowed to use it. Most apps should instead migrate to use scoped storage. To modify or delete files, apps should request write access from the user as described at &lt;a href="https://goo.gle/android-mediastore-createwriterequest"&gt;https://goo.gle/android-mediastore-createwriterequest&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
To learn more, read these resources: Play policy: &lt;a href="https://goo.gle/policy-storage-help"&gt;https://goo.gle/policy-storage-help&lt;/a&gt; Allowable use cases: &lt;a href="https://goo.gle/policy-storage-usecases"&gt;https://goo.gle/policy-storage-usecases&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: ScopedStorage&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/android-storage-usecases"&gt;https://goo.gle/android-storage-usecases&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMangledCRLF" defaultSeverity="ERROR" displayName="Mangled file line endings" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mangled file line endings&lt;br&gt;&lt;br&gt;On Windows, line endings are typically recorded as carriage return plus newline: \r\n.&lt;br/&gt;
&lt;br/&gt;
This detector looks for invalid line endings with repeated carriage return characters (without newlines). Previous versions of the ADT plugin could accidentally introduce these into the file, and when editing the file, the editor could produce confusing visual artifacts.&lt;br&gt;&lt;br&gt;Issue id: MangledCRLF&lt;br&gt;&lt;br&gt;&lt;a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=375421"&gt;https://bugs.eclipse.org/bugs/show_bug.cgi?id=375421&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsupportedTvHardware" defaultSeverity="ERROR" displayName="Unsupported TV Hardware Feature" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsupported TV Hardware Feature&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-feature&gt;&lt;/code&gt; element should not require this unsupported TV hardware feature. Any uses-feature not explicitly marked with &lt;code&gt;required="false"&lt;/code&gt; is necessary on the device to be installed on. Ensure that any features that might prevent it from being installed on a TV device are reviewed and marked as not required in the manifest.&lt;br&gt;&lt;br&gt;Issue id: UnsupportedTvHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/tv/start/hardware.html#unsupported-features"&gt;https://developer.android.com/training/tv/start/hardware.html#unsupported-features&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidId" defaultSeverity="ERROR" displayName="Invalid ID declaration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid ID declaration&lt;br&gt;&lt;br&gt;An id definition &lt;b&gt;must&lt;/b&gt; be of the form &lt;code&gt;@+id/yourname&lt;/code&gt;. The tools have not rejected strings of the form &lt;code&gt;@+foo/bar&lt;/code&gt; in the past, but that was an error, and could lead to tricky errors because of the way the id integers are assigned.&lt;br/&gt;
&lt;br/&gt;
If you really want to have different "scopes" for your id's, use prefixes instead, such as &lt;code&gt;login_button1&lt;/code&gt; and &lt;code&gt;login_button2&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStartActivityAndCollapseDeprecated" defaultSeverity="ERROR" displayName="TileService.startActivityAndCollapse(Intent) is deprecated" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TileService.startActivityAndCollapse(Intent) is deprecated&lt;br&gt;&lt;br&gt;&lt;code&gt;TileService#startActivityAndCollapse(Intent)&lt;/code&gt; has been deprecated, and will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if used in apps targeting Android versions UpsideDownCake and higher. Convert the Intent to a PendingIntent.&lt;br&gt;&lt;br&gt;Issue id: StartActivityAndCollapseDeprecated&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDiscouragedApi" defaultSeverity="WARNING" displayName="Using discouraged APIs" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using discouraged APIs&lt;br&gt;&lt;br&gt;Discouraged APIs are allowed and are not deprecated, but they may be unfit for common use (e.g. due to slow performance or subtle behavior).&lt;br&gt;&lt;br&gt;Issue id: DiscouragedApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppLinkUriRelativeFilterGroupError" defaultSeverity="ERROR" displayName="URI relative filter group invalid" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;URI relative filter group invalid&lt;br&gt;&lt;br&gt;Ensure that your URI relative filter group is correctly configured.&lt;br&gt;&lt;br&gt;Issue id: AppLinkUriRelativeFilterGroupError&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/uri-relative-filter-group-element?utm_source=lint"&gt;https://developer.android.com/guide/topics/manifest/uri-relative-filter-group-element?utm_source=lint&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNamespaceTypo" defaultSeverity="ERROR" displayName="Misspelled namespace declaration" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Misspelled namespace declaration&lt;br&gt;&lt;br&gt;Accidental misspellings in namespace declarations can lead to some very obscure error messages. This check looks for potential misspellings to help track these down.&lt;br&gt;&lt;br&gt;Issue id: NamespaceTypo&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMockLocation" defaultSeverity="ERROR" displayName="Using mock location provider in production" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using mock location provider in production&lt;br&gt;&lt;br&gt;Using a mock location provider (by requiring the permission &lt;code&gt;android.permission.ACCESS_MOCK_LOCATION&lt;/code&gt;) should &lt;b&gt;only&lt;/b&gt; be done in debug builds (or from tests). In Gradle projects, that means you should only request this permission in a test or debug source set specific manifest file.&lt;br/&gt;
&lt;br/&gt;
To fix this, create a new manifest file in the debug folder and move the &lt;code&gt;&amp;lt;uses-permission&gt;&lt;/code&gt; element there. A typical path to a debug manifest override file in a Gradle project is src/debug/AndroidManifest.xml.&lt;br&gt;&lt;br&gt;Issue id: MockLocation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNonResizeableActivity" defaultSeverity="WARNING" displayName="Activity is set to be non-resizeable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Activity is set to be non-resizeable&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;activity&gt;&lt;/code&gt; element should be allowed to be resized to allow users to take advantage of the multi-window environments available on larger screen Android devices.&lt;br/&gt;
&lt;br/&gt;
To fix the issue, consider declaring the corresponding activity element with &lt;code&gt;resizableActivity="true"&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: NonResizeableActivity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/arc/window-management"&gt;https://developer.android.com/topic/arc/window-management&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSupportAnnotationUsage" defaultSeverity="ERROR" displayName="Incorrect support annotation usage" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect support annotation usage&lt;br&gt;&lt;br&gt;This lint check makes sure that the support annotations (such as &lt;code&gt;@IntDef&lt;/code&gt; and &lt;code&gt;@ColorInt&lt;/code&gt;) are used correctly. For example, it's an error to specify an &lt;code&gt;@IntRange&lt;/code&gt; where the &lt;code&gt;from&lt;/code&gt; value is higher than the &lt;code&gt;to&lt;/code&gt; value.&lt;br&gt;&lt;br&gt;Issue id: SupportAnnotationUsage&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingId" defaultSeverity="WARNING" displayName="Fragments should specify an id or tag" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Fragments should specify an &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;tag&lt;/code&gt;&lt;br&gt;&lt;br&gt;If you do not specify an &lt;code&gt;android:id&lt;/code&gt; or an &lt;code&gt;android:tag&lt;/code&gt; attribute on a &lt;code&gt;&amp;lt;fragment&gt;&lt;/code&gt; element, then if the activity is restarted (for example for an orientation rotation) you may lose state. From the fragment documentation:&lt;br/&gt;
&lt;br/&gt;
"Each fragment requires a unique identifier that the system can use to restore the fragment if the activity is restarted (and which you can use to capture the fragment to perform transactions, such as remove it).&lt;br/&gt;
&lt;br/&gt;
* Supply the &lt;code&gt;android:id&lt;/code&gt; attribute with a unique ID.&lt;br/&gt;
* Supply the &lt;code&gt;android:tag&lt;/code&gt; attribute with a unique string.&lt;br/&gt;
&lt;br/&gt;
If you provide neither of the previous two, the system uses the ID of the container view.&lt;br&gt;&lt;br&gt;Issue id: MissingId&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/fragments.html"&gt;https://developer.android.com/guide/components/fragments.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDataBindingWithoutKapt" defaultSeverity="WARNING" displayName="Data Binding without Annotation Processing" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Data Binding without Annotation Processing&lt;br&gt;&lt;br&gt;Apps that use Kotlin and data binding should also apply the kotlin-kapt plugin.&lt;br&gt;&lt;br&gt;Issue id: DataBindingWithoutKapt&lt;br&gt;&lt;br&gt;&lt;a href="https://kotlinlang.org/docs/reference/kapt.html"&gt;https://kotlinlang.org/docs/reference/kapt.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintVisibleForTests" defaultSeverity="WARNING" displayName="Visible Only For Tests" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Visible Only For Tests&lt;br&gt;&lt;br&gt;This check looks for accesses from production code (e.g. not tests) where the access would not have been allowed with the intended production visibility.&lt;br/&gt;
&lt;br/&gt;
Depending on your development environment, you may be able to use an &lt;code&gt;@VisibleForTesting&lt;/code&gt; annotation to specify the intended visibility if the method had not been more widely visible for the tests.&lt;br/&gt;
&lt;br/&gt;
When using &lt;code&gt;androidx.annotations.VisibleForTesting&lt;/code&gt;, the production visibility is assumed to be private unless specified with the &lt;code&gt;otherwise=&lt;/code&gt; parameter. &lt;code&gt;com.google.common.annotations.VisibleForTesting&lt;/code&gt; and &lt;code&gt;com.android.internal.annotations.VisibleForTesting&lt;/code&gt; work similarly with their own parameters called &lt;code&gt;productionVisibility&lt;/code&gt; and &lt;code&gt;visibility&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If instead you use &lt;code&gt;org.jetbrains.annotations.VisibleForTesting&lt;/code&gt;, there is no such parameter, and the production visibility is instead assumed to be "one step down" from the testing visibility. For example, if the testing visibility is public, the production visibility is assumed to be package-private.&lt;br&gt;&lt;br&gt;Issue id: VisibleForTests&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongGradleMethod" defaultSeverity="ERROR" displayName="Wrong Gradle method invoked" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Gradle method invoked&lt;br&gt;&lt;br&gt;This lint check looks for suspicious Gradle DSL calls.&lt;br/&gt;
&lt;br/&gt;
One common example is attempting to create product flavor or build type specific dependencies by placing the &lt;code&gt;dependencies&lt;/code&gt; block inside a product flavor or build type.&lt;br/&gt;
&lt;br/&gt;
Another one is KTS specific. When migrating from Groovy to KTS, be extra careful with some calls into plugin DSL methods; in some cases, you might have to insert an explicit &lt;code&gt;import&lt;/code&gt; statement, even if the code compiles without it; instead you are silently calling a generated method.&lt;br/&gt;
&lt;br/&gt;
For example, with the Firebase App Distribution plugin, you &lt;i&gt;cannot&lt;/i&gt; just convert this &lt;code&gt;build.gradle&lt;/code&gt; snippet:
&lt;pre&gt;
buildTypes {
    release {
        firebaseAppDistribution {
            artifactType="APK"
            releaseNotesFile="/path/to/releasenotes.txt"
            testers="ali@example.com, bri@example.com, cal@example.com"
        }
    }
}
&lt;/pre&gt;
to this KTS:
&lt;pre&gt;
buildTypes {
    getByName("release") {
        firebaseAppDistribution {
            artifactType = "APK"
            releaseNotesFile = "/path/to/releasenotes.txt"
            testers = "ali@example.com, bri@example.com, cal@example.com"
        }
    }
}
&lt;/pre&gt;
You have to &lt;i&gt;also&lt;/i&gt; add this import at the top of the file:
&lt;pre&gt;
import com.google.firebase.appdistribution.gradle.firebaseAppDistribution
&lt;/pre&gt;
&lt;br/&gt;
If you get this error on other DSL constructs inside build types or product flavors, check the plugin documentation.&lt;br&gt;&lt;br&gt;Issue id: WrongGradleMethod&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringFormatMatches" defaultSeverity="ERROR" displayName="String.format string doesn't match the XML format string" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;String.format&lt;/code&gt; string doesn't match the XML format string&lt;br&gt;&lt;br&gt;This lint check ensures the following:&lt;br/&gt;
(1) If there are multiple translations of the format string, then all translations use the same type for the same numbered arguments&lt;br/&gt;
(2) The usage of the format string in Java is consistent with the format string, meaning that the parameter types passed to String.format matches those in the format string.&lt;br&gt;&lt;br&gt;Issue id: StringFormatMatches&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMotionLayoutMissingId" defaultSeverity="ERROR" displayName="Views inside MotionLayout require an android:id" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Views inside &lt;code&gt;MotionLayout&lt;/code&gt; require an &lt;code&gt;android:id&lt;/code&gt;&lt;br&gt;&lt;br&gt;Views inside &lt;code&gt;MotionLayout&lt;/code&gt; require an &lt;code&gt;android:id&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: MotionLayoutMissingId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBatteryLife" defaultSeverity="WARNING" displayName="Battery Life Issues" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Battery Life Issues&lt;br&gt;&lt;br&gt;This issue flags code that either&lt;br/&gt;
* negatively affects battery life, or&lt;br/&gt;
* uses APIs that have recently changed behavior to prevent background tasks from consuming memory and battery excessively.&lt;br/&gt;
&lt;br/&gt;
Generally, you should be using &lt;code&gt;WorkManager&lt;/code&gt; instead.&lt;br/&gt;
&lt;br/&gt;
For more details on how to update your code, please see &lt;a href="https://developer.android.com/topic/performance/background-optimization"&gt;https://developer.android.com/topic/performance/background-optimization&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: BatteryLife&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedAttribute" defaultSeverity="WARNING" displayName="Attribute unused on older versions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Attribute unused on older versions&lt;br&gt;&lt;br&gt;This check finds attributes set in XML files that were introduced in a version newer than the oldest version targeted by your application (with the &lt;code&gt;minSdkVersion&lt;/code&gt; attribute).&lt;br/&gt;
&lt;br/&gt;
This is not an error; the application will simply ignore the attribute. However, if the attribute is important to the appearance or functionality of your application, you should consider finding an alternative way to achieve the same result with only available attributes, and then you can optionally create a copy of the layout in a layout-vNN folder which will be used on API NN or higher where you can take advantage of the newer attribute.&lt;br/&gt;
&lt;br/&gt;
Note: This check does not only apply to attributes. For example, some tags can be unused too, such as the new &lt;code&gt;&amp;lt;tag&gt;&lt;/code&gt; element in layouts introduced in API 21.&lt;br&gt;&lt;br&gt;Issue id: UnusedAttribute&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="불필요한 제어자" path="Java/Lombok"><inspection shortName="RedundantModifiersValLombok" defaultSeverity="WARNING" displayName="'val' 앞의 불필요한 final" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;val&lt;/code&gt; 앞의 불필요한 &lt;code&gt;final&lt;/code&gt; 제어자를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantModifiersValLombok&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantModifiersUtilityClassLombok" defaultSeverity="WARNING" displayName="@UtilityClass 제어자" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@UtilityClass&lt;/code&gt; 어노테이션이 추가된 클래스에 대한 불필요한 제어자를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantModifiersUtilityClassLombok&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantModifiersValueLombok" defaultSeverity="WARNING" displayName="@Value 제어자" enabled="false" language="JAVA" pluginId="Lombook Plugin" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@Value&lt;/code&gt; 어노테이션이 추가된 클래스에 대한 불필요한 제어자를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantModifiersValueLombok&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="JPA" path=""><inspection shortName="JpaDomInspection" defaultSeverity="ERROR" displayName="persistence.xml 문제" enabled="false" language="XML" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;

XML 구성 파일 내의 다음과 같은 문제를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;인스턴스화할 수 없는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;필요한 클래스를 확장하지 않는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;부적절한 범위를 가진 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;요구되는 패턴(예: Java 식별자)과 일치하지 않는 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 하위 태그 또는 속성을 포함하지 않는 태그&lt;/li&gt;
  &lt;li&gt;이름이 중복된 객체를 정의하는 태그&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;persistence&amp;gt;
    &amp;lt;persistence-unit name="example-persistence-unit"&amp;gt;
        &amp;lt;provider&amp;gt;org.example.SomeRandomClass&amp;lt;/provider&amp;gt; // 오류: provider 클래스는 PersistenceProvider 인터페이스를 구현해야 합니다
    &amp;lt;/persistence-unit&amp;gt;
&amp;lt;/persistence&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JpaDomInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssociationNotMarkedInspection" defaultSeverity="WARNING" displayName="엔티티 속성이 연결 어노테이션으로 표시되지 않았습니다" enabled="false" language="UAST" pluginId="com.intellij.jpa.jpb.model" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해당하는 어노테이션으로 표시되지 않은 연결을 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AssociationNotMarkedInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConverterNotAnnotatedInspection" defaultSeverity="WARNING" displayName="JPA 컨버터는 @Converter로 어노테이션되어야 합니다" enabled="false" language="UAST" pluginId="com.intellij.jpa.jpb.model" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JPA 컨버터에 &lt;pre&gt;&lt;code&gt;@Converter&lt;/code&gt;&lt;/pre&gt; 어노테이션이 있는지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ConverterNotAnnotatedInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JpaDataSourceORMDomInspection" defaultSeverity="ERROR" displayName="XML에서 미해결 데이터베이스 참조" enabled="false" language="XML" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구성된 데이터 소스 내부에서 해결되지 않는 Persistence ORM XML 설명자를 보고하고 데이터 소스를 새로고침하거나 다른 데이터 소스를 할당할 것을 제안합니다.

&lt;p&gt;&lt;b&gt;데이터베이스 테이블 예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="sql"&gt;
  CREATE TABLE DATA_TABLE (
    ID INTEGER,
    DATA VARCHAR(100)
  );
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;

&lt;p&gt;&lt;b&gt;JSP 파일 예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="jsp"&gt;
  &amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
  &amp;lt;entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm" version="1.0"&amp;gt;
    &amp;lt;entity name="JavaEntity" class="JavaEntity"&amp;gt;
        &amp;lt;table name="UNKNOWN_TABLE"/&amp;gt; // 오류: 해결되지 않은 테이블
        &amp;lt;attributes&amp;gt;
          &amp;lt;id name="id"&amp;gt;
            &amp;lt;column name="ID" nullable="false"/&amp;gt;
          &amp;lt;/id&amp;gt;
          &amp;lt;basic name="UNKNOWN_COLUMN"&amp;gt; // 오류: 해결되지 않은 열
            &amp;lt;column name="UNKNOWN_COLUMN" length="12"/&amp;gt;
          &amp;lt;/basic&amp;gt;
        &amp;lt;/attributes&amp;gt;
    &amp;lt;/entity&amp;gt;
  &amp;lt;/entity-mappings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;참고:&lt;/b&gt; 'Assign datasource'(데이터 소스 할당) 액션을 통해 데이터 소스를 구성할 수 있습니다
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JpaDataSourceORMDomInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaModelReferenceInspection" defaultSeverity="ERROR" displayName="쿼리의 미해결 참조" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음과 같은 JPA 어노테이션 및 API 메서드 내 해결되지 않은 심볼을 보고합니다:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;AttributeOverride&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;AssociationOverride&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;MapsId&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;MapKey&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Criteria API 메서드&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Entity
  @AssociationOverrides({
    @AssociationOverride(name = "missingAttribute", joinColumns = { ... }), // 오류: 해결돠지 않은 속성
    @AssociationOverride(name = "existingAttribute", joinColumns = { ... })
  })
  public class JavaEntity {
    @OneToOne
    AnotherEntity existingAttribute;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JpaModelReferenceInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaAttributeMemberSignatureInspection" defaultSeverity="ERROR" displayName="지속성 속성 시그니처 확인" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음과 같은 JPA 사양 위반 사례를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;메서드 또는 필드에 여러 속성이 구성되어 있음&lt;/li&gt;
  &lt;li&gt;Embeddable 객체에 잘못된 속성이 사용됨(JPA 1.0)&lt;/li&gt;
  &lt;li&gt;지속성 속성 메타데이터가 필드 또는 프로퍼티 getter에 지정되어 있지 않음&lt;/li&gt;
  &lt;li&gt;프로퍼티 기반 액세스가 가능한 setter 또는 getter가 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Entity
  @Table(name = "TABLE")
  public class JavaEntity {

    private Integer id; // 오류: getter 및 setter가 모두 있어야 합니다

    public Integer getId() { ... }



    private String data;

    public String getData() { ... }

    @Basic // 오류: 지속성 어노테이션은 필드 또는 getter 메서드에 있어야 합니다
    public void setData(String data) { ... }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JpaAttributeMemberSignatureInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaMissingIdInspection" defaultSeverity="ERROR" displayName="지속성 엔티티에 기본 키가 누락되었습니다." enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
누락된 식별 프로퍼티 지속성 객체를 보고합니다.&lt;br/&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Entity
  public class JavaEntity { // 오류: 엔티티 클래스는 @Id 어노테이션이 추가된 프로퍼티를 포함해야 함

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JpaMissingIdInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LombokAllArgsInspection" defaultSeverity="WARNING" displayName="인수가 없는 생성자가 정의되지 않은 JPA 엔티티에 @AllArgsConstructor를 사용하면 JPA 사양을 위배합니다." enabled="false" language="UAST" pluginId="com.intellij.jpa.jpb.model" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JPA 엔티티에서 &lt;pre&gt;&lt;code&gt;@lombok.AllArgsConstructor&lt;/code&gt;&lt;/pre&gt; 가 사용되는지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LombokAllArgsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ManyToManyCascadeRemove" defaultSeverity="WARNING" displayName="@ManyToMany 연결의 경우 REMOVE 엔티티 상태 전환을 캐스케이드 처리하면 링크 테이블 외부까지 전파되므로 적절하지 않습니다." enabled="false" language="UAST" pluginId="com.intellij.jpa.jpb.model" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
 &lt;pre&gt;&lt;code&gt;@ManyToMany&lt;/code&gt;&lt;/pre&gt; 와 &lt;pre&gt;&lt;code&gt;CascadeType.REMOVE&lt;/code&gt;&lt;/pre&gt; 속성의 연결을 확인합니다.
 &lt;pre&gt;&lt;code&gt;CascadeType.REMOVE&lt;/code&gt;&lt;/pre&gt; 를 &lt;pre&gt;&lt;code&gt;@ManyToMany&lt;/code&gt;&lt;/pre&gt; 에 대해 지정하면 링크 테이블 외부로 전달되기 때문에 캐스케이드 처리하기에 적절하지 않습니다.
상위 측의 다른 엔티티가 반대 측을 참조할 수 있으므로, 자동으로 제거하면 다음 예외가 발생할 수 있습니다. &lt;pre&gt;&lt;code&gt;ConstraintViolationException&lt;/code&gt;&lt;/pre&gt;.
예: &lt;pre&gt;&lt;code&gt;@ManyToMany(cascade = CascadeType.ALL)&lt;/code&gt;&lt;/pre&gt; 이 정의되고 첫 번째 사람이 삭제되면, 삭제되는 주소와 다른 사람이 아직 연결되어 있으므로 Hibernate가 예외를 던집니다.
자세한 정보는 &lt;a href="https://vladmihalcea.com/hypersistence-optimizer/docs/user-guide/#ManyToManyCascadeRemoveEvent"&gt;이 자료&lt;/a&gt;를 참조하세요.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ManyToManyCascadeRemove&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssociationFieldHasColumnAnnotation" defaultSeverity="WARNING" displayName="@Colum으로 표시된 연결 필드" enabled="false" language="UAST" pluginId="com.intellij.jpa.jpb.model" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
 &lt;pre&gt;&lt;code&gt;@Column&lt;/code&gt;&lt;/pre&gt; 어노테이션이 &lt;pre&gt;&lt;code&gt;@OneToOne&lt;/code&gt;&lt;/pre&gt;
그리고 &lt;pre&gt;&lt;code&gt;@ManyToOne&lt;/code&gt;&lt;/pre&gt; 어노테이션을 가진 연결 속성에 잘못 사용된 경우를 탐지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AssociationFieldHasColumnAnnotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JpaQlInspection" defaultSeverity="ERROR" displayName="쿼리 언어 확인" enabled="false" language="JPAQL" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지속성 QL 쿼리 내부의 다음과 같은 오류를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;일치하지 않는 표현식 타입&lt;/li&gt;
  &lt;li&gt;잘못된 매개변수&lt;/li&gt;
  &lt;li&gt;빈 조건 또는 상수 조건&lt;/li&gt;
  &lt;li&gt;해결되지 않은 심볼&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;쿼리 예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="sql"&gt;
SELECT OBJECT(e) FROM JavaEntity e WHERE TRUE // 경고: 상수 조건

SELECT OBJECT(e) FROM JavaEntity e WHERE e.id BETWEEN 0 AND '2' // 오류: 숫자 값이 필요하나 문자열이 사용되었습니다

SELECT e from JavaEntity e where e.id=?1 and e.name=?3 // 오류: 실제 쿼리 매개변수가 2개 밖에 없습니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JpaQlInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaQueryApiInspection" defaultSeverity="ERROR" displayName="미해결 쿼리 및 쿼리 매개변수" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명명된 쿼리와 네이티브 쿼리 및 관련 API 메서드 내 해결되지 않은 심볼을 보고합니다.
&lt;ul&gt;
  &lt;li&gt;알 수 없는 명명된 쿼리&lt;/li&gt;
  &lt;li&gt;알 수 없는 쿼리 매개변수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Entity
  @NamedQuery(name = "SelectByConditionQuery", query = "...")
  public class JavaEntity { ... }

  class Main {
    public static void executeQuery() {
      Persistence.createEntityManagerFactory("")
        .createEntityManager()
        .createNamedQuery("SelectAllQuery") // 오류: 알 수 없는 쿼리 이름
        ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JpaQueryApiInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaConfigDomFacetInspection" defaultSeverity="WARNING" displayName="Persistence.xml이 패싯에 추가되지 않았습니다." enabled="false" language="XML" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
누락된 persistence.xml 구성 파일을 보고하고 해당 파일을 지속성 패싯에 추가할 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JpaConfigDomFacetInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaDataSourceORMInspection" defaultSeverity="ERROR" displayName="어노테이션에서 미해결 데이터베이스 참조" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음 Persistence ORM 어노테이션 내부의 참조가 구성된 데이터 소스 안에서 해결될 수 없는 경우를 보고합니다.&lt;br/&gt;
&lt;ul&gt;
  &lt;li&gt; Table&lt;/li&gt;
  &lt;li&gt; Column&lt;/li&gt;
  &lt;li&gt; [Any]To[Any]&lt;/li&gt;
  &lt;li&gt; JoinColumn / JoinTable&lt;/li&gt;
  &lt;li&gt; NamedQuery / NativeQuery&lt;/li&gt;
  &lt;li&gt; Embeddable&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;

데이터 소스를 새로고침하거나 다른 데이터 소스를 할당할 것을 제안합니다.&lt;br/&gt;

&lt;p&gt;&lt;b&gt;데이터베이스 테이블 예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="sql"&gt;
  CREATE TABLE DATA_TABLE (
    ID INTEGER,
    DATA VARCHAR(100)
);
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;

&lt;p&gt;&lt;b&gt;JPA 엔티티 클래스 예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Entity
  @Table(name = "UNKNOWN_TABLE") // 해결되지 않은 참조
  public class JavaEntity {
    @Column(name = "ID") // 정의되지 않은 테이블 내 열을 해결할 수 없음
    Integer id;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;참고:&lt;/b&gt; '데이터 소스 할당' 액션 또는 엔티티 클래스에 해당하는 여백 아이콘을 통해 데이터 소스를 구성할 수 있습니다
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JpaDataSourceORMInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OneToOneWithLazy" defaultSeverity="WARNING" displayName="@OneToOne 연결에서 소유하지 않는 측에 FetchType.LAZY를 지정하면 로드에 영향을 주지 않습니다. 관련 엔티티는 FetchType.EAGER가 정의된 것처럼 로드됩니다." enabled="false" language="UAST" pluginId="com.intellij.jpa.jpb.model" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
 &lt;pre&gt;&lt;code&gt;@OneToOne&lt;/code&gt;&lt;/pre&gt; 와 &lt;pre&gt;&lt;code&gt;FetchType.Lazy&lt;/code&gt;&lt;/pre&gt; 속성의 연결을 확인합니다.
 &lt;pre&gt;&lt;code&gt;FetchType.LAZY&lt;/code&gt;&lt;/pre&gt; 의 비소유 측이 &lt;pre&gt;&lt;code&gt;@OneToOne&lt;/code&gt;&lt;/pre&gt; 연결의 비소유 측에 대해 로딩에 영향을 주지 않는지 확인합니다.
관련 엔티티는 &lt;pre&gt;&lt;code&gt;FetchType.EAGER&lt;/code&gt;&lt;/pre&gt; 가 정의된 것처럼 계속 로드됩니다.
자세한 정보는 &lt;a
  href="https://docs.jboss.org/hibernate/orm/6.1/userguide/html_single/Hibernate_User_Guide.html#associations-one-to-one-bidirectional-lazy"&gt;이 문서&lt;/a&gt;를 참조하세요.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: OneToOneWithLazy&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JpaAttributeTypeInspection" defaultSeverity="ERROR" displayName="지속성 속성 타입 확인" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JPA 속성의 프로퍼티 타입 불일치를 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Entity
  public class JavaEntity {

    @OneToOne
    Map&amp;lt;Integer, AnotherEntity&amp;gt; incorrectRelationship; // 오류: 'One To One' 속성 타입은 map이 아니라 entity여야 합니다

    @ManyToMany
    Map&amp;lt;Integer, AnotherEntity&amp;gt; correctRelationship;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JpaAttributeTypeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaORMDomInspection" defaultSeverity="ERROR" displayName="orm.xml 문제" enabled="false" language="XML" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
'orm.xml' 구성 파일 내 모든 데이터베이스 객체로의 해결되지 않은 참조를 보고합니다:
&lt;ul&gt;
  &lt;li&gt;테이블&lt;/li&gt;
  &lt;li&gt;열&lt;/li&gt;
  &lt;li&gt;스키마&lt;/li&gt;
  &lt;li&gt;카탈로그&lt;/li&gt;
  &lt;li&gt;시퀀스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;데이터베이스 테이블 예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code lang="sql"&gt;
CREATE TABLE DATA_TABLE (
  ID INTEGER,
  DATA VARCHAR(100)
);
&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;

&lt;p&gt;&lt;b&gt;orm.xml 파일 예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
&amp;lt;entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm" version="1.0"&amp;gt;
    &amp;lt;package&amp;gt;example&amp;lt;/package&amp;gt;
    &amp;lt;entity name="JavaEntity" class="JavaEntity"&amp;gt;
        &amp;lt;table name="DATA_TABLE"/&amp;gt;
        &amp;lt;attributes&amp;gt;
          &amp;lt;id name="id"&amp;gt;
            &amp;lt;column name="UNKNOWN_ID" nullable="false" length="20"/&amp;gt; // 오류: 해결되지 않은 열 이름
          &amp;lt;/id&amp;gt;
          &amp;lt;basic name="data"&amp;gt;
            &amp;lt;column name="DATA" length="12"/&amp;gt; // 좋음
          &amp;lt;/basic&amp;gt;
        &amp;lt;/attributes&amp;gt;
    &amp;lt;/entity&amp;gt;
&amp;lt;/entity-mappings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JpaORMDomInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LombokBuilderAllArgsInspection" defaultSeverity="WARNING" displayName="Lombok @Builder에는 이 클래스의 적절한 생성자가 필요합니다" enabled="false" language="UAST" pluginId="com.intellij.jpa.jpb.model" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JPA 엔티티에 &lt;pre&gt;&lt;code&gt;@lombok.Builder&lt;/code&gt;&lt;/pre&gt; 에 대한 all-args 생성자가 있는지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LombokBuilderAllArgsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JpaObjectClassSignatureInspection" defaultSeverity="ERROR" displayName="지속성 객체 클래스 시그니처 확인" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음과 같은 경우에 잘못 정의된 지속성 객체 클래스를 보고합니다.

&lt;ul&gt;
  &lt;li&gt;클래스가 최상위가 아닌 경우&lt;/li&gt;
  &lt;li&gt;클래스가 final인 경우&lt;/li&gt;
  &lt;li&gt;클래스에 어노테이션이 여러 번 추가된 경우&lt;/li&gt;
  &lt;li&gt;클래스가 지속성 엔티티 및 엔티티 리스너 둘 다로 정의된 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Entity
  @EntityListeners(value = JavaEntity.class) // 오류: @Entity 및 @EntityListener 어노테이션이 같은 클래스를 가리킵니다
  public final class JavaEntity { // 오류: 지속성 엔티티는 final일 수 없습니다
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JpaObjectClassSignatureInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MoreThanOneIdInspection" defaultSeverity="WARNING" displayName="엔티티에 2개 이상의 ID 속성이 있습니다." enabled="false" language="UAST" pluginId="com.intellij.jpa.jpb.model" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
하나의 엔티티에 있는 여러 id 속성을 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MoreThanOneIdInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LombokBuilderInspection" defaultSeverity="WARNING" displayName="인수 없는 생성자가 정의되지 않은 JPA 엔티티에 @Builder를 사용하면 JPA 사양에 위배됩니다." enabled="false" language="UAST" pluginId="com.intellij.jpa.jpb.model" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JPA 엔티티에서 &lt;pre&gt;&lt;code&gt;@lombok.Builder&lt;/code&gt;&lt;/pre&gt; 가 사용되는지 확인합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LombokBuilderInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JpaEntityListenerInspection" defaultSeverity="ERROR" displayName="엔티티 리스너 문제" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음과 같은 JPA 사양 위반 사례를 보고합니다.&lt;br/&gt;
&lt;ul&gt;
  &lt;li&gt;인수 없는 public 생성자를 포함하지 않는 엔티티 리스터 클래스&lt;/li&gt;
  &lt;li&gt;잘못된 시그니처를 가진 엔티티 리스너 메서드&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Entity
  @EntityListeners(value = JavaEntityListener.class)
  class JavaEntity { ... }

  class JavaEntityListener {

    @PostLoad
    void postLoad(String parameter) { ... } // 오류: 여기에서 'postLoad' 메서드는 'Object' 타입의 매개변수를 받아야 합니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JpaEntityListenerInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaEntityListenerWarningsInspection" defaultSeverity="WARNING" displayName="엔티티 리스너 경고" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
엔티티 리스너 메서드가 없는 엔티티 리스너 클래스를 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Entity
  @EntityListeners(value = JavaEntityListener.class)
  public class JavaEntity { ... }

  class JavaEntityListener { // 오류: 엔티티 리스너용 메서드를 찾을 수 없습니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JpaEntityListenerWarningsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JpaEntityGraphsInspection" defaultSeverity="ERROR" displayName="해결되지 않은 엔티티 그래프 이름" enabled="false" language="UAST" pluginId="com.intellij.javaee.jpa" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
EntityGraph 관련 어노테이션 내부의 다음과 같은 해결되지 않은 속성을 보고합니다:&lt;br/&gt;
&lt;ul&gt;
  &lt;li&gt; &lt;code&gt;@NamedAttributeNode&lt;/code&gt; 내 value&lt;/li&gt;
  &lt;li&gt; &lt;code&gt;@NamedAttributeNode&lt;/code&gt; 내 명명된 하위 그래프&lt;/li&gt;
  &lt;li&gt; &lt;code&gt;@NamedEntityGraph&lt;/code&gt; 내 name&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Entity
  @NamedEntityGraph(name = "entity-graph", ...)
  public class JavaEntity {
    public void foo() {
      Persistence.createEntityManagerFactory("")
        .createEntityManager()
        .getEntityGraph("unknown-entity-graph"); // 해결되지 않은 참조
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JpaEntityGraphsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="FreeMarker" path=""><inspection shortName="FtlImportCallInspection" defaultSeverity="ERROR" displayName="해결되지 않은 외부 호출" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;다른 파일에 있는 해결되지 않은 &lt;code&gt;#macro&lt;/code&gt; 및 &lt;code&gt;#function&lt;/code&gt; 지시문을 보고합니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 필요한 파일에 대해 &lt;code&gt;#import&lt;/code&gt; 또는 &lt;code&gt;#include&lt;/code&gt;를 사용할 것을 제안합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FtlImportCallInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FtlLanguageInspection" defaultSeverity="ERROR" displayName="내장 오류" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;FreeMarker 언어 오류를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FtlLanguageInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FtlReferencesInspection" defaultSeverity="WARNING" displayName="해결되지 않은 참조" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;해결되지 않은 FreeMarker 참조를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FtlReferencesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FtlFileReferencesInspection" defaultSeverity="ERROR" displayName="해결되지 않은 파일 참조" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;#include&lt;/code&gt; 및 &lt;code&gt;#import&lt;/code&gt; 지시문 내 해결되지 않은 FreeMarker 파일 참조를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FtlFileReferencesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FtlDeprecatedBuiltInsInspection" defaultSeverity="WARNING" displayName="기본 제공 항목은 더 이상 사용되지 않습니다" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;지원 중단되는 기본 제공 항목을 보고합니다(예: &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;exists&lt;/code&gt;, &lt;code&gt;if_exists&lt;/code&gt;, &lt;code&gt;web_safe&lt;/code&gt;).&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FtlDeprecatedBuiltInsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FtlWellformednessInspection" defaultSeverity="ERROR" displayName="지시문 형식이 잘못되었습니다" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;형식이 잘못된 FreeMarker 지시문을 보고합니다(예: 잘못된 중첩, 누락된 닫는 태그 등).&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FtlWellformednessInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FtlTypesInspection" defaultSeverity="WARNING" displayName="잘못된 표현식 타입" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 FreeMarker 표현식 타입을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FtlTypesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FtlCallsInspection" defaultSeverity="ERROR" displayName="잘못된 호출 지시문" enabled="false" language="FTL" pluginId="com.intellij.freemarker" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;매크로 선언과 일치하지 않는 FreeMarker 호출을 보고합니다(예: 누락된 매개변수, 잘못된 타입 등).&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FtlCallsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="유효성 이슈" path="JavaScript 및 TypeScript"><inspection shortName="BadExpressionStatementJS" defaultSeverity="WEAK WARNING" displayName="대입 또는 호출이 아닌 표현식 구문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대입 또는 호출이 아닌 표현식 구문을 보고합니다.
그러한 구문은 보통 오류를 나타냅니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: BadExpressionStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionWithInconsistentReturnsJS" defaultSeverity="WARNING" displayName="일관되지 않은 반환이 있는 함수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
일부 사례에서 값을 반환하지 않는 반면 
다른 사례에서는 값이 반환되지 않는 함수를 보고합니다. 이는 보통 오류를 나타냅니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function foo() {
  if (true)
    return 3;
  return;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FunctionWithInconsistentReturnsJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringLiteralBreaksHTMLJS" defaultSeverity="WARNING" displayName="HTML 구문 분석을 중단하는 문자열 리터럴" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;&amp;lt;/&lt;/code&gt; 시퀀스를 포함하는 문자열 리터럴을 보고합니다.  그러한 문자열을 사용하면
JavaScript 코드가 포함된 모든 HTML이 잘못 분석될 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: StringLiteralBreaksHTMLJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThisExpressionReferencesGlobalObjectJS" defaultSeverity="WARNING" displayName="전역 객체를 참조하는 'this' 식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
객체 리터럴 또는 생성자 본문 외부에 있는 &lt;code&gt;this&lt;/code&gt; 표현식을 보고합니다.  그러한 &lt;code&gt;this&lt;/code&gt;
표현식은 최상위 "global" JavaScript 객체를 참조하지만
거의 쓸모가 없습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ThisExpressionReferencesGlobalObjectJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSOctalInteger" defaultSeverity="ERROR" displayName="8진 정수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;0o&lt;/code&gt; 대신 사용이 중단된 &lt;code&gt;0&lt;/code&gt; 접두사를 사용한 8진수 정수 리터럴을 보고합니다.&lt;br/&gt;
그러한 리터럴은 최근 ECMAScript 코드에서 허용되지 않기 때문에 strict 모드에서 사용하면 오류로 처리됩니다.&lt;br/&gt;
ES5 및 ES3 언어 수준에서 이 검사를 강제 실행하려면 다음 'ES5- 코드에서 오래된 8진수 리터럴 사용에 대한 경고' 체크박스를 선택하십시오.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSOctalInteger&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSConstantReassignment" defaultSeverity="ERROR" displayName="const 또는 readonly 변수에 할당을 시도합니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상수 또는 읽기 전용 변수에 값이 다시 대입된 경우를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSConstantReassignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReservedWordUsedAsNameJS" defaultSeverity="WARNING" displayName="이름으로 사용되는 예약 단어" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이름으로 사용된 JavaScript 예약어를 보고합니다.  JavaScript 사양에는 
현재 키워드로 사용되지 않는 많은 단어가 예약되어 있습니다.  이러한 단어를 식별자로 사용하면 JavaScript의 이후 버전이 키워드로 사용하기 시작할 경우 코드가 파손될 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReservedWordUsedAsNameJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Kotlin" path=""><inspection shortName="DeprecatedGradleDependency" defaultSeverity="WARNING" displayName="Gradle에서 사용되지 않는 라이브러리가 사용되었습니다" enabled="false" language="Groovy" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Gradle 빌드 스크립트에서 지원 중단된 종속성을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
      compile "org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.0"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
      compile "org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.2.0"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DeprecatedGradleDependency&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DifferentKotlinGradleVersion" defaultSeverity="WARNING" displayName="Kotlin Gradle과 IDE 플러그인 버전이 다릅니다" enabled="false" language="Groovy" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
현재 IDE 플러그인에서 Gradle 플러그인 버전이 제대로 지원되지 않음을 보고합니다.
&lt;p&gt;이는 오류 보고 또는 코드 동작에서 IDE와 Gradle 빌드 사이의 일관성 문제를 야기할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:0.0.1"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;문제를 해결하려면 Kotlin Gradle 플러그인 버전이 IDE 플러그인에 번들로 포함된 Kotlin 버전과 일치하도록 변경합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DifferentKotlinGradleVersion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinMavenPluginPhase" defaultSeverity="WARNING" displayName="Kotlin Maven Plugin이 잘못 구성되었습니다" enabled="false" language="XML" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">Kotlin-Maven 플러그인 구성 문제를 보고합니다.</inspection><inspection shortName="DeprecatedMavenDependency" defaultSeverity="WARNING" displayName="Maven에서 사용되지 않는 라이브러리가 사용되었습니다" enabled="false" language="XML" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지원 중단된 Maven 종속성을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;dependencies&gt;
    &amp;lt;dependency&gt;
        &amp;lt;groupId&gt;org.jetbrains.kotlin&amp;lt;/groupId&gt;
        &amp;lt;artifactId&gt;kotlin-stdlib-jre7&amp;lt;/artifactId&gt;
        &amp;lt;version&gt;${kotlin.version}&amp;lt;/version&gt;
    &amp;lt;/dependency&gt;
  &amp;lt;/dependencies&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 지원 중단된 종속성을 계속 지원되는 종속성으로 변경합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
   &amp;lt;dependencies&gt;
    &amp;lt;dependency&gt;
        &amp;lt;groupId&gt;org.jetbrains.kotlin&amp;lt;/groupId&gt;
        &amp;lt;artifactId&gt;kotlin-stdlib-jdk7&amp;lt;/artifactId&gt;
        &amp;lt;version&gt;${kotlin.version}&amp;lt;/version&gt;
    &amp;lt;/dependency&gt;
  &amp;lt;/dependencies&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DeprecatedMavenDependency&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DifferentStdlibGradleVersion" defaultSeverity="WARNING" displayName="Kotlin 라이브러리와 Gradle 플러그인 버전이 다릅니다" enabled="false" language="Groovy" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
서로 다른 Kotlin stdlib 및 컴파일러 버전을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
    classpath "org.jetbrains.kotlin:kotlin-stdlib:0.0.1"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;문제를 해결하려면 Kotlin stdlib 버전이 Kotlin 컴파일러 버전과 일치하도록 변경합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DifferentStdlibGradleVersion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinInvalidBundleOrProperty" defaultSeverity="ERROR" displayName="잘못된 프로퍼티 키" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kotlin 파일에서 해결되지 않은 &lt;code&gt;.properties&lt;/code&gt; 파일 키 및 리소스 번들에 대한 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KotlinInvalidBundleOrProperty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinTestJUnit" defaultSeverity="WARNING" displayName="kotlin-test-junit을 사용할 수 있습니다" enabled="false" language="XML" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;kotlin-test-junit&lt;/code&gt;이 없는 &lt;code&gt;kotlin-test&lt;/code&gt; 및 &lt;code&gt;junit&lt;/code&gt; 종속성의 사용을 보고합니다.
&lt;p&gt;Kotlin 및 JUnit을 함께 사용하려면 &lt;code&gt;kotlin-test-junit&lt;/code&gt; 종속성을 사용하는 것이 좋습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KotlinTestJUnit&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DifferentKotlinMavenVersion" defaultSeverity="WARNING" displayName="Maven과 IDE 플러그인 버전이 다릅니다" enabled="false" language="XML" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
현재 IDE 플러그인에서 Maven 플러그인 버전이 제대로 지원되지 않음을 보고합니다.
&lt;p&gt;이 일관성 문제는 IDE 및 컴파일러에서 오류 보고가 다르게 동작하는 상황으로 이어질 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DifferentKotlinMavenVersion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DifferentMavenStdlibVersion" defaultSeverity="WARNING" displayName="라이브러리와 Maven 플러그인 버전이 다릅니다" enabled="false" language="XML" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
서로 다른 Kotlin stdlib 및 컴파일러 버전을 보고합니다.
&lt;p&gt;여러 다른 버전의 Kotlin 컴파일러를 사용한 뒤 표준 라이브러리를 사용하면 예상하지 못한 런타임 문제로 이어질 수 있으므로 삼가야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DifferentMavenStdlibVersion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="React" path="JavaScript 및 TypeScript"><inspection shortName="JSXDomNesting" defaultSeverity="WARNING" displayName="잘못된 DOM 요소 중첩" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
DOM 사양에 따라 제대로 중첩되지 않은 JSX 파일의 HTML 요소를 탐지합니다.
React는 잘못 중첩된 요소에 대해 런타임 경고를 보고합니다.


&lt;!--Write your description here.--&gt;
&lt;!--Start the description with a verb in 3rd person singular, like reports, detects, highlights.--&gt;
&lt;!--In the first sentence, briefly explain what exactly the inspection helps you detect.--&gt;
&lt;!--Make sure the sentence is not very long and complicated.--&gt;
&lt;!--&lt;p&gt;--&gt;
&lt;!--  The first sentence must be in a dedicated paragraph separated from the rest of the text. This will make the description easier to read.--&gt;
&lt;!--  Make sure the description doesn’t just repeat the inspection title.--&gt;
&lt;!--&lt;/p&gt;--&gt;
&lt;!--&lt;p&gt;--&gt;
&lt;!--  See https://plugins.jetbrains.com/docs/intellij/inspections.html#descriptions for more information.--&gt;
&lt;!--&lt;/p&gt;--&gt;
&lt;!--&amp;lt;!&amp;ndash; tooltip end &amp;ndash;&amp;gt;--&gt;
&lt;!--&lt;p&gt;Text after this comment will only be shown in the settings of the inspection.&lt;/p&gt;--&gt;

&lt;!--&lt;p&gt;To open related settings directly from the description, add a link with `settings://$` optionally followed by `?$` to pre-select a UI--&gt;
&lt;!--  element.&lt;/p&gt;--&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSXDomNesting&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="toString() 문제" path="Java"><inspection shortName="ClassHasNoToStringMethod" defaultSeverity="WARNING" displayName="클래스가 'toString()' 메서드를 재정의하지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;toString()&lt;/code&gt; 메서드가 없는 클래스를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ClassHasNoToStringMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldNotUsedInToString" defaultSeverity="WARNING" displayName="'toString()' 메서드에서 필드가 사용되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스의 &lt;code&gt;toString()&lt;/code&gt; 메서드에서 사용되지 않는 필드를 보고합니다.
&lt;p&gt;&lt;code&gt;toString()&lt;/code&gt; 메서드가 마지막으로 업데이트된 후 추가된 필드를 찾아줍니다.
  빠른 수정은 &lt;code&gt;toString()&lt;/code&gt; 메서드를 다시 생성합니다.&lt;/p&gt;
&lt;p&gt;
&lt;b&gt;Generate(생성) | toString()&lt;/b&gt; 대화상자에서 이 검사의 필드를 제외할 수 있습니다.
또한 &lt;em&gt;코드 생성에서 getter 사용&lt;/em&gt; 옵션이 활성화된 경우 이 검사를 통해 getter 메서드와 관련된 문제도 검사할 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Relevant {
    &lt;b&gt;private&lt;/b&gt; String name; // not used in toString()
    &lt;b&gt;private int&lt;/b&gt; index;
    &lt;b&gt;private int&lt;/b&gt; length;

    @Override
    &lt;b&gt;public&lt;/b&gt; String toString() {
        &lt;b&gt;return&lt;/b&gt; "Relevant{" + "index=" + index +
          ", length=" + length + '}';
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Relevant {
    &lt;b&gt;private&lt;/b&gt; String name;
    &lt;b&gt;private int&lt;/b&gt; index;
    &lt;b&gt;private int&lt;/b&gt; length;

    @Override
    &lt;b&gt;public&lt;/b&gt; String toString() {
        &lt;b&gt;return&lt;/b&gt; "Relevant{" + "name='" + name + '\'' +
          ", index=" + index + ", length=" + length + '}';
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FieldNotUsedInToString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="공통" path="Reactive Streams"><inspection shortName="ReactiveStreamsSubscriberImplementation" defaultSeverity="WARNING" displayName="클래스가 Subscriber를 구현" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;Subscriber&lt;/code&gt; 인터페이스를 직접 구현하는 클래스를 보고합니다.&lt;/p&gt;
&lt;p&gt;RxJava, Reactor 또는 Mutiny의 정적 제너레이터를 사용하는 것이 좋습니다. 예를 들면 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Flux.just()&lt;/code&gt;, &lt;code&gt;Flux.create()&lt;/code&gt;, &lt;code&gt;Flux.generate()&lt;/code&gt;, &lt;code&gt;Flux.from()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Mono.create()&lt;/code&gt;, &lt;code&gt;Mono.from()&lt;/code&gt;, &lt;code&gt;Mono.just()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Flowable.just()&lt;/code&gt;, &lt;code&gt;Flowable.from()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Maybe.just()&lt;/code&gt;, &lt;code&gt;Maybe.from()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Multi.createFrom()&lt;/code&gt;, &lt;code&gt;Multi.createBy()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Uni.createFrom()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReactiveStreamsSubscriberImplementation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactiveStreamsUnusedPublisher" defaultSeverity="WARNING" displayName="사용되지 않는 publisher" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;사용되지 않는 &lt;code&gt;Publisher&lt;/code&gt; 인스턴스를 보고합니다.&lt;/p&gt;
&lt;p&gt;
  새 &lt;code&gt;Publisher&lt;/code&gt; 인스턴스를 생성하는 연산자(Mono/Flux/Flowable을 반환하는 Mono/Flux/Flowable 객체의 메서드)를 사용하려면 &lt;code&gt;subscribe()&lt;/code&gt;를 통해 생성된 &lt;code&gt;Publisher&lt;/code&gt;를 구독해야 합니다.
&lt;/p&gt;
&lt;p&gt;
  반환된 &lt;code&gt;Publisher&lt;/code&gt;를 구독하지 않고 팩토리(예: &lt;code&gt;Mono.just()&lt;/code&gt;)를 사용할 경우, 사용되지 않으며 불필요한 메모리 할당으로 취급되는 객체가 생성됩니다.
&lt;/p&gt;
&lt;p&gt;
  예를 들어, 이 &lt;code&gt;Publisher&lt;/code&gt;를 구독하지 않는 경우나 연산자를 적용하여 새 &lt;code&gt;Publisher&lt;/code&gt;를 생성한 후 구독하지 않는 경우, &lt;code&gt;Mono.just(1, 2, 3).map(i -&gt; i + 3)&lt;/code&gt;은 실행되지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;사용되지 않는 &lt;code&gt;Flux&lt;/code&gt; 인스턴스:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
Flux.just(1, 2, 3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;컨슈머가 사용하는 &lt;code&gt;Flux&lt;/code&gt; 인스턴스:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
Flux.just(1, 2, 3).subscribe(System.out::println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Error Prone 또는 AssertJ의 &lt;code&gt;@CanIgnoreReturnValue&lt;/code&gt; 어노테이션이 추가된 메서드에 대한 호출은 보고되지 않습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReactiveStreamsUnusedPublisher&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactiveStreamsThrowInOperator" defaultSeverity="WEAK WARNING" displayName="Reactive 연산자 내 Throw 문" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reactor/RxJava 연산자 코드의 &lt;code&gt;throw&lt;/code&gt; 식을 보고합니다.&lt;/p&gt;
&lt;p&gt;Reactor/RxJava 연산자에서 예외를 던지면 'Reactive 같은' 오류(예: &lt;code&gt;flatMap()&lt;/code&gt;의 &lt;code&gt;Mono.error()&lt;/code&gt; 또는 &lt;code&gt;Flowable.error()&lt;/code&gt;, Reactor &lt;code&gt;handle()&lt;/code&gt; 연산자의 &lt;code&gt;sink.error()&lt;/code&gt; 호출)를 반환할 수 있으므로 문제가 있음을 나타냅니다.
&lt;/p&gt;
&lt;p&gt;
또한 Reactor factory 메서드는 오류 없이 검사된 예외의 반환을 허용하지만 &lt;code&gt;Exceptions&lt;/code&gt; 클래스 없이 그러한 예외를 던질 경우 컴파일 오류가 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
Flux.just(1, 2, 3).flatMap(i -&gt; {
            throw new RuntimeException();
        })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
Flux.just(1, 2, 3).flatMap(i -&gt; {
            return Flux.error(new RuntimeException());
        })
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReactiveStreamsThrowInOperator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactiveStreamsTooLongSameOperatorsChain" defaultSeverity="WARNING" displayName="너무 긴 동일 메서드 체인" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;긴 Reactive Streams 변환 체인을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map()&lt;/code&gt; 또는 &lt;code&gt;filter()&lt;/code&gt;와 같은 각 연산자 메서드 호출은 해당 연산자에 대한 일부 객체를 생성합니다. 
  각 구독에서 각 스트림 요소에 대한 긴 연산자 체인을 호출하면 성능 오버헤드가 발생할 수 있습니다.
  이를 방지하려면 가능한 경우 긴 호출 체인을 연산자 호출 하나로 결합합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
Flux.just(1, 2, 3)
        .map(it -&gt; it + 1)
        .map(it -&gt; it + 2)
        .map(it -&gt; it + 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
Flux.just(1, 2, 3)
        .map(it -&gt; it + 1 + 2 + 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2019.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReactiveStreamsTooLongSameOperatorsChain&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactiveStreamsPublisherImplementation" defaultSeverity="WARNING" displayName="클래스가 Publisher를 구현" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;Publisher&lt;/code&gt; 인터페이스를 직접 구현하는 클래스를 보고합니다.&lt;/p&gt;
&lt;p&gt;RxJava, Reactor 또는 Mutiny의 정적 제너레이터를 사용하는 것이 좋습니다. 예를 들면 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Flux.just()&lt;/code&gt;, &lt;code&gt;Flux.create()&lt;/code&gt;, &lt;code&gt;Flux.generate()&lt;/code&gt;, &lt;code&gt;Flux.from()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Mono.create()&lt;/code&gt;, &lt;code&gt;Mono.from()&lt;/code&gt;, &lt;code&gt;Mono.just()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Flowable.just()&lt;/code&gt;, &lt;code&gt;Flowable.from()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Maybe.just()&lt;/code&gt;, &lt;code&gt;Maybe.from()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Multi.createFrom()&lt;/code&gt;, &lt;code&gt;Multi.createBy()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Uni.createFrom()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReactiveStreamsPublisherImplementation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactiveStreamsNullableInLambdaInTransform" defaultSeverity="WARNING" displayName="변환 메서드에서 람다로부터 null 또는 null 가능 항목을 반환" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reactive Stream 체인에서 &lt;code&gt;null&lt;/code&gt;을 반환할 수 있는 변환 연산자를 보고합니다.&lt;/p&gt;

&lt;p&gt;
  Reactive Stream은 그러한 코드가 실패하는 원인을 제공하는 null 가능 값을 지원하지 않습니다.
  빠른 수정에서는 &lt;code&gt;map()&lt;/code&gt;을 예외를 생략한 &lt;code&gt;mapNotNull&lt;/code&gt;로 교체하기를 제안합니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;repository.findWithTailableCursorBy()
    .map(e -&gt; (Person)null)
    .doOnNext(System.out::println)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;repository.findWithTailableCursorBy()
    .mapNotNull(e -&gt; (Person)null)
    .doOnNext(System.out::println)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;2019.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReactiveStreamsNullableInLambdaInTransform&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java EE" path=""><inspection shortName="JavaeeApplicationDomInspection" defaultSeverity="ERROR" displayName="Java EE 애플리케이션 설명자 정확성" enabled="false" language="XML" pluginId="com.intellij.javaee" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
'application.xml' 구성 파일 내부의 다음과 같은 문제를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;인스턴스화할 수 없는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;필요한 클래스를 확장하지 않는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;부적절한 범위를 가진 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;요구되는 패턴(예: Java 식별자)과 일치하지 않는 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 하위 태그 또는 속성을 포함하지 않는 태그&lt;/li&gt;
  &lt;li&gt;이름이 중복된 객체를 정의하는 태그&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;application&amp;gt;
    &amp;lt;module id="ExampleWebModule"&amp;gt;
      &amp;lt;web&amp;gt; // 오류: 'web-uri' 하위 태그가 정의되어야 합니다
        &amp;lt;context-root&amp;gt;ExampleWebApp&amp;lt;/context-root&amp;gt;
      &amp;lt;/web&amp;gt;
    &amp;lt;/module&amp;gt;
&amp;lt;/application&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JavaeeApplicationDomInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ServletWithoutMappingInspection" defaultSeverity="ERROR" displayName="서블릿 매핑" enabled="false" language="XML" pluginId="com.intellij.javaee.web" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
관련 매핑이 없는 서블릿을 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;web-app&amp;gt;
    &amp;lt;servlet&amp;gt;
      &amp;lt;servlet-name&amp;gt;foo&amp;lt;/servlet-name&amp;gt; // 오류: 서블릿에 매핑이 있어야 합니다
      &amp;lt;servlet-class&amp;gt;javax.servlet.Servlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;/servlet&amp;gt;
  
    &amp;lt;filter&amp;gt;
      &amp;lt;filter-name&amp;gt;bar&amp;lt;/filter-name&amp;gt; // 오류: 필터에 매핑이 있어야 합니다
      &amp;lt;filter-class&amp;gt;java.lang.String&amp;lt;/filter-class&amp;gt;
    &amp;lt;/filter&amp;gt;
  &amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ServletWithoutMappingInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="WebProperties" defaultSeverity="ERROR" displayName="Web.xml 오류" enabled="false" language="XML" pluginId="com.intellij.javaee.web" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
웹 모듈을 서버에 배포하는 데 사용되는 설명자에서 다음과 같은 문제를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;인스턴스화할 수 없는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;필요한 클래스를 확장하지 않는 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;부적절한 범위를 가진 클래스에 대한 참조&lt;/li&gt;
  &lt;li&gt;빈 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;요구되는 패턴(예: Java 식별자)과 일치하지 않는 태그 및 속성 값&lt;/li&gt;
  &lt;li&gt;필요한 하위 태그 또는 속성을 포함하지 않는 태그&lt;/li&gt;
  &lt;li&gt;이름이 중복된 객체를 정의하는 태그&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;web-app&amp;gt;
  &amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;CustomFilter&amp;lt;/filter-name&amp;gt; // 오류: servlet-name 또는 url-pattern 하위 태그가 정의되어야 합니다
  &amp;lt;/filter-mapping&amp;gt;
  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;CustomServletName&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/ baseUrl&amp;lt;/url-pattern&amp;gt; // 오류: URI-pattern은 공백을 포함할 수 없습니다
  &amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: WebProperties&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="WebWarnings" defaultSeverity="WARNING" displayName="Web.xml 경고" enabled="false" language="XML" pluginId="com.intellij.javaee.web" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
웹 모듈을 서버에 배포하기 위한 설명자에 나열되어 있는 중복된 welcome 파일을 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
  &amp;lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd"&amp;gt;
  &amp;lt;web-app&amp;gt;
    &amp;lt;welcome-file-list&amp;gt;
      &amp;lt;welcome-file&amp;gt;
        Welcome1.jsp
      &amp;lt;/welcome-file&amp;gt;
      &amp;lt;welcome-file&amp;gt;
        /Welcome1.jsp // 오류: 중복된 welcome-file
      &amp;lt;/welcome-file&amp;gt;
      &amp;lt;welcome-file&amp;gt;
        Welcome3.jsp
      &amp;lt;/welcome-file&amp;gt;
    &amp;lt;/welcome-file-list&amp;gt;
  &amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: WebWarnings&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MimeType" defaultSeverity="ERROR" displayName="MIME 타입" enabled="false" language="XML" pluginId="com.intellij.javaee.web" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;

MIME 타입 이름의 유효성을 제어할 수 있습니다.

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MimeType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SecurityRoles" defaultSeverity="ERROR" displayName="보안 역할 이름 정확성" enabled="false" language="XML" pluginId="com.intellij.javaee" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
잘못된 보안 역할 이름을 보고합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;web-app&amp;gt;
    &amp;lt;security-role&amp;gt;
      &amp;lt;role-name&amp;gt;custom#role&amp;lt;/role-name&amp;gt; // 오류: 유효하지 않은 이름
    &amp;lt;/security-role&amp;gt;
    &amp;lt;security-role&amp;gt;
      &amp;lt;role-name&amp;gt;customRole&amp;lt;/role-name&amp;gt; // 유효한 이름
    &amp;lt;/security-role&amp;gt;
  &amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SecurityRoles&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="발생할 수 있는 버그" path="Groovy"><inspection shortName="GrPermitsClause" defaultSeverity="ERROR" displayName="확장이 허용되지 않은 하위 클래스" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
sealed 기본 클래스를 확장하지 않는 허용된 클래스를 보고합니다.
&lt;p&gt;Groovy에서는 모든 허용된 클래스를 컴파일 시간에 사용할 필요가 없고 기본 클래스와 함께 컴파일링할 필요가 없습니다. 컴파일러는 허용된 비확장 하위 클래스의 처리에 관해 사용자에게 경고하지 않지만, 이는 sealed 클래스의 본질과 모순됩니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A permits B {} // B를 보고합니다
  class B {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrPermitsClause&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyLabeledStatement" defaultSeverity="WARNING" displayName="라벨 지정된 구문 검사" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상위 워크플로에서 이미 사용한 라벨을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
cycle:
for (element in list) {
  cycle: // 혼란스러운 라벨 반복
  element.chars().forEach {
  }
}
&lt;/code&gt;
&lt;/pre&gt;


&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyLabeledStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyRangeTypeCheck" defaultSeverity="WARNING" displayName="올바르지 않은 범위 인수" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;next()&lt;/code&gt; 또는 &lt;code&gt;previous()&lt;/code&gt; 메서드를 포함하지 않거나 &lt;code&gt;java.lang.Comparable&lt;/code&gt; 인터페이스를 구현하지 않는 범위에서 사용된 타입을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyRangeTypeCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInfiniteLoopStatement" defaultSeverity="WARNING" displayName="무한 루프 문" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
예외를 던져야만 종료할 수 있는 &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;do&lt;/code&gt; 문을 보고합니다. 그러한 구문은 올바를 수 있지만 대개 실수로 발생합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
while(true) {
  Thread.sleep(1000)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyInfiniteLoopStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDivideByZero" defaultSeverity="WARNING" displayName="0으로 나누기" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
0으로 나누기 연산 또는 0의 나머지 연산을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def a = 42
  a / 0 // 경고
  a % 0.0 // 경고
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyDivideByZero&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrSwitchExhaustivenessCheck" defaultSeverity="WEAK WARNING" displayName="switch 식의 완전성 확인" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
일치하는 표현식의 가능한 모든 결과를 포함하지 않는 switch 식을 보고합니다.
&lt;p&gt;Groovy에서는 switch 식이 완전하지 않아도 됩니다. 묵시적 &lt;code&gt;default -&gt; null&lt;/code&gt; 브랜치가 삽입된 것처럼 동작합니다.
  개발자가 필요한 &lt;code&gt;case&lt;/code&gt; 브랜치를 삽입하는 것을 잊어버린 경우 예기치 않은 null이 발생할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum A { X, Y }

  def foo(A a) {
    def x = switch (a) { // reports switch
      case A.X -&gt; ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrSwitchExhaustivenessCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInArgumentCheck" defaultSeverity="WARNING" displayName="호환되지 않는 'in'인수 타입" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
호환되지 않는 타입의 항목 및 컨테이너가 포함된 멤버십 연산자 &lt;code&gt;in&lt;/code&gt;의 사용을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = [1, 2]
if ("foo" in list) {} // 문자열을 포함할 수 없는 정수 목록
&lt;/code&gt;
&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyInArgumentCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDocCheck" defaultSeverity="ERROR" displayName="해결되지 않은 GroovyDoc 참조" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
GroovyDoc 주석 내에서 해결되지 않은 참조를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyDocCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SecondUnsafeCall" defaultSeverity="WARNING" displayName="두 번째 안전하지 않은 호출" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;체인 메서드 또는 프로퍼티를 호출하는 동안 발생할 수 있는 &lt;b&gt;NullPointerException&lt;/b&gt;을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  domain?.getZone().getName()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  domain?.getZone()?.getName()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SecondUnsafeCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnresolvedAccess" defaultSeverity="WEAK WARNING" displayName="해결되지 않은 참조 표현식" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;해결할 수 없는 참조 표현식을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrUnresolvedAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAccessibility" defaultSeverity="WARNING" displayName="액세스할 수 없는 요소" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
액세스 권한을 초과하는 참조를 보고합니다.
&lt;p&gt;private 멤버에 액세스하면 캡슐화가 손상됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyAccessibility&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConstructorNamedArguments" defaultSeverity="WARNING" displayName="생성자 호출의 이름 지정된 인수" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 클래스의 프로퍼티에 대응하지 않는 디폴트 클래스 생성자 호출의 명명된 인수를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
      def name
      def age
  }

  // 'firstName' 프로퍼티가 없습니다
  new Person(firstName: "John")
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyConstructorNamedArguments&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrEqualsBetweenInconvertibleTypes" defaultSeverity="WARNING" displayName="변환할 수 없는 타입의 객체 간의 'equals()'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대상과 인수의 타입이 호환되지 않는 &lt;code&gt;equals()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;그러한 호출은 이론적으로 유용할 수 있지만 버그일 가능성이 매우 높습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    new HashSet&amp;lt;String&amp;gt;() == new TreeSet&amp;lt;Integer&amp;gt;())
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrEqualsBetweenInconvertibleTypes&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNonShortCircuitBoolean" defaultSeverity="WARNING" displayName="쇼트 서킷이 아닌 부울" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
'and' 및 'or' bool 연산자(&lt;code&gt;&amp;&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt;)의 비단락 형식을
보고합니다.
&lt;p&gt;
  이러한 비단락 버전은 유용할 때도 있지만 비단락 형식(&lt;code&gt;&amp;&amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt;)의 오타인 경우가 많아 탐지하기 어려운 버그를 발생시킬 수 있습니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if (a &amp; b) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if (a &amp;&amp; b) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyNonShortCircuitBoolean&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUntypedAccess" defaultSeverity="WARNING" displayName="타입이 없는 참조 표현식" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;타입을 파악할 수 없는 참조 표현식을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyUntypedAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyResultOfObjectAllocationIgnored" defaultSeverity="WARNING" displayName="객체 대입의 결과가 무시됨" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 연산의 결과가 무시된 객체 할당을 보고합니다.
&lt;p&gt;
  그러한 할당 표현식은 Groovy에서 올바르지만 보통 실수이거나 매우 복잡한 객체 초기화 전략을 나타냅니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyResultOfObjectAllocationIgnored&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInfiniteRecursion" defaultSeverity="WARNING" displayName="무한 재귀" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
무한으로 재귀하거나 예외를 던지는 메서드를 보고합니다.
이 검사에서 보고되는 메서드는 올바로 완료되지 않습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
// 이 함수는 항상 더 깊이 들어갑니다
def fibonacci(int n) {
  return fibonacci(n-1) + fibonacci(n-2)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyInfiniteRecursion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Velocity" path=""><inspection shortName="VtlReferencesInspection" defaultSeverity="WARNING" displayName="참조 검사" enabled="false" language="VTL" pluginId="com.intellij.velocity" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Velocity 참조가 잘못 해결된 경우를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VtlReferencesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VtlTypesInspection" defaultSeverity="WARNING" displayName="타입 검사" enabled="false" language="VTL" pluginId="com.intellij.velocity" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이항 및 단항 표현식이 잘못된 타입의 피연산자를 포함하는 경우를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VtlTypesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VtlFileReferencesInspection" defaultSeverity="WARNING" displayName="파일 참조 검사" enabled="false" language="VTL" pluginId="com.intellij.velocity" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;#include&lt;/code&gt; 및 &lt;code&gt;#parse&lt;/code&gt; 지시문 내 Velocity 파일 참조가 잘못 해결된 경우를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VtlFileReferencesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VtlInterpolationsInspection" defaultSeverity="ERROR" displayName="정형성 검사" enabled="false" language="VTL" pluginId="com.intellij.velocity" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;#macro&lt;/code&gt; 및 &lt;code&gt;#set&lt;/code&gt; 지시문 내 형식 표시가 잘못 사용된 경우를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VtlInterpolationsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VtlDirectiveArgsInspection" defaultSeverity="WARNING" displayName="지시문 인수 검사" enabled="false" language="VTL" pluginId="com.intellij.velocity" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Velocity 지시문의 잘못된 값 또는 인수 타입을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VtlDirectiveArgsInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="스레딩 문제" path="Java"><inspection shortName="BusyWait" defaultSeverity="WARNING" displayName="바쁜 대기" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루프 내에서 발생하는 &lt;code&gt;java.lang.Thread.sleep()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;이러한 호출은 '대기 중이라 바쁨'(busy-waiting)을 나타냅니다. 바쁜 대기 중인 스레드는 잠긴 리소스를 해제하지 않기 때문에 이 상태는 비효율적이기 쉽고, 예기치 않은 교착 상태가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
     volatile int x;
     public void waitX() throws Exception {
      while (x &amp;gt; 0) {
        Thread.sleep(10);//경고: 루프 내 'Thread.sleep()' 호출이 바쁜 대기 중일 수 있습니다
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: BusyWait&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NakedNotify" defaultSeverity="WARNING" displayName="해당하는 상태 변경 없는 'notify()' 또는 'notifyAll()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
탐지 가능한 상태 변화가 일어나지 않고도 &lt;code&gt;Object.notify()&lt;/code&gt; 또는 &lt;code&gt;Object.notifyAll()&lt;/code&gt;이 호출되는 경우를 보고합니다.
&lt;p&gt;
  일반적으로 &lt;code&gt;Object.notify()&lt;/code&gt; 및 &lt;code&gt;Object.notifyAll()&lt;/code&gt;은 상태 변화가 일어났음을 다른 스레드에 알리는 데 사용됩니다. 이때 상태 변화는 &lt;code&gt;Object.notify()&lt;/code&gt; 또는 &lt;code&gt;Object.notifyAll()&lt;/code&gt; 호출을 포함하는 동기화된 컨텍스트에서 호출 이전에 일어나야 합니다. 그러한 상태 변화가 없는 것이 반드시 잘못된 것은 아니지만 검사해 볼 가치는 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (this) {
    notify();
  }
  // no state change
  synchronized (this) {
    notify(); // 이 notify는 불필요할 수 있습니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: NakedNotify&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DoubleCheckedLocking" defaultSeverity="WARNING" displayName="이중 검사된 락" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"&gt;이중 검사된 잠금&lt;/a&gt;을 보고합니다.
&lt;p&gt;
  이중 검사된 잠금은 동기화 비용을 줄이는 한편 스레드가 안전한 방식으로 요청 기반의 필드 초기화를 시도합니다.
  이 방식을 &lt;code&gt;volatile&lt;/code&gt;로 선언되지 않은 필드에서 사용할 경우, 스레드 안전이 유지되지 않습니다.
  Java 1.4 이하 버전을 사용할 경우, 이중 검사된 잠금은 &lt;code&gt;volatile&lt;/code&gt; 필드에서도 작동하지 않습니다.
  해당 문제와 관련한 자세한 설명은 위에 링크된 글을 참조하세요.
&lt;/p&gt;
&lt;p&gt;부적절한 이중 검사된 잠금의 예시:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    private Helper helper = null;
    public Helper getHelper() {
      if (helper == null)
        synchronized(this) {
          if (helper == null) helper = new Helper();
        }
        return helper;
      }
    }
    // 다른 함수 및 멤버...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DoubleCheckedLocking&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitNotifyNotInSynchronizedContext" defaultSeverity="WARNING" displayName="'wait()' 또는 'notify()'가 동기화된 컨텍스트에 없음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대응하는 동기화된 구문 또는 동기화된 메서드 안에서 이루어지지 않는 &lt;code&gt;wait()&lt;/code&gt;, &lt;code&gt;notify()&lt;/code&gt;, &lt;code&gt;notifyAll()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  잠금을 포함하지 않는 객체에서 이러한 메서드를 호출하면 &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; 예외가 발생합니다.
  그러한 구문이 반드시 오류인 것은 아니지만, 포함하는 메서드가 호출되기 전에 필요한 잠금을 얻을 수 있으므로 살펴볼 필요가 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Sync {
    private final Object lock = new Object();

    void test() throws InterruptedException {
      synchronized (this) {
        lock.wait(); // 'lock.wait()'가 'lock'에서 동기화되지 않습니다
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: WaitNotifyNotInSynchronizedContext&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptySynchronizedStatement" defaultSeverity="WARNING" displayName="빈 'synchronized' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 비어 있는 &lt;code&gt;synchronized&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;
  빈 &lt;code&gt;synchronized&lt;/code&gt; 문은 다른 스레드의 특정 리소스 릴리스를 대기하는 데 사용됩니다. 그러나 빈 &lt;code&gt;synchronized&lt;/code&gt; 문 완료 직후 동일한 리소스가 다시 획득되지 않는다는 보장은 없습니다.
  적절한 동기화를 위해 &lt;code&gt;synchronized&lt;/code&gt; 블록 내에서 리소스를 활용해야 합니다.
&lt;/p&gt;
&lt;p&gt;
  또한 불필요한 코드를 제거하면 리팩터링 후 빈 &lt;code&gt;synchronized&lt;/code&gt; 블록이 표시될 수 있습니다. 이 경우 &lt;code&gt;synchronized&lt;/code&gt; 블록 자체가 불필요하므로 제거해야 합니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized(lock) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  빠른 수정에서는 빈 synchronized 문을 제거할 것을 제안합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 검사는 JSP 파일에서 비활성화되어 있습니다.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: EmptySynchronizedStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadStartInConstruction" defaultSeverity="WARNING" displayName="객체 생성 중에 'Thread.start()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
객체 생성 도중 &lt;code&gt;java.lang.Thread&lt;/code&gt; 또는 하위 클래스에서 &lt;code&gt;start()&lt;/code&gt;를 호출하는 경우를 보고합니다.
&lt;p&gt;
  그러한 구문은 때때로 유용하지만 상속 문제가 발생할 수 있으므로 피해야 합니다.
  객체 생성 도중 스레드를 시작하는 클래스의 하위 클래스는 스레드가 시작되기 전에 자신의 초기화 로직을 완료하지 못합니다.
&lt;/p&gt;
&lt;p&gt;이 검사는 스레드를 시작하는 클래스가 &lt;code&gt;final&lt;/code&gt;로 선언된 경우에는 보고하지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyThread extends Thread {
    MyThread() {
      start();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThreadStartInConstruction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AwaitWithoutCorrespondingSignal" defaultSeverity="WARNING" displayName="해당하는 'signal()'이 없는 'await()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대응하는 &lt;code&gt;Condition.signal()&lt;/code&gt; 또는 &lt;code&gt; Condition.signalAll() &lt;/code&gt; 로의 호출을 찾을 수 없는 경우 &lt;code&gt;Condition.await()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  대응하는 &lt;code&gt;Condition.signal()&lt;/code&gt;이 없이 스레드에서 &lt;code&gt;Condition.await()&lt;/code&gt;를 호출하면 스레드는 중단되거나 "비정상적으로 깨어나기" 전까지 비활성화될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;현재 클래스의 필드를 대상으로 하는 호출만 이 검사에서 보고됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Queue {
    private final Condition isEmpty = ...;

    void add(Object elem) {
      // ...
      // isEmpty.signal();
      // ...
    }

    void remove(Object elem) throws InterruptedException {
      // ...
      isEmpty.await(); // 'await()'가 대응하는 'signal()'/'signalAll()' 호출을 포함하지 않습니다
      // ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: AwaitWithoutCorrespondingSignal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadLocalNotStaticFinal" defaultSeverity="WARNING" displayName="'ThreadLocal' 필드가 'static final'로 선언되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;static final&lt;/code&gt;로 선언되지 않은 &lt;code&gt;java.lang.ThreadLocal&lt;/code&gt; 타입의 필드를 보고합니다.
&lt;p&gt;
  대부분의 경우 &lt;code&gt;java.lang.ThreadLocal&lt;/code&gt; 인스턴스는 상태를 스레드에 연결합니다. 
  static final이 아닌 &lt;code&gt;java.lang.ThreadLocal&lt;/code&gt; 필드는 상태를 인스턴스-스레드 결합에 연결합니다.
  일반적으로 이는 불필요하며 메모리 누수와 잘못된 동작을 초래하는 버그인 경우가 많습니다.
&lt;/p&gt;
&lt;p&gt;
  빠른 수정은 필드를 &lt;code&gt;static final&lt;/code&gt;로 만들도록 제안합니다.
&lt;p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private ThreadLocal tl = ThreadLocal.withInitial(() -&gt; Boolean.TRUE);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThreadLocalNotStaticFinal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionSignal" defaultSeverity="WARNING" displayName="'signalAll()' 대신 'signal()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.concurrent.locks.Condition.signal()&lt;/code&gt; 호출을 보고합니다. 유용한 경우도 있으나 거의 모든 경우에 &lt;code&gt;signalAll()&lt;/code&gt;이 더 안전하고 나은 선택입니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConditionSignal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSynchronizedMethodOverridesSynchronizedMethod" defaultSeverity="WARNING" displayName="비동기화된 메서드가 'synchronized' 메서드를 재정의합니다." enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;synchronized&lt;/code&gt; 메서드를 재정의하는 비 &lt;code&gt;synchronized&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;
  상위 클래스 메서드가 &lt;code&gt;synchronized&lt;/code&gt;로 선언되지 않을 경우 재정의된 메서드는 자동으로 동기화되지 않습니다. 따라서 하위 클래스를 사용할 때 예기치 않은 경합 조건이 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    synchronized void process() {}
  }
  class Sub extends Super {
    // 동기화되지 않은 메서드 'process()'는 동기화된 메서드를 재정의합니다
    void process() {}
  }  
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonSynchronizedMethodOverridesSynchronizedMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitWithoutCorrespondingNotify" defaultSeverity="WARNING" displayName="해당하는 'notify()'가 없는 'wait()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대응하는 &lt;code&gt;Object.notify()&lt;/code&gt; 또는 &lt;code&gt;Object.notifyAll()&lt;/code&gt;을 찾을 수 없는 경우 &lt;code&gt;Object.wait()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;이 검사는 현재 클래스의 필드를 참조하는 한정자를 사용한 호출만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {
    public Object foo = new Object();

    void bar() throws InterruptedException {
      this.foo.wait();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: WaitWithoutCorrespondingNotify&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SignalWithoutCorrespondingAwait" defaultSeverity="WARNING" displayName="해당하는 'await()'가 없는 'signal()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대응하는 &lt;code&gt;Condition.await()&lt;/code&gt; 호출을 찾을 수 없는 경우 &lt;code&gt;Condition.signal()&lt;/code&gt; 또는 &lt;code&gt;Condition.signalAll()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;현재 클래스의 필드를 대상으로 하는 호출만 이 검사에서 보고됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Queue {
    private final Condition isEmpty = ...;

    void add(Object elem) {
      // ...
      isEmpty.signal(); // 경고: 대응하는 'await()'가 없는 'signal()' 호출
      // ...
    }

    void remove(Object elem) throws InterruptedException {
      // ...
      //      isEmpty.await();
      // ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: SignalWithoutCorrespondingAwait&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitNotInLoop" defaultSeverity="WARNING" displayName="'wait()'가 루프에서 호출되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루프 내부에서 이루어지지 않는 &lt;code&gt;wait()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  &lt;code&gt;wait()&lt;/code&gt;는 보통 어떤 조건이 true가 될 때까지 스레드를 중지하기 위해 사용됩니다.
  스레드가 다른 이유로 깨어났을 수 있으므로 &lt;code&gt;wait()&lt;/code&gt; 호출이 반환된 후 조건을 검사해야 합니다.
  루프는 이를 수행하기 위한 간단한 방법입니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class BoundedCounter {
    private int count;
    synchronized void inc() throws InterruptedException {
      if (count &gt;= 10) wait();
      ++count;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;좋은 코드는 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class BoundedCounter {
    private int count;
    synchronized void inc() throws InterruptedException {
      while (count &gt;= 10) wait();
      ++count;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: WaitNotInLoop&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicFieldAccessedInSynchronizedContext" defaultSeverity="WARNING" displayName="'synchronized' 컨텍스트에서 비 private 필드 액세스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동기화된 컨텍스트에서 액세스할 수 있으며 &lt;code&gt;final&lt;/code&gt; 또는 &lt;code&gt;private&lt;/code&gt;이 아닌 필드를 보고합니다.
&lt;p&gt;
  &lt;code&gt;private&lt;/code&gt;이 아닌 필드에 항상 동기화된 방식으로 액세스할 수 있는 것은 아니며, 그렇게 '부분적으로 동기화된' 액세스는 예기치 않은 데이터 구조의 일관성 문제를 야기할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar {
    public String field1;
  }
  public Bar myBar;

  synchronized public void sample() {
   myBar.field1 = "bar";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PublicFieldAccessedInSynchronizedContext&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AwaitNotInLoop" defaultSeverity="WARNING" displayName="'await()'가 루프에서 호출되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.concurrent.locks.Condition.await()&lt;/code&gt;가 루프 내부에서 호출되지 않는 경우를 보고합니다.
&lt;p&gt;
  &lt;code&gt;await()&lt;/code&gt; 및 관련 메서드는 보통 어떤 조건이 true가 될 때까지 스레드를 중지하기 위해 사용됩니다.
  스레드가 다른 이유로 시작되었을 수 있으므로 &lt;code&gt;await()&lt;/code&gt; 호출이 반환된 후 조건을 검사해야 합니다.
  루프는 이를 수행하기 위한 간단한 방법입니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void acquire(Condition released) throws InterruptedException {
    released.await();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;좋은 코드는 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void acquire(Condition released) throws InterruptedException {
    while (acquired) {
      released.await();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AwaitNotInLoop&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonAtomicOperationOnVolatileField" defaultSeverity="WARNING" displayName="'volatile' 필드에 대한 아토믹이 아닌 연산" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
volatile 필드에서 atomic이 아닌 연산을 보고합니다.
&lt;p&gt;
  atomic이 아닌 연산의 예시로는 증분 연산자를 사용하는 필드의 업데이트가 있습니다.
  해당 연산에는 읽기 및 쓰기 작업이 포함되며 중간에 다른 수정이 발생할 수 있어 데이터가 손상될 수 있습니다.
  연산을 &lt;code&gt;synchronized&lt;/code&gt; 블록으로 감싸거나 &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; 패키지의 클래스 중 하나를 사용하여 atomic으로 설정할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private volatile int v = 1;

  void foo() {
    v = 2 * v;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonAtomicOperationOnVolatileField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizeOnThis" defaultSeverity="WARNING" displayName="'this' 동기화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;class&lt;/code&gt; 표현식의 동기화를 보고합니다.
보고된 구문에는 &lt;code&gt;synchronized&lt;/code&gt; 블록 및 &lt;code&gt;wait()&lt;/code&gt;, &lt;code&gt;notify()&lt;/code&gt; 또는 &lt;code&gt;notifyAll()&lt;/code&gt; 호출이 포함됩니다.
&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;class&lt;/code&gt; 표현식의 동기화가 부적절한 이유로는 다음과 같은 몇 가지가 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    동기화가 클래스의 외부 인터페이스의 일부가 되므로 향후 다른 잠금 메커니즘을 변경하기 어렵습니다
  &lt;/li&gt;
  &lt;li&gt;
    주어진 객체를 잠그는 대상을 추적하기 어렵습니다
  &lt;/li&gt;
  &lt;li&gt;
    서비스 거부 공격(DoS)이 의도적으로 발생하거나 하위 클래스화 시 실수로 발생할 수 있습니다
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그 대신 액세스를 완전히 제어할 수 있는 &lt;code&gt;private final&lt;/code&gt; lock 객체에서 동기화를 고려할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void print() {
    synchronized(this) { // 경고: 'this' 클래스의 잠금 연산은 예기치 않은 부수 효과를 발생시킬 수 있습니다
      System.out.println("synchronized");
    }
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SynchronizeOnThis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizeOnLock" defaultSeverity="WARNING" displayName="'Lock' 객체 동기화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt;의 인스턴스를 잠그는 &lt;code&gt;synchronized&lt;/code&gt; 블록을 보고합니다.
이러한 동기화는 의도된 경우가 거의 없으므로 &lt;code&gt;.lock()&lt;/code&gt; 및 &lt;code&gt;.unlock()&lt;/code&gt;의 적절한 버전을 대신 사용해야 합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final ReentrantLock lock = new ReentrantLock();

  public void foo() {
    synchronized (lock) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SynchronizeOnLock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NotifyCalledOnCondition" defaultSeverity="WARNING" displayName="'java.util.concurrent.locks.locks.Condition' 객체에서 'notify()' 또는 'notifyAll()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.concurrent.locks.Condition&lt;/code&gt; 객체에서 이루어진 &lt;code&gt;notify()&lt;/code&gt; 또는 &lt;code&gt;notifyAll()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  이는 프로그래밍 오류일 수 있으며 대신 &lt;code&gt;signal()&lt;/code&gt; 또는 &lt;code&gt;signalAll()&lt;/code&gt; 메서드의 일부 변형이 의도되었을 수 있습니다. 그렇지 않은 경우, &lt;code&gt;IllegalMonitorStateException&lt;/code&gt;이 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    final Lock l = new ReentrantLock();
    final Condition c = l.newCondition();

    void release() {
      l.lock();
      try {
        c.notifyAll(); // 'signalAll()'이 의도되었을 수 있습니다
      } finally {
        l.unlock();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: NotifyCalledOnCondition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadYield" defaultSeverity="WARNING" displayName="'Thread.yield()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Thread.yield()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  &lt;code&gt;yield()&lt;/code&gt;의 동작은 비결정적이고 플랫폼에 의존하기 때문에 이 메서드를 사용하는 것이 적절한 경우는 거의 없습니다.
  이 메서드의 사용은 상세한 프로파일링 및 벤치마킹과 결합하여 실제로 원하는 효과를 얻을 수 있도록 해야 합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public static void main(String[] args) {
    Runnable r = () -&gt; {
      for (int i = 0; i &amp;lt; 10; i++) {
        System.out.println(i);
        Thread.yield();
      }
    };
    new Thread(r).start();
    new Thread(r).start();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThreadYield&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToNativeMethodWhileLocked" defaultSeverity="WARNING" displayName="'native' 메서드가 잠긴 상태에서 해당 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;synchronized&lt;/code&gt; 블록 또는 메서드 내부의 &lt;code&gt;native&lt;/code&gt; 메서드 호출을 보고합니다.
&lt;p&gt;
  가능하면 &lt;code&gt;native&lt;/code&gt; 메서드 호출을 동기화된 컨텍스트 외부에 유지하는 것이 더 낫습니다. 그러한 호출은 비용이 큰 컨텍스트 전환을 발생시켜 성능 이슈로 이어질 수 있기 때문입니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  native void nativeMethod();

  void example(){
    synchronized (lock){
      nativeMethod(); // 경고
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CallToNativeMethodWhileLocked&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadPriority" defaultSeverity="WARNING" displayName="'Thread.setPriority()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Thread.setPriority()&lt;/code&gt; 호출을 보고합니다.
Java 사양에서는 우선순위가 스레드를 스케줄링하는 데 사용되는 방식이나 심지어 사용되는지 여부조차 보장하지 않기 때문에 스레드 우선순위의 변경은 본질적으로 포팅 불가능한 작업입니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThreadPriority&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizedMethod" defaultSeverity="WARNING" displayName="'synchronized' 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드에 사용된 &lt;code&gt;synchronized&lt;/code&gt; 제어자를 보고합니다.
&lt;p&gt;
  메서드에 &lt;code&gt;synchronized&lt;/code&gt; 제어자를 사용하는 것이 좋지 않은 이유로는 다음과 같은 몇 가지가 있습니다.
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    잠금 상태에서는 최대한 적은 작업이 수행되어야 합니다. 그러므로 보통 &lt;code&gt;synchronized&lt;/code&gt; 블록을 사용하여 공유 상태에서 작동하는 코드만 유지하는 것이 더 낫습니다.
  &lt;/li&gt;
  &lt;li&gt;
    동기화는 메서드의 인터페이스의 일부가 됩니다. 다른 잠금 메커니즘으로의 전환이 어려워집니다.
  &lt;/li&gt;
  &lt;li&gt;
    무엇이 특정 객체를 잠그고 있는지 추적하기가 힘들어집니다.
  &lt;/li&gt;
  &lt;li&gt;
    DoS(서비스 거부) 공격은 메서드의 클래스를 상속받을 때 의도적으로 또는 자신도 모르게 실행이 가능해집니다.
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
  그 대신 액세스를 완전히 제어할 수 있는 &lt;code&gt;private final&lt;/code&gt; lock 객체에서 동기화를 고려할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;synchronized(this)&lt;/code&gt;으로 메서드 본문을 래핑하는 빠른 수정이 제공됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public synchronized void fooBar() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public void fooBar() {
      synchronized (this) {
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사에서 다음 옵션을 구성할 수 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;네이티브 메서드 포함&lt;/strong&gt;- 네이티브 메서드를 검사의 범위로 포함합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;동기화된 메서드를 재정의하는 메서드 무시&lt;/strong&gt; - &lt;code&gt;synchronized&lt;/code&gt; 메서드를 재정의하는 메서드를 보고하지 않습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: SynchronizedMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadLocalSetWithNull" defaultSeverity="WEAK WARNING" displayName="'null'을 인수로 갖는 'ThreadLocal.set()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
null을 인수로 갖는 &lt;code&gt;java.lang.ThreadLocal.set()&lt;/code&gt;을 보고합니다.
&lt;p&gt;이러한 호출은 리소스를 해제하지 않아 메모리 누수를 일으킬 수 있습니다.&lt;/p&gt;
발생 원인은 다음과 같을 수 있습니다.
&lt;ul&gt;
  &lt;li&gt;먼저 &lt;code&gt;ThreadLocal.set(null)&lt;/code&gt;이 현재 스레드와 연관된 맵을 찾습니다. 해당하는 맵이 없으면 생성됩니다.&lt;/li&gt;
  &lt;li&gt;키와 값이 설정됩니다. &lt;code&gt;map.set(this, value)&lt;/code&gt;에서 &lt;code&gt;this&lt;/code&gt;는 &lt;code&gt;ThreadLocal&lt;/code&gt;의 인스턴스를 의미합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;리소스를 해제하려면 &lt;code&gt;java.lang.ThreadLocal.remove()&lt;/code&gt;를 사용해야 합니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = new ThreadLocal&amp;lt;&amp;gt;();
  threadLocal.set(null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  threadLocal.remove();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;2023.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ThreadLocalSetWithNull&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizationOnGetClass" defaultSeverity="WARNING" displayName="'getClass()' 동기화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;getClass()&lt;/code&gt; 호출의 동기화를 보고합니다.
&lt;p&gt;
  동기화를 포함하는 클래스가 하위 클래스화될 경우 해당 하위 클래스는 다른 클래스 객체에서 동기화됩니다. 일반적으로 &lt;code&gt;getClass()&lt;/code&gt; 호출을 클래스 리터럴 표현식(예: &lt;code&gt;String.class&lt;/code&gt;)으로 대체할 수 있습니다. 더 좋은 해결 방법은 액세스가 완전히 제어될 수 있는 &lt;code&gt;private static final&lt;/code&gt; lock 객체에서 동기화를 수행하는 것입니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; synchronized(getClass()) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SynchronizationOnGetClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SleepWhileHoldingLock" defaultSeverity="WARNING" displayName="'Thread.sleep()'을 동기화 중에 호출 #loc" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;synchronized&lt;/code&gt; 블록 또는 메서드 내부에서 발생하는 &lt;code&gt;java.lang.Thread.sleep()&lt;/code&gt; 메서드 호출을 보고합니다.
&lt;p&gt;
  &lt;code&gt;synchronized&lt;/code&gt; 블록 내부의 &lt;code&gt;sleep()&lt;/code&gt;은 성능 저하, 확장성 부족, 심지어 교착상태를 초래할 수 있습니다. 대신 &lt;code&gt;wait()&lt;/code&gt;를 사용해 보세요. 이는 걸려 있는 잠금을 해제합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (lock) {
    Thread.sleep(100);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SleepWhileHoldingLock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadStopSuspendResume" defaultSeverity="WARNING" displayName="'Thread.stop()', 'suspend()' 또는 'resume()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Thread.stop()&lt;/code&gt;,
&lt;code&gt;Thread.suspend()&lt;/code&gt; 및 &lt;code&gt;Thread.resume()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  이러한 호출은 본질적으로 데이터 손상 및 교착상태로 이어지기 쉬우므로 사용하지 않는 것이 좋습니다.
  &lt;code&gt;stop&lt;/code&gt; 대신 협조적 취소를, &lt;code&gt;suspend&lt;/code&gt; 및 &lt;code&gt;resume&lt;/code&gt;을 직접 호출하는 대신 중단을 사용하는 것이 더 낫습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThreadStopSuspendResume&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldAccessedSynchronizedAndUnsynchronized" defaultSeverity="WARNING" displayName="'synchronized' 및 비동기화 컨텍스트 모두에서 액세스되는 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;synchronized&lt;/code&gt; 컨텍스트 및 &lt;code&gt;synchronized&lt;/code&gt;가 아닌 컨텍스트 모두에서 액세스하는 final이 아닌 필드를 보고합니다.
이 검사에서는 &lt;code&gt;volatile&lt;/code&gt; 필드 및 생성자와 이니셜라이저의 액세스도 무시됩니다.
&lt;p&gt;
  이처럼 '부분적으로 동기화된' 액세스는 보통 코딩 실수로 인한 결과이며 이로 인해 예기치 않은 데이터 구조의 불일치가 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Program {
    Console console; // 경고: 'console' 필드는 동기화된 컨텍스트 및 동기화되지 않은 컨텍스트 모두에서 액세스할 수 있습니다

    public synchronized void execute() {
      console.print("running");
    }

    public void check() {
      console.check();
    }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  간단한 getter 및 setter도 액세스로 간주할지 여부를 명시하는 옵션을 사용합니다.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: FieldAccessedSynchronizedAndUnsynchronized&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AtomicFieldUpdaterNotStaticFinal" defaultSeverity="WARNING" displayName="'AtomicFieldUpdater' 필드가 'static final'로 선언되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;static final&lt;/code&gt;이 아닌 다음 타입의 필드를 보고합니다:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;java.util.concurrent.atomic.AtomicLongFieldUpdater&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.concurrent.atomic.AtomicIntegerFieldUpdater&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.concurrent.atomic.AtomicReferenceFieldUpdater&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
 
클래스의 모든 인스턴스에서 &lt;code&gt;volatile&lt;/code&gt; 필드를 업데이트하는 데 필요한 atomic 필드 업데이터는 하나뿐이므로 거의 항상 &lt;code&gt;static&lt;/code&gt;일 수 있습니다.

&lt;p&gt;업데이터를 &lt;code&gt;final&lt;/code&gt;로 만들면 JVM이 성능 향상을 위해 액세스를 최적화할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    private volatile int id;
    private AtomicIntegerFieldUpdater&amp;lt;Main&amp;gt; idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, "id");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    private volatile int id;
    private static final AtomicIntegerFieldUpdater&amp;lt;Main&amp;gt; idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, "id");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AtomicFieldUpdaterNotStaticFinal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitCalledOnCondition" defaultSeverity="WARNING" displayName="'java.util.concurrent.locks.locks.Condition' 객체에서 'wait()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.concurrent.locks.Condition&lt;/code&gt; 객체에서 이루어진 &lt;code&gt;wait()&lt;/code&gt; 호출을 보고합니다. 이는 프로그래밍 오류일 수 있으며 대신 &lt;code&gt;await()&lt;/code&gt; 메서드의 변형이 의도되었을 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void acquire(Condition released) throws InterruptedException {
    while (acquired) {
      released.wait();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;좋은 코드는 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void acquire(Condition released) throws InterruptedException {
    while (acquired) {
      released.await();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: WaitCalledOnCondition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizationOnLocalVariableOrMethodParameter" defaultSeverity="WARNING" displayName="지역 변수 또는 메서드 매개변수 동기화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지역 변수 또는 매개변수의 동기화를 보고합니다. 
&lt;p&gt;
  그러한 동기화를 사용하면 정확한 연산을 보장하기가 매우 어렵습니다.
  이 코드는 synchronized 래퍼 클래스를 사용하여 액세스를 제어하거나 필드에서 동기화를 진행하여 개선할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void bar() {
    final Object lock = new Object();
    synchronized (lock) { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SynchronizationOnLocalVariableOrMethodParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ThreadWithDefaultRunMethod" defaultSeverity="WARNING" displayName="디폴트 'run()' 메서드로 스레드 초기화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Runnable&lt;/code&gt; 매개변수를 지정하거나 &lt;code&gt;run()&lt;/code&gt; 메서드를 재정의하지 않고 &lt;code&gt;Thread&lt;/code&gt;나 상속자가 인스턴스화되면 보고합니다.
해당 스레드는 아무 효과가 없습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Thread().start();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThreadWithDefaultRunMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AccessToNonThreadSafeStaticFieldFromInstance" defaultSeverity="WARNING" displayName="Non-thread-safe 'static' 필드 액세스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
스레드 안전하지 않은 타입의 &lt;code&gt;static&lt;/code&gt; 필드에 대한 액세스를 보고합니다.
&lt;p&gt;
  인스턴스 메서드 또는 비동기 블록에서 &lt;code&gt;static&lt;/code&gt; 필드에 액세스할 경우 여러 스레드가 해당 필드에 액세스할 수 있습니다.
  이때 예외나 잘못된 결과와 같이 불명확한 부수 효과가 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Sample {
    private static final SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
    String method() {
      return df.format("");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  스레드 안전한 것으로 간주할 타입을 지정할 수 있습니다.
  해당 타입에는 스레드 안전한 하위 클래스가 있을 수 있으므로, 정확히 해당 타입이 포함된 필드 또는 정확히 해당 타입으로 초기화된 필드만 보고됩니다.
&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: AccessToNonThreadSafeStaticFieldFromInstance&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitOrAwaitWithoutTimeout" defaultSeverity="WARNING" displayName="시간 제한 없는 'wait()' 또는 'await()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
시간 제한을 지정하지 않은 &lt;code&gt;Object.wait()&lt;/code&gt; 또는 &lt;code&gt;Condition.await()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  &lt;code&gt;notify()&lt;/code&gt;/&lt;code&gt;notifyAll()&lt;/code&gt; 또는 &lt;code&gt;signal()&lt;/code&gt;/&lt;code&gt;signalAll()&lt;/code&gt;가 호출되지 않는 경우, 하나의 구성 요소에서 장애가 발생하면 대기 중인 구성 요소가 차단될 수 있으므로 그러한 호출은 고가용성 프로그램에서 위험할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object bar) throws InterruptedException {
    bar.wait();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: WaitOrAwaitWithoutTimeout&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NotifyWithoutCorrespondingWait" defaultSeverity="WARNING" displayName="해당하는 'wait()'가 없는 'notify()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대응하는 &lt;code&gt;Object.wait()&lt;/code&gt; 호출을 찾을 수 없는 경우 &lt;code&gt;Object.notify()&lt;/code&gt; 또는 &lt;code&gt;Object.notifyAll()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;현재 클래스의 필드를 대상으로 하는 호출만 이 검사에서 보고됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (synList) {
    synList.notify(); //synList.wait()이 전혀 호출되지 않습니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NotifyWithoutCorrespondingWait&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemRunFinalizersOnExit" defaultSeverity="WARNING" displayName="'System.runFinalizersOnExit()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;System.runFinalizersOnExit()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
  이는 Java 언어에서 가장 위험한 호출 중 하나입니다. 본질적으로 스레드에서 안전하지 않으며 데이터 손상, 교착상태를 야기할 수 있고 호출 지점과 멀리 떨어진 프로그램의 일부에 영향을 줄 수 있습니다.
  이 호출은 사용이 중단되었으며 JDK 11에서 제거되었으므로 사용하지 않기를 강력히 권장합니다.
&lt;/p&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 10 이하인 경우에만 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SystemRunFinalizersOnExit&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedSynchronizedStatement" defaultSeverity="WARNING" displayName="중첩된 'synchronized' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
중첩된 &lt;code&gt;synchronized&lt;/code&gt; 문을 보고합니다.
일부 경우엔 교착 상태가 발생할 수 있으므로 가능하다면 중첩된 동기화를 사용하지 않는 것이 좋습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (lockA){
    //스레드 1에서 lockB 대기 중
    synchronized (lockB){ //경고
    }
  }
  ...
  synchronized (lockB) {
    //스레드 2에서 lockA 대기 중
    synchronized (lockA) { //경고
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NestedSynchronizedStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizationOnStaticField" defaultSeverity="WARNING" displayName="'static' 필드 동기화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;static&lt;/code&gt; 필드의 동기화를 보고합니다. 
&lt;code&gt;static&lt;/code&gt; 필드의 동기화는 엄밀하게 부정확하다고 할 수 없지만 경합으로 인해 성능이 저하될 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SynchronizationOnStaticField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AtomicFieldUpdaterIssues" defaultSeverity="WARNING" displayName="일관되지 않은 'AtomicFieldUpdater' 선언" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;,
&lt;code&gt;AtomicIntegerFieldUpdater&lt;/code&gt; 또는 &lt;code&gt;AtomicReferenceFieldUpdater&lt;/code&gt; 필드(&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; 패키지) 관련 문제를 보고합니다.
&lt;p&gt;보고된 문제는 지정된 필드 없음, 지정된 필드에 액세스 가능하지 않음, 지정된 필드의 타입이 잘못됨 등, 원자 필드 업데이터에서 발생할 수 있는 런타임 문제와 동일합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;pre&gt;&lt;code&gt;
  class A {
    private static volatile int value = 0;
    private static final AtomicIntegerFieldUpdater updater =
    AtomicIntegerFieldUpdater.newUpdater((A.class), "value"); // 경고: 필드 'value'에 'static' 제어자가 있습니다
  }
  &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;&lt;pre&gt;&lt;code&gt;
  class B {
    private static final AtomicIntegerFieldUpdater updater =
      AtomicIntegerFieldUpdater.newUpdater(B.class, "value"); // 경고: 클래스 'B'에 'value'라는 필드가 없습니다
  }
  &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AtomicFieldUpdaterIssues&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizedOnLiteralObject" defaultSeverity="WARNING" displayName="리터럴로 초기화된 객체 동기화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
리터럴로 초기화되는 객체를 잠그는 &lt;code&gt;synchronized&lt;/code&gt; 블록을 보고합니다.
&lt;p&gt;
  문자열 리터럴은 억류(intern)되며 &lt;code&gt;Character&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt; 및 &lt;code&gt;Number&lt;/code&gt; 리터럴은 캐시에서 할당될 수 있습니다.
  이로 인해 동일한 리터럴로 초기화된 객체를 사용하는 시스템의 다른 부분이 실제로는 동일한 객체에 대한 참조를 보유할 수 있습니다. 이때 lock 객체가 private으로 간주될 경우 예기치 않은 교착 상태가 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    final String mutex = "Mutex";
    void method() {
      synchronized (mutex) {
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;strong&gt;가능한 모든 리터럴에 대해 경고&lt;/strong&gt; 옵션을 사용하여 &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt; 및 &lt;code&gt;Number&lt;/code&gt; 객체의 동기화를 보고합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SynchronizedOnLiteralObject&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticInitializerReferencesSubClass" defaultSeverity="WARNING" displayName="정적 이니셜라이저가 하위 클래스를 참조" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
static 이니셜라이저 또는 static 필드에서 하위 클래스를 참조하는 클래스를 보고합니다.
&lt;p&gt;스레드 한 개가 상위 클래스를 로드하고 다른 스레드는 동시에 하위 클래스를 로드하려는 경우 이러한 참조로 인해 JVM 수준의 교착 상태가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    static final Child field = new Child();
  }
  class Child extends Parent { }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: StaticInitializerReferencesSubClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectNotify" defaultSeverity="WARNING" displayName="'notifyAll()' 대신 'notify()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Object.notify()&lt;/code&gt; 호출을 보고합니다. 유용한 경우도 있으나 거의 모든 경우에 &lt;code&gt;Object.notifyAll()&lt;/code&gt;이 더 나은 선택입니다. &lt;code&gt;Object.notify()&lt;/code&gt; 호출은 교착상태로 이어질 수 있기 때문입니다.
논의를 위해 Doug Lea의 &lt;i&gt;Java 내 동시성 프로그래밍&lt;/i&gt;을 참고하세요.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ObjectNotify&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodMayBeSynchronized" defaultSeverity="WARNING" displayName="'synchronized' 블록이 있는 메서드를 'synchronized'  메서드로 바꿀 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문에 하나의 &lt;code&gt;synchronized&lt;/code&gt; 문이 포함된 메서드를 보고합니다.
이 &lt;code&gt;synchronized&lt;/code&gt; 문의 잠금 표현식은 인스턴스 메서드의 &lt;code&gt;this&lt;/code&gt; 또는 static 메서드의 &lt;code&gt;[ClassName].class&lt;/code&gt;와 동등해야 합니다.
&lt;p&gt;
  해당 메서드의 가독성을 개선하려면 &lt;code&gt;synchronized&lt;/code&gt; 래퍼를 제거하고 메서드를 &lt;code&gt;synchronized&lt;/code&gt;로 표시해야 합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int generateInt(int x) {
    synchronized (this) {
      return 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public synchronized int generateInt(int x) {
    return 1;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: MethodMayBeSynchronized&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WhileLoopSpinsOnField" defaultSeverity="WARNING" displayName="필드에서 'while' 루프 스핀" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;volatile&lt;/code&gt;이 아닌 필드의 값에서 스핀하며 다른 스레드에 의해 변경되기를 기다리는&lt;code&gt;while&lt;/code&gt; 루프를 보고합니다.
&lt;p&gt;
그러한 루프는 루프 내에서 조금만 작업해도 CPU 사용량이 엄청나게 늘어나는 것 외에도 의도된 것과 다른 의미를 가질 가능성이 있습니다.
Java 메모리 모델에서는 다른 스레드가 필드 값을 변경하는 경우에도 그러한 루프가 완료되지 않습니다.
&lt;/p&gt;
&lt;p&gt;
또한 Java 9 이후에서 일부 하드웨어의 성능을 상당히 향상시킬 수 있도록 &lt;code&gt;volatile&lt;/code&gt; 필드의 스핀 루프 내에서 &lt;code&gt;Thread.onSpinWait()&lt;/code&gt;을 호출할 것을 권장합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SpinsOnField {
    boolean ready = false;

    void run() {
      while (!ready) {
      }
      // do some work
    }

    void markAsReady() {
      ready = true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SpinsOnField {
    volatile boolean ready = false;

    void run() {
      while (!ready) {
        Thread.onSpinWait();
      }
      // do some work
    }

    void markAsReady() {
      ready = true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
빈 &lt;code&gt;while&lt;/code&gt; 루프만 보고하려면 검사 옵션을 사용하세요.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: WhileLoopSpinsOnField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SafeLock" defaultSeverity="WARNING" displayName="획득했지만 안전하게 해제되지 않는 잠금" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;try&lt;/code&gt; 블록 전에 획득하지 않거나 대응하는 &lt;code&gt;finally&lt;/code&gt; 블록에서 잠금이 해제되지 않은 &lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt; 리소스를 보고합니다. 이러한 리소스를 닫기 전에 예외가 던져질 경우 의도치 않게 리소스 누수가 발생할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  lock.lock(); // 'finally' 블록이 누락되었으므로 보고됩니다
  try {
    doSmthWithLock();
  } catch (IOException e) {
    throw new UncheckedIOException(e);
  }
  lock.unlock();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SafeLock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AccessToStaticFieldLockedOnInstance" defaultSeverity="WARNING" displayName="'static' 필드에 대한 액세스가 인스턴스 데이터에서 잠겨 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;this&lt;/code&gt;의 인스턴스 필드에 잠겨 있는 상수가 아닌 정적 필드로의 액세스를 보고합니다.
&lt;p&gt;
  인스턴스 데이터에 정적 필드를 잠그는 것은 필드가 다른 인스턴스에 의해 수정되는 것을 방지하지 못하므로 예기치 않은 경합 조건을 초래할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static String test;
  public void foo() {
      synchronized (this) {
          System.out.println(test); // 경고
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  특정 타입의 static 필드를 무시하도록 허용하는 빠른 수정이 있습니다.
  무시된 타입은 검사 옵션에서 관리할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 옵션을 사용하여, static 필드에 사용된 클래스 중 무시되어야 하는 클래스를 지정합니다.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AccessToStaticFieldLockedOnInstance&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SharedThreadLocalRandom" defaultSeverity="WARNING" displayName="'ThreadLocalRandom'인스턴스를 공유할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
스레드 간에 공유될 수 있는&lt;code&gt;java.util.concurrent.ThreadLocalRandom&lt;/code&gt; 인스턴스를 보고합니다.
&lt;p&gt;
  &lt;code&gt;ThreadLocalRandom&lt;/code&gt;은 스레드 안전한 클래스가 아니기 때문에 스레드 간에 공유될 수 없습니다.
  이 검사는 메서드 인수로 사용된 필드에 대입되거나 지역 변수에 대입되어 익명 클래스 또는 중첩된 클래스에서 사용되는 인스턴스를 보고합니다. 이러한 인스턴스는 스레드 간에 공유될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;ThreadLocalRandom&lt;/code&gt;은 보통 &lt;code&gt;ThreadLocalRandom.current().nextInt(...)&lt;/code&gt;
  (또는 &lt;code&gt;nextDouble(...)&lt;/code&gt; etc.)와 같이 사용됩니다.
  모두 이러한 형식으로 사용될 경우, &lt;code&gt;ThreadLocalRandom&lt;/code&gt; 인스턴스는 우발적으로 여러 스레드에서 사용될 수 없습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    class Main {
      void printRandomNumbersAsync() {
        ThreadLocalRandom random = ThreadLocalRandom.current();
        CompletableFuture.supplyAsync(() -&amp;gt; generateNumbers(random))
          .thenAccept(numbers -&amp;gt; System.out.println(Arrays.toString(numbers)));
      }

      private int[] generateNumbers(Random random) {
        return random.ints(1000, 0, 100).toArray();
      }
    }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;ThreadLocalRandom&lt;/code&gt; 인스턴스를 인수로 전달하기에 안전한 메서드를 나열하려면 옵션을 사용하세요.
  메서드 이름으로 정규 표현식을 사용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SharedThreadLocalRandom&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnconditionalWait" defaultSeverity="WARNING" displayName="조건 없는 'wait()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동기화된 컨텍스트 내에서 조건 없이 호출되는 &lt;code&gt;wait()&lt;/code&gt;를 보고합니다.
&lt;p&gt;
  일반적으로 &lt;code&gt;wait()&lt;/code&gt;는 어떤 조건이 true가 될 때까지 스레드를 차단하는 데 사용됩니다. &lt;code&gt;wait()&lt;/code&gt;가 조건 없이 호출되었다면 잠금을 획득하기 전에 조건을 검사한 경우가 대부분입니다. 그러한 경우 검사 시간과 잠금을 획득한 시간 사이에 조건이 true가 되는 순간 데이터 경합이 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
  이 검사를 통해 발견한 구문이 항상 잘못된 건 아니지만, 검사해볼 가치는 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar {
      void foo() throws InterruptedException {
          synchronized (this) {
              wait(); // 경고
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnconditionalWait&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsThread" defaultSeverity="WARNING" displayName="클래스가 'Thread'를 바로 확장" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.lang.Thread&lt;/code&gt;를 직접 확장하는 클래스를 보고합니다.
나중에 수정하기 쉬운 재사용 가능한 코드를 더 많이 작성하기 위해 상속보다는 합성을 우선하기를 보통 권장합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MainThread extends Thread {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExtendsThread&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitWhileHoldingTwoLocks" defaultSeverity="WARNING" displayName="두 개의 잠금을 유지하면서 'wait()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
현재 스레드가 두 개의 잠금을 유지하는 동안 발생할 수 있는 &lt;code&gt;wait()&lt;/code&gt; 메서드 호출을 보고합니다.
&lt;p&gt;
  &lt;code&gt;wait()&lt;/code&gt;를 호출하면 대상에서 하나의 잠금만 해제되므로 두 개의 잠금이 걸린 상태로 대기하면 교착상태가 발생하기 쉽습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (lockA) {
    synchronized (lockB) {
      lockB.wait(); //경고
      // 스레드 A가 lockA를 보유하며 여기에서 정체되어 있습니다
    }
  }

  synchronized (lockA) { // 스레드 B가 블록에 들어가서 스레드 A를 해제할 수 없습니다
    lockB.notify();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: WaitWhileHoldingTwoLocks&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizeOnNonFinalField" defaultSeverity="WARNING" displayName="final이 아닌 필드 동기화" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;final&lt;/code&gt;이 아닌 필드 참조로 구성된 &lt;code&gt;synchronized&lt;/code&gt; 문 잠금 표현식을 보고합니다.
동일 객체에서 연산이 수행되어도 다양한 스레드가 각기 다른 잠금을 획득할 수 있으므로 해당 구문이 유의미할 가능성은 낮습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private Object o;
  public void foo() {
    synchronized (o) // final이 아닌 필드에서의 동기화
    { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SynchronizeOnNonFinalField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VolatileArrayField" defaultSeverity="WARNING" displayName="volatile 배열 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;volatile&lt;/code&gt;로 선언된 배열 필드를 보고합니다. 배열 자체에 대한 액세스는 &lt;code&gt;volatile&lt;/code&gt; 필드 규칙을 따르지만 배열의 내용에 대한 액세스는 그렇지 않으므로 해당 선언은 혼동될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Data {
    private volatile int[] idx = new int[0];
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  배열 내용에 이와 같은 volatile 액세스가 필요한 경우 &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt;을 대신 사용하는 것이 좋습니다.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Data {
    private final AtomicIntegerArray idx = new AtomicIntegerArray(new int[0]);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: VolatileArrayField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="대입 이슈" path="JavaScript 및 TypeScript"><inspection shortName="NestedAssignmentJS" defaultSeverity="WARNING" displayName="중첩된 대입" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/NestedAssignment.html --&gt;
&lt;html&gt;
&lt;body&gt;
다른 표현식 내부에 중첩된 대입 표현식을 보고합니다(예: &lt;code&gt;a = b = 1&lt;/code&gt;).
그러한 표현식은 혼란을 일으킬 수 있으며 지정된 구문은 정확히 한 가지 일을 해야 한다는 일반적인 디자인 규칙을 위반합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NestedAssignmentJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToForLoopParameterJS" defaultSeverity="WARNING" displayName="'for' 루프 매개변수에 대입" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;for&lt;/code&gt; 루프 매개변수로 선언된 변수에 대입한 경우를 보고합니다.
의도된 경우도 있으나 이 구문은 혼란을 일으킬 가능성이 매우 크며 보통 오류의 결과입니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AssignmentToForLoopParameterJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceAssignmentWithOperatorAssignmentJS" defaultSeverity="WARNING" displayName="대입을 연산자 대입으로 바꿀 수 있습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/ReplaceAssignmentWithOperatorAssignment.html --&gt;
&lt;html&gt;
&lt;body&gt;
연산자 대입으로 코드를 짧고 분명하게 만들 수 있는 대입 연산을 보고합니다.
&lt;p&gt;
  예:
&lt;pre&gt;
&lt;code&gt;  x = x + 3;&lt;/code&gt;
  &lt;code&gt;x = x / 3;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 결과는 다음과 같습니다.
&lt;pre&gt;
  &lt;code&gt;x += 3;&lt;/code&gt;
  &lt;code&gt;x /= 3;&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceAssignmentWithOperatorAssignmentJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SillyAssignmentJS" defaultSeverity="WARNING" displayName="변수가 자신에게 할당됨" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;x = x&lt;/code&gt; 형식의 대입을 보고합니다. 
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SillyAssignmentJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentResultUsedJS" defaultSeverity="WARNING" displayName="대입 결과 사용" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대입의 결과가 상위 표현식에서 사용된 대입 표현식을 보고합니다. 그러한 대입은 보통 코딩 오류를 나타냅니다
(예: &lt;code&gt;==&lt;/code&gt; 대신 &lt;code&gt;=&lt;/code&gt;).
게다가 대입 평가가 예기치 못한 방식으로 외부 표현식에 영향을 미칠 수 있기 때문에 연산 순서로 인해 혼란이 발생할 수 있습니다.
&lt;p&gt;소괄호 내 표현식은 무시됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AssignmentResultUsedJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSAssignmentUsedAsCondition" defaultSeverity="WARNING" displayName="대입이 조건으로 사용되었습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/AssignmentUsedAsCondition.html --&gt;
&lt;html&gt;
&lt;body&gt;
&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; 또는 &lt;code&gt;do&lt;/code&gt; 문의 조건으로 사용되는 대입을 보고합니다. 의도된 경우도 있으나 이러한 사용은 혼란을 일으키며, 보통 오타입니다(예:&lt;code&gt;==&lt;/code&gt; 대신 &lt;code&gt;=&lt;/code&gt; 사용).
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: JSAssignmentUsedAsCondition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToFunctionParameterJS" defaultSeverity="WARNING" displayName="함수 매개변수에 대입" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
증분 연산과 감소 연산을 포함한 함수 매개변수로의 대입을 보고합니다.
의도된 경우도 있으나 이 구문은 혼란을 일으킬 가능성이 매우 크며 보통 오류의 결과입니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AssignmentToFunctionParameterJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="HTML" path=""><inspection shortName="CheckValidXmlInScriptTagBody" defaultSeverity="ERROR" displayName="형식이 잘못된 'script' 태그 내용" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
유효하지 않은 XML인 &lt;code&gt;script&lt;/code&gt; 태그의 내용을 보고합니다.&lt;br&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;script type="text/javascript"&gt;
    console.log('&amp;lt;');
  &amp;lt;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;script type="text/javascript"&gt;
    console.log('&amp;amp;lt;');
  &amp;lt;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CheckValidXmlInScriptTagBody&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlExtraClosingTag" defaultSeverity="WARNING" displayName="불필요한 닫는 태그" enabled="false" language="HTML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
빈 요소의 불필요한 닫는 태그를 보고합니다(예: &lt;code&gt;img&lt;/code&gt; 또는 &lt;code&gt;br&lt;/code&gt;).
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;body&gt;
      &amp;lt;br&gt;&amp;lt;/br&gt;
    &amp;lt;/body&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;body&gt;
      &amp;lt;br&gt;
    &amp;lt;/body&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlExtraClosingTag&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlNonExistentInternetResource" defaultSeverity="WARNING" displayName="해결되지 않은 웹 링크" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해결되지 않은 웹 링크를 보고합니다. 백그라운드에서 네트워크 요청을 실행해 작동합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlNonExistentInternetResource&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlDeprecatedTag" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 태그" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
더 이상 사용되지 않는 HTML5 태그를 보고합니다. 더 이상 사용되지 않는 태그를 CSS 또는 다른 태그로 바꿀 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlDeprecatedTag&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlUnknownTarget" defaultSeverity="WARNING" displayName="링크 내 해결되지 않은 파일" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
링크 내 해결되지 않은 파일을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlUnknownTarget&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlUnknownTag" defaultSeverity="WARNING" displayName="알 수 없는 태그" enabled="false" language="HTML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
알 수 없는 HTML 태그를 보고합니다. 보고하지 않아야 할 태그를 구성할 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlUnknownTag&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckEmptyScriptTag" defaultSeverity="WARNING" displayName="빈 태그" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
일부 브라우저에서 작동하지 않는 빈 태그를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;script/&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;script&gt;&amp;lt;/script&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CheckEmptyScriptTag&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlDeprecatedAttribute" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 속성" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
더 이상 사용되지 않는 HTML5 속성을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlDeprecatedAttribute&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlMissingClosingTag" defaultSeverity="INFORMATION" displayName="닫는 태그 누락" enabled="false" language="HTML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
닫는 태그가 없는 HTML 요소를 보고합니다.
일부 코드 스타일은 HTML 요소에 닫는 태그가 선택 사항인 곳에도 닫는 태그가 있어야 합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;body&gt;
      &amp;lt;p&gt;Behold!
    &amp;lt;/body&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;body&gt;
      &amp;lt;p&gt;Behold!&amp;lt;/p&gt;
    &amp;lt;/body&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlMissingClosingTag&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlUnknownAnchorTarget" defaultSeverity="WARNING" displayName="링크 내 해결되지 않은 코드 조각" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;#&lt;/code&gt; 기호 뒤의 해결되지 않은 URL의 마지막 부분을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlUnknownAnchorTarget&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlPresentationalElement" defaultSeverity="INFORMATION" displayName="프레젠테이션 태그" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
프레젠테이션 HTML 태그를 보고합니다. 프레젠테이션 태그를 CSS 또는 다른 태그로 바꿀 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlPresentationalElement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlUnknownAttribute" defaultSeverity="WARNING" displayName="알 수 없는 속성" enabled="false" language="HTML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
알 수 없는 HTML 속성을 보고합니다. 보고하지 않아야 할 속성을 구성할 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlUnknownAttribute&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlUnknownBooleanAttribute" defaultSeverity="WARNING" displayName="잘못된 부울 속성" enabled="false" language="HTML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
값이 없는 bool이 아닌 HTML 속성을 보고합니다. 보고하지 않아야 할 속성을 구성할 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlUnknownBooleanAttribute&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlWrongAttributeValue" defaultSeverity="WARNING" displayName="잘못된 속성 값" enabled="false" language="HtmlCompatible" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
잘못된 HTML 속성값을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HtmlWrongAttributeValue&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckImageSize" defaultSeverity="WARNING" displayName="일치하지 않는 이미지 크기" enabled="false" language="XML" pluginId="HtmlTools" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
참조 이미지의 실제 너비와 높이와 다른 &lt;code&gt;img&lt;/code&gt; 태그의 &lt;code&gt;width&lt;/code&gt; 및 &lt;code&gt;height&lt;/code&gt; 속성 값을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CheckImageSize&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RequiredAttributes" defaultSeverity="WARNING" displayName="필수 속성 누락" enabled="false" language="XML" pluginId="com.intellij" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
XML/HTML 태그 내 누락된 필수 속성을 보고합니다. 보고하지 않아야 할 속성을 구성할 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RequiredAttributes&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="스타일 문제" path="Kotlin"><inspection shortName="AddOperatorModifier" defaultSeverity="INFORMATION" displayName="함수에 'operator' 제어자가 있어야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
연산자 규칙 중 하나와 일치하지만 &lt;code&gt;operator&lt;/code&gt; 키워드가 없는 함수를 보고합니다.
&lt;p&gt;&lt;code&gt;operator&lt;/code&gt; 제어자를 추가하면 함수 컨슈머가 관용적 Kotlin 코드를 사용할 수 있게 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Complex(val real: Double, val imaginary: Double) {
      fun plus(other: Complex) =
          Complex(real + other.real, imaginary + other.imaginary)
  }

  fun usage(a: Complex, b: Complex) {
      a.plus(b)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;operator&lt;/code&gt; 제어자 키워드를 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Complex(val real: Double, val imaginary: Double) {
      operator fun plus(other: Complex) =
          Complex(real + other.real, imaginary + other.imaginary)
  }

  fun usage(a: Complex, b: Complex) {
      a + b
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AddOperatorModifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceIsEmptyWithIfEmpty" defaultSeverity="WEAK WARNING" displayName="'if' 조건을 람다 호출로 바꿀 수 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
디폴트 값을 대입하기 위해 &lt;code&gt;if&lt;/code&gt; 문의 &lt;code&gt;isEmpty&lt;/code&gt;, &lt;code&gt;isBlank&lt;/code&gt;, &lt;code&gt;isNotEmpty&lt;/code&gt; 또는 &lt;code&gt;isNotBlank&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;빠른 수정에서는 &lt;code&gt;if&lt;/code&gt; 조건을 &lt;code&gt;ifEmpty&lt;/code&gt; 또는 &lt;code&gt;ifBlank&lt;/code&gt; 호출로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;): List&amp;lt;Int&amp;gt; {
      return if (list.isEmpty()) {
          println()
          foo()
      } else {
          list
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;): List&amp;lt;Int&amp;gt; {
      return list.ifEmpty {
          println()
          foo()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 Kotlin 언어 버전이 1.3 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceIsEmptyWithIfEmpty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceGuardClauseWithFunctionCall" defaultSeverity="INFORMATION" displayName="guard 절을 Kotlin의 함수 호출로 바꿀 수 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
함수 호출로 바꿀 수 있는 guard 절을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test(foo: Int?) {
      if (foo == null) throw IllegalArgumentException("foo") // 바꿀 수 있는 절
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test(foo: Int?) {
      checkNotNull(foo)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceGuardClauseWithFunctionCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertSecondaryConstructorToPrimary" defaultSeverity="INFORMATION" displayName="기본 생성자로 변환" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
더 간결한 기본 생성자로 바꿀 수 있는 보조 생산자를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User {
      val name: String

      constructor(name: String) {
          this.name = name
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 코드를 자동으로 변환합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User(val name: String) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConvertSecondaryConstructorToPrimary&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="BooleanLiteralArgument" defaultSeverity="WEAK WARNING" displayName="매개변수 이름이 없는 부울 리터럴 인수" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명시적 매개변수 이름이 지정되지 않은 &lt;code&gt;boolean&lt;/code&gt; 타입의 호출 인수를 보고합니다.
&lt;p&gt;
    여러 부울 리터럴이 순차적으로 전달될 때 매개변수의 순서를 잊어버리기 쉬워 오류로 이어질 수 있습니다.
    명시적 매개변수 이름을 사용하면 코드를 읽고 이해하기 더 쉽습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}

  fun usage() {
      check(true, false, true) // 이게 무슨 뜻이죠?
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 누락된 매개변수 이름을 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}

  fun usage() {
      check(checkName = true, checkAddress = false, checkPhone = true)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BooleanLiteralArgument&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ObjectLiteralToLambda" defaultSeverity="WEAK WARNING" displayName="객체 리터럴을 람다로 변환 가능" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
람다 식이 있는 호출로 변환 가능한 하나의 abstract 메서드를 포함하는 Java 인터페이스를 구현하는 익명 객체 리터럴을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class SomeService {
  val threadPool = Executors.newCachedThreadPool()
    
  fun foo() {
    threadPool.submit(object : Runnable {
      override fun run() {
        println("hello")
      }
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
    threadPool.submit { println("hello") }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ObjectLiteralToLambda&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JoinDeclarationAndAssignment" defaultSeverity="WEAK WARNING" displayName="'?.'로 접을 수 있는 If-Then" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음 대입과 결합 가능한 프로퍼티 선언을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x: String
  x = System.getProperty("")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 선언을 대입과 결합합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x = System.getProperty("")
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;&lt;b&gt;멤버 프로퍼티가 복잡하게 초기화되면 보고&lt;/b&gt; 옵션을 비활성화하면 초기화가 복잡한 프로퍼티를 건너뛸 수 있습니다. 이는 두 가지 경우를 처리합니다.&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;프로퍼티 초기화가 복잡한 경우(여러 줄로 구성된 표현식 또는 복합/제어흐름 표현식)&lt;/li&gt;
    &lt;li&gt;프로퍼티가 1차적으로 초기화된 다음 뒤따르는 코드에서 즉시 사용되는 경우(예: 추가적인 메서드의 초기화를 호출)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JoinDeclarationAndAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FilterIsInstanceCallWithClassLiteralArgument" defaultSeverity="WEAK WARNING" displayName="클래스 리터럴 인수가 있는 'filterIsInstance' 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;클래스 리터럴 인수가 있는 Kotlin 표준 라이브러리 함수 &lt;code&gt;filterIsInstance&lt;/code&gt;의 호출을 보고합니다. 구체화된 타입 매개변수를 포함한 이 함수의 버전을 사용하고 &lt;code&gt;::class.java&lt;/code&gt; 구문을 지양하는 것이 관용적입니다.&lt;/p&gt;

&lt;p&gt;참고: 타입 인수 목록 내에서 &lt;code&gt;Class&lt;*, *&gt;&lt;/code&gt; 구문은 바람직하지 않을 수 있으므로 제네릭 클래스 리터럴이 검사에서 보고되지 않습니다.&lt;/p&gt;

&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(list: List&amp;lt;*&gt;) {
      list.filterIsInstance(Int::class.java)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(list: List&amp;lt;*&gt;) {
      list.filterIsInstance&amp;lt;Int&gt;()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FilterIsInstanceCallWithClassLiteralArgument&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplacePutWithAssignment" defaultSeverity="WEAK WARNING" displayName="'map.put()'을 대입으로 변환할 수 있습니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
색인화 연산자(&lt;code&gt;[]&lt;/code&gt;)로 바꿀 수 있는 &lt;code&gt;map.put&lt;/code&gt; 함수 호출을 보고합니다.
&lt;p&gt;문법적 설탕을 사용하면 코드를 단순화할 수 있습니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;put&lt;/code&gt; 호출을 대입으로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(map: MutableMap&amp;lt;Int, String&amp;gt;) {
      map.put(42, &amp;quot;foo&amp;quot;)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(map: MutableMap&amp;lt;Int, String&amp;gt;) {
      map[42] = &amp;quot;foo&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplacePutWithAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceRangeStartEndInclusiveWithFirstLast" defaultSeverity="WEAK WARNING" displayName="박싱된 프로퍼티를 박싱되지 않은 프로퍼티로 바꿀 수 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;b&gt;박싱된&lt;/b&gt; &lt;code&gt;Range.start&lt;/code&gt; 및 &lt;code&gt;Range.endInclusive&lt;/code&gt; 프로퍼티를 보고합니다.
&lt;p&gt;이들 프로퍼티는 불필요한 호출을 피하기 위해 &lt;b&gt;unboxed&lt;/b&gt; &lt;code&gt;first&lt;/code&gt; 및 &lt;code&gt;last&lt;/code&gt; 프로퍼티로 바꿀 수 있습니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;endInclusive&lt;/code&gt; 프로퍼티를 그에 대응하는 &lt;code&gt;first&lt;/code&gt; 및 &lt;code&gt;last&lt;/code&gt;로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(range: CharRange) {
      val lastElement = range.endInclusive
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(range: CharRange) {
      val lastElement = range.last
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceRangeStartEndInclusiveWithFirstLast&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertToStringTemplate" defaultSeverity="WEAK WARNING" displayName="문자열 템플릿으로 변환 가능한 문자열 연결" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자열 템플릿으로 변환할 수 있는 문자열 연결을 보고합니다.
&lt;p&gt;문자열 템플릿을 사용하는 것이 코드 가독성을 위해 좋습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      val capitals = mapOf("France" to "Paris", "Spain" to "Madrid")
      for ((country, capital) in capitals) {
          print(capital + " is a capital of " + country)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      val capitals = mapOf("France" to "Paris", "Spain" to "Madrid")
      for ((country, capital) in capitals) {
          print("$capital is a capital of $country")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConvertToStringTemplate&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConvertTwoComparisonsToRangeCheck" defaultSeverity="WEAK WARNING" displayName="두 개의 비교 항목을 범위 검사로 변환해야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
범위 검사로 변환할 수 있는 두 개의 연속 비교를 보고합니다.
&lt;p&gt;범위를 검사하면 테스트 대상 중복을 제거해 코드가 더 단순해집니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun checkMonth(month: Int): Boolean {
      return month &gt;= 1 &amp;&amp; month &amp;lt;= 12
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 비교를 기반으로 하는 검사를 하나의 범위로 바꿉니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun checkMonth(month: Int): Boolean {
      return month in 1..12
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConvertTwoComparisonsToRangeCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfThenToElvis" defaultSeverity="WEAK WARNING" displayName="'?:'으로 접을 수 있는 If-Then" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
elvis(&lt;code&gt;?:&lt;/code&gt;) 식으로 접을 수 있는 &lt;code&gt;if-then&lt;/code&gt; 식을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun maybeFoo(): String? = "foo"

  var foo = maybeFoo()
  val bar = if (foo == null) "hello" else foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;if-then&lt;/code&gt; 식을 elvis(&lt;code&gt;?:&lt;/code&gt;) 식으로 변환합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun maybeFoo(): String? = "foo"

  var foo = maybeFoo()
  val bar = foo ?: "hello"
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IfThenToElvis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifiableCallChain" defaultSeverity="WARNING" displayName="컬렉션 타입에 대한 호출 체인을 단순화 가능" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
하나의 호출로 바꿀 수 있는 두 개의 호출 체인을 보고합니다.
&lt;p&gt;이렇게 하면 불필요한 코드가 실행되는 것을 피할 수 있습니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 호출 체인을 하나의 호출로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      listOf(1, 2, 3).filter { it &amp;gt; 1 }.count()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      listOf(1, 2, 3).count { it &amp;gt; 1 }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SimplifiableCallChain&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceRangeToWithRangeUntil" defaultSeverity="WEAK WARNING" displayName="'rangeTo' 또는 '..' 호출을 '..&lt;'로 바꿔야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;..&lt;/code&gt; 호출 대신 &lt;code&gt;rangeTo&lt;/code&gt; 또는 &lt;code&gt;..&lt;/code&gt; 연산자 호출을 보고합니다.
&lt;p&gt;대응하는 함수를 사용하면 코드가 더 단순해집니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;rangeTo&lt;/code&gt; 또는 &lt;code&gt;..&lt;/code&gt; 호출을 &lt;code&gt;..&lt;/code&gt;로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int) {
      for (i in 0..a - 1) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int) {
      for (i in 0..&amp;lt;a) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceRangeToWithRangeUntil&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyAssertNotNull" defaultSeverity="INFORMATION" displayName="'assert' 호출을 '!!' 또는 '?:'으로 바꾸기 가능" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
선언된 변수의 null이 아닌 값을 검사하는 &lt;code&gt;assert&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;&lt;code&gt;!!&lt;/code&gt; 또는 &lt;code&gt;?:&lt;/code&gt;를 사용하면 코드가 더 단순해집니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 변수 이니셜라이저에서 &lt;code&gt;assert&lt;/code&gt;를 &lt;code&gt;!!&lt;/code&gt; 또는 &lt;code&gt;?:&lt;/code&gt; 연산자로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(p: Array&amp;lt;String?&amp;gt;) {
      val v = p[0]
      assert(v != null, { &amp;quot;Should be not null&amp;quot; })
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(p: Array&amp;lt;String?&amp;gt;) {
      val v = p[0] ?: error(&amp;quot;Should be not null&amp;quot;)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SimplifyAssertNotNull&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ProtectedInFinal" defaultSeverity="WEAK WARNING" displayName="'protected' 가시성은 final 클래스에서 사실상 'private'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;final&lt;/code&gt; 클래스에서 사용된 &lt;code&gt;protected&lt;/code&gt;의 가시성을 보고합니다.
그러한 경우 &lt;code&gt;protected&lt;/code&gt; 멤버는 클래스 자체에서만 액세스할 수 있으므로 실질적으로 &lt;code&gt;private&lt;/code&gt;입니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class FinalClass {
      &lt;b&gt;protected&lt;/b&gt; fun foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class FinalClass {
      &lt;b&gt;private&lt;/b&gt; fun foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ProtectedInFinal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceContains" defaultSeverity="INFORMATION" displayName="'contains' 호출을 'in' 연산자로 바꾸기" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;contains&lt;/code&gt; 멤버 호출을 &lt;code&gt;in&lt;/code&gt; 연산자로 바꿉니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a.contains(b)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;b in a&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceContains&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceWithIgnoreCaseEquals" defaultSeverity="WEAK WARNING" displayName="'equals(..., ignoreCase = true)'로 바꿔야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;equals(..., ignoreCase = true)&lt;/code&gt;로 바꿀 수 있는 대/소문자를 구별하지 않는 비교를 보고합니다.
&lt;p&gt;&lt;code&gt;equals()&lt;/code&gt;를 사용하면 문자열을 비교할 때 &lt;code&gt;toLowerCase()&lt;/code&gt; 또는 &lt;code&gt;toUpperCase()&lt;/code&gt;를 사용해 여분의 문자열을 대입할 필요가 없습니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 대/소문자를 구분하지 않으며 &lt;code&gt;toLowerCase()&lt;/code&gt; 또는 &lt;code&gt;toUpperCase()&lt;/code&gt;를 사용하는 비교를 &lt;code&gt;equals(..., ignoreCase = true)&lt;/code&gt;로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;참고:&lt;/b&gt; 일부 로케일에서는 의미가 바뀔 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val a = &amp;quot;KoTliN&amp;quot;
      val b = &amp;quot;KOTLIN&amp;quot;
      println(a.toLowerCase() == b.toLowerCase())
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val a = &amp;quot;KoTliN&amp;quot;
      val b = &amp;quot;KOTLIN&amp;quot;
      println(a.equals(b, ignoreCase = true))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceWithIgnoreCaseEquals&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyNegatedBinaryExpression" defaultSeverity="WEAK WARNING" displayName="부정된 bool 표현식을 단순화할 수 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단순화할 수 있는 부정된 bool 표현식을 보고합니다.
&lt;p&gt;빠른 수정에서는 bool 표현식을 단순화합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    fun test(n: Int) {
        !(0 == 1)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    fun test(n: Int) {
        0 != 1
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IEEE-754 NaN 값이 포함된 경우, 이 액션에 의해 코드 의미가 변경될 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    fun main() {
        println(!(Double.NaN &amp;gt;= 0)) // true
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    fun main() {
        println(Double.NaN &amp;lt; 0) // false
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SimplifyNegatedBinaryExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyBooleanWithConstants" defaultSeverity="WEAK WARNING" displayName="bool 표현식을 단순화할 수 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상수로 줄일 수 있는 부분을 포함하는 bool 표현식을 보고합니다.
&lt;p&gt;빠른 수정에서는 그러한 조건을 단순화합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun use(arg: Boolean) {
      if (false == arg) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun use(arg: Boolean) {
      if (!arg) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SimplifyBooleanWithConstants&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceAssociateFunction" defaultSeverity="WEAK WARNING" displayName="'associate'를 'associateBy' 또는 'associateWith'로 바꿀 수 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;associateBy()&lt;/code&gt; 또는 &lt;code&gt;associateWith()&lt;/code&gt;로 바꿀 수 있는 &lt;code&gt;associate()&lt;/code&gt; 및 &lt;code&gt;associateTo()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
    이 두 함수는 주어진 시퀀스 또는 컬렉션(리시버로)의 요소에 적용되는 변환 함수를 받아들입니다.
    이 쌍은 결과 &lt;code&gt;Map&lt;/code&gt;을 빌드하는 데 사용됩니다.
&lt;/p&gt;
&lt;p&gt;
    변환자가 &lt;code&gt;it&lt;/code&gt;을 참조한다는 것을 고려할 때 &lt;code&gt;associate[To]()&lt;/code&gt; 호출은 성능 기준에 더 부합하는 &lt;code&gt;associateBy()&lt;/code&gt; 또는 &lt;code&gt;associateWith()&lt;/code&gt;로 바꿀 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun getKey(i: Int) = 1L
  fun getValue(i: Int) = 1L

  fun test() {
      arrayOf(1).associate { getKey(it) to it }  // 바꿀 수 있는 'associate()'
      listOf(1).associate { it to getValue(it) } // 바꿀 수 있는 'associate()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun getKey(i: Int) = 1L
  fun getValue(i: Int) = 1L

  fun test() {
      arrayOf(1).associateBy { getKey(it) }
      listOf(1).associateWith { getValue(it) }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceAssociateFunction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceArrayOfWithLiteral" defaultSeverity="WEAK WARNING" displayName="'arrayOf' 호출을 배열 리터럴 [...]로 바꾸기 가능" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;[...]&lt;/code&gt; 배열 리터럴로 바꿀 수 있는 &lt;code&gt;arrayOf&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  annotation class MyAnnotation(val strings: Array&amp;lt;String&amp;gt;)

  @MyAnnotation(arrayOf("alpha", "beta", "omega")) // 바꿀 수 있는 'arrayOf()'
  class MyClass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  annotation class MyAnnotation(val strings: Array&amp;lt;String&amp;gt;)

  @MyAnnotation(["alpha", "beta", "omega"])
  class MyClass
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceArrayOfWithLiteral&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnclearPrecedenceOfBinaryExpression" defaultSeverity="WARNING" displayName="우선 순위가 다른 여러 연산자" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
괄호 없이 여러 다른 연산자로 구성된 바이너리 표현식을 보고합니다.
&lt;p&gt;그러한 표현식은 연산자마다 &lt;a href="https://kotlinlang.org/docs/reference/grammar.html#expressions"&gt;우선순위 규칙&lt;/a&gt;을 사용하므로 가독성이 떨어집니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;
  fun foo(b: Boolean?, i: Int?) {
      val x = b ?: i == null // '(b ?: i) == null'로 평가됨
      val y = i ?: 0 + 1 // 'i ?: (0 + 1)'로 평가됨
  }
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnclearPrecedenceOfBinaryExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MayBeConstant" defaultSeverity="WEAK WARNING" displayName="'protected' 가시성은 final 클래스에서 사실상 'private'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
성능과 Java 상호운용성을 개선하기 위해 &lt;code&gt;const&lt;/code&gt;로 선언될 수 있는 객체 내의 최상위 &lt;code&gt;val&lt;/code&gt; 프로퍼티를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object A {
      val foo = 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object A {
      const val foo = 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;b&gt;라이브러리 저작자를 위한 팁:&lt;/b&gt; 공개 API 심볼에 const를 사용하면 컴파일 시간의 라이브러리 버전이 런타임 버전과 다를 경우 두 가지 다른 값이 사용될 수 있기 때문에 위험합니다. 주의해서 사용하세요.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MayBeConstant&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceSizeCheckWithIsNotEmpty" defaultSeverity="WEAK WARNING" displayName="크기 검사를 'isNotEmpty()'로 바꿀 수 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;isNotEmpty()&lt;/code&gt;로 바꿔야 할 &lt;code&gt;Collections/Array/String&lt;/code&gt; 크기 검사를 보고합니다.
&lt;p&gt;&lt;code&gt;isNotEmpty()&lt;/code&gt;를 사용하면 코드가 더 단순해집니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 크기 검사를 &lt;code&gt;isNotEmpty()&lt;/code&gt;로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val arrayOf = arrayOf(1, 2, 3)
      arrayOf.size &amp;gt; 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val arrayOf = arrayOf(1, 2, 3)
      arrayOf.isNotEmpty()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceSizeCheckWithIsNotEmpty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SortModifiers" defaultSeverity="WEAK WARNING" displayName="비표준 제어자 순서" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#modifiers-order"&gt;스타일 가이드&lt;/a&gt;에서 추천하는 순서를 따르지 않는 제어자를 보고합니다.
&lt;p&gt;&lt;b&gt;제어자 정렬&lt;/b&gt; 빠른 수정을 사용해 코드를 자동으로 수정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private inline fun correctOrder(f: () -&gt; Unit) {} // &amp;lt;== 문제 없음

  infix private fun Int.wrongOrder(expr: Int) {} // &amp;lt;== 순서가 잘못됨. 빠른 수정에서는 제어자를 'private infix'로 수정합니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SortModifiers&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceSizeZeroCheckWithIsEmpty" defaultSeverity="WEAK WARNING" displayName="크기가 0인지 여부에 대한 검사를 'isEmpty()'로 바꿀 수 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;isEmpty()&lt;/code&gt;로 바꿔야 할 &lt;code&gt;Collections/Array/String&lt;/code&gt;의 &lt;code&gt;size == 0&lt;/code&gt; 검사를 보고합니다.
&lt;p&gt;&lt;code&gt;isEmpty()&lt;/code&gt;를 사용하면 코드가 더 단순해집니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 크기 검사를 &lt;code&gt;isEmpty()&lt;/code&gt;로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val arrayOf = arrayOf(1, 2, 3)
      arrayOf.size == 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val arrayOf = arrayOf(1, 2, 3)
      arrayOf.isEmpty()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceSizeZeroCheckWithIsEmpty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantElseInIf" defaultSeverity="INFORMATION" displayName="불필요한 'else'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;return&lt;/code&gt;이 있는 &lt;code&gt;if&lt;/code&gt;에서 불필요한 &lt;code&gt;else&lt;/code&gt;를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(arg: Boolean): Int {
      if (arg) return 0
      else { // 이 else는 불필요합니다. 중괄호 내 코드를 그냥 밖으로 내어 왼쪽으로 이동할 수 있습니다
          someCode()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(arg: Boolean): Int {
      if (arg) return 0
      someCode()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantElseInIf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MapGetWithNotNullAssertionOperator" defaultSeverity="INFORMATION" displayName="null이 아닌 어설션 연산자 (!!)가 있는 'map.get()'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;map.getValue()&lt;/code&gt;, &lt;code&gt;map.getOrElse()&lt;/code&gt; 등으로 대체 가능한 &lt;code&gt;map.get()!!&lt;/code&gt;을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun test(map: Map&amp;lt;Int, String&amp;gt;): String = map.get(0)!!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun test(map: Map&amp;lt;Int, String&amp;gt;): String = map.getValue(0)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MapGetWithNotNullAssertionOperator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MemberVisibilityCanBePrivate" defaultSeverity="WEAK WARNING" displayName="클래스 멤버는 'private' 가시성을 가질 수 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
캡슐화 원칙을 따르기 위해 &lt;code&gt;private&lt;/code&gt;으로 만들 수 있는 선언을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Service(val url: String) {
    fun connect(): URLConnection = URL(url).openConnection()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후(&lt;code&gt;Service&lt;/code&gt; 클래스 외부에서 &lt;code&gt;url&lt;/code&gt;이 사용되지 않는다고 가정):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Service(private val url: String) {
    fun connect(): URLConnection = URL(url).openConnection()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MemberVisibilityCanBePrivate&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FoldInitializerAndIfToElvis" defaultSeverity="WEAK WARNING" displayName="'?:'로 접을 수 있는 If-Null return/break/..." enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이니셜라이저의 elvis 연산자로 변환 가능한 변수가 초기화 직후 null인지 아닌지 검사하는 &lt;code&gt;if&lt;/code&gt; 식을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(foo: Int?, bar: Int): Int {
      var i = foo
      if (i == null) {
          return bar
      }
      return i
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 이니셜라이저가 포함된 &lt;code&gt;if&lt;/code&gt; 식을 elvis 식으로 변환합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(foo: Int?, bar: Int): Int {
      var i = foo ?: return bar
      return i
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FoldInitializerAndIfToElvis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NullableBooleanElvis" defaultSeverity="INFORMATION" displayName="elvis 대신 상등 검사를 null 가능한 부울 검사에 사용 가능" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
elvis 연산자 대신 상등 검사가 사용되어야 하는 경우를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun check(a: Boolean? = null) {
    if (a ?: false) throw IllegalStateException()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun check(a: Boolean? = null) {
    if (a == true) throw IllegalStateException()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NullableBooleanElvis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantRunCatching" defaultSeverity="WEAK WARNING" displayName="중복 'runCatching' 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;getOrThrow&lt;/code&gt; 바로 다음에 오는 &lt;code&gt;runCatching&lt;/code&gt; 호출을 보고합니다.
그러한 호출은 &lt;code&gt;run&lt;/code&gt;만으로 바꿀 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() = runCatching { doSomething() }.getOrThrow()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() = run { doSomething() }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantRunCatching&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CanBeVal" defaultSeverity="WARNING" displayName="지역 'var'은 한정되지 않으며 'val'로서 선언 가능" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
절대 수정되지 않으며 &lt;code&gt;var&lt;/code&gt; 키워드로 선언된 지역 변수를 보고합니다.
&lt;p&gt;Kotlin에서는 변숫값이 절대로 변하지 않도록 &lt;code&gt;val&lt;/code&gt; 키워드를 사용해 실질적인 불변 변수를 선언하도록 권장됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      var primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)
      var fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)
      print("Same numbers: " + primeNumbers.intersect(fibonacciNumbers))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;var&lt;/code&gt; 키워드를 &lt;code&gt;val&lt;/code&gt;로 바꿉니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      val primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)
      val fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)
      print("Same numbers: " + primeNumbers.intersect(fibonacciNumbers))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CanBeVal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ImplicitThis" defaultSeverity="INFORMATION" displayName="묵시적 'this'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
묵시적 &lt;b&gt;this&lt;/b&gt;의 사용을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      fun s() = ""

      fun test() {
          s()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 &lt;b&gt;this&lt;/b&gt;를 명시적으로 지정합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      fun s() = ""

      fun test() {
          this.s()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ImplicitThis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceToWithInfixForm" defaultSeverity="WEAK WARNING" displayName="'to' 호출을 중위 형식으로 바꿔야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
infix 형식으로 바꿀 수 있는 &lt;code&gt;to&lt;/code&gt; 함수 호출을 보고합니다.
&lt;p&gt;infix 형식을 사용하면 코드가 더 단순해집니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;to&lt;/code&gt;를 infix 형식으로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int, b: Int) {
      val pair = a.to(b)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int, b: Int) {
      val pair = a to b
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceToWithInfixForm&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertPairConstructorToToFunction" defaultSeverity="INFORMATION" displayName="Pair 생성자를 'to' 함수로 변환" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;to()&lt;/code&gt; infix 함수 호출로 바꿀 수 있는 &lt;code&gt;Pair&lt;/code&gt; 생성자 호출을 보고합니다.
&lt;p&gt;
    명시적 생성자 호출은 특히 여러 번 사용될 때 장황해질 수 있습니다.
    생성자 호출을 &lt;code&gt;to()&lt;/code&gt;로 바꾸면 코드를 더 쉽게 읽고 관리할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val countries = mapOf(
      Pair("France", "Paris"),
      Pair("Spain", "Madrid"),
      Pair("Germany", "Berlin")
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val countries = mapOf(
      "France" to "Paris",
      "Spain" to "Madrid",
      "Germany" to "Berlin"
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConvertPairConstructorToToFunction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CascadeIf" defaultSeverity="WEAK WARNING" displayName="캐스케이드 'if'를 'when'으로 대체 가능" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
subject를 포함하는 &lt;code&gt;when&lt;/code&gt; 식으로 바꿀 수 있는 세 개 이상의 브랜치를 포함하는 &lt;code&gt;if&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun translateNumber(n: Int): String {
    return if (n == 1) {
      "one"
    } else if (n == 2) {
      "two"
    } else {
      "???"
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;if&lt;/code&gt; 식을 &lt;code&gt;when&lt;/code&gt; 식으로 변환합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun translateNumber(n: Int): String {
    return when (n) {
      1 -&gt; {
        "one"
      }
      2 -&gt; {
        "two"
      }
      else -&gt; {
        "???"
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CascadeIf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MoveLambdaOutsideParentheses" defaultSeverity="WEAK WARNING" displayName="소괄호 내 람다 인수" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
외부로 이동 가능한 소괄호 내 람다 식을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun square(a: Int, b: (Int) -&amp;gt; Int) {
  b(a * a)
}

fun foo() {
  square(2, { it })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo() {
  square(2){ it }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MoveLambdaOutsideParentheses&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseExpressionBody" defaultSeverity="INFORMATION" displayName="여기에는 표현식 본문 구문을 권장" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
표현식 본문 구문으로 바꿀 수 있는 &lt;code&gt;return&lt;/code&gt; 식(한 줄 또는 &lt;code&gt;when&lt;/code&gt;)을 보고합니다.
&lt;p&gt;&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#functions"&gt;스타일 가이드&lt;/a&gt;에서는 표현식 본문 구문을 권장합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;표현식 본문으로 변환&lt;/b&gt; 빠른 수정을 사용해 코드를 자동으로 수정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun sign(x: Int): Int {
      return when { // &amp;lt;== 단순화할 수 있습니다
          x &amp;lt; 0 -&gt; -1
          x &gt; 0 -&gt; 1
          else -&gt; 0
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun sign(x: Int): Int = when {
      x &amp;lt; 0 -&gt; -1
      x &gt; 0 -&gt; 1
      else -&gt; 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UseExpressionBody&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceMapGetOrDefault" defaultSeverity="INFORMATION" displayName="'map.getOrDefault()'를 색인과 Elvis 연산자로 바꿀 수 있습니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;map.getOrDefault(key, defaultValue)&lt;/code&gt; 함수 호출을 색인 생성 및 elvis 연산자(&lt;code&gt;map[key] ?: defaultValue&lt;/code&gt;)로 바꿉니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(map: Map&amp;lt;Int, String&amp;gt;) {
      map&lt;spot&gt;.getOrDefault(1, "foo")&lt;/spot&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(map: Map&amp;lt;Int, String&amp;gt;) {
      map&lt;spot&gt;[1] ?: "foo"&lt;/spot&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceMapGetOrDefault&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceSubstringWithDropLast" defaultSeverity="WEAK WARNING" displayName="'substring' 호출을 'dropLast' 호출로 바꿔야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;s.dropLast(x)&lt;/code&gt;로 바꿀 수 있는 &lt;code&gt;s.substring(0, s.length - x)&lt;/code&gt; 같은 호출을 보고합니다.
&lt;p&gt;대응하는 함수를 사용하면 코드가 더 단순해집니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;substring&lt;/code&gt; 호출을 &lt;code&gt;dropLast&lt;/code&gt;로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substring(0, s.length - 5)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.dropLast(5)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceSubstringWithDropLast&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceSubstringWithSubstringAfter" defaultSeverity="WEAK WARNING" displayName="'substring' 호출을 'substringAfter'로 바꿔야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;s.substringAfter(x)&lt;/code&gt;로 바꿀 수 있는 &lt;code&gt;s.substring(s.indexOf(x))&lt;/code&gt; 같은 호출을 보고합니다.
&lt;p&gt;&lt;code&gt;s.substringAfter(x)&lt;/code&gt;를 사용하면 코드가 더 단순해집니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;substring&lt;/code&gt; 호출을 &lt;code&gt;substringAfter&lt;/code&gt;로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substring(s.indexOf('x'))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substringAfter('x')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceSubstringWithSubstringAfter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceJavaStaticMethodWithKotlinAnalog" defaultSeverity="WEAK WARNING" displayName="Java 메서드를 Kotlin 아날로그로 바꿔야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kotlin 함수와 대체할 수 있는 Java 메서드 호출(예: &lt;code&gt;System.out.println()&lt;/code&gt;)을 보고합니다.
&lt;p&gt;코드를 치환하여 Java 의존성을 제거하고, 관용적인 Kotlin 코드를 만듭니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 동일한 Kotlin 호출에 대한 Java 메서드 호출을 치환합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.Arrays

  fun main() {
      val a = Arrays.asList(1, 3, null)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val a = listOf(1, 3, null)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceJavaStaticMethodWithKotlinAnalog&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SafeCastWithReturn" defaultSeverity="WEAK WARNING" displayName="'return'이 있는 안전한 형 변환은 'if' 타입 검사로 바꿔야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;if&lt;/code&gt; 타입 검사로 바꿀 수 있는 &lt;code&gt;return&lt;/code&gt;을 포함하는 안전한 형 변환을 보고합니다.
&lt;p&gt;대응하는 함수를 사용하면 코드가 더 단순해집니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 안전한 형 변환을 &lt;code&gt;if&lt;/code&gt; 타입 검사로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(x: Any) {
      x as? String ?: return
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(x: Any) {
      if (x !is String) return
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SafeCastWithReturn&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceSubstringWithSubstringBefore" defaultSeverity="WEAK WARNING" displayName="'substring' 호출을 'substringBefore'로 바꿔야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;s.substringBefore(x)&lt;/code&gt;로 바꿀 수 있는 &lt;code&gt;s.substring(0, s.indexOf(x))&lt;/code&gt; 같은 호출을 보고합니다.
&lt;p&gt;&lt;code&gt;substringBefore()&lt;/code&gt;를 사용하면 코드가 더 단순해집니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;substring&lt;/code&gt; 호출을 &lt;code&gt;substringBefore&lt;/code&gt;로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substring(0, s.indexOf('x'))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substringBefore('x')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceSubstringWithSubstringBefore&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceSubstringWithIndexingOperation" defaultSeverity="WEAK WARNING" displayName="'substring' 호출을 색인 생성 연산자로 바꿔야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;"abc"[0]&lt;/code&gt;로 바꿀 수 있는 &lt;code&gt;"abc".substring(0, 1)&lt;/code&gt; 같은 호출을 보고합니다.
&lt;p&gt;색인을 통해 요소를 얻으면 코드가 더 단순해집니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;substring&lt;/code&gt; 호출을 색인 생성 연산자로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      &amp;quot;abc&amp;quot;.substring(0, 1)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      &amp;quot;abc&amp;quot;[0]
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceSubstringWithIndexingOperation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceGetOrSet" defaultSeverity="WEAK WARNING" displayName="명시적 'get' 또는 'set' 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
색인 생성 연산자 &lt;code&gt;[]&lt;/code&gt;로 바꿀 수 있는 &lt;code&gt;get&lt;/code&gt; 또는 &lt;code&gt;set&lt;/code&gt; 함수에 대한 명시적 호출을 보고합니다.
&lt;p&gt;
    Kotlin에서는 타입에서 사전 정의된 세트에 대한 사용자 지정 구현을 허용합니다.
    연산자를 오버로드하기 위해 &lt;code&gt;operator&lt;/code&gt; 제어자를 포함하는 함수를 표시할 수 있습니다.
    &lt;pre&gt;&lt;code&gt;
  operator fun get(index: Int) {}
  operator fun set(index: Int, value: Int) {}
    &lt;/code&gt;&lt;/pre&gt;

위의 함수는 색인 생성 연산자에 대응합니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class Test {
      operator fun get(i: Int): Int = 0
  }

  fun test() {
      Test().get(0) // 바꿀 수 있는 'get()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class Test {
      operator fun get(i: Int): Int = 0
  }

  fun test() {
      Test()[0]
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceGetOrSet&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceWithOperatorAssignment" defaultSeverity="WEAK WARNING" displayName="대입을 연산자 대입으로 바꿀 수 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
연산자 대입으로 바꿀 수 있는 간단한 대입(&lt;code&gt;y = y + x&lt;/code&gt;와 같은)으로 변수를 수정한 경우 이를 보고합니다.
&lt;p&gt;빠른 수정이 대입을 대입 연산자로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val list = mutableListOf(1, 2, 3)
      list = list + 4
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val list = mutableListOf(1, 2, 3)
      list += 4
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceWithOperatorAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantAsSequence" defaultSeverity="WEAK WARNING" displayName="중복 'asSequence' 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;성능에 긍정적인 영향을 주지 않는 불필요한 &lt;code&gt;asSequence()&lt;/code&gt; 호출을 보고합니다.&lt;/p&gt;
&lt;p&gt;
    &lt;code&gt;asSequence()&lt;/code&gt;는 연산을 지연하여 수행하고 중간 컬렉션을 생성하지 않으므로 여러 연산을 포함하는 컬렉션 처리 속도를 높입니다.
&lt;/p&gt;
&lt;p&gt;
    하지만 터미널 연산(예: &lt;code&gt;toList()&lt;/code&gt;)이 &lt;code&gt;asSequence()&lt;/code&gt; 직후에 사용될 경우 성능에 긍정적 영향을 미치지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;String&amp;gt;) {
      list.&lt;b&gt;asSequence()&lt;/b&gt;.last()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;String&amp;gt;) {
      list.last()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantAsSequence&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceCallWithBinaryOperator" defaultSeverity="WEAK WARNING" displayName="2진 연산자로 바꾸기 가능" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
2진 연산자, 특히 비교와 연관된 연산자로 바꿀 수 있는 함수 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test(): Boolean {
      return 2.compareTo(1) &gt; 0 // 바꿀 수 있는 'compareTo()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test(): Boolean {
      return 2 &gt; 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceCallWithBinaryOperator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceSubstringWithTake" defaultSeverity="WEAK WARNING" displayName="'substring' 호출을 'take' 호출로 바꿔야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;s.take(x)&lt;/code&gt;로 바꿀 수 있는 &lt;code&gt;s.substring(0, x)&lt;/code&gt; 같은 호출을 보고합니다.
&lt;p&gt;&lt;code&gt;take()&lt;/code&gt;를 사용하면 코드가 더 단순해집니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;substring&lt;/code&gt; 호출을 &lt;code&gt;take()&lt;/code&gt;로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substring(0, 10)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.take(10)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceSubstringWithTake&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceRangeToWithUntil" defaultSeverity="WEAK WARNING" displayName="'rangeTo' 또는 '..' 호출을 'until'로 바꿔야 합니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;until&lt;/code&gt; 호출 대신 &lt;code&gt;rangeTo&lt;/code&gt; 또는 &lt;code&gt;..&lt;/code&gt; 연산자 호출을 보고합니다.
&lt;p&gt;대응하는 함수를 사용하면 코드가 더 단순해집니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;rangeTo&lt;/code&gt; 또는 &lt;code&gt;..&lt;/code&gt; 호출을 &lt;code&gt;until&lt;/code&gt;로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int) {
      for (i in 0..a - 1) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int) {
      for (i in 0 until a) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceRangeToWithUntil&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveEmptyParenthesesFromAnnotationEntry" defaultSeverity="WEAK WARNING" displayName="어노테이션 내의 불필요한 소괄호" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
어노테이션 항목에서 불필요한 빈 소괄호를 보고합니다.
&lt;p&gt;코드를 정리하려면 '불필요한 소괄호 제거' 빠른 수정을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  annotation class MyAnnotationA
  annotation class MyAnnotationB(val x: Int)
  annotation class MyAnnotationC(val x: Int = 10) // 디폴트 값이 있습니다

  @MyAnnotationA() // &amp;lt;== 소괄호가 불필요합니다
  fun testA() {
  }

  @MyAnnotationB() // &amp;lt;== 인수 누락, 소괄호가 필요합니다
  fun testB() {
  }

  @MyAnnotationC() // &amp;lt;== 소괄호가 불필요합니다
  fun testC() {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveEmptyParenthesesFromAnnotationEntry&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaMapForEach" defaultSeverity="WEAK WARNING" displayName="Java Map.forEach 메서드 호출을 Kotlin의 forEach로 바꿔야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kotlin의 &lt;b&gt;forEach&lt;/b&gt;로 대체 가능한 Java Map.&lt;code&gt;forEach&lt;/code&gt; 메서드 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(map: HashMap&amp;lt;Int, String&gt;) {
      map.forEach { key, value -&gt;
          foo(key, value)
      }
  }

  fun foo(i: Int, s: String) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정은 소괄호를 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(map: HashMap&amp;lt;Int, String&gt;) {
      map.forEach { (key, value) -&gt;
          foo(key, value)
      }
  }

  fun foo(i: Int, s: String) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JavaMapForEach&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceNotNullAssertionWithElvisReturn" defaultSeverity="WEAK WARNING" displayName="null이 아닌 어설션을 'return'으로 바꿀 수 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
elvis 연산자 및 반환(&lt;code&gt;?: return&lt;/code&gt;)으로 바꿀 수 있는 비 null 어설션(&lt;code&gt;!!&lt;/code&gt;) 호출을 보고합니다.
&lt;p&gt;비 null 어설션은 예상하지 못한 NPE(NullPointerException)로 이어질 수 있습니다. 관례적으로 &lt;code&gt;!!&lt;/code&gt;를 사용하지 않는 것이 좋습니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 비 null 어설션을 &lt;code&gt;return&lt;/code&gt; 또는 &lt;code&gt;return null&lt;/code&gt;로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(number: Int?) {
      val x = number!!
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(number: Int?) {
      val x = number ?: return
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceNotNullAssertionWithElvisReturn&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LiftReturnOrAssignment" defaultSeverity="WEAK WARNING" displayName="return 또는 대입을 제거 가능" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;return&lt;/code&gt; 문 또는 대입을 밖으로 꺼내면 표현식으로 변환할 수 있는 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt; 및 &lt;code&gt;try&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(arg: Int): String {
      when (arg) {
          0 -&gt; return "Zero"
          1 -&gt; return "One"
          else -&gt; return "Multiple"
      }
  }
&lt;/code&gt;&lt;/pre&gt;
빠른 수정을 적용한 후:
&lt;pre&gt;&lt;code&gt;
  fun foo(arg: Int): String {
      return when (arg) {
          0 -&gt; "Zero"
          1 -&gt; "One"
          else -&gt; "Multiple"
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 검사로 다중 구문 브랜치가 있는 더 복잡한 코드를 강조 표시하려면 '모든 브랜치가 단일 구문일 때만 보고' 옵션을 해제하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LiftReturnOrAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceCollectionCountWithSize" defaultSeverity="WEAK WARNING" displayName="컬렉션 집계를 크기로 변환 가능" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Collection&amp;lt;T&amp;gt;.count()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
    이 함수 호출은 &lt;code&gt;.size&lt;/code&gt;로 바꿀 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
    &lt;code&gt;.size&lt;/code&gt; 양식은 연산이 O(1)이며 여분의 객체를 할당하지 않도록 보장하는 반면 &lt;code&gt;count()&lt;/code&gt;는, O(n)이자 할당하는 &lt;code&gt;Iterable&amp;lt;T&amp;gt;.count()&lt;/code&gt;와 혼동될 수 있습니다.
    &lt;br&gt;
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun foo() {
      var list = listOf(1,2,3)
      list.count() // 바꿀 수 있는 'count()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun foo() {
      var list = listOf(1,2,3)
      list.size
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceCollectionCountWithSize&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CopyWithoutNamedArguments" defaultSeverity="WEAK WARNING" displayName="데이터 클래스의 'copy' 메서드가 이름 지정된 인수 없이 호출됨" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명명된 인수가 없는 데이터 클래스의 &lt;code&gt;copy()&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;
    &lt;code&gt;copy()&lt;/code&gt; 함수의 모든 인수는 옵션이므로 어떤 프로퍼티가 수정되었는지 이해하기가 어렵습니다.
    매개변수 이름을 명시적으로 제공하면 &lt;code&gt;data class&lt;/code&gt; 선언을 탐색할 필요 없이 코드를 쉽게 이해할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class User(val name: String, val age: Int)

  fun copyUser(user: User): User {
      return user.copy("John")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 모든 &lt;code&gt;copy()&lt;/code&gt; 인수에 매개변수 이름을 제공합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class User(val name: String, val age: Int)

  fun copyUser(user: User): User {
      return user.copy(name = "John")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CopyWithoutNamedArguments&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TrailingComma" defaultSeverity="WEAK WARNING" displayName="후미 쉼표 권장" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
권장하는 &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#trailing-commas"&gt;스타일 가이드&lt;/a&gt;를 따르지 않는 후행 쉼표를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TrailingComma&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceAssertBooleanWithAssertEquality" defaultSeverity="WEAK WARNING" displayName="어설션 부울을 어설션 상등으로 바꿀 수 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
어설션 상등 함수로 바꿀 수 있는 &lt;code&gt;assertTrue()&lt;/code&gt; 및 &lt;code&gt;assertFalse()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;
    &lt;code&gt;assertEquals()&lt;/code&gt;, &lt;code&gt;assertSame()&lt;/code&gt; 및 이들의 부정 대응(-Not-)은 실패 시 더 많은 정보 메시지를 제공합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  assertTrue(a == b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  assertEquals(a, b)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceAssertBooleanWithAssertEquality&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedLambdaShadowedImplicitParameter" defaultSeverity="WEAK WARNING" displayName="중첩된 람다에 가려진 묵시적 매개변수가 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
가려진 묵시적 매개변수가 있는 중첩된 람다를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(listOfLists: List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;) {
  listOfLists.forEach {
    it.forEach {
      println(it)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(listOfLists: List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;) {
  listOfLists.forEach {
    it.forEach { it1 -&amp;gt;
      println(it1)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NestedLambdaShadowedImplicitParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IntroduceWhenSubject" defaultSeverity="WEAK WARNING" displayName="인수 삽입으로 단순화 가능한 'when'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대상 인수를 삽입하여 간소화할 수 있는 &lt;code&gt;when&lt;/code&gt; 식을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(obj: Any): String {
      return when {
          obj is String -&gt; "string"
          obj is Int -&gt; "int"
          else -&gt; "unknown"
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 대상 인수를 삽입합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(obj: Any): String {
      return when (obj) {
          is String -&gt; "string"
          is Int -&gt; "int"
          else -&gt; "unknown"
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IntroduceWhenSubject&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantObjectTypeCheck" defaultSeverity="INFORMATION" displayName="객체에 대한 관용적이지 않은 'is' 타입 검사" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;객체의 비 관용적인 &lt;code&gt;is&lt;/code&gt; 타입 검사를 보고합니다.&lt;/p&gt;
&lt;p&gt;그러한 검사를 참조 비교로 바꾸기를 권장합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object Foo

  fun foo(arg: Any) = when {
      arg &lt;b&gt;is&lt;/b&gt; Foo -&gt; ...
      arg &lt;b&gt;!is&lt;/b&gt; Foo -&gt; ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object Foo

  fun foo(arg: Any) = when {
      arg &lt;b&gt;===&lt;/b&gt; Foo -&gt; ...
      arg &lt;b&gt;!==&lt;/b&gt; Foo -&gt; ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantObjectTypeCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceReadLineWithReadln" defaultSeverity="WEAK WARNING" displayName="'readLine'을 'readln' 혹은 'readlnOrNull'로 대체 가능" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;readln()&lt;/code&gt; 또는 &lt;code&gt;readlnOrNull()&lt;/code&gt;로 바꿀 수 있는 &lt;code&gt;readLine()&lt;/code&gt;을 보고합니다.
&lt;p&gt;
    대응하는 함수를 사용하면 코드가 더 단순해집니다.
&lt;/p&gt;
&lt;p&gt;
    빠른 수정에서는 &lt;code&gt;readLine()!!&lt;/code&gt;을 &lt;code&gt;readln()&lt;/code&gt;으로 바꾸고 &lt;code&gt;readLine()&lt;/code&gt;을 &lt;code&gt;readlnOrNull()&lt;/code&gt;로 바꿉니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    val x = readLine()!!
    val y = readLine()?.length
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    val x = readln()
    val y = readlnOrNull()?.length
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceReadLineWithReadln&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MoveVariableDeclarationIntoWhen" defaultSeverity="WEAK WARNING" displayName="변수 선언을 'when'으로 이동할 수 있습니다." enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;when&lt;/code&gt; 식 내부로 이동 가능한 변수 선언을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun someCalc(x: Int) = x * 42

fun foo(x: Int): Int {
  val a = someCalc(x)
  return when (a) {
    1 -&amp;gt; a
    2 -&amp;gt; 2 * a
    else -&amp;gt; 24
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(x: Int): Int {
  return when (val a = someCalc(x)) {
    1 -&amp;gt; a
    2 -&amp;gt; 2 * a
    else -&amp;gt; 24
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MoveVariableDeclarationIntoWhen&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UsePropertyAccessSyntax" defaultSeverity="WEAK WARNING" displayName="프로퍼티 액세스 구문으로 바꾸기 가능한 접근자 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kotlin 통합 프로퍼티로 바꿀 수 있는 Java &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;&lt;b&gt;프로퍼티 액세스 구문 사용&lt;/b&gt; 빠른 수정을 사용해 코드를 자동으로 수정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Java:
  public class JavaClassWithGetter {
      private final String expr = "result";

      // ...

      public String getExpr() {
          return expr;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
  // Kotlin:
  fun test(j: JavaClassWithGetter) {
      // ...
      j.getExpr() // &amp;lt;== 빠른 수정에서는 표현식을 'j.expr'로 단순화합니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UsePropertyAccessSyntax&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Android" path=""><inspection shortName="AndroidUnresolvableTag" defaultSeverity="ERROR" displayName="해결할 수 없는 태그" enabled="false" language="XML" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!--
  ~ Copyright (C) 2019 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
이 검사는 Android 리소스 파일에서 해결할 수 없는 XML 태그 참조를 강조 표시합니다
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AndroidUnresolvableTag&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AndroidElementNotAllowed" defaultSeverity="WARNING" displayName="Android XML 요소는 허용되지 않습니다" enabled="false" language="XML" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 Android 리소스 파일과 AndroidManifest.xml에서 허용되지 않은 XML 태그를 강조 표시합니다
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AndroidElementNotAllowed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AndroidNonConstantResIdsInSwitch" defaultSeverity="ERROR" displayName="switch 문 내 상수가 아닌 리소스 ID" enabled="false" language="JAVA" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
Android 라이브러리 모듈의 switch 문에서 리소스 ID를 사용하는 것을 검증합니다.&lt;br&gt;
리소스 ID는 SDK 도구 r14 이후 final이 아니므로 라이브러리 코드가 이러한 ID를 상수로 취급해서는 안 됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AndroidNonConstantResIdsInSwitch&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidUnknownAttribute" defaultSeverity="WARNING" displayName="알 수 없는 Android XML 속성" enabled="false" language="XML" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 Android 리소스 파일과 AndroidManifest.xml에서 알려지지 않은 XML 속성을 강조 표시합니다
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AndroidUnknownAttribute&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlWrongFileType" defaultSeverity="WARNING" displayName="Android XML 루트 태그 유효성 검사" enabled="false" language="XML" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 XML 리소스가 문서에서 권장되는 유형의 리소스 폴더에 저장되었는지 확인합니다
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: XmlWrongFileType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AndroidDomInspection" defaultSeverity="ERROR" displayName="Android 리소스 유효성 검사" enabled="false" language="XML" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
  Android XML 파일 내의 리소스 참조를 검증합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AndroidDomInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="NavigationFile" defaultSeverity="ERROR" displayName="탐색 파일" enabled="false" language="XML" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 조각 내의 이름 속성에서 유효하지 않은 목적지 및 탐색 리소스 파일의 활동 태그를 강조 표시합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NavigationFile&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AndroidMissingOnClickHandler" defaultSeverity="WARNING" displayName="onClick 핸들러가 관련 액티비티에서 누락됨" enabled="false" language="XML" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
OnClick XML 속성에서 지정된 메서드가 관련 Activity에서 선언되었는지 확인합니다
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AndroidMissingOnClickHandler&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Correctness" path="Android/Lint"><inspection shortName="AndroidLintUseCompatLoadingForDrawables" defaultSeverity="WARNING" displayName="Should not call Context.getDrawable or Resources.getDrawable directly" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Should not call &lt;code&gt;Context.getDrawable&lt;/code&gt; or &lt;code&gt;Resources.getDrawable&lt;/code&gt; directly&lt;br&gt;&lt;br&gt;Use Compat loading of drawables&lt;br&gt;&lt;br&gt;Issue id: UseCompatLoadingForDrawables&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.appcompat&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460343"&gt;https://issuetracker.google.com/issues/new?component=460343&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFragmentLiveDataObserve" defaultSeverity="ERROR" displayName="Use getViewLifecycleOwner() as the LifecycleOwner instead of a Fragment instance when observing a LiveData object." enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use getViewLifecycleOwner() as the LifecycleOwner instead of a Fragment instance when observing a LiveData object.&lt;br&gt;&lt;br&gt;When observing a LiveData object from a fragment's onCreateView,                 onViewCreated, onActivityCreated, or onViewStateRestored method                 getViewLifecycleOwner() should be used as the LifecycleOwner rather than the                 Fragment instance. The Fragment lifecycle can result in the Fragment being                 active longer than its view. This can lead to unexpected behavior from                 LiveData objects being observed longer than the Fragment's view is active.&lt;br&gt;&lt;br&gt;Issue id: FragmentLiveDataObserve&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.fragment&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460964"&gt;https://issuetracker.google.com/issues/new?component=460964&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongRequiresOptIn" defaultSeverity="ERROR" displayName="Experimental annotations defined in Kotlin must use kotlin.RequiresOptIn" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Experimental annotations defined in Kotlin must use kotlin.RequiresOptIn&lt;br&gt;&lt;br&gt;Experimental features defined in Kotlin source code must be annotated with the Kotlin&lt;br/&gt;
&lt;code&gt;@RequiresOptIn&lt;/code&gt; annotation. Using &lt;code&gt;androidx.annotation.RequiresOptIn&lt;/code&gt; will prevent the&lt;br/&gt;
Kotlin compiler from enforcing its opt-in policies.&lt;br&gt;&lt;br&gt;Issue id: WrongRequiresOptIn&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.annotation.experimental&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=459778"&gt;https://issuetracker.google.com/issues/new?component=459778&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUsingOnClickInXml" defaultSeverity="WARNING" displayName="Using android:onClick on older version of the platform is broken" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;android:onClick&lt;/code&gt; on older version of the platform is broken&lt;br&gt;&lt;br&gt;Old versions of the platform do not properly support resolving &lt;code&gt;android:onClick&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: UsingOnClickInXml&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.appcompat&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460343"&gt;https://issuetracker.google.com/issues/new?component=460343&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDetachAndAttachSameFragment" defaultSeverity="WARNING" displayName="Separate attach() and detach() into separate FragmentTransactions" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Separate attach() and detach() into separate FragmentTransactions&lt;br&gt;&lt;br&gt;When doing a FragmentTransaction that includes both attach()                 and detach() operations being committed on the same fragment instance, it is a                 no-op. The reason for this is that the FragmentManager optimizes all operations                 within a single transaction so the attach() and detach() cancel each other out                 and neither is actually executed. To get the desired behavior, you should separate                 the attach() and detach() calls into separate FragmentTransactions.&lt;br&gt;&lt;br&gt;Issue id: DetachAndAttachSameFragment&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.fragment&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460964"&gt;https://issuetracker.google.com/issues/new?component=460964&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseAndroidAlpha" defaultSeverity="ERROR" displayName="android:alpha attribute missing on ColorStateList" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;android:alpha&lt;/code&gt; attribute missing on &lt;code&gt;ColorStateList&lt;/code&gt;&lt;br&gt;&lt;br&gt;&lt;code&gt;ColorStateList&lt;/code&gt; uses app:alpha without &lt;code&gt;android:alpha&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: UseAndroidAlpha&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.appcompat&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460343"&gt;https://issuetracker.google.com/issues/new?component=460343&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeOptInUsageWarning" defaultSeverity="WARNING" displayName="Unsafe opt-in usage intended to be warning-level severity" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsafe opt-in usage intended to be warning-level severity&lt;br&gt;&lt;br&gt;This API has been flagged as opt-in with warning-level severity.&lt;br/&gt;
&lt;br/&gt;
Any declaration annotated with this marker is considered part of an unstable or&lt;br/&gt;
otherwise non-standard API surface and its call sites should accept the opt-in&lt;br/&gt;
aspect of it by using the &lt;code&gt;@OptIn&lt;/code&gt; annotation, using the marker annotation --&lt;br/&gt;
effectively causing further propagation of the opt-in aspect -- or configuring&lt;br/&gt;
the &lt;code&gt;UnsafeOptInUsageWarning&lt;/code&gt; check's options for project-wide opt-in.&lt;br/&gt;
&lt;br/&gt;
To configure project-wide opt-in, specify the &lt;code&gt;opt-in&lt;/code&gt; option value in &lt;code&gt;lint.xml&lt;/code&gt;&lt;br/&gt;
as a comma-delimited list of opted-in annotations:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="UnsafeOptInUsageWarning"&gt;
        &amp;lt;option name="opt-in" value="com.foo.ExperimentalBarAnnotation" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;Issue id: UnsafeOptInUsageWarning&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.annotation.experimental&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=459778"&gt;https://issuetracker.google.com/issues/new?component=459778&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseGetLayoutInflater" defaultSeverity="WARNING" displayName="Use getLayoutInflater() to get the LayoutInflater instead of calling LayoutInflater.from(Context)." enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use getLayoutInflater() to get the LayoutInflater instead of calling LayoutInflater.from(Context).&lt;br&gt;&lt;br&gt;Using LayoutInflater.from(Context) can return a LayoutInflater                  that does not have the correct theme.&lt;br&gt;&lt;br&gt;Issue id: UseGetLayoutInflater&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.fragment&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460964"&gt;https://issuetracker.google.com/issues/new?component=460964&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRepeatOnLifecycleWrongUsage" defaultSeverity="ERROR" displayName="Wrong usage of repeatOnLifecycle." enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong usage of repeatOnLifecycle.&lt;br&gt;&lt;br&gt;The repeatOnLifecycle APIs should be used when the View is created,                 that is in the &lt;code&gt;onCreate&lt;/code&gt; lifecycle method for Activities, or &lt;code&gt;onViewCreated&lt;/code&gt; in                 case you're using Fragments.&lt;br&gt;&lt;br&gt;Issue id: RepeatOnLifecycleWrongUsage&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.lifecycle&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=413132"&gt;https://issuetracker.google.com/issues/new?component=413132&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDialogFragmentCallbacksDetector" defaultSeverity="WARNING" displayName="Use onCancel() and onDismiss() instead of calling setOnCancelListener() and setOnDismissListener() from onCreateDialog()" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use onCancel() and onDismiss() instead of calling setOnCancelListener() and setOnDismissListener() from onCreateDialog()&lt;br&gt;&lt;br&gt;When using a &lt;code&gt;DialogFragment&lt;/code&gt;, the &lt;code&gt;setOnCancelListener&lt;/code&gt; and                 &lt;code&gt;setOnDismissListener&lt;/code&gt; callback functions within the &lt;code&gt;onCreateDialog&lt;/code&gt; function                  __must not be used__ because the &lt;code&gt;DialogFragment&lt;/code&gt; owns these callbacks.                  Instead the respective &lt;code&gt;onCancel&lt;/code&gt; and &lt;code&gt;onDismiss&lt;/code&gt; functions can be used to                  achieve the desired effect.&lt;br&gt;&lt;br&gt;Issue id: DialogFragmentCallbacksDetector&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.fragment&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460964"&gt;https://issuetracker.google.com/issues/new?component=460964&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExperimentalAnnotationRetention" defaultSeverity="ERROR" displayName="Experimental annotation with incorrect retention" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Experimental annotation with incorrect retention&lt;br&gt;&lt;br&gt;Experimental annotations defined in Java source should use default (&lt;code&gt;CLASS&lt;/code&gt;) retention, while Kotlin-sourced annotations should use &lt;code&gt;BINARY&lt;/code&gt; retention.&lt;br&gt;&lt;br&gt;Issue id: ExperimentalAnnotationRetention&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.annotation.experimental&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=459778"&gt;https://issuetracker.google.com/issues/new?component=459778&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseSwitchCompatOrMaterialXml" defaultSeverity="WARNING" displayName="Replace usage of Switch widget" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Replace usage of &lt;code&gt;Switch&lt;/code&gt; widget&lt;br&gt;&lt;br&gt;Use &lt;code&gt;SwitchCompat&lt;/code&gt; from AppCompat or &lt;code&gt;MaterialSwitch&lt;/code&gt; from Material library&lt;br&gt;&lt;br&gt;Issue id: UseSwitchCompatOrMaterialXml&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.appcompat&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460343"&gt;https://issuetracker.google.com/issues/new?component=460343&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseSwitchCompatOrMaterialCode" defaultSeverity="WARNING" displayName="Replace usage of Switch widget" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Replace usage of &lt;code&gt;Switch&lt;/code&gt; widget&lt;br&gt;&lt;br&gt;Use &lt;code&gt;SwitchCompat&lt;/code&gt; from AppCompat or &lt;code&gt;MaterialSwitch&lt;/code&gt; from Material library&lt;br&gt;&lt;br&gt;Issue id: UseSwitchCompatOrMaterialCode&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.appcompat&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460343"&gt;https://issuetracker.google.com/issues/new?component=460343&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseCompatTextViewDrawableApis" defaultSeverity="WARNING" displayName="Should not call TextView.setCompoundDrawableTintList or TextView.setCompoundDrawableTintMode directly" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Should not call &lt;code&gt;TextView.setCompoundDrawableTintList&lt;/code&gt; or &lt;code&gt;TextView.setCompoundDrawableTintMode&lt;/code&gt; directly&lt;br&gt;&lt;br&gt;Use Compat loading of compound text view drawables&lt;br&gt;&lt;br&gt;Issue id: UseCompatTextViewDrawableApis&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.appcompat&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460343"&gt;https://issuetracker.google.com/issues/new?component=460343&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseAppTint" defaultSeverity="ERROR" displayName="app:tint attribute should be used on ImageView and ImageButton" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;app:tint&lt;/code&gt; attribute should be used on &lt;code&gt;ImageView&lt;/code&gt; and &lt;code&gt;ImageButton&lt;/code&gt;&lt;br&gt;&lt;br&gt;&lt;code&gt;ImageView&lt;/code&gt; or &lt;code&gt;ImageButton&lt;/code&gt; uses &lt;code&gt;android:tint&lt;/code&gt; instead of &lt;code&gt;app:tint&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: UseAppTint&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.appcompat&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460343"&gt;https://issuetracker.google.com/issues/new?component=460343&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeLifecycleWhenUsage" defaultSeverity="ERROR" displayName="Unsafe UI operation in finally/catch of Lifecycle.whenStarted of similar method" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsafe UI operation in finally/catch of Lifecycle.whenStarted of similar method&lt;br&gt;&lt;br&gt;If the &lt;code&gt;Lifecycle&lt;/code&gt; is destroyed within the block of                     &lt;code&gt;Lifecycle.whenStarted&lt;/code&gt; or any similar &lt;code&gt;Lifecycle.when&lt;/code&gt; method is suspended,                     the block will be cancelled, which will also cancel any child coroutine                     launched inside the block. As as a result, If you have a try finally block                     in your code, the finally might run after the Lifecycle moves outside                     the desired state. It is recommended to check the &lt;code&gt;Lifecycle.isAtLeast&lt;/code&gt;                     before accessing UI in finally block. Similarly,                     if you have a catch statement that might catch &lt;code&gt;CancellationException&lt;/code&gt;,                     you should check the &lt;code&gt;Lifecycle.isAtLeast&lt;/code&gt; before accessing the UI. See                     documentation of &lt;code&gt;Lifecycle.whenStateAtLeast&lt;/code&gt; for more details&lt;br&gt;&lt;br&gt;Issue id: UnsafeLifecycleWhenUsage&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.lifecycle&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=413132"&gt;https://issuetracker.google.com/issues/new?component=413132&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseCompatTextViewDrawableXml" defaultSeverity="WARNING" displayName="Compat compound drawable attributes should be used on TextView" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Compat compound drawable attributes should be used on &lt;code&gt;TextView&lt;/code&gt;&lt;br&gt;&lt;br&gt;&lt;code&gt;TextView&lt;/code&gt; uses &lt;code&gt;android:&lt;/code&gt; compound drawable attributes instead of &lt;code&gt;app:&lt;/code&gt; ones&lt;br&gt;&lt;br&gt;Issue id: UseCompatTextViewDrawableXml&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.appcompat&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460343"&gt;https://issuetracker.google.com/issues/new?component=460343&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFragmentAddMenuProvider" defaultSeverity="ERROR" displayName="Use getViewLifecycleOwner() as the LifecycleOwner instead of a Fragment instance." enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use getViewLifecycleOwner() as the LifecycleOwner instead of a Fragment instance.&lt;br&gt;&lt;br&gt;The Fragment lifecycle can result in a Fragment being active                 longer than its view. This can lead to unexpected behavior from lifecycle aware                 objects remaining active longer than the Fragment's view. To solve this issue,                 getViewLifecycleOwner() should be used as a LifecycleOwner rather than the                 Fragment instance once it is safe to access the view lifecycle in a                 Fragment's onCreateView, onViewCreated, onActivityCreated, or                 onViewStateRestored methods.&lt;br&gt;&lt;br&gt;Issue id: FragmentAddMenuProvider&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.fragment&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460964"&gt;https://issuetracker.google.com/issues/new?component=460964&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeRepeatOnLifecycleDetector" defaultSeverity="ERROR" displayName="RepeatOnLifecycle should be used with viewLifecycleOwner in Fragments." enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;RepeatOnLifecycle should be used with viewLifecycleOwner in Fragments.&lt;br&gt;&lt;br&gt;The repeatOnLifecycle APIs should be used with the viewLifecycleOwner                 in Fragments as opposed to lifecycleOwner.&lt;br&gt;&lt;br&gt;Issue id: UnsafeRepeatOnLifecycleDetector&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.fragment&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460964"&gt;https://issuetracker.google.com/issues/new?component=460964&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFragmentTagUsage" defaultSeverity="WARNING" displayName="Use FragmentContainerView instead of the &lt;fragment&gt; tag" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use FragmentContainerView instead of the &amp;lt;fragment&gt; tag&lt;br&gt;&lt;br&gt;FragmentContainerView replaces the &amp;lt;fragment&gt; tag as the preferred                 way of adding fragments via XML. Unlike the &amp;lt;fragment&gt; tag, FragmentContainerView                 uses a normal &lt;code&gt;FragmentTransaction&lt;/code&gt; under the hood to add the initial fragment,                 allowing further FragmentTransaction operations on the FragmentContainerView                 and providing a consistent timing for lifecycle events.&lt;br&gt;&lt;br&gt;Issue id: FragmentTagUsage&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/androidx/fragment/app/FragmentContainerView.html"&gt;https://developer.android.com/reference/androidx/fragment/app/FragmentContainerView.html&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.fragment&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460964"&gt;https://issuetracker.google.com/issues/new?component=460964&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseRequireInsteadOfGet" defaultSeverity="ERROR" displayName="Use the 'require_____()' API rather than 'get____()' API for more descriptive error messages when it's null." enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use the 'require_____()' API rather than 'get____()' API for more descriptive error messages when it's null.&lt;br&gt;&lt;br&gt;AndroidX added new "require____()" versions of common "get___()" APIs, such as getContext/getActivity/getArguments/etc. Rather than wrap these in something like requireNotNull(), using these APIs will allow the underlying component to try to tell you _why_ it was null, and thus yield a better error message.&lt;br&gt;&lt;br&gt;Issue id: UseRequireInsteadOfGet&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.fragment&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460964"&gt;https://issuetracker.google.com/issues/new?component=460964&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFragmentBackPressedCallback" defaultSeverity="ERROR" displayName="Use getViewLifecycleOwner() as the LifecycleOwner instead of a Fragment instance." enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use getViewLifecycleOwner() as the LifecycleOwner instead of a Fragment instance.&lt;br&gt;&lt;br&gt;The Fragment lifecycle can result in a Fragment being active                 longer than its view. This can lead to unexpected behavior from lifecycle aware                 objects remaining active longer than the Fragment's view. To solve this issue,                 getViewLifecycleOwner() should be used as a LifecycleOwner rather than the                 Fragment instance once it is safe to access the view lifecycle in a                 Fragment's onCreateView, onViewCreated, onActivityCreated, or                 onViewStateRestored methods.&lt;br&gt;&lt;br&gt;Issue id: FragmentBackPressedCallback&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.fragment&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460964"&gt;https://issuetracker.google.com/issues/new?component=460964&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseCompatLoadingForColorStateLists" defaultSeverity="WARNING" displayName="Should not call Resources.getColorStateList directly" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Should not call &lt;code&gt;Resources.getColorStateList&lt;/code&gt; directly&lt;br&gt;&lt;br&gt;Use Compat loading of color state lists&lt;br&gt;&lt;br&gt;Issue id: UseCompatLoadingForColorStateLists&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.appcompat&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460343"&gt;https://issuetracker.google.com/issues/new?component=460343&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidFragmentVersionForActivityResult" defaultSeverity="ERROR" displayName="Update to Fragment 1.3.0 to use ActivityResult APIs" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Update to Fragment 1.3.0 to use ActivityResult APIs&lt;br&gt;&lt;br&gt;In order to use the ActivityResult APIs you must upgrade your                 Fragment version to 1.3.0. Previous versions of FragmentActivity                 failed to call super.onRequestPermissionsResult() and used invalid request codes&lt;br&gt;&lt;br&gt;Issue id: InvalidFragmentVersionForActivityResult&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/permissions/requesting#make-the-request"&gt;https://developer.android.com/training/permissions/requesting#make-the-request&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.activity&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=527362"&gt;https://issuetracker.google.com/issues/new?component=527362&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeOptInUsageError" defaultSeverity="ERROR" displayName="Unsafe opt-in usage intended to be error-level severity" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsafe opt-in usage intended to be error-level severity&lt;br&gt;&lt;br&gt;This API has been flagged as opt-in with error-level severity.&lt;br/&gt;
&lt;br/&gt;
Any declaration annotated with this marker is considered part of an unstable or&lt;br/&gt;
otherwise non-standard API surface and its call sites should accept the opt-in&lt;br/&gt;
aspect of it by using the &lt;code&gt;@OptIn&lt;/code&gt; annotation, using the marker annotation --&lt;br/&gt;
effectively causing further propagation of the opt-in aspect -- or configuring&lt;br/&gt;
the &lt;code&gt;UnsafeOptInUsageError&lt;/code&gt; check's options for project-wide opt-in.&lt;br/&gt;
&lt;br/&gt;
To configure project-wide opt-in, specify the &lt;code&gt;opt-in&lt;/code&gt; option value in &lt;code&gt;lint.xml&lt;/code&gt;&lt;br/&gt;
as a comma-delimited list of opted-in annotations:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="UnsafeOptInUsageError"&gt;
        &amp;lt;option name="opt-in" value="com.foo.ExperimentalBarAnnotation" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;Issue id: UnsafeOptInUsageError&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.annotation.experimental&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=459778"&gt;https://issuetracker.google.com/issues/new?component=459778&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseSupportActionBar" defaultSeverity="WARNING" displayName="Should not call Activity.setActionBar if you extend AppCompatActivity" enabled="false" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Should not call &lt;code&gt;Activity.setActionBar&lt;/code&gt; if you extend &lt;code&gt;AppCompatActivity&lt;/code&gt;&lt;br&gt;&lt;br&gt;Use &lt;code&gt;AppCompatActivity.setSupportActionBar&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: UseSupportActionBar&lt;br/&gt;&lt;br/&gt;
Vendor: Android Open Source Project&lt;br/&gt;
Identifier: androidx.appcompat&lt;br/&gt;
Feedback: &lt;a href="https://issuetracker.google.com/issues/new?component=460343"&gt;https://issuetracker.google.com/issues/new?component=460343&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="프로퍼티 파일" path=""><inspection shortName="DuplicatePropertyInspection" defaultSeverity="WARNING" displayName="중복 프로퍼티" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="252.23892.464" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
값은 다르지만 키 또는 프로퍼티 값이 중복된 프로퍼티 키를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
property1=&lt;b&gt;&lt;font color="#000080"&gt;value&lt;/font&gt;&lt;/b&gt;;
property2=&lt;b&gt;&lt;font color="#000080"&gt;value&lt;/font&gt;&lt;/b&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;옵션&lt;/b&gt; 목록에서 검사가 중복된 항목을 검색해야 하는 영역을 선택할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: DuplicatePropertyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedProperty" defaultSeverity="WARNING" displayName="사용되지 않는 프로퍼티" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
포함되어 있는 .properties 파일 외부에서 참조되지 않는 프로퍼티를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnusedProperty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedMessageFormatParameter" defaultSeverity="WARNING" displayName="누락된 메시지 형식 매개변수" enabled="false" language="Properties" pluginId="com.intellij.java-i18n" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.text.MessageFormat&lt;/code&gt; 서식 문자열처럼 보이나 &lt;code&gt;{xx}&lt;/code&gt; 종류의 일부 매개변수를 사용하지 않는 프로퍼티 값을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# 매개변수 {0}이(가) 사용되지 않습니다
&lt;b&gt;error.message&lt;/b&gt;=Something happened in line &lt;b&gt;{1}&lt;/b&gt;
  &lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnusedMessageFormatParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InconsistentResourceBundle" defaultSeverity="ERROR" displayName="Inconsistent Resource Bundle" enabled="false" language="Properties" pluginId="com.intellij.java-i18n" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
리소스 번들에 포함된 프로퍼티 파일의 문제를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;누락된 번역 보고&lt;/b&gt; &lt;br&gt;&lt;br&gt;
  상위 프로퍼티 파일에 포함되어 있지만 상속에서 누락된 프로퍼티를 보고하려면 이 옵션을 사용하세요(파생 언어가 아닌 경우).

  &lt;br&gt;&lt;br&gt; &lt;p&gt;예:&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;
    # messages.properties
    abc=xxx

    # messages_fr.properties
    # Empty file
  &lt;/code&gt;&lt;/pre&gt;

  비어 있음 프로퍼티 &lt;code&gt;abc&lt;/code&gt;가 번역되지 않은 것으로 보고됩니다.
  &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/li&gt;

  &lt;li&gt;&lt;b&gt;일관되지 않은 프로퍼티 보고&lt;/b&gt; &lt;br&gt;&lt;br&gt;
  상속된 프로퍼티 파일에 포함되어 있지만 상위 항목(또는 상위 항목이 없는 경우 형제 항목)에서 누락된 프로퍼티를 보고하려면 이 옵션을 사용하세요.

  &lt;br&gt;&lt;br&gt; &lt;p&gt;예:&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;
    # messages.properties
    # 빈 파일

    # messages_fr.properties
    abc=xxx
  &lt;/code&gt;&lt;/pre&gt;

  여기에서 프로퍼티 &lt;code&gt;abc&lt;/code&gt; 번역은 프랑스어 이외의 언어로는 제공되지 않습니다. 따라서 (디폴트) 프로퍼티 파일 &lt;code&gt;messages.properties&lt;/code&gt;에서 누락된 것으로 보고됩니다.
  &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/li&gt;

  &lt;li&gt;&lt;b&gt;같은 값으로 재정의된 프로퍼티 보고&lt;/b&gt; &lt;br&gt;&lt;br&gt;
  몇몇 프로퍼티 파일에 그대로 복사하여 붙여 넣은 프로퍼티를 보고하려면 이 옵션을 사용하세요. &lt;br&gt;

  &lt;br&gt;&lt;br&gt; &lt;p&gt;예:&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;
    # messages.properties
    abc=xxx

    # messages_fr.properties
    abc=xxx
  &lt;/code&gt;&lt;/pre&gt;
  프로퍼티 &lt;code&gt;abc&lt;/code&gt;는 파일 &lt;code&gt;messages_fr.properties&lt;/code&gt;에서 불필요하게 상속된 것으로 보고됩니다.
  &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/li&gt;

  &lt;li&gt;&lt;b&gt;서로 다른 자리표시자로 재정의된 프로퍼티 보고&lt;/b&gt; &lt;br&gt;&lt;br&gt;
  재정의된 프로퍼티에서 자리표시자 일관성을 확인하려면 이 옵션을 사용하세요.

  &lt;br&gt;&lt;br&gt; &lt;p&gt;예:&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;
    # messages.properties
    qwe={0}xxx{1}
    abc={0}yyy{1}

    # messages_fr.properties
    qwe={0}xxx{0}xxx{1}
    abc={0}yyy
  &lt;/code&gt;&lt;/pre&gt;

  프로퍼티 &lt;code&gt;abc&lt;/code&gt;는 &lt;code&gt;messages.properties&lt;/code&gt;에 해당되지 않는 값이 있는 메시지 형식 자리표시자가 프로퍼티에 포함된 것으로 보고됩니다.
  &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/li&gt;

  &lt;li&gt;&lt;b&gt;서로 다른 값의 끝부분으로 재정의된 프로퍼티 보고&lt;/b&gt; &lt;br&gt;&lt;br&gt;
  재정의된 프로퍼티에서 끝부분의 일관성을 확인하려면 이 옵션을 사용하세요.
  &lt;br&gt;&lt;br&gt; &lt;p&gt;예:&lt;/p&gt;

  &lt;pre&gt;&lt;code&gt;
    # messages.properties
    abc=xxxzzz

    # messages_fr.properties
    abc=xxx;
  &lt;/code&gt;&lt;/pre&gt;

  프로퍼티 &lt;code&gt;abc&lt;/code&gt;는 특수 기호(&lt;code&gt;!&lt;/code&gt; / &lt;code&gt;?&lt;/code&gt; / &lt;code&gt;.&lt;/code&gt; / &lt;code&gt;:&lt;/code&gt; / &lt;code&gt;;&lt;/code&gt;)로 끝나는 것으로 보고되며 &lt;code&gt;messages.properties&lt;/code&gt; 내의 상위 값은 그렇지 않습니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: InconsistentResourceBundle&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UseEllipsisInPropertyInspection" defaultSeverity="WARNING" displayName="생략 부호 대신 3개의 마침표 문자" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
UTF-8 프로퍼티 파일에서 생략 기호 대신 사용된 세 개의 '마침표' 문자를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UseEllipsisInPropertyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TrailingSpacesInProperty" defaultSeverity="WARNING" displayName="프로퍼티 내 후행 공백" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
키 또는 값이 공백으로 끝나는 모든 프로퍼티를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TrailingSpacesInProperty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AlphaUnsortedPropertiesFile" defaultSeverity="WEAK WARNING" displayName="프로퍼티 파일 또는 리소스 번들이 알파벳순으로 정렬되지 않음" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
알파벳 순으로 정렬되지 않은 리소스 번들 또는 .properties 파일을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AlphaUnsortedPropertiesFile&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousLocalesLanguages" defaultSeverity="WARNING" displayName="의심스러운 리소스 번들 로케일 언어" enabled="false" language="Properties" pluginId="com.intellij.java-i18n" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Java에서 지원되지 않는 언어 코드가 포함된 로케일을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousLocalesLanguages&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WrongPropertyKeyValueDelimiter" defaultSeverity="WEAK WARNING" displayName="프로퍼티 키/값 구분 문자가 코드 스타일 설정과 일치하지 않습니다." enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="252.23892.464" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
키 또는 값 구분자가 코드 스타일 설정과 일치하지 않는 프로퍼티를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: WrongPropertyKeyValueDelimiter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="캡슐화" path="Java"><inspection shortName="ProtectedInnerClass" defaultSeverity="WARNING" displayName="protected 중첩 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;protected&lt;/code&gt; 중첩 클래스를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Outer {
    protected static class Nested {} // 경고
    protected class Inner {}         // 경고
    protected enum Mode {}           // 설정에 따른 경고
    protected interface I {}         // 설정에 따른 경고
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;'protected' 내의 열거형 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;protected&lt;/code&gt; 내의 열거형을 무시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;'protected' 내의 인터페이스 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;protected&lt;/code&gt; 내의 인터페이스를 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ProtectedInnerClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicField" defaultSeverity="INFORMATION" displayName="'public' 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;public&lt;/code&gt; 필드를 보고합니다.
상수(&lt;code&gt;static&lt;/code&gt; 및 &lt;code&gt;final&lt;/code&gt;로 표기된 필드)는 보고되지 않습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public String name;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;다음으로 어노테이션이 추가된 경우 무시&lt;/b&gt; 목록을 사용하여 무시할 어노테이션을 지정합니다. 이 검사는 해당 어노테이션이 추가된 필드를 무시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;열거형의 'public final' 필드 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;enum&lt;/code&gt; 타입의 &lt;code&gt;public final&lt;/code&gt; 필드를 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PublicField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageVisibleInnerClass" defaultSeverity="WARNING" displayName="패키지 표시 중첩 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
접근 제어자 없이 선언된 중첩 클래스(package-private이라고도 함)를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Outer {
    static class Nested {}  // 경고
    class Inner {}          // 경고
    enum Mode {}            // 설정에 따른 경고
    interface I {}          // 설정에 따른 경고
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;package-visible 내의 열거형 무시&lt;/b&gt; 옵션을 사용하여 package-private 내의 열거형을 무시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;package-visible 내의 인터페이스 무시&lt;/b&gt; 옵션을 사용하여 package-private 내의 인터페이스를 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PackageVisibleInnerClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicInnerClass" defaultSeverity="WARNING" displayName="'public' 중첩 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;public&lt;/code&gt; 중첩 클래스를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Outer {
    public static class Nested {} // 경고
    public class Inner {}         // 경고
    public enum Mode {}           // 설정에 따른 경고
    public interface I {}         // 설정에 따른 경고
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;'public' 내의 열거형 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;public&lt;/code&gt; 내의 열거형을 무시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;'public' 내의 인터페이스 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;public&lt;/code&gt; 내의 인터페이스를 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PublicInnerClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentOrReturnOfFieldWithMutableType" defaultSeverity="WARNING" displayName="가변 타입이 있는 필드의 대입 또는 반환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 매개변수의 반환이나 대입이 &lt;code&gt;Collection&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Calendar&lt;/code&gt;와 같은 배열이나 가변 타입의 필드로 이뤄졌음을 보고합니다.
&lt;p&gt;이러한 타입은 가변적이므로, 이 구문으로 인해
  소유 클래스 외부에서 예기치 않은 객체 상태 수정이 발생할 수 있습니다. 이 구문은 성능면에서 유익할 수 있지만
  본질적으로 버그가 발생하기 쉽습니다.&lt;/p&gt;
&lt;p&gt;다음과 같은 가변 타입이 보고됩니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;java.util.Date&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Calendar&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Collection&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Map&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.common.collect.Multimap&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.common.collect.Table&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;빠른 수정에서는 배열에 대해 필드의 &lt;code&gt;.clone()&lt;/code&gt; 메서드 호출을 추가하거나 수정 불가능한 컬렉션 래퍼를 사용합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.*;
  class Log {
    private String[] messages = {"one", "two", "three"};
    private Map&amp;lt;String, String&amp;gt; map = new HashMap&lt;&gt;();

    String[] getMessages() {
      return messages; // 경고: String[] 필드 'messages' 반환
    }

    Map&amp;lt;String, String&amp;gt; mapping() {
      return map; // 경고: Map&amp;lt;String, String&amp;gt; 필드 'map' 반환
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.*;
  class Log {
    String[] messages = {"one", "two", "three"};
    private Map&amp;lt;String, String&amp;gt; map = new HashMap&lt;&gt;();

    String[] getMessages() {
      return messages.clone();
    }

    Map&amp;lt;String, String&amp;gt; mapping() {
      return Collections.unmodifiableMap(map);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;private 메서드의 대입 및 반환 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;private&lt;/code&gt; 메서드의 대입과 반환을 무시합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: AssignmentOrReturnOfFieldWithMutableType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProtectedField" defaultSeverity="WARNING" displayName="protected 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;protected&lt;/code&gt; 필드를 보고합니다.
&lt;p&gt;상수(&lt;code&gt;static&lt;/code&gt; 또는 &lt;code&gt;final&lt;/code&gt;로 표기된 변수)는 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class A {
    protected Object object;              // 경고
    protected final static int MODE = 0;  // 상수는 경고하지 않음
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ProtectedField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageVisibleField" defaultSeverity="WARNING" displayName="Package-visible 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
접근 제어자 없이 선언된 필드(package-private이라고도 함)를 보고합니다.
&lt;p&gt;상수(&lt;code&gt;static&lt;/code&gt; 및 &lt;code&gt;final&lt;/code&gt;로 표기된 필드)는 보고되지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class A {
    Object object;             // 경고
    final static int MODE = 0; // 상수는 경고하지 않음
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PackageVisibleField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfAnotherObjectsPrivateField" defaultSeverity="WARNING" displayName="다른 객체의 비 public 필드에 액세스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 객체의 &lt;code&gt;private&lt;/code&gt; 또는 &lt;code&gt;protected&lt;/code&gt; 필드로의 액세스를 보고합니다.
Java는 현재 객체와 동일한 클래스의 객체인 경우 이러한 필드 액세스를 허용하지만 일부 코드 스타일에서는 이러한 사용을 추천하지 않습니다. 또한 &lt;code&gt;private&lt;/code&gt; 필드에 대한 직접적 액세스는 Spring 및 Hibernate와 같은 구성요소 지향의 아키텍처에서 실패할 수 있습니다. 이러한 아키텍처에서는 다른 객체에 대한 모든 액세스가 메서드 호출을 통해 이루어져, 프레임워크가 프록시를 사용하여 액세스를 중개할 수 있도록 기대됩니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Base {
    protected int bar;

    void increment(Base base) {
      bar++;
      base.bar++; // warning: direct access to another object's non-public field
    }
  }
&lt;/code&gt;&lt;/pre&gt;
이 필드를 캡슐화하는 빠른 수정을 사용할 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;동일한 클래스의 액세스 무시&lt;/b&gt; 옵션을 사용하여 동일한 클래스의 액세스를 무시하고 내부 또는 외부 클래스의 액세스를 보고합니다.
    &lt;p&gt;내부 클래스의 액세스도 무시하는 경우 중첩된 &lt;b&gt;내부 클래스의 액세스 무시&lt;/b&gt;를 사용합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;b&gt;'equals()' 메서드의 액세스 무시&lt;/b&gt;를 사용하여 &lt;code&gt;equals()&lt;/code&gt; 메서드의 액세스를 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UseOfAnotherObjectsPrivateField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="비트 연산 이슈" path="JavaScript 및 TypeScript"><inspection shortName="JSBitwiseOperatorUsage" defaultSeverity="WARNING" displayName="비트 연산 사용 위치" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Bitwise AND("&lt;code&gt;&amp;&lt;/code&gt;") 또는 OR("&lt;code&gt;|&lt;/code&gt;") 연산자의 의심스러운 사용 위치를 보고합니다.
보통 오타이며 bool 연산 AND("&lt;code&gt;&amp;&amp;&lt;/code&gt;") 및 OR("&lt;code&gt;||&lt;/code&gt;")을 적용한 결과가 기대됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSBitwiseOperatorUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncompatibleMaskJS" defaultSeverity="WARNING" displayName="호환되지 않는 비트 마스크 연산" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/IncompatibleMask.html --&gt;
&lt;html&gt;
&lt;body&gt;
반드시 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt;로 평가되는 비트 마스크 식을 보고합니다.
&lt;code&gt;constant1&lt;/code&gt; 및 &lt;code&gt;constant2&lt;/code&gt;가 호환되지 않은 
비트마스크 상수인 경우 표현식 양식은 &lt;code&gt;(var &amp; constant1) == constant2&lt;/code&gt; 
또는 &lt;code&gt;(var | constant1) == constant2&lt;/code&gt;입니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
// 호환되지 않는 마스크: 마스크의 마지막 바이트가 0이므로,
// 0x1200 등은 가능하나 0x1234는 불가능합니다
if ((mask &amp; 0xFF00) == 0x1234) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IncompatibleMaskJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessBitwiseExpressionJS" defaultSeverity="WARNING" displayName="Bitwise 표현식을 단순화할 수 있음" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/PointlessBitwiseExpression.html --&gt;
&lt;html&gt;
&lt;body&gt;
0을 사용한 &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, 또는 시프트 연산을 포함하는 표현식을 보고합니다. 그러한 표현식은 완전히 완료되지 않은 자동 리팩토링으로 인해 발생할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PointlessBitwiseExpressionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ShiftOutOfRangeJS" defaultSeverity="WARNING" displayName="잘못된 상수에 의한 시프트 연산이 있을 수 있음" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/plugins/InspectionGadgets/src/inspectionDescriptions/ShiftOutOfRange.html --&gt;
&lt;html&gt;
&lt;body&gt;
&lt;code&gt;0..31&lt;/code&gt; 범위 외의 정수 시프트 연산, 음의 값 또는 과도하게 큰 값에 의해 시프트 연산 등 두 번째 피연산자가 합리적인 범위 외의 정수인 시프트 연산을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ShiftOutOfRangeJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="오류 처리" path="Groovy"><inspection shortName="GroovyEmptyCatchBlock" defaultSeverity="WARNING" displayName="빈 'catch' 블록" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
빈 &lt;code&gt;catch&lt;/code&gt; 블록을 보고합니다. 의도된 경우도 있으나 빈 &lt;code&gt;catch&lt;/code&gt; 블록은 디버그를 매우 어렵게 만들 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
try {
  throw new Exception()
}
catch (Exception e) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
try {
  throw new Exception()
}
catch (Exception ignored) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyEmptyCatchBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyThrowFromFinallyBlock" defaultSeverity="WARNING" displayName="'finally' 블록 내 'throw'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;finally&lt;/code&gt; 블록 내부의 &lt;code&gt;throw&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;
  의도한 경우도 있으나 이러한 &lt;code&gt;throw&lt;/code&gt; 문은 던져진 예외를 가리고 디버그를 매우 복잡하게 만들 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyThrowFromFinallyBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnusedCatchParameter" defaultSeverity="WARNING" displayName="사용되지 않는 'catch' 매개변수" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;대응하는 블록에서 사용되지 않는 &lt;b&gt;catch&lt;/b&gt; 매개변수를
보고합니다. 이 검사는 이름이 "ignore" 또는 "ignored"인 &lt;b&gt;catch&lt;/b&gt; 매개변수를
보고하지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      def arr = new int[3]
      arr[5] = 5
  } catch(Exception &lt;b&gt;ex&lt;/b&gt;) {
      println('Catching the exception')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 &lt;b&gt;ex&lt;/b&gt; 매개변수는 &lt;b&gt;catch&lt;/b&gt; 블록에서 사용되지 않습니다.
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      def arr = new int[3]
      arr[5] = 5
  } catch(Exception &lt;b&gt;ignored&lt;/b&gt;) {
      println('Catching the exception')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyUnusedCatchParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyReturnFromFinallyBlock" defaultSeverity="WARNING" displayName="'finally' 블록 내 'return'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;finally&lt;/code&gt; 블록 내의 &lt;code&gt;return&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;
  의도한 경우도 있으만 이러한 &lt;code&gt;return&lt;/code&gt; 문은 던져진 예외를 가리고 디버그를 매우 복잡하게 만들 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyReturnFromFinallyBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyContinueOrBreakFromFinallyBlock" defaultSeverity="WARNING" displayName="'finally' 블록의 'continue' 또는 'break'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;finally&lt;/code&gt; 블록 내부의 &lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;continue&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;의도된 경우도 있으나 이러한 구문은 혼란을 일으키며, 던져진 예외를 가리고 디버그를 매우 복잡하게 만들 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyContinueOrBreakFromFinallyBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyEmptyTryBlock" defaultSeverity="WARNING" displayName="빈 'try' 블록" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
빈 &lt;code&gt;try&lt;/code&gt; 블록을 보고합니다.
빈 &lt;code&gt;try&lt;/code&gt; 블록은 보통 코딩 오류를 의미합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
try {
}
finally {
  close()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyEmptyTryBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyEmptyFinallyBlock" defaultSeverity="WARNING" displayName="빈 'finally' 블록" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
빈 &lt;code&gt;finally&lt;/code&gt; 블록을 보고합니다.
일반적으로 빈 &lt;code&gt;finally&lt;/code&gt; 블록은 코딩 오류를 의미합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
try {
  throw new Exception()
}
finally {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyEmptyFinallyBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="XPath" path=""><inspection shortName="CheckNodeTest" defaultSeverity="WARNING" displayName="알 수 없는 요소 또는 속성 이름" enabled="false" language="XPath" pluginId="XPathView" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
XPath 표현식에서 사용되지만 관련 XML 파일에서 누락되었거나 참조된 스키마에 정의되지 않은 요소 및 속성의 이름을 보고합니다.
이러한 이름은 종종 오타일 수 있으며 그렇지 않은 경우 런타임 시에만 발견될 수 있습니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;xsl:template match="&lt;b&gt;h:txtarea&lt;/b&gt;" /&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
  만약 &lt;code&gt;h&lt;/code&gt;가 XHTML 네임스페이스에 바운드될 때, 검사는 &lt;code&gt;match&lt;/code&gt; 표현식의 이 일부를 알 수 없는 요소 이름으로 보고합니다. 이는 이 요소의 올바른 이름은 “ textarea” 이기 때문입니다.
&lt;/p&gt;


&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CheckNodeTest&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantTypeConversion" defaultSeverity="WARNING" displayName="불필요한 타입 변환" enabled="false" language="XPath" pluginId="XPathView" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 형 변환을 보고합니다.
&lt;code&gt;string()&lt;/code&gt;, &lt;code&gt;number()&lt;/code&gt; 또는 &lt;code&gt;boolean()&lt;/code&gt; 함수의 인수 타입이 해당 함수의 반환 타입과 동일하거나 또는 필요한 표현식 타입이 &lt;code&gt;any&lt;/code&gt;인 경우 형 변환은 불필요합니다. 불필요한 변환 제거를 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantTypeConversion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IndexZeroUsage" defaultSeverity="WARNING" displayName="색인 0이 포함된 XPath 술부" enabled="false" language="XPath" pluginId="XPathView" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
술부 색인 또는 &lt;code&gt;position()&lt;/code&gt; 함수 비교에서 사용된 &lt;code&gt;0&lt;/code&gt;을 보고합니다. XPath에서 색인은 항상 &lt;code&gt;0&lt;/code&gt;이 &lt;em&gt;아닌&lt;/em&gt; &lt;code&gt;1&lt;/code&gt;부터 시작하기 때문에 이러한 사용은 거의 언제나 버그입니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  //someelement[&lt;b&gt;position() = 0&lt;/b&gt;]&lt;/code&gt; or &lt;code&gt;//something[&lt;b&gt;0&lt;/b&gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IndexZeroUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ImplicitTypeConversion" defaultSeverity="WARNING" displayName="묵시적 타입 변환" enabled="false" language="XPath" pluginId="XPathView" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
사전 정의된 XPath 타입인 &lt;code&gt;STRING&lt;/code&gt;, &lt;code&gt;NUMBER&lt;/code&gt;, &lt;code&gt;BOOLEAN&lt;/code&gt; 및 &lt;code&gt;NODESET&lt;/code&gt; 간 묵시적 변환을 보고합니다. 타입을 더 명확히하며 감지하기 어려운 버그를 방지하는 XSLT 스크립트 작성을 돕습니다:
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;xsl:if test="&lt;b&gt;foo&lt;/b&gt;" /&gt;
&lt;/code&gt;&lt;/pre&gt;
이는 다음과 동일하지 않습니다.
&lt;pre&gt;&lt;code&gt;
  &amp;lt;xsl:if test="&lt;b&gt;string(foo)&lt;/b&gt;" /&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
첫 번째 테스트는 'foo' 요소가 있는지 확인합니다(&lt;code&gt;count(foo) &gt; 0)&lt;/code&gt;. 두 번째 테스트는 요소가 텍스트를 실제로 포함하고 있을 때에만 true를 나타냅니다(&lt;code&gt;string-length(foo) &gt; 0&lt;/code&gt;). 타입 변환을 더 명시적으로 만드는 것을 제안합니다.
&lt;/p&gt;

&lt;p&gt;
  다음 옵션을 사용해 검사를 구성하세요.
&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;특정 타입간 묵시적 변환을 활성화 또는 비활성화&lt;/li&gt;
&lt;li&gt;예를 들어 &lt;code&gt;&amp;lt;xsl:if test="number(foo)" /&gt;&lt;/code&gt;와 같이, 실제 예상 타입으로 귀결되지 않는 명시적 변환을 항상 보고&lt;/li&gt; 
&lt;li&gt;&lt;code&gt;string()&lt;/code&gt; 함수를 &lt;code&gt;string-length() &gt; 0&lt;/code&gt; 작성을 위한 단축키로 사용하여  &lt;code&gt;NODESET&lt;/code&gt; 에서  &lt;code&gt;BOOLEAN&lt;/code&gt; 으로의 변환을 무시합니다.&lt;/li&gt;&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ImplicitTypeConversion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HardwiredNamespacePrefix" defaultSeverity="WARNING" displayName="하드코딩된 네임스페이스 접두사" enabled="false" language="XPath" pluginId="XPathView" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
콜론(&lt;code&gt;:&lt;/code&gt;)을 포함하는 문자열과 &lt;code&gt;name()&lt;/code&gt; 함수 간 비교를 보고합니다.  이러한 사용은 주로 비교에서 네임스페이스 접두사가 하드코딩되었음을 나타냅니다. 이렇게 하면 같은 네임스페이스에 대해 다른 접두사를 사용하는 XML을 실행할 경우 코드가 중단됩니다.

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;xsl:if test="name() = 'xlink:href'"&gt;...&amp;lt;xsl:if&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HardwiredNamespacePrefix&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Kubernetes" path=""><inspection shortName="KubernetesNonEditableResources" defaultSeverity="WARNING" displayName="편집 불가한 Kubernetes 리소스" enabled="false" language="yaml" pluginId="com.intellij.kubernetes" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
편집 불가한 (읽기 전용) Kubernetes 리소스 타입을 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KubernetesNonEditableResources&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KubernetesMissingKeys" defaultSeverity="ERROR" displayName="누락된 Kubernetes YAML 키" enabled="false" language="yaml" pluginId="com.intellij.kubernetes" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kubernetes 리소스 파일에서 누락된 필수 키를 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KubernetesMissingKeys&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KubernetesDeprecatedValues" defaultSeverity="WARNING" displayName="지원 중단된 Kubernetes 리소스 프로퍼티 값" enabled="false" language="yaml" pluginId="com.intellij.kubernetes" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kubernetes 리소스 파일 내 지원 중지된 값을 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KubernetesDeprecatedValues&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KubernetesUnknownKeys" defaultSeverity="ERROR" displayName="알 수 없는 Kubernetes YAML 키" enabled="false" language="yaml" pluginId="com.intellij.kubernetes" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kubernetes 리소스 파일에서 인식되지 않는 키를 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KubernetesUnknownKeys&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HelmChartMissingKeys" defaultSeverity="ERROR" displayName="Chart.yaml 키 누락" enabled="false" language="yaml" pluginId="com.intellij.kubernetes" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Chart.yaml에서 누락된 필수 키를 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HelmChartMissingKeys&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KubernetesDeprecatedResources" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 Kubernetes 리소스" enabled="false" language="yaml" pluginId="com.intellij.kubernetes" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
곧 사용할 수 없게 될 Kubernetes 리소스 타입을 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KubernetesDeprecatedResources&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KubernetesDeprecatedKeys" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 Kubernetes 리소스 프로퍼티" enabled="false" language="yaml" pluginId="com.intellij.kubernetes" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kubernetes 리소스 파일에서 지원이 중단된 키를 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KubernetesDeprecatedKeys&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KubernetesDuplicatedEnvVars" defaultSeverity="ERROR" displayName="중복된 EnvVar 정의" enabled="false" language="yaml" pluginId="com.intellij.kubernetes" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kubernetes 컨테이너 정의에서 중복된 EnvVars를 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KubernetesDuplicatedEnvVars&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KubernetesUnknownValues" defaultSeverity="ERROR" displayName="알 수 없는 Kubernetes YAML 값" enabled="false" language="yaml" pluginId="com.intellij.kubernetes" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kubernetes 리소스 파일에서 유효하지 않은 값을 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KubernetesUnknownValues&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HelmChartUnknownValues" defaultSeverity="ERROR" displayName="잘못된 Chart.yaml 값" enabled="false" language="yaml" pluginId="com.intellij.kubernetes" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Chart.yaml 및 requirements.yaml에서 인식되지 않는 값을 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HelmChartUnknownValues&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HelmChartUnknownKeys" defaultSeverity="WARNING" displayName="알 수 없는 Chart.yaml 키" enabled="false" language="yaml" pluginId="com.intellij.kubernetes" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Chart.yaml에서 인식되지 않는 키를 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: HelmChartUnknownKeys&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KubernetesNonEditableKeys" defaultSeverity="WARNING" displayName="편집 불가한 Kubernetes 리소스 프로퍼티" enabled="false" language="yaml" pluginId="com.intellij.kubernetes" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Kubernetes 리소스 파일에서 편집 불가한 (읽기 전용) 키를 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KubernetesNonEditableKeys&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KubernetesUnknownResourcesInspection" defaultSeverity="WARNING" displayName="알 수 없는 Kubernetes 리소스" enabled="false" language="yaml" pluginId="com.intellij.kubernetes" pluginVersion="252.23892.515" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인식되지 않는 Kubernetes 리소스 타입을 보고합니다.
&lt;br&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KubernetesUnknownResourcesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="발생할 수 있는 버그" path="Kotlin"><inspection shortName="UnusedLambdaExpressionBody" defaultSeverity="WARNING" displayName="람다 식 본문이 있는 함수의 사용되지 않는 반환값" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
호출한 함수가 표현식 본문에서 람다를 반환할 경우 사용되지 않는 반환 값을 가지는 호출을 보고합니다.
&lt;p&gt;
함수 헤더와 본문 블록 사이에 &lt;code&gt;=&lt;/code&gt;가 있다면 함수의 코드가 평가되지 않으며 이는 잘못된 동작으로 이어질 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;함수 선언에서 = 토큰 제거&lt;/b&gt;를 사용해 코드를 자동으로 수정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun printHello() = { println("Hello") }

  fun main() {
      printHello() // 이 함수는 아무것도 출력하지 않습니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun printHello() { println("Hello") }

  fun main() {
      printHello()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnusedLambdaExpressionBody&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceArrayEqualityOpWithArraysEquals" defaultSeverity="WARNING" displayName="'==' 및 '!='를 통한 배열 비교" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;contentEquals()&lt;/code&gt;로 바꿔야 하는 배열에 대한 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 연산자의 사용을 보고합니다.
&lt;p&gt;
    &lt;code&gt;==&lt;/code&gt;와 &lt;code&gt;!=&lt;/code&gt; 연산자는 배열의 내용이 아닌 배열 참조를 비교합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test() {
      val a = arrayOf(1, 2, 3)
      val b = arrayOf(1, 2, 3)
      println(a == b) // 참조 비교
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test() {
      val a = arrayOf(1, 2, 3)
      val b = arrayOf(1, 2, 3)
      println(a.contentEquals(b))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReplaceArrayEqualityOpWithArraysEquals&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignedValueIsNeverRead" defaultSeverity="WARNING" displayName="대입된 값이 한 번도 읽히지 않습니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;대입된 값이 이후에 코드에서 사용되지 않는 대입을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): Int = 42

  fun example() {
      var local = 0
      print(local)
      local = 42  // 대입된 값이 사용되지 않습니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
    &lt;li&gt;빠른 수정이 적용되면 대입이 삭제됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): Int = 42

  fun example() {
      var local = 0
      print(local)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
    &lt;li&gt;표현식의 오른쪽(RHS)에 잠재적인 부수 효과가 있는 경우, 빠른 수정에서는 RHS 표현식을 유지하여 부수 효과를 보존하도록 제안합니다.
    &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): Int = 42

  fun example() {
      var local = 0
      print(local)
      foo()  // 부수 효과를 보존하기 위해 함수 호출이 유지됩니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AssignedValueIsNeverRead&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedLambdaExpression" defaultSeverity="WARNING" displayName="사용되지 않는 람다 식" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
호출되지 않거나 대입되지 않은 람다 식을 보고합니다.

&lt;p&gt;
  호출되지 않거나 변수에 대입되지 않은 람다 식은 프로그램 실행에 영향을 주지 않으며, 의도하지 않았을 가능성이 높습니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
    {} // 경고: 람다 식이 호출되지 않습니다
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
    run {} // 이제 람다가 'run' 함수를 통해 호출됩니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnusedLambdaExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RunBlockingInSuspendFunction" defaultSeverity="WARNING" displayName="suspend 함수 내의 'runBlocking'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;suspend&lt;/code&gt; 함수 내의 &lt;code&gt;runBlocking&lt;/code&gt; 호출을 참조합니다.
&lt;p&gt;&lt;code&gt;suspend&lt;/code&gt; 함수 내에서 &lt;code&gt;runBlocking&lt;/code&gt;을 사용하면 호출 스레드를 차단하여 비동기 프로그래밍의 목적에 어긋납니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 컨텍스트에 따라 다음 중 하나로 &lt;code&gt;runBlocking&lt;/code&gt; 호출을 대체합니다.&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;run&lt;/code&gt; 호출.&lt;/li&gt;
    &lt;li&gt;특정 &lt;code&gt;CoroutineContext&lt;/code&gt;가 사용되는 경우 &lt;code&gt;withContext&lt;/code&gt; 호출&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;runBlocking&lt;/code&gt; 래퍼 없이 직접 인라인화된 코드&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
suspend fun something() {
  runBlocking {
    code() // 여기서 스레드가 막힙니다
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
suspend fun something() {
  code() // 비동기 실행
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2025.1에서 추가&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RunBlockingInSuspendFunction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="VariableNeverRead" defaultSeverity="WARNING" displayName="한 번도 읽히지 않는 변수" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
코드에서 정의된 후 전혀 사용되지 않는 로컬 변수를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      var local = 42 // 변수 'local'이 사용되지 않습니다
      local = 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: VariableNeverRead&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EqualsOrHashCode" defaultSeverity="WARNING" displayName="'equals()' 및 'hashCode()'가 쌍으로 되어 있지 않습니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;equals()&lt;/code&gt;를 재정의하지만 &lt;code&gt;hashCode()&lt;/code&gt;는 재정의하지 않는 클래스 또는 그 반대의 클래스를 보고합니다.
또한 &lt;code&gt;equals()&lt;/code&gt; 또는 &lt;code&gt;hashCode()&lt;/code&gt;를 재정의하는 객체 선언을 보고합니다.
&lt;p&gt;이러한 항목은 클래스가 &lt;code&gt;Collection&lt;/code&gt;에 추가될 때 바람직하지 않은 동작을 발생시킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C1 {
      override fun equals(other: Any?) = true
  }

  class C2 {
      override fun hashCode() = 0
  }

  object O1 {
      override fun equals(other: Any?) = true
  }

  object O2 {
      override fun hashCode() = 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 클래스의 &lt;code&gt;equals()&lt;/code&gt; 또는 &lt;code&gt;hashCode()&lt;/code&gt;를 재정의하고 객체의 해당 메서드를 삭제합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
   class C1 {
       override fun equals(other: Any?) = true
       override fun hashCode(): Int {
           return javaClass.hashCode()
       }
   }

   class C2 {
       override fun hashCode() = 0
       override fun equals(other: Any?): Boolean {
           if (this === other) return true
           if (javaClass != other?.javaClass) return false
           return true
       }
   }

   object O1 {
   }

   object O2 {
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EqualsOrHashCode&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousCascadingIf" defaultSeverity="WARNING" displayName="의심스러운 중첩 'if' 식" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;마지막 &lt;code&gt;else&lt;/code&gt; 브랜치가 점으로 연결되거나 이진 표현식의 일부인 경우 캐스케이드 &lt;code&gt;if&lt;/code&gt; 식을 보고합니다.
&lt;/p&gt;
&lt;p&gt;이렇게 되면 가장 안쪽의 &lt;code&gt;if-else&lt;/code&gt; 식만이 외부 표현식의 리시버 또는 왼쪽 피연산자가 되어 의도한 로직과 다를 수 있기 때문에 예상치 못한 동작이 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun printNumberSign(num: Int) {
    if (num &gt; 0) {
        "positive"
    } else if (num &lt; 0) {
        "negative"
    } else {
        "zero"
    }.let { print(it) }
}

fun main() {
    printNumberSign(1) // 'let'의 리시버는 내부 'if-else' 식뿐이므로 아무것도 출력되지 않습니다
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;첫 번째 빠른 수정 적용 후(&lt;code&gt;when&lt;/code&gt;으로 변환):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun printNumberSign(num: Int) {
    when {
        num &gt; 0 -&gt; {
            "positive"
        }

        num &lt; 0 -&gt; {
            "negative"
        }

        else -&gt; {
            "zero"
        }
    }.let { print(it) }
}

fun main() {
    printNumberSign(1) // 'positive'를 출력합니다
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;또는 두 번째 빠른 수정으로, 중첩된 &lt;code&gt;else&lt;/code&gt; 브랜치를 명시적으로 만들면서 원래의 의미를 유지하기 위해 구분하는 중괄호를 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun printNumberSign(num: Int) {
    if (num &gt; 0) {
        "positive"
    } else {
        if (num &lt; 0) {
            "negative"
        } else {
            "zero"
        }.let { print(it) }
    }
}

fun main() {
    printNumberSign(1) // 아무것도 출력되지 않지만 코드는 더 명확합니다
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousCascadingIf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousEqualsCombination" defaultSeverity="WEAK WARNING" displayName="==와 ===의 의심스러운 조합" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단일 표현식 내 같은 변수에서 사용되는 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;===&lt;/code&gt; 비교를 보고합니다.
&lt;p&gt;&lt;code&gt;==&lt;/code&gt;와 &lt;code&gt;===&lt;/code&gt;는 유사해서 모르는 사이에 섞일 수 있으며 &lt;code&gt;==&lt;/code&gt;가 대신 사용되었는지 확인하려면 세심한 주의를 기울여야 합니다. &lt;code&gt;===&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (type === FIELD || type == METHOD || type == ANNOTATION_METHOD || // '=='가 잘못 사용되었습니다
      type === LAMBDA_EXPRESSION) return
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousEqualsCombination&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LateinitVarOverridesLateinitVar" defaultSeverity="WARNING" displayName="'lateinit var' 프로퍼티가 'lateinit var' 프로퍼티를 재정의" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 &lt;code&gt;lateinit var&lt;/code&gt; 프로퍼티를 재정의하는 &lt;code&gt;lateinit var&lt;/code&gt; 프로퍼티를 보고합니다.
&lt;p&gt;하위 클래스 인스턴스가 하나의 프로퍼티에 대해 필드를 2개 갖게 되어, 사실상 상위 클래스의 필드는 사용되지 않은 채로 남게 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    open class BaseClass {
      open lateinit var name: String
    }

    class RealClass : BaseClass() {
      override lateinit var name: String
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LateinitVarOverridesLateinitVar&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectInheritsException" defaultSeverity="WARNING" displayName="예외는 객체일 수 없습니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
예외는 본질적으로 스택 추적과 같은 정보를 포함하는 스테이트풀이므로 &lt;code&gt;Exception&lt;/code&gt;을 상속한 객체를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
object MyEx: Exception()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class MyEx: Exception()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ObjectInheritsException&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AddExplicitTargetToParameterAnnotation" defaultSeverity="WEAK WARNING" displayName="불필요한 보간 접두사" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명시적 타깃 없어서 디폴트 타깃이 적절하지 못하고 예상치 못하게 설정될 수 있는 값 매개변수 어노테이션의 사용을 보고합니다.
&lt;p&gt;
    명시적 타깃이 없는 값 매개변수 어노테이션은 Kotlin 2.1.20 전의 매개변수 자체에만 적용됩니다.
    매개변수와 필드 또는 프로퍼티 모두에 적용 가능한 어노테이션의 경우, 해당 어노테이션이 &lt;code&gt;val&lt;/code&gt; 또는 &lt;code&gt;var&lt;/code&gt; 생성자 매개변수에 사용될 때 이 동작은 의도한 바가 아닐 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
예:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Example(
    @Param val foo: String,
    @ParamField val bar: String, // 어노테이션이 필드에는 없고 매개변수에만 있습니다
    @ParamProperty val baz: String, // 어노테이션이 프로퍼티에는 없고 매개변수에만 있습니다
    @ParamProperty boo: String,
)

@Target(AnnotationTarget.VALUE_PARAMETER)
annotation class Param
@Target(AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.FIELD)
annotation class ParamField
@Target(AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.PROPERTY)
annotation class ParamProperty
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Example(
    @Param val foo: String,
    @field:ParamField val bar: String,
    @property:ParamProperty val baz: String,
    @ParamProperty boo: String,
)

@Target(AnnotationTarget.VALUE_PARAMETER)
annotation class Param
@Target(AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.FIELD)
annotation class ParamField
@Target(AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.PROPERTY)
annotation class ParamProperty
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AddExplicitTargetToParameterAnnotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MainFunctionReturnUnit" defaultSeverity="WARNING" displayName="메인 함수는 'Unit'을 반환해야 합니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
기본 함수에 &lt;code&gt;Unit&lt;/code&gt;의 반환 타입이 없는 경우를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;code&gt;fun main() = "Hello world!"&lt;/code&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MainFunctionReturnUnit&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinEqualsBetweenInconvertibleTypes" defaultSeverity="WARNING" displayName="변환할 수 없는 타입의 객체 간의 'equals()'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
리시버와 인수가 기본, 열거형 또는 문자열 타입과 호환되지 않는 &lt;code&gt;equals()&lt;/code&gt; 호출을 보고합니다.

&lt;p&gt;그러한 호출은 이론적으로 유용할 수 있지만 버그일 가능성이 매우 높습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  5.equals("");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: KotlinEqualsBetweenInconvertibleTypes&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousVarProperty" defaultSeverity="WARNING" displayName="의심스러운 'var' 프로퍼티: 해당 setter가 해당 getter 결과에 영향을 미치지 않음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
백킹 필드를 참조하지 않는 디폴트 setter 및 getter를 포함하는 &lt;code&gt;var&lt;/code&gt; 프로퍼티를 보고합니다.
&lt;p&gt;
그러한 프로퍼티는 setter를 호출하는데 영향을 주지 않으므로 &lt;code&gt;val&lt;/code&gt;로 변경하고 이니셜라이저를 삭제하면 더 깔끔합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;val로 변경하고 이니셜라이저 삭제&lt;/b&gt; 빠른 수정을 사용해 코드를 자동으로 수정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 이 프로퍼티는 항상 '1'을 반환하며 프로터피가 'var'인지는 중요하지 않습니다
  var foo: Int = 0
      get() = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousVarProperty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedExpression" defaultSeverity="WARNING" displayName="사용되지 않는 표현식" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
사용되지 않는 표현식을 보고합니다. 이는 코드가 불완전하거나 &lt;code&gt;return&lt;/code&gt;문이 누락되었음을 나타냅니다.

&lt;p&gt;
    사용되지 않는 표현식이 함수의 마지막 구문이며 해당 표현식의 타입이 함수의 반환 타입과 일치하는 경우, 빠른 수정으로 &lt;code&gt;return&lt;/code&gt; 키워드를 자동으로 추가할 수 있습니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun example(): Int {
    val x = 10
    x // 경고: 표현식이 사용되지 않습니다
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun example(): Int {
    val x = 10
    return x
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnusedExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="WrapUnaryOperator" defaultSeverity="WEAK WARNING" displayName="숫자 상수를 가진 모호한 단항 연산자 사용" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;-1.inc()&lt;/code&gt; 같은 마침표 한정자 뒤에 나오는 단항 연산자를 보고합니다.
&lt;p&gt;&lt;code&gt;.inc()&lt;/code&gt;보다 &lt;code&gt;-&lt;/code&gt;의 우선순위가 낮으므로 &lt;code&gt;-1.inc()&lt;/code&gt; 같은 코드는 오해의 소지가 있습니다.
    결과적으로 &lt;code&gt;-1.inc()&lt;/code&gt;는 예상되는 &lt;code&gt;0&lt;/code&gt; 대신 &lt;code&gt;-2&lt;/code&gt;를 평가합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;단항 연산자와 값을 ()로 래핑&lt;/b&gt; 빠른 수정을 사용해 코드를 자동으로 수정할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: WrapUnaryOperator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FilterIsInstanceResultIsAlwaysEmpty" defaultSeverity="WARNING" displayName="'filterIsInstance' 호출의 결과가 항상 비어 있습니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;대상 타입이 필터링이 호출되고 있는 요소 타입의 하위 타입이 아닌 Kotlin 표준 라이브러리 함수 &lt;code&gt;filterIsInstance&lt;/code&gt;/&lt;code&gt;filterIsInstanceTo&lt;/code&gt;를 검사가 탐지합니다.&lt;/p&gt;

&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    val list = listOf&amp;lt;Int&amp;gt;(1, 2, 3)
    val filteredList = list.filterIsInstance&amp;lt;Boolean&amp;gt;() // 빈 결과
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FilterIsInstanceResultIsAlwaysEmpty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DataClassPrivateConstructor" defaultSeverity="WARNING" displayName="private 데이터 클래스 생성자가 'copy' 메서드를 통해 노출됨" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
데이터 클래스의 &lt;code&gt;private&lt;/code&gt; 기본 생성자를 보고합니다.
&lt;p&gt;
    &lt;code&gt;data&lt;/code&gt; 클래스는 생성자와 비슷하게 사용할 수 있는 &lt;code&gt;copy()&lt;/code&gt; factory 메서드를 가지고 있습니다.
    충분한 안전성을 제공하려면 생성자가 &lt;code&gt;private&lt;/code&gt;으로 표시되지 않아야 합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class User private constructor(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 생성자 가시성 제어자를 &lt;code&gt;public&lt;/code&gt;으로 변경합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class User(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DataClassPrivateConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinConstantConditions" defaultSeverity="WARNING" displayName="상수 조건" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
항상 true, false, null 또는 0으로 정적으로 알려진, 자명하지 않은 조건 및 값을 보고합니다.
의도한 경우도 있지만, 이는 종종 프로그램에 논리적 오류가 있다는 것을 나타냅니다. 또한, &lt;code&gt;when&lt;/code&gt; 브랜치에 연결할 수 없으며 항상 실패하는 것으로 정적으로 알려진 일부 표현식을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun process(x: Int?) {
  val isNull = x == null
  if (!isNull) {
    if (&lt;span style="background: yellow"&gt;x != null&lt;/span&gt;) {} // 조건이 항상 true입니다
    require(&lt;span style="background: yellow"&gt;x!! &amp;lt; 0 &amp;&amp; x &amp;gt; 10&lt;/span&gt;) // 조건이 항상 false입니다
  } else {
    println(x&lt;span style="background: yellow"&gt;!!&lt;/span&gt;) // !! operator will always fail
  }
}
fun process(v: Any) {
  when(v) {
    is CharSequence -&amp;gt; println(v &lt;span style="background: yellow"&gt;as&lt;/span&gt; Int) // 형 변환이 항상 실패합니다
    &lt;span style="background: yellow"&gt;is String&lt;/span&gt; -&amp;gt; println(v) // 브랜치에 도달할 수 없습니다
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
    조건에 없는 상숫값을 가진 변수를 보고하지 않으려면 '상수가 변수에 저장되면 경고' 옵션을 선택 취소합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: KotlinConstantConditions&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AmbiguousNonLocalJump" defaultSeverity="WEAK WARNING" displayName="로컬이 아닌 모호한 'break' 또는 'continue'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루프 같은 함수의 람다 내에서 &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt;가 사용된 경우를 보고합니다.
&lt;p&gt;
    &lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;continue&lt;/code&gt; 키워드는 항상 실제 루프(&lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;do-while&lt;/code&gt;)에 적용됩니다. &lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;continue&lt;/code&gt;는 함수에 적용되지 않습니다. 예를 들어, &lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;continue&lt;/code&gt;는 &lt;code&gt;forEach&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;에 적용되지 않습니다.
&lt;/p&gt;
&lt;p&gt;
    루프 같은 함수(예: &lt;code&gt;forEach&lt;/code&gt;) 내에서 &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt;를 사용하면 혼동될 수 있습니다.
    이 검사는 라벨을 추가하여 어떤 구문에 &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt;가 적용되는지 명확히 하도록 제안합니다.
&lt;/p&gt;
&lt;p&gt;
    Kotlin에는 루프 같은 함수의 개념이 없으므로 이 검사는 경험적 지식을 사용합니다. &lt;code&gt;callsInPlace(EXACTLY_ONCE)&lt;/code&gt; 또는 &lt;code&gt;callsInPlace(AT_LEAST_ONCE)&lt;/code&gt; 컨트랙트 중 하나가 없는 함수는 루프 같은 함수라고 가정합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    for (file in files) {
        file.readLines().forEach { line -&gt;
            if (line == commentMarkerLine) continue
            println(line)
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 명확히 구분 짓는 라벨을 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    loop@ for (file in files) {
        file.readLines().forEach { line -&gt;
            if (line == commentMarkerLine) continue@loop
            println(line)
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AmbiguousNonLocalJump&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantLabel" defaultSeverity="WARNING" displayName="불필요한 라벨" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
'break', 'continue' 혹은 'return' 구문에서 참조될 수 없는 불필요한 라벨을 보고합니다. 
&lt;p&gt;
이러한 라벨은 안전하게 제거될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(c: Boolean) {
    b@ while (true) a@ {
        while (true) {
            break@b
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(c: Boolean) {
    b@ while (true) {
        while (true) {
            break@b
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantLabel&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DestructuringWrongName" defaultSeverity="WARNING" displayName="구조 분해 선언의 변수가 잘못된 데이터 클래스 프로퍼티의 이름을 사용" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구조 분해된 데이터 클래스의 다른 프로퍼티 이름과 일치하는 구조 분해 선언의 항목을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Foo(val a: String, val b: Int, val c: String)

  fun bar(f: Foo) {
      val (a, c) = f
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 변수 이름이 해당 클래스 필드의 이름과 일치하도록 변경합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Foo(val a: String, val b: Int, val c: String)

  fun bar(f: Foo) {
      val (a, b) = f
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DestructuringWrongName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaIoSerializableObjectMustHaveReadResolve" defaultSeverity="WARNING" displayName="Serializable 객체는 'readResolve'를 구현해야 함" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
    &lt;code&gt;java.io.Serializable&lt;/code&gt;을 구현하지만 &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/input.html#the-readresolve-method"&gt;readResolve&lt;/a&gt;는 구현하지 않는 &lt;code&gt;object&lt;/code&gt;(&lt;code&gt;data object&lt;/code&gt; 포함)를 보고합니다
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.io.Serializable

  object Foo : Serializable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 &lt;code&gt;readResolve&lt;/code&gt; 메서드를 구현합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.io.Serializable

  object Foo : Serializable {
      private fun readResolve() = Foo
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JavaIoSerializableObjectMustHaveReadResolve&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UselessCallOnNotNull" defaultSeverity="WARNING" displayName="null이 아닌 타입에 대한 불필요한 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
null 가능 리시버에서만 의미가 있는 null이 아닌 리시버에 대한 호출을 보고합니다.
&lt;p&gt;&lt;code&gt;orEmpty()&lt;/code&gt; 또는 &lt;code&gt;isNullOrEmpty&lt;/code&gt; 같은 표준 라이브러리의 여러 함수는 null 가능 타입의 리시버에서 호출했을 때에만 의미가 있습니다. 그렇지 않은 경우 결과가 같으므로 생략하거나 단순화할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;불필요한 호출 제거&lt;/b&gt; 및 &lt;b&gt;호출을 다음으로 변경…&lt;/b&gt; 빠른 수정을 사용해 코드를 자동으로 수정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(s: String) {
      val x = s.orEmpty() // 빠른 수정에서는 's'로 단순화합니다
      val y = s.isNullOrEmpty() // 빠른 수정에서는  's.isEmpty()'로 단순화합니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UselessCallOnNotNull&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IncompleteDestructuring" defaultSeverity="INFORMATION" displayName="불완전한 구조 분해 선언" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불완전한 구조 분해 선언을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Person(val name: String, val age: Int)
  val person = Person("", 0)
  val (name) = person
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 새 변수를 사용해 구조 분해 선언을 완성합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Person(val name: String, val age: Int)
  val person = Person("", 0)
  val (name, age) = person
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IncompleteDestructuring&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RecursivePropertyAccessor" defaultSeverity="WARNING" displayName="재귀적 프로퍼티 접근자" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
    &lt;code&gt;StackOverflowError&lt;/code&gt;를 발생시킬 수 있는 재귀 프로퍼티 접근자 호출을 보고합니다.
    그러한 호출은 보통 백킹 필드 액세스와 혼동됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var counter: Int = 0
      set(value) {
          &lt;b&gt;counter&lt;/b&gt; = if (value &amp;lt; 0) 0 else value
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var counter: Int = 0
      set(value) {
          &lt;b&gt;field&lt;/b&gt; = if (value &amp;lt; 0) 0 else value
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RecursivePropertyAccessor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConvertNaNEquality" defaultSeverity="WARNING" displayName="'NaN'을 통한 상등 검사를 'isNaN' 호출로 변환" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;isNaN()&lt;/code&gt; 검사로 바꿔야 하는 &lt;code&gt;Float.NaN&lt;/code&gt; 또는 &lt;code&gt;Double.NaN&lt;/code&gt; 상등 검사를 보고합니다.
&lt;p&gt;
    IEEE 754에 따르면 NaN에 대한 상등 검사는 &lt;code&gt;NaN == NaN&lt;/code&gt;일지라도 항상 &lt;code&gt;false&lt;/code&gt;를 반환합니다.
    따라서 그러한 검사는 실수일 가능성이 높습니다.
&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 다른 비교 기술을 사용하고 &lt;code&gt;NaN&lt;/code&gt; 값을 올바로 처리하는 &lt;code&gt;isNaN()&lt;/code&gt; 검사로 비교를 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(value: Double): Boolean {
      return Double.NaN == value
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(value: Double): Boolean {
      return value.isNaN()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConvertNaNEquality&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SelfAssignment" defaultSeverity="WARNING" displayName="불필요한 대입" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
자신에게 대입된 변수를 보고합니다.
&lt;p&gt;빠른 수정에서는 불필요한 대입을 제거합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      var bar = 1
      bar = bar
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      var bar = 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SelfAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedUnaryOperator" defaultSeverity="WARNING" displayName="사용되지 않는 단항 연산자" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
사용되지 않는 표현식에 있는 숫자 타입에 대한 단항 연산자를 보고합니다.
&lt;p&gt;단항 연산자를 괄호 없이 사용하면 이전 표현식을 망가뜨립니다.
결과적으로 여러 줄로 구성된 수학적 표현식에서 오해의 소지가 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val result = 1 + 2 * 3
                  + 3              // &amp;lt;== '+ 3'이 'result' 변수에 속하지 않으며 사용되지 않습니다
      println("Result = $result")  // 결과는 기대 값인 '10'이 아니라 '7'입니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnusedUnaryOperator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayInDataClass" defaultSeverity="WARNING" displayName="데이터 클래스 내 배열 프로퍼티" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;equals()&lt;/code&gt; 또는 &lt;code&gt;hashCode()&lt;/code&gt;가 재정의되지 않은 &lt;code&gt;data&lt;/code&gt; 클래스의 &lt;code&gt;Array&lt;/code&gt; 타입이 있는 프로퍼티를 보고합니다.
&lt;p&gt;
    배열 매개변수가 참조 상등과 비교되며 이는 예상하지 못한 동작일 수 있습니다.
    그러한 경우 &lt;code&gt;equals()&lt;/code&gt; 및 &lt;code&gt;hashCode()&lt;/code&gt;를 재정의하는 것이 좋습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Text(val lines: Array&amp;lt;String&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 누락된 &lt;code&gt;equals()&lt;/code&gt; 및 &lt;code&gt;hashCode()&lt;/code&gt; 구현을 생성합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Text(val lines: Array&amp;lt;String&amp;gt;) {
      override fun equals(other: Any?): Boolean {
          if (this === other) return true
          if (javaClass != other?.javaClass) return false

          other as Text

          if (!lines.contentEquals(other.lines)) return false

          return true
      }

      override fun hashCode(): Int {
          return lines.contentHashCode()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ArrayInDataClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UselessCallOnCollection" defaultSeverity="WARNING" displayName="컬렉션 타입에 대한 불필요한 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이미 필터링된 컬렉션의 표준 라이브러리에서 &lt;code&gt;filter…&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;&lt;code&gt;filterNotNull()&lt;/code&gt; 또는 &lt;code&gt;filterIsInstance&lt;/code&gt; 같은 표준 라이브러리의 여러 함수는 결과 타입과는 다른 타입을 가지는 리시버에서 호출했을 때에만 의미가 있습니다. 그렇지 않은 경우 그러한 호출은 결과가 같으므로 생략할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;불필요한 호출 제거&lt;/b&gt; 빠른 수정을 사용해 코드를 자동으로 수정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;String&amp;gt;) {
      val x = list.filterNotNull() // 빠른 수정에서는 'list'로 단순화합니다
      val y = list.filterIsInstance&amp;lt;String&amp;gt;() // 빠른 수정에서는 'list'로 단순화합니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UselessCallOnCollection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ForEachParameterNotUsed" defaultSeverity="WEAK WARNING" displayName="반복 요소가 forEach에서 사용되지 않음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
iterable 값을 사용하지 않는 &lt;code&gt;forEach&lt;/code&gt; 루프를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  listOf(1, 2, 3).forEach { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;forEach&lt;/code&gt; 섹션에 익명 매개변수를 삽입합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  listOf(1, 2, 3).forEach { _ -&gt; }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ForEachParameterNotUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DelegationToVarProperty" defaultSeverity="WARNING" displayName="'var' 프로퍼티로 위임" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;var&lt;/code&gt; 프로퍼티에 대한 인터페이스 위임을 보고합니다.
&lt;p&gt;위임에는 프로퍼티의 초기 값만 사용하며 이후의 대입은 위임에 영향을 주지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example(var text: CharSequence): CharSequence by text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 프로퍼티를 불변 프로퍼티로 바꿉니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example(val text: CharSequence): CharSequence by text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;어떤 이유로든 가변성이 필요한 경우 다음과 같은 방법도 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example(text: CharSequence): CharSequence by text {
      var text = text
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: DelegationToVarProperty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinUnreachableCode" defaultSeverity="WARNING" displayName="도달할 수 없는 코드" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;

실행 시 도달할 수 없는 코드 구문을 보고합니다.
&lt;p&gt;
    빠른 검사에서는 도달할 수 없는 코드를 제거합니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun value(): Int {
      return 42
      print("Hello, world !")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun value(): Int {
      return 42
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: KotlinUnreachableCode&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SelfReferenceConstructorParameter" defaultSeverity="WARNING" displayName="생성자는 완료할 수 없음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
null이 아니며 자신을 참조하는 매개변수를 포함하는 생성자를 보고합니다.
&lt;p&gt;그러한 생성자는 클래스로 인스턴스화될 수 없습니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 매개변수 타입을 null 가능으로 변환합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SelfRef(val ref: SelfRef)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SelfRef(val ref: SelfRef?)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SelfReferenceConstructorParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedFlow" defaultSeverity="WARNING" displayName="사용되지 않는 흐름" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;생성되었지만 소비되거나 나른 함수로 전달되지 않는 Kotlinx Coroutine Flow를 보고합니다.&lt;/p&gt;
&lt;p&gt;터미널 연산자를 사용하여 Flow가 수집되지 않는다면 Flow를 정의하는 코드가 실행되지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo() {
    flowOf(1).onEach { println(it) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;터미널 연산자의 &lt;a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/"&gt;일부 예시&lt;/a&gt;를 참조하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnusedFlow&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KDocUnresolvedReference" defaultSeverity="WARNING" displayName="KDoc 내 해결되지 않은 참조" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
KDoc 주석 내에서 해결되지 않은 참조를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * [unresolvedLink]
   */
  fun foo() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;문제를 해결하려면 링크를 올바르게 설정합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KDocUnresolvedReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousCollectionReassignment" defaultSeverity="WEAK WARNING" displayName="증강 대입이 내부에 새 컬렉션을 생성" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
읽기 전용 &lt;code&gt;Collection&lt;/code&gt;에 있는 증분 대입(&lt;code&gt;+=&lt;/code&gt;) 표현식을 보고합니다.
&lt;p&gt;읽기 전용 &lt;&lt;code&gt;Collection&lt;/code&gt;의 증분 대입(&lt;code&gt;+=&lt;/code&gt;) 표현식은 새 컬렉션을 임시로 할당하므로 성능이 저하될 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;타입을 가변으로 변경&lt;/b&gt; 빠른 수정을 사용해 코드를 자동으로 수정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      var list = listOf(0)
      list += 42 // 여기에 새 목록이 할당되어 있습니다. list = list + 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      val list = mutableListOf(0)
      list += 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousCollectionReassignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="클래스 구조" path="Java"><inspection shortName="FinalStaticMethod" defaultSeverity="WARNING" displayName="'static' 메서드를 'final'로 선언" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;final&lt;/code&gt;로 표시된 정적 메서드를 보고합니다.
&lt;p&gt;이러한 코드는 &lt;code&gt;final&lt;/code&gt; 키워드의 효과에 대한 오류 또는 잘못된 가정을 나타낼 수 있습니다.
정적 메서드는 런타임 다형성에 영향을 받지 않으므로 정적 메서드에 사용된 &lt;code&gt;final&lt;/code&gt; 키워드의 목적은 오로지 하위 클래스에서 해당 메서드가 숨겨지지 않도록 하는 것입니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: FinalStaticMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantDeclaredInInterface" defaultSeverity="WARNING" displayName="인터페이스에서 선언된 상수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인터페이스에 선언된 상수(&lt;code&gt;public static final&lt;/code&gt; 필드)를 보고합니다.
&lt;p&gt;일부 코딩 표준에 따르면 추상 클래스에서 상수를 선언해야 할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConstantDeclaredInInterface&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodReturnAlwaysConstant" defaultSeverity="WARNING" displayName="메서드가 클래스별 상수를 반환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
다양한 상속자와 다를 수 있는 상수만을 반환하는 메서드를 보고합니다.
&lt;p&gt;&lt;b&gt;코드 | 코드 검사&lt;/b&gt; 또는
  &lt;b&gt;코드 | 코드 분석 | 이름별로 검사 실행&lt;/b&gt;에서만 사용 가능하며 에디터에서 보고되지 않습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MethodReturnAlwaysConstant&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NoopMethodInAbstractClass" defaultSeverity="WARNING" displayName="추상 클래스에 NOP 메서드 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;abstract&lt;/code&gt; 클래스의 no-op(무연산) 메서드를 보고합니다.
&lt;p&gt;일반적으로 해당 메서드를 상속하는 클래스에서 구현을 제공하도록 메서드 자체를 &lt;code&gt;abstract&lt;/code&gt;로 선언하는 것이 더 좋은 설계입니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Test {
    protected void doTest() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NoopMethodInAbstractClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UtilityClass" defaultSeverity="WARNING" displayName="유틸리티 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
유틸리티 클래스를 보고합니다.
&lt;p&gt;유틸리티 클래스에서 모든 필드와 메서드가 &lt;code&gt;static&lt;/code&gt;으로 선언되어 있으며, 유틸리티 클래스의 존재는 객체 지향 설계가 잘 지켜지지 않는다는 의미일 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
특수 어노테이션을 지정하려면 &lt;b&gt;다음으로 어노테이션이 추가된 경우 무시&lt;/b&gt; 옵션을 사용합니다. 이 검사는 해당 어노테이션 중 하나가 추가된 클래스를 무시합니다.&lt;/p&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UtilityClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ListenerMayUseAdapter" defaultSeverity="WARNING" displayName="클래스가 리스너를 구현하지 않고 어댑터를 확장할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해당 어댑터를 확장하는 대신 리스너를 구현하는 클래스를 보고합니다.
&lt;p&gt;빠른 수정을 사용하여 리스너 구현을 어댑터 확장으로 대체한 후 남겨진 불필요한 빈 메서드를 제거할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  빈 메서드가 발견되지 않은 경우에도 경고하도록 검사를 구성하려면 &lt;b&gt;빈 구현 메서드가 발견될 경우에만 경고&lt;/b&gt; 옵션을 사용합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ListenerMayUseAdapter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalUtilityClass" defaultSeverity="WARNING" displayName="유틸리티 클래스가 'final'이 아님" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;final&lt;/code&gt; 또는 &lt;code&gt;abstract&lt;/code&gt;가 아닌 유틸리티 클래스를 보고합니다.
&lt;p&gt;유틸리티 클래스에는 모든 필드 및 메서드가 &lt;code&gt;static&lt;/code&gt;으로 선언되어 있습니다.
유틸리티 클래스를 &lt;code&gt;final&lt;/code&gt;로 설정하면 해당 클래스가 실수로 하위 클래스가 되지 않도록 방지할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class UtilityClass {
    public static void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public final class UtilityClass {
    public static void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonFinalUtilityClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UtilityClassCanBeEnum" defaultSeverity="WARNING" displayName="유틸리티 클래스가 'enum'이 될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
열거형으로 변환할 수 있는 유틸리티 클래스를 보고합니다.
&lt;p&gt;일부 코딩 스타일 가이드라인에서는 &lt;code&gt;private&lt;/code&gt; 생성자에서 코드 커버리지 문제를 피하기 위해 유틸리티 클래스를 열거형으로 구현하도록 요구합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class StringUtils {
    public static final String EMPTY = "";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum StringUtils {
    ;
    public static final String EMPTY = "";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;열거형&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UtilityClassCanBeEnum&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinalPrivateMethod" defaultSeverity="WARNING" displayName="'private' 메서드를 'final'로 선언" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;final&lt;/code&gt; 및 &lt;code&gt;private&lt;/code&gt; 키워드 모두가 표시된 메서드를 보고합니다.
&lt;p&gt;&lt;code&gt;private&lt;/code&gt; 메서드는 메서드의 가시성때문에 의미있게 재정의될 수 없기때문에, 이를 &lt;code&gt;final&lt;/code&gt;로 선언하는 것은 불필요합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FinalPrivateMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantDeclaredInAbstractClass" defaultSeverity="WARNING" displayName="상수를 'abstract' 클래스로 선언" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
추상 클래스에 선언된 상수(&lt;code&gt;public static final&lt;/code&gt; 필드)를 보고합니다.
&lt;p&gt;일부 코딩 표준에 따르면 인터페이스에서 상수를 선언해야 할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConstantDeclaredInAbstractClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleTopLevelClassesInFile" defaultSeverity="WARNING" displayName="단일 파일 내 여러 최상위 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단일 Java 파일에서 여러 개의 최상위 클래스를 보고합니다.
&lt;p&gt;파일 1개에 최상위 클래스가 여러 개일 경우 혼동될 수 있으며 다양한 소프트웨어 도구의 유용성이 저하됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MultipleTopLevelClassesInFile&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterCanBeLocal" defaultSeverity="WARNING" displayName="매개변수로 전달된 값이 한 번도 읽히지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지역 변수로 바꿀 수 있는 불필요한 메서드 매개변수를 보고합니다.
&lt;p&gt;매개변수의 모든 지역 사용 위치가 해당 매개변수의 대입 앞에 오는 경우, 이 매개변수는 제거될 수 있으며 지역 변수로 바꿀 수 있습니다.
이러한 매개변수로 전달되는 값은 덮어쓰여지기 때문에 이러한 매겨변수를 갖는 것은 의미가 없습니다.
  일반적으로 이 문제는 리팩터링으로 인해 나타납니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(int p) {
    p = 1;
    System.out.print(p);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test() {
    int p = 1;
    System.out.print(p);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ParameterCanBeLocal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ClassNameDiffersFromFileName" defaultSeverity="WARNING" displayName="클래스 이름이 파일 이름과 다름" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
포함하는 파일의 이름과 일치하지 않는 최상위 클래스 이름을 보고합니다.
&lt;p&gt;Java 사양에서는 해당 방식으로 &lt;code&gt;public&lt;/code&gt; 클래스의 이름을 지정할 수 있지만, 이름이 일치하지 않는 파일은 혼란을 유발할 수 있으며 이로 인해 다양한 소프트웨어 도구의 유용성이 감소할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassNameDiffersFromFileName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassInitializer" defaultSeverity="WARNING" displayName="비 'static' 이니셜라이저" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스의 &lt;code&gt;static&lt;/code&gt;이 아닌 이니셜라이저를 보고합니다.
&lt;p&gt;일부 코딩 표준에서는 인스턴스 이니셜라이저의 사용을 금지하며, 초기화 시 생성자 또는 필드 이니셜라이저를 사용하도록 권장합니다.
  또한 &lt;code&gt;static&lt;/code&gt; 키워드를 삭제할 경우 예기치 않게 &lt;code&gt;static&lt;/code&gt;이 아닌 이니셜라이저가 생성되거나 알 수 없는 버그가 발생할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;이 검사는 익명 클래스의 인스턴스 이니셜라이저를 보고하지 않습니다.
  &lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;클래스에 하나 이상의 생성자가 있는 경우에만 경고&lt;/b&gt; 옵션을 사용하여 생성자가 없는 클래스의 인스턴스 이니셜라이저를 무시합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassInitializer&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassMayBeInterface" defaultSeverity="INFORMATION" displayName="추상 'class'가 'interface'가 될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
인터페이스로 변환할 수 있는 &lt;code&gt;abstract&lt;/code&gt; 클래스를 보고합니다.
&lt;p&gt;Java는 다중 클래스 상속을 지원하지 않지만, 클래스는 다중 인터페이스를 구현할 수 있으므로 클래스 대신 인터페이스를 사용하는 것이 좋습니다.&lt;/p&gt;
&lt;p&gt;클래스는 (Object 이외의) 상위 클래스가 없거나, &lt;code&gt;public static final&lt;/code&gt; 필드, &lt;code&gt;public abstract&lt;/code&gt; 메서드 및 &lt;code&gt;public&lt;/code&gt; 내부 클래스만 가지는 경우 인터페이스로 변환될 수 있습니다.
&lt;!-- tooltip end --&gt;

&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
abstract class Example {
    public static final int MY_CONST = 42;
    public abstract void foo();
}

class Inheritor extends Example {
    @Override
    public void foo() {
        System.out.println(MY_CONST);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
interface Example {
    int MY_CONST = 42;
    void foo();
}

class Inheritor implements Example {
    @Override
    public void foo() {
        System.out.println(MY_CONST);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;default&lt;/code&gt; 메서드로 변환될 수 있는 &lt;code&gt;static&lt;/code&gt; 메서드 및 추상이 아닌 메서드를 포함하는 클래스만 보고하려면
&lt;b&gt;Java 8을 사용할 때 추상이 아닌 메서드가 포함된 클래스 보고&lt;/b&gt; 옵션을 사용하세요 (언어 수준 8 이상에서만 적용 가능).
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ClassMayBeInterface&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousInnerClass" defaultSeverity="INFORMATION" displayName="익명 클래스는 내부 클래스로 대체될 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
익명의 클래스를 보고합니다.
&lt;p&gt;익명 클래스를 내부 클래스로 바꾸면 코드의 가독성이 향상되고 유지 관리가 더욱 간편해지는 경우가 있습니다.
  또한 일부 코드 표준에서는 익명 클래스의 사용을 권장하지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example {
    public static void main(String[] args) {
      new Thread() {
        public void run() {
          work()
        }

        private void work() {}
      }.start();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example {
    public static void main(String[] args) {
      new MyThread().start();
    }

    private static class MyThread extends Thread {
      public void run() {
        work();
      }

      private void work() {}
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AnonymousInnerClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InterfaceMayBeAnnotatedFunctional" defaultSeverity="WARNING" displayName="인터페이스에 @FunctionalInterface'로 어노테이션 추가 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@FunctionalInterface&lt;/code&gt; 어노테이션을 추가할 수 있는 인터페이스를 보고합니다.
&lt;p&gt;인터페이스에 &lt;code&gt;@FunctionalInterface&lt;/code&gt; 어노테이션을 추가하는 것은 인터페이스가 함수형이며 더 이상 &lt;code&gt;abstract&lt;/code&gt; 메서드를 추가할 수 없음을 의미합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface FileProcessor {
    void execute(File file);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @FunctionalInterface
  interface FileProcessor {
    void execute(File file);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;이 검사는 Java 8부터 사용할 수 있는 Java 기능 &amp;#39;람다 식&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: InterfaceMayBeAnnotatedFunctional&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithOnlyPrivateConstructors" defaultSeverity="WARNING" displayName="'private' 생성자만 있는 클래스는 'final'로 선언되어야 함" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;private&lt;/code&gt; 생성자만 있는 클래스를 보고합니다.
&lt;p&gt;&lt;code&gt;private&lt;/code&gt; 생성자만 있는 클래스는 파일 외부로 확장될 수 없으며 &lt;code&gt;final&lt;/code&gt;로 선언되어야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassWithOnlyPrivateConstructors&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinalMethod" defaultSeverity="WARNING" displayName="메서드가 재정의될 수 없습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;final&lt;/code&gt;로 선언된 메서드를 보고합니다.
이러한 메서드는 재정의 불가능하며, 객체 지향 설계가 제대로 되지 않았음을 의미할 수 있습니다.
  일부 코딩 표준에서는 &lt;code&gt;final&lt;/code&gt; 메서드를 권장하지 않습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FinalMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticNonFinalField" defaultSeverity="WARNING" displayName="'static' 및 비 'final' 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;final&lt;/code&gt;이 아닌 &lt;code&gt;static&lt;/code&gt; 필드를 보고합니다.
&lt;p&gt;빠른 수정을 통해 &lt;code&gt;final&lt;/code&gt;이 아닌 &lt;code&gt;static&lt;/code&gt; 필드에 &lt;code&gt;final&lt;/code&gt; 제어자를 추가할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이 검사는 필드의 가변성을 검사하지 않습니다. 예를 들어, &lt;code&gt;final&lt;/code&gt; 제어자를 대략적인 값이 설정된 필드에 추가할 경우 컴파일 오류가 발생합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;'public' 필드만 보고&lt;/b&gt; 옵션을 사용하면 검사는 &lt;code&gt;public&lt;/code&gt; 필드만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: StaticNonFinalField&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalFieldInEnum" defaultSeverity="WARNING" displayName="'enum' 내 final이 아닌 필드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
열거형 타입에서 final이 아닌 필드를 보고합니다.
final이 아닌 필드는 일반적으로 권장되지 않는 전역 가변 상태를 도입합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum Enum {
    FIRST("first"),
    SECOND("second");

    public String str;

    Enum(String str) {
        this.str = str;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum Enum {
    FIRST("first"),
    SECOND("second");

    public final String str;

    Enum(String str) {
        this.str = str;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
''final'로 만들 수 없는 필드 무시' 옵션을 사용하면 빠른 수정을 사용하여 final로 만들 수 있는 필드만 경고합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: NonFinalFieldInEnum&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinalClass" defaultSeverity="WARNING" displayName="클래스는 상속할 수 없습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;final&lt;/code&gt;로 선언된 클래스를 보고합니다.
&lt;code&gt;sealed&lt;/code&gt; 클래스 또는 인터페이스를 확장하는 final 클래스는 보고되지 않습니다.
이러한 클래스는 상속 불가능하며, 객체 지향 설계가 제대로 되지 않았음을 의미할 수 있습니다.
일부 코딩 표준에서는 &lt;code&gt;final&lt;/code&gt; 클래스를 권장하지 않습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public final class&lt;/b&gt; Main {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Main {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FinalClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MarkerInterface" defaultSeverity="WARNING" displayName="마커 인터페이스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 또는 필드가 없는 마커 인터페이스를 보고합니다.
&lt;p&gt;이러한 인터페이스는 혼동될 수 있으며 일반적으로 설계 실패를 의미합니다.&lt;/p&gt;
&lt;p&gt;이 검사는 두 개 이상의 인터페이스를 확장하는 인터페이스 또는 상위 인터페이스의 제네릭 타입을 지정하는 인터페이스를 무시합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MarkerInterface&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UtilityClassWithPublicConstructor" defaultSeverity="WARNING" displayName="'public' 생성자가 있는 유틸리티 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;public&lt;/code&gt; 생성자가 있는 유틸리티 클래스를 보고합니다.
&lt;p&gt;유틸리티 클래스에는 모든 필드 및 메서드가 &lt;code&gt;static&lt;/code&gt;으로 선언되어 있습니다. 해당 클래스에서 &lt;code&gt;public&lt;/code&gt; 생성자를 생성하면 혼동될 수 있으며 예기치 않은 클래스 인스턴스화가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public final class UtilityClass {
    public UtilityClass(){
    }
    public static void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public final class UtilityClass {
    private UtilityClass(){
    }
    public static void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UtilityClassWithPublicConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyClass" defaultSeverity="WARNING" displayName="빈 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
빈 클래스와 빈 Java 파일을 보고합니다.
&lt;p&gt;클래스에 필드, 메서드, 생성자 또는 이니셜라이저가 포함되지 않은 경우 빈 클래스입니다. 주요 변경 사항 또는 리팩터링 이후 빈 클래스가 남는 경우가 종종 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example {
    List&amp;lt;String&amp;gt; getList() {
       return new ArrayList&amp;lt;&amp;gt;() {

       };
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example {
    List&amp;lt;String&amp;gt; getList() {
       return new ArrayList&amp;lt;&amp;gt;();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    특수 어노테이션을 지정하려면 &lt;b&gt;다음으로 어노테이션이 추가된 경우 무시&lt;/b&gt; 옵션을 사용합니다. 이 검사는 해당 주석으로 표시된 클래스를 무시합니다.
  &lt;/li&gt;
  &lt;li&gt;&lt;p&gt;
    &lt;b&gt;클래스가 상위 타입의 매개변수화인 경우 무시&lt;/b&gt; 옵션을 사용하여 상위 클래스를 매개변수화하는 클래스를 무시합니다. 예:
  &lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;class MyList extends ArrayList&amp;lt;String&amp;gt; {}&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;b&gt;java.lang.Throwable의 하위 클래스 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;java.lang.Throwable&lt;/code&gt;을 확장하는 클래스를 무시합니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;b&gt;주석을 내용으로 간주&lt;/b&gt; 옵션을 사용하여 주석이 포함된 클래스를 무시합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: EmptyClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InnerClassOnInterface" defaultSeverity="WARNING" displayName="인터페이스의 내부 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;interface&lt;/code&gt; 클래스의 내부 클래스를 보고합니다.
&lt;p&gt;일부 코딩 표준은 해당 클래스 사용을 권장하지 않습니다. 이 검사는 열거형 클래스 및 어노테이션 인터페이스를 보고하지 않습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;b&gt;인터페이스의 내부 인터페이스 무시&lt;/b&gt; 옵션을 사용하여 내부 인터페이스를 무시합니다. 예:
&lt;pre&gt;&lt;code&gt;
  interface I {
    interface Inner {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InnerClassOnInterface&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Singleton" defaultSeverity="WARNING" displayName="싱글턴" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
싱글턴 클래스를 보고합니다.
&lt;p&gt;싱글턴 클래스는 클래스의 인스턴스 한 개만 인스턴스화할 수 있는 방식으로 선언됩니다. 싱글턴 클래스는 테스트를 복잡하게 만들 수 있으며 싱글턴 클래스가 있다는 것은 객체 지향 설계가 잘 지켜지지 않는다는 의미일 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Singleton {
    private static final Singleton ourInstance = new Singleton();

    private Singleton() {
    }

    public Singleton getInstance() {
        return ourInstance;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: Singleton&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LimitedScopeInnerClass" defaultSeverity="INFORMATION" displayName="지역 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지역 클래스를 보고합니다.
&lt;p&gt;지역 클래스는 코드 블록 내에 선언되었으며 이름이 지정된 중첩 클래스입니다.
지역 클래스는 일반적이지 않으므로 혼동될 수 있습니다.
  또한 일부 코드 표준은 지역 클래스 사용을 권장하지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example {
    void test() {
      class Local { // 여기
      }
      new Local();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example {
    void test() {
      new Local();
    }

    private static class Local { // 여기
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LimitedScopeInnerClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldCanBeLocal" defaultSeverity="WARNING" displayName="필드를 지역 변수로 변환 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
지역 변수로 바꿀 수 있는 불필요한 클래스 필드를 보고합니다.
&lt;p&gt;필드의 모든 지역 사용 위치가 해당 필드의 할당 앞에 오는 경우, 이 필드는 제거될 수 있으며 지역 변수로 바꿀 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FieldCanBeLocal&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UtilityClassWithoutPrivateConstructor" defaultSeverity="WARNING" displayName="'private' 생성자가 없는 유틸리티 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;private&lt;/code&gt; 생성자가 없는 유틸리티 클래스를 보고합니다.
&lt;p&gt;유틸리티 클래스에는 모든 필드 및 메서드가 &lt;code&gt;static&lt;/code&gt;으로 선언되어 있습니다. 유틸리티 클래스에서 &lt;code&gt;private&lt;/code&gt; 생성자를 생성하면 예기치 않은 인스턴스화를 방지할 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  특수 어노테이션을 지정하려면 &lt;b&gt;다음으로 어노테이션이 추가된 경우 무시&lt;/b&gt; 옵션을 사용합니다. 이 검사는 해당 어노테이션 중 하나로 표시된 클래스를 무시합니다.
&lt;p&gt;
&lt;b&gt;메인 메서드만 있는 클래스 무시&lt;/b&gt; 옵션을 사용하여 메인을 제외한 메서드가 없는 클래스를 무시합니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UtilityClassWithoutPrivateConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicConstructor" defaultSeverity="WARNING" displayName="'public' 생성자를 factory 메서드로 바꿀 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;public&lt;/code&gt; 생성자를 보고합니다.
&lt;p&gt;일부 코딩 표준에서는 &lt;code&gt;public&lt;/code&gt; 생성자의 사용을 지양하고 &lt;code&gt;static&lt;/code&gt; factory 메서드를 사용하도록 권장합니다.
이 방식을 사용하면 호출 사이트에 영향을 미치지 않고도 구현을 교체할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    private String name;

    public Test(String name) {
        this.name = name;
    }

    public void test() {
        System.out.println(name);
    }

    public static void main(String[] args) {
        new Test("str").test();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    private String name;

    private Test(String name) {
        this.name = name;
    }

    public static Test getInstance(String name) {
        return new Test(name);
    }

    public void test() {
        System.out.println(name);
    }

    public static void main(String[] args) {
        getInstance("str").test();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PublicConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="숫자 문제" path="Java"><inspection shortName="CharUsedInArithmeticContext" defaultSeverity="WARNING" displayName="산술 컨텍스트에서 'char' 표현식 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
더하기 또는 빼기 표현식에 사용된 &lt;code&gt;char&lt;/code&gt; 타입의 표현식을 보고합니다.
&lt;p&gt;이러한 코드가 반드시 문제인 것은 아니지만 버그가 발생할 수 있습니다(예: 문자열이 필요한 경우).&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt; &lt;code&gt;int a = 'a' + 42;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;빠른 수정 적용 후: &lt;code&gt;int a = (int) 'a' + 42;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;String&lt;/code&gt; 컨텍스트의 경우:
&lt;pre&gt;&lt;code&gt;int i1 = 1;
int i2 = 2;
System.out.println(i2 + '-' + i1 + &amp;quot; = &amp;quot; + (i2 - i1));&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;code&gt;System.out.println(i2 + &amp;quot;-&amp;quot; + i1 + &amp;quot; = &amp;quot; + (i2 - i1));&lt;/code&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CharUsedInArithmeticContext&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConfusingFloatingPointLiteral" defaultSeverity="WARNING" displayName="혼동되는 부동소수점 리터럴" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
소수점이 없거나 소수점 앞 또는 뒤에 숫자가 없는 부동소수점 수를 보고합니다.
&lt;p&gt;그러한 리터럴은 혼란을 일으킬 수 있으며 몇 가지 코딩 표준을 위반합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double d = .03;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double d = 0.03;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;b&gt;과학적 표기에서 부동소수점 리터럴 무시&lt;/b&gt; 옵션을 사용하여 과학적 표기에서 부동 소수점 수를 무시합니다.&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ConfusingFloatingPointLiteral&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessArithmeticExpression" defaultSeverity="WARNING" displayName="무의미한 산술 표현식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
무의미한 산술 표현식을 보고합니다. 그러한 표현식에는 0 더하기 또는 빼기, 0 또는 1로 곱하기, 1로 나누기가 포함됩니다.
&lt;p&gt;그러한 표현식은 자동화된 리팩터링의 결과일 수 있으며 개발자가 의도한 결과가 아닐 가능성이 높습니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 그러한 표현식을 단순화합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int a) {
    int x = a - a;
    int y = a + 0;
    int res = x / x;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int a) {
    int x = 0;
    int y = a;
    int res = 1;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  드문 경우, 모든 가능한 입력에 대해 제안된 교체는 원래 코드와 완전히 동등하지 않을 수 있습니다. 예를 들어, 검사는 &lt;code&gt;x / x&lt;/code&gt;를 &lt;code&gt;1&lt;/code&gt;로 바꿀 것을 제안합니다.
  하지만 &lt;code&gt;x&lt;/code&gt;가 0인 경우 원래 코드는 &lt;code&gt;ArithmeticException&lt;/code&gt;을 던지거나 &lt;code&gt;NaN&lt;/code&gt;을 발생시킵니다.
  또한 &lt;code&gt;x&lt;/code&gt;가 &lt;code&gt;NaN&lt;/code&gt;인 경우 결과 또한 &lt;code&gt;NaN&lt;/code&gt;입니다. 그러한 동작이 의도되었을 가능성은 매우 낮습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PointlessArithmeticExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LongLiteralsEndingWithLowercaseL" defaultSeverity="WARNING" displayName="'L' 대신 'l'로 끝나는 'long' 리터럴" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
소문자 'l'로 끝나는 &lt;code&gt;long&lt;/code&gt; 리터럴을 보고합니다. 소문자
'l'이 리터럴 '1'(숫자)과 매우 유사하므로 해당 리터럴은 혼동될 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  long nights = 100l;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  long nights = 100L;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LongLiteralsEndingWithLowercaseL&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantMathCall" defaultSeverity="WARNING" displayName="지속적 'Math' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
간단한 컴파일 타임 상수로 대체될 수 있는 &lt;code&gt;java.lang.Math&lt;/code&gt; 또는 &lt;code&gt;java.lang.StrictMath&lt;/code&gt; 메서드 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double v = Math.sin(0.0);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double v = 0.0;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConstantMathCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="BadOddness" defaultSeverity="WARNING" displayName="의심스러운 홀수 검사" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;x % 2 == 1&lt;/code&gt; 형식의 홀수/짝수 검사를 보고합니다. 
이러한 검사는 홀수인 음수 값에 사용하는 경우 실패합니다.
대신 &lt;code&gt;x % 2 != 0&lt;/code&gt; 또는 &lt;code&gt;(x &amp; 1) == 1&lt;/code&gt;을 사용해 보세요.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BadOddness&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonReproducibleMathCall" defaultSeverity="WARNING" displayName="재현 불가능한 'Math' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
결과의 정확한 재현을 보장할 수 없는 &lt;code&gt;java.lang.Math&lt;/code&gt; 메서드 호출을 보고합니다.
&lt;p&gt;결과의 재현성이 필요한 환경에서는 &lt;code&gt;java.lang.StrictMath&lt;/code&gt;를 대신 사용해야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonReproducibleMathCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnaryPlus" defaultSeverity="WARNING" displayName="단항 덧셈" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;+&lt;/code&gt; 단항 연산자 사용을 보고합니다. 단항 더하기는 일반적으로 무효 연산이며, 존재하는 경우 코드 오류를 나타냅니다. 예를 들면 증가 연산자(&lt;code&gt;+++&lt;/code&gt; 등) 또는 등호 연산자(&lt;code&gt;=+&lt;/code&gt; 등)의 조합이 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void unaryPlus(int i) {
    int x = + +i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음과 같은 빠른 수정이 제안됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;&lt;code&gt;i&lt;/code&gt; 변수 앞의 &lt;code&gt;+&lt;/code&gt; 연산자를 제거합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void unaryPlus(int i) {
    int x = i;
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 연산자를 접두사 증가 연산자와 치환합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void unaryPlus(int i) {
    int x = ++i;
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
아래의 체크박스를 사용하여 이항 또는 다른 단항 표현식과 함께 사용하는 단항 더하기를 보고합니다.
즉, 이 검사에서는 단항 더하기 표현식이 배열 이니셜라이저 표현식 또는 메서드 인수로 사용된 경우를 보고하지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnaryPlus&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BigDecimalEquals" defaultSeverity="WARNING" displayName="'BigDecimal'에서 'equals()' 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
두 개의 &lt;code&gt;java.math.BigDecimal&lt;/code&gt; 숫자를 비교하는 &lt;code&gt;equals()&lt;/code&gt; 호출을 보고합니다.
두 개의 &lt;code&gt;java.math.BigDecimal&lt;/code&gt; 숫자는 값과 크기가 모두 동일한 경우에만 같기 때문에 이는 보통 실수입니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (new BigDecimal("2.0").equals(
    new BigDecimal("2.00"))) {} // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (new BigDecimal("2.0").compareTo(
    new BigDecimal("2.00")) == 0) {} // true
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BigDecimalEquals&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IntegerDivisionInFloatingPointContext" defaultSeverity="WARNING" displayName="부동소수점 컨텍스트에서 정수 나누기" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
결과가 부동 소수점 숫자로 사용되는 정수 나눗셈을 보고합니다.
해당 나눗셈은 보통 오류이며, 정수 나눗셈 시 발생한 끝수 버림으로 인해 예기치 않은 결과가 나올 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  float x = 3.0F + 3 * 2 / 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  float x = 3.0F + ((float) (3 * 2)) /5;
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IntegerDivisionInFloatingPointContext&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyComplexArithmeticExpression" defaultSeverity="WARNING" displayName="지나치게 복잡한 산술 표현식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
항의 개수가 많은 연산 표현식을 보고합니다. 그러한 표현식은 이해하기 어려울 수 있으며 오류를 포함할 수 있습니다.
&lt;p&gt;매개변수, 변수 참조 및 기타 주요 표현식은 항으로 계산합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;
  &lt;pre&gt;&lt;code&gt;int calc(int a, int b) {
        return a + a + a + b + b + b + b; // 이 줄은 7개 항을 포함하므로 보고됩니다.
    }&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;아래 필드를 사용해 산술 표현식에 허용된 최대 항 개수를 지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: OverlyComplexArithmeticExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OctalAndDecimalIntegersMixed" defaultSeverity="WARNING" displayName="동일한 배열의 8진 및 10진 정수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단일한 배열 이니셜라이저에서 조합된 8진수 및 10진수 리터럴을 보고합니다.
이러한 상황은 숫자 목록을 배열 이니셜라이저에 복사하는 경우에 발생할 수 있습니다.
배열의 일부 숫자는 0으로 채워질 수 있으며 컴파일러는 이러한 수를 8진수로 해석합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] elapsed = {1, 13, 052};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;선행하는 0을 제거하는 빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] elapsed = {1, 13, 52};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8진수인 경우(예: 변수 인라인 뒤) 8진수를 10진수로 변환하는 또 다른 빠른 수정을 사용할 수 있습니다.&lt;/p&gt;
&lt;code&gt;int[] elapsed = {1, 13, 42};&lt;/code&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: OctalAndDecimalIntegersMixed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegativeIntConstantInLongContext" defaultSeverity="WARNING" displayName="long 컨텍스트에 음의 정수인 16진수 상수가 사용됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
long 컨텍스트에서 음수인 int 16진수 상수를 보고합니다. 이러한 상수는 묵시적으로 long으로 확장되어, 상위 비트가 0이 아닌 1이 됩니다(예: 0xFFFF_FFFF는 0xFFFF_FFFF_FFFF_FFFFL이 됩니다).
이는 의도되었을 가능성이 낮으며, 의도되었다 하더라도 명시적 long 상수를 사용하는 것이 더 명확합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 경고: 이는 int 상수 -1이며 long으로 확장되어
  // 0xFFFF_FFFF_FFFF_FFFFL이 됩니다.
  long mask = 0xFFFF_FFFF;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2022.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NegativeIntConstantInLongContext&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InsertLiteralUnderscores" defaultSeverity="INFORMATION" displayName="판독 불가한 숫자 리터럴" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
밑줄이 포함되지 않은 긴 숫자 리터럴을 보고하고 밑줄 추가를 제안합니다. 해당 리터럴에 밑줄을 추가하면 가독성이 개선됩니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  1000000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  1_000_000
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 모듈 프로젝트의 언어 수준이 7 이상인 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InsertLiteralUnderscores&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnpredictableBigDecimalConstructorCall" defaultSeverity="WARNING" displayName="예측할 수 없는 'BigDecimal' 생성자 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;double&lt;/code&gt; 값을 허용하는 &lt;code&gt;BigDecimal&lt;/code&gt; 생성자 호출을 보고합니다.
이 생성자는 제공된 &lt;code&gt;double&lt;/code&gt; 값과 동일한 &lt;code&gt;BigDecimal&lt;/code&gt;을 생성합니다.
하지만 double은 IEEE 754 64비트 배정밀도 2진 부동소수점 형식으로 인코딩되기 때문에 정확한 값은 기대할 수 없습니다.
&lt;p&gt;예를 들어, &lt;code&gt;new BigDecimal(0.1)&lt;/code&gt;은 값이 &lt;small&gt;&lt;code&gt;0.1000000000000000055511151231257827021181583404541015625&lt;/code&gt;&lt;/small&gt;인 &lt;code&gt;BigDecimal&lt;/code&gt; 객체를 생성합니다. 이는 &lt;code&gt;double&lt;/code&gt;로 표현할 수 있는 
  0.1에 가장 근접한 숫자입니다.
  예상되는 값 &lt;code&gt;0.1&lt;/code&gt;을 포함하는 &lt;code&gt;BigDecimal&lt;/code&gt;을 얻으려면,
  &lt;code&gt;new BigDecimal("0.1")&lt;/code&gt; 또는 &lt;code&gt;BigDecimal.valueOf(0.1)&lt;/code&gt;을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Constructor {
    void foo() {
      new BigDecimal(0.1);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Constructor {
    void foo() {
      new BigDecimal("0.1");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnpredictableBigDecimalConstructorCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitNumericConversion" defaultSeverity="WARNING" displayName="묵시적 숫자 변환" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
숫자 타입 간의 묵시적 변환을 보고합니다.
&lt;p&gt;묵시적 숫자 변환 자체는 문제가 아니지만, 예기치 않은 경우, 버그 추적에 어려움이 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double m(int i) {
    return i * 10;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double m(int i) {
    return (double) (i * 10);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;변환 확장 무시&lt;/b&gt; 옵션을 사용하여 데이터 손실을 일으킬 수 없는 묵시적 변환을 무시합니다(예: &lt;code&gt;int&lt;/code&gt;-&amp;gt;&lt;code&gt;long&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;'char'에서 또는 'char'로의 변환 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;char&lt;/code&gt; 간의 변환을 무시합니다. 이 검사는 부동 소수점 수와 다른 타입 간의 변환을 계속 보고합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;상수 및 리터럴로부터의 변환 무시&lt;/b&gt;를 사용하여 검사에서 리터럴 및 컴파일 타임 상수로부터의 변환을 무시하도록 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ImplicitNumericConversion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NumericOverflow" defaultSeverity="WARNING" displayName="숫자 오버플로" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
계산 중 오버플로가 발생하는 표현식을 보고합니다.
일반적으로 이는 실수로 인해 발생하며 버그를 의미합니다. 예를 들어, 잘못된 타입이 사용된 경우나 시프트가 반대 방향으로 수행된 경우가 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  float a = 1.0f/0.0f;
  long b = 30 * 24 * 60 * 60 * 1000;
  long c = 1000L &amp;lt;&amp;lt; 62;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: NumericOverflow&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DivideByZero" defaultSeverity="WARNING" displayName="0으로 나누기" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
0으로 나누기 연산 또는 0의 나머지 연산을 보고합니다.
그러한 표현식은 double 또는 float에 대해 &lt;code&gt;Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt; 또는 &lt;code&gt;NaN&lt;/code&gt; 결과를 반환하며 integer에 대해 &lt;code&gt;ArithmeticException&lt;/code&gt;을 던집니다.
&lt;p&gt;표현식의 결과가 &lt;code&gt;NaN&lt;/code&gt;인 있는 경우, 수정은 나누기 표현식을 &lt;code&gt;NaN&lt;/code&gt; 상수로 바꿀 것을 제안합니다.
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: DivideByZero&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BigDecimalMethodWithoutRoundingCalled" defaultSeverity="WARNING" displayName="반올림 모드 인수 없이 'BigDecimal' 메서드 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
반올림 모드 인수가 없는 &lt;code&gt;divide()&lt;/code&gt; 또는 &lt;code&gt;setScale()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;결과에 정확한 값이 표시되지 않을 경우(예: 소수점이 무한히 전개되는 경우) 해당 호출로 인해 &lt;code&gt;ArithmeticException&lt;/code&gt;이 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;반올림 모드를 지정하면 &lt;code&gt;ArithmeticException&lt;/code&gt;을 방지할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  BigDecimal.valueOf(1).divide(BigDecimal.valueOf(3));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BigDecimalMethodWithoutRoundingCalled&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CachedNumberConstructorCall" defaultSeverity="WARNING" displayName="기본 인수가 있는 숫자 생성자 호출" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
기본 &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt; 또는 &lt;code&gt;byte&lt;/code&gt; 인수를 가진 새로운 &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt; 또는 &lt;code&gt;Byte&lt;/code&gt; 객체의 인스턴스화를 보고합니다.
&lt;p&gt;Java 5에 도입된 static 메서드인 &lt;code&gt;valueOf()&lt;/code&gt;를 사용하는 것이 좋습니다. 기본적으로 이 메서드는 -128~127 사이 값의 객체를 캐싱합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer i = new Integer(1);
  Long l = new Long(1L);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 코드는 다음과 같이 변경됩니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer i = Integer.valueOf(1);
  Long l = Long.valueOf(1L);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 5 이상인 경우에만 보고합니다&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;Ignore new number expressions with a String argument(문자열 인수가 있는 새 숫자 표현식 무시)&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;String&lt;/code&gt; 인수가 있는 숫자 생성자 호출을 무시합니다.&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;Report only when constructor is @Deprecated(생성자가 @Deprecated인 경우에만 보고)&lt;/b&gt; 옵션을 사용하여 지원 중단된 생성자 호출만 보고합니다.
  JDK 9부터 &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt; 및 &lt;code&gt;Byte&lt;/code&gt; 생성자는 지원 중단됩니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CachedNumberConstructorCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveLiteralUnderscores" defaultSeverity="INFORMATION" displayName="숫자 리터럴의 밑줄" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
밑줄이 포함된 숫자 리터럴을 보고하고 빠른 수정을 사용해 밑줄을 제거하도록 제안합니다.
언어 수준을 낮춰야 할 경우 유용할 수 있습니다.
&lt;p&gt;빠른 수정은 숫자 리터럴에서 밑줄을 제거합니다. 예를 들어 &lt;code&gt;1_000_000&lt;/code&gt;은 &lt;code&gt;1000000&lt;/code&gt;으로 변환됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;i&gt;밑줄이 있는 숫자 리터럴&lt;/i&gt;은 Java 7에 등장했습니다.
  이 검사는 이전 Java 버전과의 하위 호환성을 위해 다운그레이드하는 데 도움이 될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2020.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RemoveLiteralUnderscores&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousLiteralUnderscore" defaultSeverity="WARNING" displayName="숫자 리터럴의의심스러운 밑줄" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
자릿수를 3개가 아닌 단위로 묶어서 밑줄 숫자 구분 기호를 사용하는 10진수 리터럴을 보고합니다.
이러한 리터럴에는 오타가 있을 수 있습니다.
&lt;p&gt;이 검사는 두 개의 연속적인 밑줄을 포함하는 리터럴에 대해 경고하지 않습니다.
&lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;float&lt;/code&gt; 리터럴의 소수 부분에 밑줄을 생략하는 것 또한 허용됩니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt; &lt;code&gt;int oneMillion = 1_000_0000;&lt;/code&gt;&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SuspiciousLiteralUnderscore&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparisonToNaN" defaultSeverity="WARNING" displayName="'Double.NaN' 또는 'Float.NaN'과 비교" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;Double.NaN&lt;/code&gt; 또는 &lt;code&gt;Float.NaN&lt;/code&gt;에 대한 비교를 보고합니다.
NaN은 자신을 포함하여 어느 것과도 동등하지 않으므로 비교는 의미가 없습니다.
&lt;code&gt;Double.isNaN()&lt;/code&gt; 또는 &lt;code&gt;Float.isNaN()&lt;/code&gt; 메서드를 대신 사용합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x == Double.NaN) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (Double.isNaN(x)) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ComparisonToNaN&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LossyConversionCompoundAssignment" defaultSeverity="WARNING" displayName="복합 대입 내 묵시적 형 변환은 손실될 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
오른쪽 피연산자의 타입이 변수 타입과 호환되지 않아 대입할 수 없는 복합 대입을 보고합니다.
&lt;p&gt;
이러한 복합 대입 중에는 묵시적인 형 변환이 발생하여 손실 변환이 일어날 수 있습니다.

&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  long c = 1;
  c += 1.2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  long c = 1;
  c += (long) 1.2;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2023.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LossyConversionCompoundAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ComparisonOfShortAndChar" defaultSeverity="WARNING" displayName="'short' 및 'char' 값 비교" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;short&lt;/code&gt; 및 &lt;code&gt;char&lt;/code&gt; 값 간의 상등 비교를 보고합니다.
&lt;p&gt;이러한 비교는 탐지하기 어려운 버그를 초래할 수 있습니다. 두 값 모두 2바이트 길이지만, &lt;code&gt;short&lt;/code&gt; 값은 부호가 있는 반면 &lt;code&gt;char&lt;/code&gt; 값은 부호가 없기 때문입니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if (Character.MAX_VALUE == shortValue()) {} //true일 수 없습니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ComparisonOfShortAndChar&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OctalLiteral" defaultSeverity="WARNING" displayName="8진 정수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
8진수 정수 리터럴을 보고합니다. 일부 코딩 표준에서는 10진수 리터럴과 혼동될 수 있으므로 8진수 리터럴의 사용을 금지합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 015;
  int j = 0_777;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 검사는 두 가지 빠른 수정을 제공합니다.
  &lt;b&gt;Convert octal literal to decimal literal(8진수 리터럴을 10진수 리터럴로 변환)&lt;/b&gt; 빠른 수정을 적용한 후 코드는 다음과 같이 변경됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 13;
  int j = 511;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;Remove leading zero to make decimal(선행 0을 제거하여 10진수 만들기)&lt;/b&gt; 빠른 수정을 적용한 후 코드는 다음과 같이 변경됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 15;
  int j = 777;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: OctalLiteral&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FloatingPointEquality" defaultSeverity="WARNING" displayName="부동소수점 상등 비교" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 연산자를 사용하여 비교되는 부동 소수점 값을 보고합니다.
&lt;p&gt;부동 소수점 값은 본질적으로 부정확하며, 정확한 상등을 위한 비교가 원하던 의미인 경우가 거의 없습니다.&lt;/p&gt;
&lt;p&gt;이 검사는 0 및 무한 리터럴과의 비교를 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  void m(double d1, double d2) {
    if (d1 == d2) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FloatingPointEquality&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryUnaryMinus" defaultSeverity="WARNING" displayName="불필요한 단항 뺄셈" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 단항 빼기를 보고합니다. 그러한 표현식은 이해하기 어려울 수 있으며 오류를 포함할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    int x = - -i;
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기에서는 다음과 같은 빠른 수정이 제안됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;&lt;code&gt;i&lt;/code&gt; 변수 앞의 &lt;code&gt;-&lt;/code&gt; 연산자를 제거합니다.&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    int x = i;
  }&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
 &lt;p&gt;&lt;code&gt;+&lt;/code&gt; 연산자를 접두사 감소 연산자로 바꿉니다.&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    int x = --i;
  }&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;다른 예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    i += - 8;
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    i -= 8;
  }&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryUnaryMinus&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Spring Core" path="Spring"><inspection shortName="SpringElInspection" defaultSeverity="WARNING" displayName="잘못된 Spring 표현 언어(SpEl) 구문" enabled="false" language="SpEL" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Spring Expression Language(SpEL) 코드에서 구문 오류를 보고합니다(예: 해결되지 않은 참조 및 잘못된 위치).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
@Controller
public class MyController {
    @Value("#{T(java.lang.Math).&lt;strong&gt;unknown&lt;/strong&gt;()}") // 프로퍼티 또는 메서드 'unknown'을 해결할 수 없습니다
    public void setValue(String s) {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringElInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringHandlersSchemasHighlighting" defaultSeverity="ERROR" displayName="'spring.handlers' 또는 'spring.schemas' 파일 내 해결되지 않은 파일 또는 클래스 참조" enabled="false" language="Properties" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;spring.handlers&lt;/code&gt; 및 &lt;code&gt;spring.schemas&lt;/code&gt; 파일에서 해결되지 않은 클래스 및 파일 참조를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;code&gt;spring.handlers&lt;/code&gt; 파일 예시:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
   a=my.company.MyHandler
   b=my.company.UnknownHandler // " 'my.company.UnknownHandler' 클래스를 해결할 수 없습니다"라고 보고됩니다
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringHandlersSchemasHighlighting&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringElStaticFieldInjectionInspection" defaultSeverity="WARNING" displayName="static 필드 내의 잘못된 SpEL 삽입" enabled="false" language="JAVA" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Spring Expression Language(SpEL)를 static 필드에 삽입('null' 값이 삽입됨)하려는 시도를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@Controller
public class MyController {
    &lt;strong&gt;@Value&lt;/strong&gt;("#{systemProperties['some.key']}")  //  static 필드에 삽입하는 것은 허용되지 않습니다
    static String spelWithDefaultValue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringElStaticFieldInjectionInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="코드 구문이 바람직하지 않을 수 있습니다" path="JavaScript 및 TypeScript"><inspection shortName="CommaExpressionJS" defaultSeverity="WARNING" displayName="쉼표 표현식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
쉼표 표현식을 보고합니다. 이러한 표현식은 보통 과도하게 교묘한 코드의 징후이며 미묘한 버그로 이어질 수 있습니다.
이니셜라이저 또는 &lt;code&gt;for&lt;/code&gt; 루프의 업데이트 섹션 내 쉼표 표현식은 무시됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CommaExpressionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VoidExpressionJS" defaultSeverity="WARNING" displayName="'void' 표현식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;void&lt;/code&gt; 표현식을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: VoidExpressionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueStatementWithLabelJS" defaultSeverity="WARNING" displayName="라벨이 있는 'continue' 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
라벨이 지정된 &lt;code&gt;continue&lt;/code&gt; 문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ContinueStatementWithLabelJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueStatementJS" defaultSeverity="WARNING" displayName="'continue' 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;continue&lt;/code&gt; 문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ContinueStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BreakStatementWithLabelJS" defaultSeverity="WARNING" displayName="라벨이 있는 'break' 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
라벨이 지정된 &lt;code&gt;break&lt;/code&gt; 구문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: BreakStatementWithLabelJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LabeledStatementJS" defaultSeverity="WARNING" displayName="라벨 지정된 구문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
라벨이 지정된 구문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LabeledStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WithStatementJS" defaultSeverity="WARNING" displayName="'with' 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;with&lt;/code&gt; 문을 보고합니다. 그러한 구문은 잠재적으로 혼란을 일으키는 암묵적 바인딩을 초래할 수 있으며, 새로운 변수 설정 시 불안정하게 동작할 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: WithStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DebuggerStatementJS" defaultSeverity="WARNING" displayName="'debugger' 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JavaScript 디버거와의 상호작용에 사용된 &lt;code&gt;debugger&lt;/code&gt; 문을 보고합니다.  그러한 구문은 프로덕션 코드에 포함되어서는 안 됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DebuggerStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalExpressionJS" defaultSeverity="WARNING" displayName="조건식" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
삼항 조건식을 보고합니다.  일부 코딩 표준은
명시적 &lt;code&gt;if&lt;/code&gt; 문을 위해
그러한 표현식을 금지합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ConditionalExpressionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousFunctionJS" defaultSeverity="WARNING" displayName="익명 함수" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
익명 함수를 보고합니다. 함수 표현식의 명시적 이름은 디버그에 도움이 될 수 있습니다.
ECMAScript 표준으로 지정된 &lt;code&gt;name&lt;/code&gt; 속성이 존재하는 경우, 이름 없는 표현식은 무시합니다.
예: &lt;code&gt;var bar = function() {};&lt;/code&gt;는 보고되지 않습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AnonymousFunctionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BreakStatementJS" defaultSeverity="WARNING" displayName="'break' 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;break&lt;/code&gt; 문을 보고합니다. case 블록을 끝내는 &lt;code&gt;break&lt;/code&gt; 문은 무시합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: BreakStatementJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="프로퍼티 파일" path="Java"><inspection shortName="UnsupportedCharacter" defaultSeverity="WARNING" displayName="지원되지 않는 문자" enabled="false" language="UAST" pluginId="com.intellij.java-i18n" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Java 1.8 이전 버전을 사용할 때 ISO-8859-1 문자 세트에서 지원되지 않는 문자를 프로퍼티 파일 내에서 보고합니다.
이 검사는 프로퍼티 파일에 ISO-8859-1에 매핑될 수 없는 문자가 있는지 확인하고 호환성을 위해 이러한 문자를 유니코드 이스케이프 시퀀스로 변환할 것을 제안합니다.
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;
  ISO-8859-1 인코딩과의 호환성을 보장하려면 &lt;b&gt;이스케이프 시퀀스로 변환&lt;/b&gt; 빠른 수정을 사용하세요.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  key=Java + ☕ = &#x1f340;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  key=Java + \u2615 = \uD83C\uDF40
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnsupportedCharacter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnresolvedPropertyKey" defaultSeverity="ERROR" displayName="잘못된 프로퍼티 키" enabled="false" language="JAVA" pluginId="com.intellij.java-i18n" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@PropertyKey&lt;/code&gt; 어노테이션이 추가된 매개변수가 있는 메서드로 전달된 잘못된 인수를 보고합니다.
&lt;p&gt;해당 인수는 대응하는 프로퍼티 파일에서 올바른 프로퍼티 키여야 합니다.
또한 이 검사는 &lt;code&gt;@PropertyKey&lt;/code&gt; 어노테이션의 &lt;code&gt;resourceBundle&lt;/code&gt; 인수가 기존 리소스 번들인지 검사합니다.&lt;/p&gt;
&lt;p&gt;
  새 프로퍼티를 생성하거나 기존 프로퍼티를 선택하려면 빠른 수정을 사용합니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @PropertyKey(resourceBundle = "myBundle") String value = "invalid.key";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnresolvedPropertyKey&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="PostCSS" path=""><inspection shortName="PostCssUnresolvedModuleValueReference" defaultSeverity="ERROR" displayName="해결되지 않은 CSS 모듈 값" enabled="false" language="PostCSS" pluginId="org.intellij.plugins.postcss" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://github.com/css-modules/postcss-modules-values"&gt;CSS Module Value&lt;/a&gt; (&lt;code&gt;@value&lt;/code&gt; 선언) 에 대한 해결되지 않은 참조를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@value foo from unknown;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PostCssUnresolvedModuleValueReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PostCssNesting" defaultSeverity="WARNING" displayName="잘못된 중첩 규칙" enabled="false" language="PostCSS" pluginId="org.intellij.plugins.postcss" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구문이 &lt;a href="https://github.com/postcss/postcss-nested"&gt;PostCSS Nested&lt;/a&gt;
또는 &lt;a href="https://github.com/csstools/postcss-nesting"&gt;PostCSS Nesting&lt;/a&gt; 사양을 준수하지 않는 중첩 스타일 규칙을 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
.phone {
  &amp;_title {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PostCssNesting&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PostCssCustomMedia" defaultSeverity="ERROR" displayName="잘못된 사용자 지정 미디어" enabled="false" language="PostCSS" pluginId="org.intellij.plugins.postcss" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://github.com/postcss/postcss-custom-media"&gt;PostCSS 사용자 지정 미디어&lt;/a&gt; 쿼리 내 구문 오류를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@custom-media --small-viewport (max-width: 30em);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PostCssCustomMedia&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PostCssCustomSelector" defaultSeverity="ERROR" displayName="잘못된 사용자 지정 선택자" enabled="false" language="PostCSS" pluginId="org.intellij.plugins.postcss" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://github.com/postcss/postcss-custom-selectors"&gt;PostCSS 사용자 지정 선택자&lt;/a&gt; 내 구문 오류를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@custom-selector :--heading h1, h2, h3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PostCssCustomSelector&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PostCssMediaRange" defaultSeverity="ERROR" displayName="잘못된 미디어 쿼리 범위" enabled="false" language="PostCSS" pluginId="org.intellij.plugins.postcss" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
'range' 타입인 미디어 기능으로 
대체하여 사용될 수 있는 
&lt;a href="https://github.com/postcss/postcss-media-minmax"&gt;범위 컨텍스트&lt;/a&gt; 구문을 검사합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@media screen and (500px &amp;lt;= width &amp;lt;= 1200px) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PostCssMediaRange&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="XML" path="Spring/Spring Core"><inspection shortName="SpringScopesInspection" defaultSeverity="ERROR" displayName="알 수 없는 &lt;bean&gt; 범위" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 요소의 &lt;code&gt;scope&lt;/code&gt; 속성에서 알 수 없는 값을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="beans.FooComponent" id="foo" scope="unknown"/&amp;gt;
    &amp;lt;!-- "심볼 'unknown'을 해결할 수 없습니다"라고 보고됩니다 &amp;gt;
    &amp;lt;bean class="beans.BarComponent" id="bar" scope="prototype"/&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringScopesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringFactoryMethodInspection" defaultSeverity="ERROR" displayName="'factory-method' 속성에 참조되어 있는 잘못 정의된 메서드 참조" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 요소의 &lt;code&gt;factory-method&lt;/code&gt; 속성에서 잘못된 메서드 참조를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
public class MyFactory {
public static FooBean createBean() {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
&amp;lt;beans&amp;gt;
  &amp;lt;bean class="MyFactory" id="factory"/&amp;gt;
  &amp;lt;bean factory-bean="factory" factory-method="createBean"/&amp;gt; &amp;lt;!-- Factory 메서드 'createBean'은 static일 수 없습니다 --&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringFactoryMethodInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RequiredBeanTypeInspection" defaultSeverity="ERROR" displayName="잘못 삽입된 Bean 타입" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;XML 애플리케이션 컨텍스트에서 정의된 사용자 지정 스키마 Bean 삽입의 잘못된 타입을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class SimpleBean{}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
  &amp;lt;beans ...&gt;
    &amp;lt;bean class="SimpleBean" id="simpleBean"/&amp;gt;
       &amp;lt;mvc:annotation-driven
         conversion-service="simpleBean"      &amp;lt;!-- "Bean은 'org.springframework.core.convert.ConversionService' 타입이어야 합니다"라고 보고됩니다 --&amp;gt;
         message-codes-resolver="simpleBean"  &amp;lt;!-- reports 'Bean must be of org.springframework.validation.MessageCodesResolver' type" --&amp;gt;
         validator="simpleBean"               &amp;lt;!-- "Bean은 'org.springframework.validation.Validator' 타입이어야 합니다"라고 보고됩니다 --&amp;gt;
    /&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RequiredBeanTypeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBeanLookupMethodInspection" defaultSeverity="ERROR" displayName="잘못 구성된 XML Bean 조회 메서드" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;XML 애플리케이션 컨텍스트의 Bean에 대한 잘못된 &lt;strong&gt;&amp;lt;lookup-method&amp;gt;&lt;/strong&gt;를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public abstract class FooLookupBean {
    protected abstract FooBean createCommand();
    private FooBean createCommand() {...}
    protected static FooBean createCommandStatic() {...}
    protected abstract FooBean createWithArgs(String foo);
    protected abstract OtherBean createOtherBean();
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="FooLookupBean" id="lookupTest"&amp;gt;
      &amp;lt;lookup-method bean="fooBean" name="createCommand"/&amp;gt;
      &amp;lt;!-- private --&amp;gt;
      &amp;lt;lookup-method bean="fooBean" name="createCommand"/&amp;gt; &amp;lt;!-- "메서드는 public 또는 protected여야 합니다" --&amp;gt;
      &amp;lt;!-- static --&amp;gt;
      &amp;lt;lookup-method bean="fooBean" name="createCommandStatic"/&amp;gt; &amp;lt;!-- static 메서드는 여기서 허용되지 않습니다 --&amp;gt;
      &amp;lt;!-- 인수 포함 --&amp;gt;
      &amp;lt;lookup-method bean="fooBean" name="createWithArgs"/&amp;gt; &amp;lt;!-- 메서드에 매개변수가 없어야 합니다 --&amp;gt;
      &amp;lt;!-- 존재하지 않음 --&amp;gt;
      &amp;lt;lookup-method bean="fooBean" name="unknown"/&amp;gt; &amp;lt;!-- 알 수 없는 메서드 --&amp;gt;
      &amp;lt;!-- 불일치 --&amp;gt;
      &amp;lt;lookup-method bean="fooBean" name="createOtherBean"/&amp;gt; &amp;lt;!-- Lookup 메서드 반환 타입이 'FooBean' bean 클래스와 일치하지 않습니다 --&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean class="FooBean" id="fooBean"/&amp;gt;
    &amp;lt;bean class="OtherBean" id="otherBean"/&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringBeanLookupMethodInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UtilSchemaInspection" defaultSeverity="ERROR" displayName="XML 애플리케이션 컨텍스트 내 잘못 구성된 'util' 스키마" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;XML 애플리케이션 컨텍스트에 정의된 잘못된 &lt;a href="https://www.springframework.org/schema/util"&gt;schema bean&lt;/a&gt;을 보고합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans ... xmlns:util="https://www.springframework.org/schema/util"&amp;gt;
    &amp;lt;bean class="MyBean" id="myBean"/&amp;gt;
    &amp;lt;bean class="ErrTypeBean" id="errTypeBean"/&amp;gt;
    &amp;lt;util:list list-class="java.lang.String"/&amp;gt; // "클래스가 'java.util.List'의 상속자여야 합니다"라고 보고됩니다
    &amp;lt;util:set value-type="MyBean"&amp;gt;
      &amp;lt;ref bean="fooBean"/&amp;gt;
      &amp;lt;ref bean="errTypeBean"/&amp;gt; // " 'MyBean' 타입의 컬렉션에 추가할 수 없습니다"라고 보고됩니다
    &amp;lt;/util:set&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UtilSchemaInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AbstractBeanReferencesInspection" defaultSeverity="ERROR" displayName="추상 Bean에 대한 잘못된 참조" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;참조된 추상 Bean을 보고합니다.&lt;/p&gt;

&lt;p&gt;추상 Bean은 템플릿 Bean 정의, 즉 하위 정의의 상위 정의로만 사용할 수 있습니다.
  이러한 추상 상위 Bean을 다른 Bean의 ref 프로퍼티로 참조하거나 상위 Bean ID로 &lt;code&gt;getBean()&lt;/code&gt;을 호출하여 단독으로 사용하려는 경우 오류가 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  &amp;lt;bean abstract="true" id="parentBeanWithoutClass"/&amp;gt;
  &amp;lt;bean class="com.my.company.FooBean" id="childBean" parent="parentBeanWithoutClass"&amp;gt;
  &amp;lt;!--  properties --&amp;gt;
  &amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 예시에서 상위 Bean은 불완전하며 추상이라 명시적으로 표시되었으므로 단독으로 인스턴스화가 불가합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AbstractBeanReferencesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;

</inspection><inspection shortName="SpringXmlModelInspection" defaultSeverity="ERROR" displayName="잘못된 Spring Core XML 기반 애플리케이션 컨텍스트" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href="https://spring.io/projects/spring-framework"&gt;Spring Framework&lt;/a&gt; XML 기반 애플리케이션 컨텍스트 관련 문제를 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;해결되지 않은 bean 참조&lt;/li&gt;
  &lt;li&gt;필요한 태그 또는 속성 누락&lt;/li&gt;
  &lt;li&gt;잘못된 프로퍼티 타입&lt;/li&gt;
  &lt;li&gt;일관성 없는 &lt;code&gt;enum&lt;/code&gt; 프로퍼티&lt;/li&gt;
  &lt;li&gt;참조된 bean의 잘못된 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringXmlModelInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringIncorrectResourceTypeInspection" defaultSeverity="ERROR" displayName="잘못된 리소스 타입" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;XML 애플리케이션 컨텍스트에서 참조된 잘못된 파일을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;import resource="imported-app-context.xml"/&amp;gt;
    &amp;lt;import resource="banner.txt"/&amp;gt;&amp;lt;!-- 여기에서 '잘못된 리소스 타입'을 Spring XML 애플리케이션 컨텍스트로서 보고해야 합니다 --&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringIncorrectResourceTypeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringRequiredPropertyInspection" defaultSeverity="ERROR" displayName="Spring XML Bean 선언 내에 누락된 @Required 프로퍼티 삽입" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;삽입되거나 오토와이어링되지 않은 &lt;code&gt;@Required&lt;/code&gt; setter bean 프로퍼티를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
&amp;lt;beans&amp;gt;
  &amp;lt;bean class="beans.MyComponent" id="foo"/&amp;gt;
  &amp;lt;!-- "필수 프로퍼티 누락: 'port'"를 보고합니다 --&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
public class MyComponent {
   @Required
   public void setPort(int port) // "필수 프로퍼티 'port'가 삽입되지 않았습니다"라고 보고됩니다
   {...}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringRequiredPropertyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBeanInstantiationInspection" defaultSeverity="ERROR" displayName="잘못된 비 추상 Bean 인스턴스화" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;인터페이스/추상 클래스 &lt;strong&gt;&amp;lt;bean&amp;gt;&lt;/strong&gt; 선언의 인스턴스화 오류를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="java.util.List"/&amp;gt;
    &amp;lt;!-- '추상적이지 않은 bean에서는 허용되지 않는 인터페이스'를 보고합니다 --&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringBeanInstantiationInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;

</inspection><inspection shortName="DuplicatedBeanNamesInspection" defaultSeverity="WARNING" displayName="XML 기반 애플리케이션 컨텍스트 내 Bean 이름 중복" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;애플리케이션 컨텍스트에 정의된 중복 Bean 이름을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans profile="PROD"&amp;gt;
    &amp;lt;bean class="..." id="duplicatedName"/&amp;gt;  &amp;lt;!-- 오류 --&amp;gt;
    &amp;lt;bean class="..." name="foo_name, duplicatedName"/&amp;gt; &amp;lt;!-- 'duplicatedName' 오류 --&amp;gt;
    &amp;lt;bean class="..." id="toBeAliased"/&amp;gt;

    &amp;lt;alias alias="duplicatedName" name="toBeAliased"/&amp;gt; &amp;lt;!-- 'duplicatedName' 오류 --&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DuplicatedBeanNamesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ContextComponentScanInconsistencyInspection" defaultSeverity="ERROR" displayName="XML 기반 구성 요소 검사 내 잘못된 필터 정의" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;XML 애플리케이션 컨텍스트의 &lt;strong&gt;&amp;lt;component-scan&amp;gt;&lt;/strong&gt;에서 일관성 없는 &lt;strong&gt;&amp;lt;filter&amp;gt;&lt;/strong&gt; 정의를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code lang="java"&gt;
  public class NonAnnotationTypeClass {}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;ctx:component-scan base-package="com.my.company"&amp;gt;
      &amp;lt;ctx:exclude-filter expression="com.my.company.anno.NonAnnotationTypeClass" type="annotation"/&amp;gt;
    &amp;lt;/ctx:component-scan&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 예시의 경우 &lt;code&gt;NonAnnotationTypeClass&lt;/code&gt;가 어노테이션 타입이어야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ContextComponentScanInconsistencyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringInjectionValueStyleInspection" defaultSeverity="WARNING" displayName="XML 애플리케이션 컨텍스트 내 삽입 값의 규칙 위반" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 하위 요소를 통해 구성된 프로퍼티를 보고하고 해당하는 속성으로 이를 대체하도록 제안합니다&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="MyBean" id="myBean"/&amp;gt;

    &amp;lt;bean class="MyFactory"&amp;gt;
      &amp;lt;property name="bean"&amp;gt;
        &amp;lt;ref bean="myBean"/&amp;gt; &amp;lt;!-- '명시적 &amp;lt;ref&amp;gt; 요소의 사용 위치'를 보고합니다 --&amp;gt;
      &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="MyBean" id="myBean"/&amp;gt;
    &amp;lt;bean class="MyFactory"&amp;gt;
      &amp;lt;property name="bean" ref="myBean"/&amp;gt;
    &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringInjectionValueStyleInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringInjectionValueConsistencyInspection" defaultSeverity="ERROR" displayName="XML 애플리케이션 컨텍스트 내 일관되지 않은 삽입 값" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;XML 애플리케이션 컨텍스트의 삽입점에서 일관성 없는 태그 및 속성을 보고합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt;는 &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; 또는 하위 요소를 지정해야 합니다&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt;에 포함된 하위 요소가 1개를 초과할 수 없습니다&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt;에는 &lt;code&gt;bean&lt;/code&gt; 속성, &lt;code&gt;local&lt;/code&gt; 속성 또는 &lt;code&gt;parent&lt;/code&gt; 속성이 포함될 수 있습니다&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt;는 bean을 지정해야 합니다&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;idref&amp;gt;&lt;/code&gt;에는 &lt;code&gt;bean&lt;/code&gt; 속성 또는 &lt;code&gt;local&lt;/code&gt; 속성이 포함될 수 있습니다&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;idref&amp;gt;&lt;/code&gt;는 bean을 지정해야 합니다&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;는 key를 지정해야 합니다&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;idref&amp;gt;&lt;/code&gt;에는 &lt;code&gt;key&lt;/code&gt; 속성, &lt;code&gt;key-ref&lt;/code&gt; 속성 또는 &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; 하위 속성이 포함될 수 있습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;

  &lt;em&gt;&amp;lt;!-- 1.  프로퍼티는 'ref' 속성 또는 'value' 속성 또는 하위 요소만 포함하도록 허용됩니다 --&amp;gt;&lt;/em&gt;
  &amp;lt;bean class="MyClass"&amp;gt;
    &amp;lt;property name="bean" ref="myBean" value="foo"/&amp;gt;
    &amp;lt;!-- 프로퍼티는 'ref' 속성 또는 'value' 속성 또는 하위 요소만 포함하도록 허용됩니다 --&amp;gt;
  &amp;lt;/bean&amp;gt;

  &lt;em&gt;&amp;lt;!--  2.  프로퍼티가 2개 이상의 하위 요소를 포함해서는 안 됩니다 --&amp;gt;&lt;/em&gt;
  &amp;lt;bean class="MyFactory"&amp;gt;
    &amp;lt;property name="bean"&amp;gt;
    &amp;lt;ref&amp;gt;bean&amp;lt;/ref&amp;gt; &amp;lt;!-- 프로퍼티가 2개 이상의 하위 요소를 포함해서는 안 됩니다 --&amp;gt;
     &amp;lt;value&amp;gt;foo&amp;lt;/value&amp;gt; &amp;lt;!-- 프로퍼티가 2개 이상의 하위 요소를 포함해서는 안 됩니다 --&amp;gt;
     &amp;lt;/property&amp;gt;
  &amp;lt;/bean&amp;gt;

  &lt;em&gt;&amp;lt;!-- 3. Map 항목은 키를 지정해야 합니다  --&amp;gt;&lt;/em&gt;
  &amp;lt;bean class="MyBean"&amp;gt;
     &amp;lt;property name="map"&amp;gt;
        &amp;lt;map&amp;gt;
           &amp;lt;entry value="foo"/&amp;gt;  &amp;lt;!-- Map 항목은 키를 지정해야 합니다 --&amp;gt;
        &amp;lt;/map&amp;gt;
     &amp;lt;/property&amp;gt;
  &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringInjectionValueConsistencyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringXmlAutowiringInspection" defaultSeverity="ERROR" displayName="잘못된 XML Spring Bean 오토와이어링" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;XML 애플리케이션 컨텍스트에서 구성된 Spring bean의 잘못된 오토와이어링을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
public interface FooInterface {...}
@Component public class FooBean implements FooInterface {...}
@Component public class OtherBean implements FooInterface {...}

@Component
public class MyComponent {
	 public void setFooInterface(FooInterface foo) {...}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
&amp;lt;beans&amp;gt;
	&amp;lt;bean class="beans.OtherBean" id="otherBean"/&amp;gt;
	&amp;lt;bean class="beans.FooBean" id="fooBean"/&amp;gt;

	&amp;lt;bean autowire="byType" class="beans.MyComponent" id="foo"/&amp;gt; &amp;lt;!-- "오토와이어링을 수행할 수 없습니다. 'FooInterface' 타입의 bean이 2개 이상 있습니다. --&amp;gt;
                                                                   &amp;lt;!--          Beans: otherBean,fooBean. 프로퍼티: 'fooInterface' "--&amp;gt; 라고 보고됩니다
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringXmlAutowiringInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringPlaceholdersInspection" defaultSeverity="WARNING" displayName="Spring XML 애플리케이션 컨텍스트 내 해결되지 않은 자리표시자" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Spring XML 컨텍스트에서 구성된 해결되지 않은 자리표시자를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;ctx:property-placeholder location="application.properties"/&amp;gt;

    &amp;lt;bean class="beans.ServerComponent"&amp;gt;
      &amp;lt;property name="serverName" value="${server.name}}"/&amp;gt;
      &amp;lt;property name="port" value="${unknown.property}}"/&amp;gt; &amp;lt;!-- "프로퍼티 키를 해결할 수 없습니다"라고 보고됩니다 --&amp;gt;
    &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringPlaceholdersInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBeanAttributesInspection" defaultSeverity="WARNING" displayName="Spring Bean 속성 충돌" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 속성의 구성 충돌을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="java.lang.String" factory-bean="factoryBean"/&amp;gt;
    &amp;lt;!-- 'class' 또는 'factory-bean' 중 하나가 있어야 합니다 --&amp;gt;
    &amp;lt;bean factory-bean="factoryBean" id="missingFactoryMethod"/&amp;gt; &amp;lt;!--//factory-bean이 있으면, factory-method가 있어야 합니다 --&amp;gt;

    &amp;lt;!-- 디폴트 값 'false'가 있는 속성 abstract는 불필요합니다 --&amp;gt;/
    &amp;lt;bean abstract="false" id="superfluousDefaultAttributeAbstract"/&amp;gt;

    &amp;lt;!-- 디폴트 값 'singleton'이 있는 속성 scope는 불필요합니다 --&amp;gt;/
    &amp;lt;bean id="superfluousDefaultAttributeScope" scope="singleton"/&amp;gt;


    &amp;lt;bean class="java.lang.StringBuilder"&amp;gt;
      &amp;lt;property name="length"&amp;gt;
        &amp;lt;!-- 속성 ID, 이름, 범위는 불필요합니다 --&amp;gt;
        &amp;lt;bean id="beanId" name="beanName" scope="prototype"/&amp;gt;
      &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringBeanAttributesInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SpringInactiveProfileHighlightingInspection" defaultSeverity="WARNING" displayName="비활성화된 프로파일 강조 표시" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Spring XML 애플리케이션 컨텍스트의 비활성 프로파일을 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;!-- 활성화된 프로필 &lt;strong&gt;'DEV'&lt;/strong&gt;는 이 애플리케이션 컨텍스트용으로 선택되었습니다 --&amp;gt;
  &amp;lt;beans profile="&lt;strong&gt;DEV&lt;/strong&gt;"&amp;gt;
    &amp;lt;bean class="MyFactory" factory-method="createBean"/&amp;gt;
  &amp;lt;/beans&amp;gt;
  &amp;lt;!--  이 태그의 내용은 'unused'로 강조 표시됩니다 --&amp;gt;
  &lt;em&gt;&amp;lt;beans profile="&lt;strong&gt;TESTS&lt;/strong&gt;"&amp;gt;
    &amp;lt;bean class="MyTestFactory" factory-method="createBean"/&amp;gt;
  &amp;lt;/beans&amp;gt;&lt;/em&gt;
  &amp;lt;!--  'unused' 섹션의 끝 --&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringInactiveProfileHighlightingInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBeanConstructorArgInspection" defaultSeverity="ERROR" displayName="XML Spring Bean 내 잘못된 생성자 삽입" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;생성자 기반의 종속성 삽입을 사용하는 Spring &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt;을 보고합니다.&lt;/p&gt;

&lt;p&gt;구성된 &lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt; 태그 및 정의된 &lt;code&gt;autowire&lt;/code&gt; 정책을 사용하여 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt;에 대한 적절한 생성자 또는 factory 메서드를 찾을 수 없는 경우 이 검사가 트리거됩니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
    public class MyComponent {
    // constructor
    public MyComponent(MyBean bean) {}
    // factory method
    public static MyComponent getInstance(String name, int port) {
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
    &amp;lt;beans&amp;gt;
      &amp;lt;bean class="beans.MyComponent" id="foo"&amp;gt; &amp;lt;!-- "클래스 'MyComponent'에서 일치하는 생성자를 찾을 수 없습니다"라고 보고됩니다 --&amp;gt;
         &amp;lt;constructor-arg ref="myBean"/&amp;gt;
         &amp;lt;constructor-arg value="123"/&amp;gt;
      &amp;lt;/bean&amp;gt;

      &amp;lt;bean class="beans.MyComponent" factory-method="getInstance"&amp;gt; &amp;lt;!-- "클래스에서 일치하는 factory 메서드를 찾을 수 없습니다"라고 보고됩니다 --&amp;gt;
         &amp;lt;constructor-arg value="123"/&amp;gt;
      &amp;lt;/bean&amp;gt;
    &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringBeanConstructorArgInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringPublicFactoryMethodInspection" defaultSeverity="WARNING" displayName="'factory-method' 속성에 참조되어 있는 잘못된 비 public 메서드" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;bean&amp;gt;&lt;/strong&gt; 요소의 &lt;code&gt;factory-method&lt;/code&gt; 속성에서 참조된 비 public 메서드를 보고합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
public class MyFactory {
  private static FooBean createBean() {...}
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
&amp;lt;beans&amp;gt;
  &amp;lt;bean class="MyFactory" factory-method="createBean"/&amp;gt;
  // "Factory 메서드 'createBean'은 public이어야 합니다"라고 보고됩니다
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringPublicFactoryMethodInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnparsedCustomBeanInspection" defaultSeverity="WARNING" displayName="분석되지 않은 사용자 지정 Spring bean" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;아직 분석되지 않은 알 수 없는 Spring bean 타입을 보고하거나 bean이 지원되지 않는 태그를 사용자 지정 네임스페이스에 사용하는지 여부를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnparsedCustomBeanInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InjectionValueTypeInspection" defaultSeverity="ERROR" displayName="XML 애플리케이션 컨텍스트 내 대입할 수 없는 삽입점 유형" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 삽입점 타입(프로퍼티 및 생성자 인수)을 보고합니다.&lt;/p&gt;

&lt;p&gt;허용되는 삽입점 타입은 &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;idref&lt;/code&gt; 및 모든 컬렉션 타입, 내부 Bean 등입니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code lang="java"&gt;
  public class InjectionValueTypes{
  public List&amp;lt;MyBean&amp;gt; setListBeans() {...} 
    public MyBean setMyBean() {...}
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="MyBean" id="myBean"/&amp;gt;
    &amp;lt;bean class="ErrTypeBean" id="errTypeBean"/&amp;gt;
    &amp;lt;bean class="InjectionValueTypes" id="kt"&amp;gt;
      &amp;lt;property name="myBean" ref="errTypeBean"/&amp;gt;
      &amp;lt;!-- " 'MyBean' 타입의 프로퍼티는 'ErrTypeBean'에 의해 삽입될 수 없습니다"라고 보고됩니다 --&amp;gt;
      &amp;lt;property name="listBeans"&amp;gt;
        &amp;lt;list&amp;gt;
          &amp;lt;idref local="myBean"/&amp;gt;
          &amp;lt;ref bean="myBean"/&amp;gt;
          &amp;lt;ref bean="errTypeBean"/&amp;gt; &amp;lt;!-- " 'MyBean' 타입의 컬렉션에 추가할 수 없습니다"라고 보고됩니다 --&amp;gt;
          &amp;lt;bean class="ErrTypeBean"/&amp;gt; &amp;lt;!-- "Bean은 'MyBean' 타입이어야 합니다"라고 보고됩니다 --&amp;gt;
        &amp;lt;/list&amp;gt;
      &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: InjectionValueTypeInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringXmlAutowireExplicitlyInspection" defaultSeverity="WARNING" displayName="XML 애플리케이션 컨텍스트 내 불필요한 오토와이어링된 종속 요소" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 요소의 &lt;code&gt;autowire&lt;/code&gt; 속성을 보고하고 가능한 경우 bean 프로퍼티를 명시적으로 주입하도록 제안합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class MyComponent {
    public void setOtherBean(OtherBean bean){...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code lang="xml"&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="beans.OtherBean" id="bar"/&amp;gt;
    &amp;lt;bean autowire="byType" class="beans.MyComponent"/&amp;gt;
    &amp;lt;!-- "오토와이어링된 종속성이 불필요합니다" --&amp;gt;
    &amp;lt;!-- "오토와이어링된 종속성을 명시적으로 만들 것"을 제안합니다 --&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;

&lt;pre&gt;&lt;code lang="xml"&gt;
  &amp;lt;beans&amp;gt;
    &amp;lt;bean class="beans.OtherBean" id="bar"/&amp;gt;
    &amp;lt;bean class="beans.MyComponent" id="foo"&amp;gt;
      &amp;lt;property name="otherBean" ref="otherBean"/&amp;gt;
    &amp;lt;/bean&amp;gt;
  &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringXmlAutowireExplicitlyInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SpringBeanNameConventionInspection" defaultSeverity="WARNING" displayName="Spring Bean 이름의 규칙 위반" enabled="false" language="XML" pluginId="com.intellij.spring" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Bean 이름 지정 규칙을 따르지 않는 &lt;strong&gt;&amp;lt;bean&amp;gt;&lt;/strong&gt; 이름을 보고합니다.&lt;/p&gt;

&lt;p&gt;
  규칙은 Bean 이름 지정 시 인스턴스 필드 이름에 표준 Java 규칙을 사용하는 것입니다.
  즉, Bean 이름은 소문자로 시작하고 이후 카멜 표기법이 적용됩니다.
  이와 같은 이름의 예시로는 &lt;code&gt;accountManager&lt;/code&gt;, &lt;code&gt;accountService&lt;/code&gt;, &lt;code&gt;userDao&lt;/code&gt;, &lt;code&gt;loginController&lt;/code&gt; 등이 있습니다.
  Bean 이름을 일관적으로 생성하면 구성을 더 쉽게 읽고 이해할 수 있습니다.
  또한 Spring AOP를 사용하는 경우, 이름으로 연결된 Bean 집합에 어드바이스를 적용할 때 매우 유용합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SpringBeanNameConventionInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="불필요한 구문" path="Kotlin"><inspection shortName="ComplexRedundantLet" defaultSeverity="WEAK WARNING" displayName="인수 기반 'let' 호출 중복" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 인수를 기반으로 하는 &lt;code&gt;let&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;호출 표현식에서 람다 매개변수가 한정자로만 사용되는 경우 &lt;code&gt;let&lt;/code&gt;은 불필요합니다.&lt;/p&gt;
&lt;p&gt;정규화하는 표현식에 이름을 붙여야 한다면 지역 변수를 선언하세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun splitNumbers() {
      "1,2,3".let { it.split(',') }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 여분의 &lt;code&gt;let()&lt;/code&gt; 호출을 제거합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      "1,2,3".split(',')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;또는&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun splitNumbers() {
      val numbers = "1,2,3"
      numbers.split(',')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ComplexRedundantLet&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveCurlyBracesFromTemplate" defaultSeverity="WEAK WARNING" displayName="문자열 템플릿의 불필요한 중괄호" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
간단한 식별자 주변의 문자열 템플릿에서 중괄호의 사용을 보고합니다.
&lt;p&gt;불필요한 중괄호를 제거하려면 '중괄호 제거' 빠른 수정을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundant() {
     val x = 4
     val y = "${x}" // &amp;lt;== 불필요
  }

  fun correctUsage() {
      val x = "x"
      val y = "${x.length}" // &amp;lt;== 문제 없음
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundant() {
     val x = 4
     val y = "$x"
  }

  fun correctUsage() {
      val x = "x" &amp;lt;== 업데이트됨
      val y = "${x.length}"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveCurlyBracesFromTemplate&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConstantConditionIf" defaultSeverity="WEAK WARNING" displayName="'if' 표현식의 조건은 상수임" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 상수 리터럴 조건을 가지며 단순화될 수 있는 &lt;code&gt;if&lt;/code&gt; 식을 보고합니다.
&lt;p&gt;이러한 구조는 가끔 의도적일 수 있지만 혼란을 줄 수 있으며 종종 오타 또는 이전 리팩터링으로 인한 것일 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      if (true) {
          throw IllegalStateException("Unexpected state")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;if&lt;/code&gt; 조건을 제거합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      throw IllegalStateException("Unexpected state")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConstantConditionIf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CanBeParameter" defaultSeverity="WARNING" displayName="생성자 매개변수는 프로퍼티로 사용되지 않음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;val&lt;/code&gt; 또는 &lt;code&gt;var&lt;/code&gt;를 제거할 수 있는 기본 생성자 매개변수를 보고합니다.
&lt;p&gt;
    생성자에서 클래스 프로퍼티를 선언하면 메모리 사용량이 증가합니다.
    생성자에서만 사용되는 매개변수 값은 생략할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;단, 참조된 객체는 조기에 가비지 수집될 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Task(val name: String) {
      init {
          print("Task created: $name")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 여분의 &lt;code&gt;val&lt;/code&gt; 또는 &lt;code&gt;var&lt;/code&gt; 키워드를 제거합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Task(name: String) {
      init {
          print("Task created: $name")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CanBeParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedSymbol" defaultSeverity="WARNING" displayName="사용되지 않는 심볼" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
사용되지 않거나 진입점에서 도달할 수 없는 심볼을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnusedSymbol&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantLambdaArrow" defaultSeverity="WARNING" displayName="중복된 람다 화살표" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;매개변수가 없는 람다에서 불필요한 람다 화살표를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(f: () -&gt; Unit) = f()

  fun bar() {
      foo { &lt;b&gt;-&gt;&lt;/b&gt; println("Hi!") }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(f: () -&gt; Unit) = f()

  fun bar() {
      foo { println("Hi!") }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantLambdaArrow&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantSetter" defaultSeverity="WEAK WARNING" displayName="중복 프로퍼티 setter" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 프로퍼티 setter를 보고합니다.
&lt;p&gt;
다음 경우에 setter는 불필요하다고 간주됩니다.
&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;
        setter에 본문이 없습니다. 접근자 가시성이 변경되지 않았고, 선언이 &lt;code&gt;external&lt;/code&gt;이 아니며 어노테이션을 포함하지 않습니다.
        &lt;pre&gt;&lt;code&gt;
  var myPropWithRedundantSetter: Int = 0
      set // 불필요

  var myPropA: Int = 0
      private set // 문제 없음 - 프로퍼티 가시성이 private으로 변경됩니다

  var myPropB: Int = 0
      external set // 문제 없음 - Kotlin에서 구현되지 않습니다(external)

  var myPropC: Int = 0
      @Inject set // 문제 없음 - 접근자에 어노테이션이 추가되었습니다
        &lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    &lt;li&gt;
        setter 본문은 매개변수를 백킹 필드에 대입하는 하나의 구문을 포함하는 블록입니다.
        &lt;pre&gt;&lt;code&gt;
  var prop: Int = 0
      set(value) { // 불필요
          field = value
      }
       &lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
&lt;/ol&gt;

&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantSetter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantRequireNotNullCall" defaultSeverity="WEAK WARNING" displayName="중복 'requireNotNull' 또는 'checkNotNull' 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;null 가능하지 않은 표현식에서 불필요한 &lt;code&gt;requireNotNull&lt;/code&gt; 또는 &lt;code&gt;checkNotNull&lt;/code&gt; 호출을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(i: Int) {
      requireNotNull(i) // 이 'i'는 null이 될 수 없으므로 이 'requireNotNull' 호출은 불필요합니다.
      ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(i: Int) {
      ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantRequireNotNullCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveRedundantSpreadOperator" defaultSeverity="WARNING" displayName="중복 스프레드 연산자" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;arrayOf&lt;/code&gt; 함수 호출 계열에서 불필요한 스프레드 연산자의 사용을 보고합니다.
&lt;p&gt;코드를 정리하려면 '불필요한 스프레드 연산자 제거' 빠른 수정을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(vararg s: String) { }

  fun bar(ss: Array&amp;lt;String&amp;gt;) {
      foo(*arrayOf("abc"))       // 두 개의 'foo' 호출에서 배열이 생성되어 있고
      foo(*arrayOf(*ss, "zzz"))  // 따라오는 '스프레드 처리' 역시 불필요합니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(vararg s: String) { }

  fun bar(ss: Array&amp;lt;String&amp;gt;) {
      foo("abc")
      foo(*ss, "zzz")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveRedundantSpreadOperator&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CanBePrimaryConstructorProperty" defaultSeverity="WARNING" displayName="프로퍼티가 생성자 매개변수에 명시적으로 대입되어 있음" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
기본 생성자 매개변수에 명시적으로 대입되는 프로퍼티를 보고합니다.
&lt;p&gt;기본 생성자에서 직접 프로퍼티를 선언하면 코드의 양을 줄이고 코드 가독성을 높일 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User(name: String) {
      val name = name
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 매개변수와 프로퍼티 선언을 하나의 기본 생성자 매개변수로 결합합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User(val name: String) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CanBePrimaryConstructorProperty&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantGetter" defaultSeverity="WEAK WARNING" displayName="중복 프로퍼티 getter" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;불필요한 프로퍼티 getter를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
      val a = 1
          &lt;b&gt;get&lt;/b&gt;
      val b = 1
          &lt;b&gt;get() = field&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
      val a = 1
      val b = 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantGetter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveEmptySecondaryConstructorBody" defaultSeverity="WEAK WARNING" displayName="불필요한 생성자 본문" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
보조 생성자의 빈 본문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveEmptySecondaryConstructorBody&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryVariable" defaultSeverity="WEAK WARNING" displayName="불필요한 지역 변수" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
바로 다음 &lt;code&gt;return&lt;/code&gt; 문 또는 다른 변수와 똑같은 복사본에서만 사용하는 지역 변수를 보고합니다.
&lt;p&gt;그러한 변수는 안전하게 인라인화하여 코드를 더 명확하게 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun sum(a: Int, b: Int): Int {
      val c = a + b
      return c
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun sum(a: Int, b: Int): Int {
      return a + b
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;&lt;b&gt;즉시 반환되거나 던져지는 변수 보고&lt;/b&gt; 옵션을 사용하면 즉시 반환되는 변수를 보고합니다.
    변수의 이름을 명시적으로 지정하면 코드 가시성이 개선되는 경우가 있기 때문에 이 옵션은 기본적으로 비활성화되어 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveEmptyClassBody" defaultSeverity="WEAK WARNING" displayName="빈 클래스 본문 바꾸기" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 빈 클래스 및 객체의 선언을 보고합니다.
&lt;p&gt;코드를 정리하려면 '불필요한 빈 클래스 본문 제거' 빠른 수정을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EmptyA() {} // &amp;lt;== 빈 본문

  class EmptyB {
      companion object {} // &amp;lt;== 빈 본문
  }

  fun emptyC() {
     object {} // &amp;lt;== 익명 객체, 문제 없음(보고되지 않음)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EmptyA()

  class EmptyB {
      companion object
  }

  fun emptyC() {
     object {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveEmptyClassBody&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantLambdaOrAnonymousFunction" defaultSeverity="WARNING" displayName="람다 또는 익명 함수의 중복 생성" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;즉시 생성하고 사용할 수 있는 람다 또는 익명 함수를 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;fun&lt;/b&gt; test() {
      ({ println() })() // 불필요
      (&lt;b&gt;fun&lt;/b&gt;() { println() })() // 불필요
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantLambdaOrAnonymousFunction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantEnumConstructorInvocation" defaultSeverity="WEAK WARNING" displayName="불필요한 열거형 생성자 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;열거형 항목에서 불필요한 생성자 호출을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum class Baz(i: Int = 0) {
      A(1),
      B&lt;b&gt;()&lt;/b&gt;,
      C&lt;b&gt;()&lt;/b&gt;,
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum class Baz(i: Int = 0) {
      A(1),
      B,
      C,
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantEnumConstructorInvocation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantEmptyInitializerBlock" defaultSeverity="WEAK WARNING" displayName="불필요한 빈 이니셜라이저 블록" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;불필요한 빈 이니셜라이저 블록을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      init {
          // 빈 init 블록
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantEmptyInitializerBlock&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantIf" defaultSeverity="WEAK WARNING" displayName="불필요한 'if' 문" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;하나의 구문으로 단순화할 수 있는 &lt;code&gt;if&lt;/code&gt; 문을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(): Boolean {
      if (foo()) {
         return true
      } else {
         return false
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(): Boolean {
      return foo()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantIf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantModalityModifier" defaultSeverity="WARNING" displayName="불필요한 모달리티 제어자" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
요소의 디폴트 모달리티와 일치하는 모달리티 제어자를 보고합니다(대부분 요소의 경우 &lt;code&gt;final&lt;/code&gt;, &lt;code&gt;override&lt;/code&gt;가 있는 멤버의 경우 &lt;code&gt;open&lt;/code&gt;).
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;final&lt;/b&gt; class Foo

  open class Bar : Comparable&amp;lt;Bar&amp;gt; {
      &lt;b&gt;open&lt;/b&gt; override fun compareTo(other: Bar): Int = 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo

  open class Bar : Comparable&amp;lt;Bar&amp;gt; {
      override fun compareTo(other: Bar): Int = 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantModalityModifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimpleRedundantLet" defaultSeverity="WARNING" displayName="불필요한 리시버 기반 'let' 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 리시버를 기반으로 하는 &lt;code&gt;let&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;빠른 수정에서는 불필요한 &lt;code&gt;let&lt;/code&gt; 호출을 제거합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(s: String?): Int? = s?.let { it.length }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(s: String?): Int? = s?.length
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SimpleRedundantLet&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantInnerClassModifier" defaultSeverity="WARNING" displayName="중복 'inner' 제어자" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스의 &lt;code&gt;inner&lt;/code&gt; 제어자가 외부 클래스의 멤버를 참조하지 않을 경우 불필요한 것으로 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      &lt;b&gt;inner&lt;/b&gt; class InnerClass { // 불필요한 'inner' 제어자
          fun hello() {
              println("Hi!")
          }
      }
  }

  class List {
      val objects = Array&amp;lt;Any&amp;gt;(42) { Any() }

      &lt;b&gt;inner&lt;/b&gt; class Iterator { // 필요한 'inner' 제어자
          fun next(): Any {
              return objects[0]
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      class InnerClass { // 불필요한 'inner' 제어자
          fun hello() {
              println("Hi!")
          }
      }
  }

  class List {
      val objects = Array&amp;lt;Any&amp;gt;(42) { Any() }

      &lt;b&gt;inner&lt;/b&gt; class Iterator { // 필요한 'inner' 제어자
          fun next(): Any {
              return objects[0]
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantInnerClassModifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantNullableReturnType" defaultSeverity="WARNING" displayName="중복된 null 가능한 반환 타입" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;null&lt;/code&gt;을 반환하지 않으며 null이 되지 않는 null 가능 반환 타입이 있는 함수 및 변수를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun greeting(user: String): String? = "Hello, $user!"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun greeting(user: String): String = "Hello, $user!"
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantNullableReturnType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveRedundantBackticks" defaultSeverity="WARNING" displayName="불필요한 백틱" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
참조에서 불필요한 백틱을 보고합니다.
&lt;p&gt;
    예를 들어 &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt; 같은 일부 Kotlin 키워드는 Java에서 유효한 식별자입니다.
    Java 라이브러리에서 Kotlin 키워드를 메서드에 사용하더라도 예를 들어 &lt;code&gt;foo.'is'(bar)&lt;/code&gt; 같은 백틱 문자(&lt;code&gt;'&lt;/code&gt;)를 사용해 이스케이프하여 메서드를 호출할 수 있습니다.
    이러한 이스케이프는 불필요할 때가 많으며 안전하게 생략할 수 있습니다. 검사는 그러한 경우를 발견하고 보고하며 강조 표시한 코드를 수정할 수 있는 '불필요한 백틱 제거' 빠른 수정이 함께 제공됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun 'is'(x: String) {}
  fun foo() {
      'is'("bar") // 'is'가 키워드이므로 백틱이 필요함
  }

  fun 'test that smth works as designed'() {} // 문제 없음. 가독성을 개선할 수 있는 복잡한 식별자

  val 'a' = 1  // 백틱이 필요 없음
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveRedundantBackticks&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantSamConstructor" defaultSeverity="WARNING" displayName="중복 SAM 생성자" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
람다로 바꿀 수 있는 단일 추상 메서드(SAM)의 사용을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      foo(&lt;b&gt;Runnable&lt;/b&gt; { println("Hi!") })
  }

  fun foo(other: Runnable) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      foo( { println("Hi!") })
  }

  fun foo(other: Runnable) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantSamConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantUnitReturnType" defaultSeverity="WARNING" displayName="불필요한 'Unit' 반환 타입" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
생략할 수 있는 불필요한 &lt;code&gt;Unit&lt;/code&gt; 반환 타입을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(): Unit {
      ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 &lt;code&gt;Unit&lt;/code&gt; 반환 타입을 제거합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantUnitReturnType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveRedundantQualifierName" defaultSeverity="WARNING" displayName="불필요한 한정자 이름" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스 이름, 함수 또는 프로퍼티에서 불필요한 한정자(또는 그 일부)를 보고합니다.
&lt;p&gt;
    정규화된 이름은 호출이 어떠한 객체, 함수 또는 프로퍼티를 참조하는지 지정하는 명확한 식별자입니다.
    이름을 단순화할 수 있는 컨텍스트에서 검사는 이름을 단순화할 수 있을 때 알리고, 관련된 '불필요한 한정자 이름 제거' 빠른 수정을 사용하면 코드를 수정할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package my.simple.name
  import kotlin.Int.Companion.MAX_VALUE

  class Foo

  fun main() {
      val a = my.simple.name.Foo()    // 선언된 'my.simple.name' 패키지에 'Foo'가 있으므로 한정자가 불필요합니다
      val b = kotlin.Int.MAX_VALUE    // 'MAX_VALUE'를 가져왔으므로 이로 바꿀 수 있습니다
      val c = kotlin.Double.MAX_VALUE // 기본 제공 타입을 자동으로 가져왔으므로 'Double.MAX_VALUE'로 바꿀 수 있습니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package my.simple.name
  import kotlin.Int.Companion.MAX_VALUE

  class Foo

  fun main() {
      val a = Foo()
      val b = MAX_VALUE
      val c = Double.MAX_VALUE
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveRedundantQualifierName&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveSetterParameterType" defaultSeverity="WARNING" displayName="불필요한 setter 매개변수 타입" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
프로퍼티 setter에서 명시적으로 지정된 매개변수를 보고합니다.
&lt;p&gt;
    setter 매개변수는 항상 프로퍼티 타입과 일치하므로 명시적일 필요가 없습니다.
    '명시적 타입 사양 제거' 빠른 수정을 사용하면 코드를 적절히 수정할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun process(x: Int) {}

  var x: Int = 0
      set(value: Int) = process(value) // &amp;lt;== 'Int' 사양은 안전하게 생략할 수 있습니다
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun process(x: Int) {}

  var x: Int = 0
      set(value) = process(value)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveSetterParameterType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveSingleExpressionStringTemplate" defaultSeverity="WARNING" displayName="불필요한 문자열 템플릿" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전하게 제거할 수 있는 단일 표현식 문자열 템플릿을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  val x = "Hello"
  val y = "$x"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  val x = "Hello"
  val y = x // &amp;lt;== 업데이트됨
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveSingleExpressionStringTemplate&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantValueArgument" defaultSeverity="WEAK WARNING" displayName="불필요한 값 인수" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
해당 매개변수의 디폴트 값과 동일한 인수를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(x: Int, y: Int = 2) {}

fun bar() {
    foo(1, 2)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun bar() {
    foo(1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantValueArgument&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifyWhenWithBooleanConstantCondition" defaultSeverity="WEAK WARNING" displayName="'when' 단순화 가능" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 상수 브랜치를 포함하는 &lt;code&gt;when&lt;/code&gt; 식을 보고합니다.
&lt;p&gt;&lt;b&gt;'when' 단순화&lt;/b&gt; 빠른 수정을 사용해 코드를 자동으로 수정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundant() {
      when { // &amp;lt;== 불필요. 빠른 수정에서는 when 식을 'println("true")'로 단순화합니다
          true -&gt; println("true")
          else -&gt; println("false")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SimplifyWhenWithBooleanConstantCondition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantWith" defaultSeverity="WEAK WARNING" displayName="불필요한 'with' 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
리시버에서 아무것도 액세스하지 않는 불필요한 &lt;code&gt;with&lt;/code&gt; 함수 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
      fun f(): String = ""
  }

  fun testRedundant() {
      with(c) { // &amp;lt;== 'c'가 사용되지 않으므로 'with'는 불필요
          println("1")
      }
  }

  fun testOk() {
      val c = MyClass()
      with(c) { // &amp;lt;== 'f()'가 실질적으로 'c.f()'이므로 문제 없음
          println(f())
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantWith&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantInterpolationPrefix" defaultSeverity="WEAK WARNING" displayName="불필요한 보간 접두사" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자열 템플릿 표현식 내의 불필요한 달러 기호 접두사를 보고합니다.
&lt;p&gt;
이러한 접두사는 안전하게 제거될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
예:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun example() {
    $"예: 길이가 1인 접두사는 항상 불필요합니다"
    $$"예: 문자열에 보간된 값이 없습니다"
    $$"예: 평문으로 된 $$ 달러 기호입니다 $$"
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun example() {
    "예: 길이가 1인 접두사는 항상 불필요합니다"
    "예: 문자열에 보간된 값이 없습니다"
    "예: 평문으로 된 $$ 달러 기호입니다 $$"
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantInterpolationPrefix&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantElvisReturnNull" defaultSeverity="WARNING" displayName="불필요한 '?: return null'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;불필요한 &lt;code&gt;?: return null&lt;/code&gt;을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): Int? {
      ...
  }

  fun test() : Int? {
      return foo() &lt;b&gt;?: return null&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): Int? {
      ...
  }

  fun test() : Int? {
      return foo()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantElvisReturnNull&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantSemicolon" defaultSeverity="WARNING" displayName="불필요한 세미콜론" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
    안전하게 제거할 수 있는 불필요한 세미콜론(&lt;code&gt;;&lt;/code&gt;)을 보고합니다.
&lt;p&gt;
    Kotlin에서는 각 구문 또는 표현식 끝에 세미콜론을 붙일 필요가 없습니다.
    빠른 수정에서는 불필요한 세미콜론을 제거할 것을 제안합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val myMap = mapOf("one" to 1, "two" to 2);
  myMap.forEach { (key, value) -&gt;  print("$key -&gt; $value")};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val myMap = mapOf("one" to 1, "two" to 2)
  myMap.forEach { (key, value) -&gt;  print("$key -&gt; $value")}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하지만 다음 두 경우에는 세미콜론이 필요합니다.&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;
        한 줄에 여러 구문이 포함된 경우 각 구문을 세미콜론으로 구분해야 합니다.
&lt;pre&gt;&lt;code&gt;
  map.forEach { val (key, value) = it; println("$key -&gt; $value") }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    &lt;li&gt;
        프로퍼티 또는 함수를 선언하는 &lt;code&gt;enum&lt;/code&gt; 클래스에는 열거형 상수 목록 뒤에 세미콜론이 필요합니다.
        &lt;pre&gt;&lt;code&gt;
  enum class Mode {
      SILENT, VERBOSE;

      fun isSilent(): Boolean = this == SILENT
  }
        &lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
&lt;/ol&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantSemicolon&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinRedundantOverride" defaultSeverity="WEAK WARNING" displayName="불필요한 재정의하는 메서드" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 재정의 선언을 보고합니다.
&lt;p&gt;
    예를 들어 재정의가 가시성을 변경하는 등의 작업으로 상속된 시그니처 의미를 변경하지 않는다면 재정의를 생략할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;open class&lt;/b&gt; Foo {
      open fun singleExpression() {
      }
  }

  class Bar : Foo() {
      &lt;b&gt;override&lt;/b&gt; fun singleExpression() = super.singleExpression()
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar : Foo() {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KotlinRedundantOverride&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WhenWithOnlyElse" defaultSeverity="WEAK WARNING" displayName="'when'에 'else' 브랜치만 있으므로 단순화 가능" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단순화할 수 있는 &lt;code&gt;else&lt;/code&gt; 브랜치만 포함하는 &lt;code&gt;when&lt;/code&gt; 식을 보고합니다.
&lt;p&gt;&lt;b&gt;표현식 단순화&lt;/b&gt; 빠른 수정을 사용해 코드를 자동으로 수정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundant() {
      val x = when { // &amp;lt;== 불필요. 빠른 수정에서는 when 식을 'val x = 1'로 단순화합니다
          else -&gt; 1
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: WhenWithOnlyElse&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantConstructorKeyword" defaultSeverity="WEAK WARNING" displayName="불필요한 'constructor' 키워드" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;기본 생성자의 불필요한 'constructor' 키워드를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo &lt;b&gt;constructor&lt;/b&gt;(x: Int, y: Int)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo(x: Int, y: Int)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantConstructorKeyword&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantSuspendModifier" defaultSeverity="WARNING" displayName="불필요한 'suspend' 제어자" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 suspend 함수가 내부에서 호출되지 않은 경우 &lt;code&gt;suspend&lt;/code&gt; 제어자가 불필요한 것으로 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantSuspendModifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IfThenToSafeAccess" defaultSeverity="WEAK WARNING" displayName="대입과 결합할 수 있습니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
safe-access(&lt;code&gt;?.&lt;/code&gt;) 식으로 접을 수 있는 &lt;code&gt;if-then&lt;/code&gt; 식을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun bar(x: String) = ""

  fun foo(a: String?) {
     if (a != null) bar(a) else null
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 &lt;code&gt;if-then&lt;/code&gt; 식을 safe-access(&lt;code&gt;?.&lt;/code&gt;) 식으로 변환합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun bar(x: String) = ""

  fun foo(a: String?) {
     a?.let { bar(it) }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IfThenToSafeAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="VariableInitializerIsRedundant" defaultSeverity="WARNING" displayName="불필요한 변수 이니셜라이저" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
로컬 변수의 불필요한 이니셜라이저를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      var local = 42 // 이니셜라이저가 불필요합니다
      local = 0
      println(local)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: VariableInitializerIsRedundant&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantExplicitType" defaultSeverity="WARNING" displayName="명백한 명시적 타입" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;code&gt;val f: Foo = Foo()&lt;/code&gt;와 같이 명백하여 불필요하게 명시적으로 지정된 지역 변수의 타입을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Point(val x: Int, val y: Int)

  fun foo() {
      val t: &lt;b&gt;Boolean&lt;/b&gt; = true
      val p: &lt;b&gt;Point&lt;/b&gt; = Point(1, 2)
      val i: &lt;b&gt;Int&lt;/b&gt; = 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Point(val x: Int, val y: Int)

  fun foo() {
      val t = true
      val p = Point(1, 2)
      val i = 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantExplicitType&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantVisibilityModifier" defaultSeverity="WARNING" displayName="불필요한 가시성 제어자" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
요소(대부분의 요소에서는 &lt;code&gt;public&lt;/code&gt;, protected 멤버를 재정의하는 멤버에서는 &lt;code&gt;protected&lt;/code&gt;)의
디폴트 가시성과 일치하는 가시성 제어자를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantVisibilityModifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ExplicitThis" defaultSeverity="INFORMATION" displayName="중복 명시적 this'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
명시적 &lt;code&gt;this&lt;/code&gt;가 생략 가능한 경우 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
      private val i = 1
      fun f() = this.i
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정에서는 불필요한 &lt;code&gt;this&lt;/code&gt;를 제거합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
      private val i = 1
      fun f() = i
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ExplicitThis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantUnitExpression" defaultSeverity="WARNING" displayName="불필요한 'Unit'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 &lt;code&gt;Unit&lt;/code&gt; 식을 보고합니다.
&lt;p&gt;
    Kotlin의 &lt;code&gt;Unit&lt;/code&gt;은 유의미한 것을 반환하지 않는 함수의 반환 타입으로 사용할 수 있습니다.
    &lt;code&gt;Unit&lt;/code&gt; 타입에서 가능한 값은 &lt;code&gt;Unit&lt;/code&gt; 객체 하나뿐입니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundantA(): Unit {
      return Unit // 불필요. 기본적으로 'Unit'이 반환되며 예상되는 반환 타입과 일치합니다
  }

  fun requiredA(condition: Boolean): Any {
      if (condition) return "hello"
      return Unit // 필요한 타입이 'Any'이므로 명시적 'Unit'이 필요합니다
  }

  fun redundantB(condition: Boolean): Any = if (condition) {
      fun ancillary(): Int = 1
      println("${ancillary()}")
      Unit // 마지막 표현식의 타입이 이미 'Unit'이므로 불필요합니다
  } else {
      println("else")
  }

  fun requiredB(condition: Boolean): Any = if (condition) {
      1024
      Unit // 필요. 없으면 '1024'(Int)가 반환 값이 됩니다
  } else {
      println("else")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantUnitExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantReturnLabel" defaultSeverity="WEAK WARNING" displayName="중복 'return' 라벨" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;람다 식 외부에 있는 불필요한 반환 라벨을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      return@test
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      return
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantReturnLabel&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveRedundantCallsOfConversionMethods" defaultSeverity="WARNING" displayName="불필요한 변환 메서드 호출" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
변환 메서드에 대한 불필요한 호출(예: &lt;code&gt;String&lt;/code&gt;에 있는 &lt;code&gt;toString()&lt;/code&gt; 또는 &lt;code&gt;Double&lt;/code&gt;에 있는 &lt;code&gt;toDouble()&lt;/code&gt;)을 보고합니다.
&lt;p&gt;코드를 정리하려면 '불필요한 변환 메서드 호출 제거' 빠른 수정을 사용하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveRedundantCallsOfConversionMethods&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ControlFlowWithEmptyBody" defaultSeverity="WARNING" displayName="본문이 비어 있는 제어 흐름" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 빈 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt; 또는 &lt;code&gt;for&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;의도적일 때가 가끔 있지만 이러한 구조는 혼란을 초래할 수 있으며 종종 오타가 난 결과입니다.&lt;/p&gt;
&lt;p&gt;빠른 수정에서는 구문을 제거합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (a &amp;gt; b) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ControlFlowWithEmptyBody&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantLabeledReturnOnLastExpressionInLambda" defaultSeverity="INFORMATION" displayName="람다의 마지막 표현식에 대해 불필요한 라벨 지정된 return" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
람다 내 마지막 표현식에서 사용된 라벨 지정된 반환을 보고합니다.

&lt;p&gt;그러한 반환은 불필요하며 안전하게 제거할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo() {
  listOf(1,2,3).find {
    return@find true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo() {
  listOf(1,2,3).find {
    true
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantLabeledReturnOnLastExpressionInLambda&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantCompanionReference" defaultSeverity="WARNING" displayName="불필요한 'Companion' 참조" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;불필요한 &lt;code&gt;Companion&lt;/code&gt; 참조를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
      &lt;b&gt;companion object&lt;/b&gt; {
          fun create() = A()
      }
  }
  fun test() {
      val s = A.&lt;b&gt;Companion&lt;/b&gt;.create()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
      &lt;b&gt;companion object&lt;/b&gt; {
          fun create() = A()
      }
  }
  fun test() {
      val s = A.create()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RedundantCompanionReference&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedReceiverParameter" defaultSeverity="WARNING" displayName="사용되지 않는 리시버 매개변수" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
사용되지 않는 확장 함수와 프로퍼티의 리시버 매개변수를 보고합니다.
&lt;p&gt;&lt;b&gt;불필요한 리시버 매개변수 제거&lt;/b&gt;를 사용해 코드를 자동으로 수정할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnusedReceiverParameter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveToStringInStringTemplate" defaultSeverity="WEAK WARNING" displayName="문자열 템플릿 내 불필요한 'toString()' 호출 제거" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전하게 제거할 수 있는 문자열 템플릿에서의 &lt;code&gt;toString()&lt;/code&gt; 호출을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun foo(a: Int, b: Int) = a + b

  fun test(): String {
      return "Foo: ${foo(0, 4).toString()}" // 'toString()'은 불필요합니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun foo(a: Int, b: Int) = a + b

  fun test(): String {
      return "Foo: ${foo(0, 4)}"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveToStringInStringTemplate&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveExplicitSuperQualifier" defaultSeverity="WEAK WARNING" displayName="불필요한 상위 타입 정규화" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 상위 타입 정규화를 포함하는 &lt;code&gt;super&lt;/code&gt; 멤버를 보고합니다.
&lt;p&gt;
    파생 클래스의 코드는 &lt;code&gt;super&lt;/code&gt; 키워드를 사용하는 상위 클래스 함수 및 프로퍼티 접근자 구현을 호출할 수 있습니다.
    상속받은 구현이 유래한 상위 타입을 지정하려면 예를 들어 &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; 같은 대괄호 내 상위 타입 이름으로 &lt;code&gt;super&lt;/code&gt;를 정규화할 수 있습니다. 이 정규화는 종종 불필요하며 생략할 수 있습니다.
    코드를 정리하려면 '명시적 상위 타입 정규화 제거' 빠른 수정을 사용하세요.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  open class B {
      open fun foo(){}
  }

  class A : B() {
      override fun foo() {
         super&amp;lt;B&amp;gt;.foo() // &amp;lt;== 'B'가 유일한 상위 타입이므로 불필요
      }
  }

  interface I {
      fun foo() {}
  }

  class C : B(), I {
      override fun foo() {
          super&amp;lt;B&amp;gt;.foo() // &amp;lt;== 여기에서 'B.foo()'와 'I.foo()'를 구분하기 위해 &amp;lt;B&amp;gt; 한정자가 필요합니다
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  open class B {
      open fun foo(){}
  }

  class A : B() {
      override fun foo() {
         super.foo() // &amp;lt;== 업데이트됨
      }
  }

  interface I {
      fun foo() {}
  }

  class C : B(), I {
      override fun foo() {
          super&amp;lt;B&amp;gt;.foo()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveExplicitSuperQualifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveEmptyParenthesesFromLambdaCall" defaultSeverity="WEAK WARNING" displayName="람다가 있는 함수 호출에서 불필요한 소괄호" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
유일한 매개변수인 람다가 소괄호 밖에 있는 함수 호출에서 불필요한 빈 소괄호를 보고합니다.
&lt;p&gt;코드를 정리하려면 '람다를 포함한 함수 호출에서 불필요한 소괄호 제거' 빠른 수정을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      listOf(1).forEach() {  }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      listOf(1).forEach {  }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveEmptyParenthesesFromLambdaCall&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinDoubleNegation" defaultSeverity="WEAK WARNING" displayName="불필요한 이중 부정" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 이중 부정을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  val truth = !!true&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KotlinDoubleNegation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CanUnescapeDollarLiteral" defaultSeverity="WEAK WARNING" displayName="문자열 리터럴 내 불필요한 이스케이프 처리된 달러 문자" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자열 내에서 일반적인 리터럴로 대체될 수 있는 이스케이프된 달러 문자를 보고합니다.
&lt;p&gt;
    이스케이프는 달러 이후의 콘텐츠가 문자열 보간 항목으로 잘못 해석될 수 있는 경우에만 필요합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
    "The price today is \$10. The price tomorrow will be ${'$'}20."
  }
&lt;/code&gt;&lt;/pre&gt;
빠른 수정이 안전하게 바꿀 수 있는 이스케이프된 달러 문자를 모두 일반적인 달러 문자로 변환합니다.
&lt;pre&gt;&lt;code&gt;
  fun example() {
    "The price today is $10. The price tomorrow will be $20."
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CanUnescapeDollarLiteral&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveExplicitTypeArguments" defaultSeverity="WEAK WARNING" displayName="불필요한 타입 인수" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
자동으로 추론할 수 있는 타입 인수를 포함하는 함수 호출을 보고합니다. 그러한 타입 인수는 불필요하며 안전하게 생략할 수 있습니다.
&lt;p&gt;코드를 정리하려면 '명시적 타입 인수 제거' 빠른 수정을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 여기서는 'String' 타입을 추론할 수 있습니다
  fun foo(): MutableList&amp;lt;String&amp;gt; = mutableListOf&amp;lt;String&amp;gt;()

  // 여기서는 'String'을 추론할 수 없으며 타입 인수가 필요합니다.
  fun bar() = mutableListOf&amp;lt;String&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): MutableList&amp;lt;String&amp;gt; = mutableListOf() &amp;lt;== 업데이트됨

  fun bar() = mutableListOf&amp;lt;String&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: RemoveExplicitTypeArguments&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedVariable" defaultSeverity="WARNING" displayName="사용되지 않는 변수" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이 검사는 사용되지 않는 변수를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnusedVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinUnusedImport" defaultSeverity="WARNING" displayName="사용되지 않는 import 지시문" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요한 &lt;code&gt;import&lt;/code&gt; 문을 보고합니다.

&lt;p&gt;디폴트 및 사용되지 않는 import 문은 안전하게 제거할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import kotlin.*
  import kotlin.collections.*
  import kotlin.comparisons.*
  import kotlin.io.*
  import kotlin.ranges.*
  import kotlin.sequences.*
  import kotlin.text.*

  // jvm 전용
  import java.lang.*
  import kotlin.jvm.*

  // js 전용
  import kotlin.js.*

  import java.io.* // 이 import는 사용되지 않으므로 제거해도 됩니다
  import java.util.*

  fun foo(list: ArrayList&amp;lt;String&amp;gt;) {
      list.add("")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: KotlinUnusedImport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="기타" path="Groovy"><inspection shortName="TypeCustomizer" defaultSeverity="WARNING" displayName="타입 커스터마이저 검사" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;사용자 지정 타입 검사기일 수 있지만 아직 컴파일러 리소스에 추가되지 않은 파일을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeCustomizer&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GrMethodMayBeStatic" defaultSeverity="WARNING" displayName="메서드를 'static'으로 만들 수 있음" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
안전하게 &lt;code&gt;static&lt;/code&gt;으로 만들 수 있는 메서드를 보고합니다.
&lt;p&gt;
  &lt;code&gt;synchronized&lt;/code&gt;되지 않는 메서드는 &lt;code&gt;static&lt;/code&gt; 메서드일 수 있고, 자신의 클래스 인스턴스 메서드 및 인스턴스 필드를 참조하지 않으며, 하위 클래스에서 재정의되지 않습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GrMethodMayBeStatic&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="데이터 흐름" path="Java"><inspection shortName="JvmNullDereferenceAnalysis.Local" defaultSeverity="WARNING" displayName="RML-based null dereference analysis" enabled="false" language="JVM" pluginId="com.intellij.jvm.dfa.analysis" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;이 검사는 null일 수 있는 포인터의 역참조로 이어지는 복잡한 데이터 흐름 경로를 식별하도록 설계되었습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JvmNullDereferenceAnalysis.Local&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantValueVariableUse" defaultSeverity="WARNING" displayName="값이 상수로 알려진 변수 사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상수로 알려진 변수의 모든 사용 위치를 보고합니다.
&lt;p&gt;이는 변수의 사용(읽기) 위치를 변수를 상수와 비교하는 &lt;code&gt;==&lt;/code&gt; 조건을 포함하는 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;for&lt;/code&gt; 문으로 둘러싸는 경우를 말합니다.
  이 경우 상수로 알려진 변수의 사용 위치는 실제 상수로 바꿀 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private static void foo(double number) {
        if (number == 1.0) {
            f(number);
        }
    }
    private static void f(double number) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private static void foo(double number) {
        if (number == 1.0) {
            f(1.0);
        }
    }
    private static void f(double number) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ConstantValueVariableUse&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JvmDfaAnalysis.Global" defaultSeverity="WARNING" displayName="RML 기반 분석(전역)" enabled="false" language="JVM" pluginId="com.intellij.jvm.dfa.analysis" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Java를 위한 RML 기반 전역 분석
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JvmDfaAnalysis.Global&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLocalVariable" defaultSeverity="WARNING" displayName="중복 지역 변수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다음과 같이 메서드의 이해에 아무 도움이 되지 않는 불필요한 지역 변수를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;즉시 반환되는 지역 변수.&lt;/li&gt;
  &lt;li&gt;다른 변수로 즉시 대입된 후에 더 이상 사용되지 않는 지역 변수.&lt;/li&gt;
  &lt;li&gt;다른 지역 변수 또는 매개변수와 항상 같은 값을 가지는 지역 변수.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean yes() {
    boolean b = true;
    return b;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean yes() {
    return true;
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;즉시 반환되거나 던져지는 변수 무시&lt;/b&gt; 옵션을 사용하여 즉시 반환되거나 던져지는 변수를 무시합니다.
    일부 코드 스타일에서는 명확도와 디버그 용이성을 위해 그러한 변수를 사용할 것을 제안합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;어노테이션을 가진 변수 무시&lt;/b&gt; 옵션을 사용하여 주석이 추가된 변수를 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UnnecessaryLocalVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanVariableAlwaysNegated" defaultSeverity="WARNING" displayName="부울 변수가 항상 반전됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
값이 사용되면 항상 부정되는 boolean 변수 또는 필드를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
      void m() {
        boolean b = true; //boolean 변수 'b'가 항상 반전됩니다
        System.out.println(!b);
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: BooleanVariableAlwaysNegated&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReuseOfLocalVariable" defaultSeverity="INFORMATION" displayName="지역 변수 재사용" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
값을 원래 용도와 관련 없는 새 값으로 덮어쓰면서 '재사용되는' 지역 변수를 보고합니다.
&lt;p&gt;지역 변수의 의도된 의미는 사용 위치에 따라 다를 수 있으므로 이러한 지역 변수를 재사용하면 혼동될 수 있습니다. 코드 변경으로 인해 덮어쓰인 것으로 간주된 값이 실제로 활성 상태인 것으로 보이는 경우 값이 버그에 취약할 수 있습니다. 변수의 수명을 가능한 한 짧게 유지하고 코드 간결성을 위해 지역 변수를 재사용하지 않는 것이 좋습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void x() {
        String s = "one";
        System.out.println("s = " + s);
        s = "two"; // 지역 변수 's' 재사용
        System.out.println("s = " + s);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ReuseOfLocalVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LawOfDemeter" defaultSeverity="WARNING" displayName="데메테르의 법칙" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;a href="https://en.wikipedia.org/wiki/Law_of_Demeter"&gt;데메테르의 법칙&lt;/a&gt;을 위반하는 경우를 보고합니다.
&lt;p&gt;
데메테르의 법칙은 실제로 법칙은 아니지만, 다른 호출로부터 받은 객체에서 메서드를 호출하지 않도록 스타일 가이드라인을 지정하고 있습니다.
이 가이드라인을 따르는 코드는 유지 관리, 조정, 리팩터링이 쉬우며 메서드 간의 결합 및 중복이 적고 정보 숨기기가 간편합니다. 이 가이드라인을 준수하려면 여러 래퍼 메서드를 작성해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean pay(Customer c, Invoice invoice) {
    int dollars = c.getWallet().contents; // 위반
    if (dollars &gt;= invoice.getAmount()) {
      Wallet w = c.getWallet();
      w.subtract(invoice.getAmount()); // 위반
      return true;
    }
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
위의 예는 &lt;code&gt;Customer&lt;/code&gt;의 &lt;code&gt;payInvoice(Invoice invoice)&lt;/code&gt; 메서드로 더 잘 구현할 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;b&gt;라이브러리 메서드 호출 및 라이브러리 필드 액세스 무시&lt;/b&gt; 옵션을 사용하여, 라이브러리를 변경하지 않고는 수정할 수 없는 데메테르의 법칙 위반을 무시합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: LawOfDemeter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegativelyNamedBooleanVariable" defaultSeverity="WARNING" displayName="부정적으로 이름 지정된 부울 변수" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;disabled&lt;/code&gt;, &lt;code&gt;hidden&lt;/code&gt; 또는 &lt;code&gt;isNotChanged&lt;/code&gt;와 같은 부정적인 이름의 변수를 보고합니다.
&lt;p&gt;보통 &lt;code&gt;boolean&lt;/code&gt; 값을 반전하고 이름의 부정을 제거하면 코드를 이해하기 쉬워집니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    boolean disabled = false;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NegativelyNamedBooleanVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanMethodIsAlwaysInverted" defaultSeverity="WARNING" displayName="bool 메서드가 항상 반전됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
호출되는 경우 항상 부정되는 &lt;code&gt;boolean&lt;/code&gt; 반환 타입을 가진 메서드를 보고합니다.
&lt;p&gt;메서드를 반전시키고 선택적으로 이름을 바꾸는 빠른 수정이 제공됩니다.
  성능상의 이유로, 문제가 있는 일부 메서드가 에디터에서 강조 표시되지 않을 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    boolean alwaysTrue() {
      return true;
    }

    void f() {
      if (!alwaysTrue()) {
        return;
      }
    }
    boolean member = !alwaysTrue();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    boolean alwaysFalse() {
      return false;
    }

    void f() {
      if (alwaysFalse()) {
        return;
      }
    }
    boolean member = alwaysFalse();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BooleanMethodIsAlwaysInverted&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JvmDfaAnalysis.Local" defaultSeverity="WARNING" displayName="RML 기반 분석(지역)" enabled="false" language="JVM" pluginId="com.intellij.jvm.dfa.analysis" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
로컬 RML 기반의 Java 분석
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JvmDfaAnalysis.Local&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TooBroadScope" defaultSeverity="INFORMATION" displayName="변수의 범위가 너무 넓음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
더 작은 범위로 이동할 수 있는 모든 변수 선언을 보고합니다.
&lt;p&gt;이 검사는 주로 메서드 시작 부분의 &lt;i&gt;Pascal 형식&lt;/i&gt; 선언에 유용합니다. 또한 너무 광범위한 범위를 가진 변수도 리팩터링 후에 남는 경우가 많습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  StringBuilder sb = new StringBuilder();
  System.out.println();
  sb.append(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println();
  StringBuilder sb = new StringBuilder();
  sb.append(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;내부 블록으로 이동할 수 있는 변수만 보고&lt;/b&gt; 옵션을 사용하여 더 깊은 코드 블록을 이동할 수 있는 변수만을 보고합니다.
    예를 들어, 옵션이 활성화되면 위의 &lt;code&gt;sb&lt;/code&gt; 변수에 대한 이동이 제안되지 않습니다.
    그러나 다음의 코드에 대해서는 제안됩니다.
&lt;pre&gt;&lt;code&gt;
  StringBuilder sb = new StringBuilder(a);
  if (flag) {
    sb.append(1);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;new 식을 이니설라이저로 가진 변수 보고(잠재적으로 안전하지 않음)&lt;/b&gt; 옵션을 사용하여 new 식으로 초기화되는 변수를 보고합니다. 이 경우 생성자에 비 로컬 측의 부수 효과가 있을 때 검사가 잠재적으로 안전하지 않게 됩니다. 예를 들어, 옵션이 활성화되면 &lt;code&gt;foo&lt;/code&gt; 변수에 대한 이동이 제안됩니다.
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static List&amp;lt;Foo&amp;gt; fooList = new ArrayList&amp;lt;&amp;gt;();
    String bar;

    Foo(String bar) {
        this.bar = bar;
        fooList.add(this);
    }

    public static void main(String[] args) {
      // 안전하지 않은 경우에도 이동 가능
      Foo foo = new Foo("bar");
      System.out.println(fooList.size());
      System.out.println(foo.bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TooBroadScope&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="PostgreSQL" path=""><inspection shortName="PgSelectFromProcedureInspection" defaultSeverity="WARNING" displayName="Postgres: 프로시저 호출에서 선택" enabled="false" language="SQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
타입이 있는 별칭(예: &lt;code&gt;AS t1(s VARCHAR)&lt;/code&gt;) 없이 함수나 DBLINK를 대상으로 SELECT를 만드는 경우를 보고합니다.
  &lt;p&gt;이 요구 조건은 스칼라 함수에는 적용되지 않습니다.&lt;/p&gt;
&lt;p&gt;예시(PostgreSQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE FUNCTION produce_a_table() RETURNS RECORD AS $$
SELECT 1;
$$ LANGUAGE sql;
SELECT * FROM produce_a_table() AS s (c1 INT);
SELECT * FROM produce_a_table() AS s (c1);
SELECT * FROM DBLINK('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc') AS t1;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AS s (c1 INT) &lt;/code&gt;에는 타입 별칭이 있지만 &lt;code&gt;AS s (c1)&lt;/code&gt; 및 &lt;code&gt;AS t1&lt;/code&gt;에는 타입 별칭이 없습니다.
  이 경우, 두 번째 &lt;code&gt;produce_a_table()&lt;/code&gt; 호출 및 &lt;code&gt;DBLINK()&lt;/code&gt;가 강조 표시됩니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: PgSelectFromProcedureInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Flow 타입 검사기" path="JavaScript 및 TypeScript"><inspection shortName="FlowJSConfig" defaultSeverity="WARNING" displayName=".flowconfig 누락" enabled="false" language="Flow JS" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
프로젝트 내에 관련 &lt;code&gt;.flowconfig&lt;/code&gt; 파일이 없지만 &lt;code&gt;@flow&lt;/code&gt; 플래그를 포함하는 JavaScript 파일을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FlowJSConfig&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FlowJSFlagCommentPlacement" defaultSeverity="WARNING" displayName="잘못된 위치에 사용된 @flow 태그" enabled="false" language="Flow JS" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
파일 맨 위에 위치하지 않는 &lt;code&gt;@flow&lt;/code&gt; 플래그 주석을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: FlowJSFlagCommentPlacement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Testing" path=""><inspection shortName="AndroidLintIgnoreWithoutReason" defaultSeverity="WARNING" displayName="@Ignore without Reason" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;@Ignore without Reason&lt;br&gt;&lt;br&gt;Ignoring a test without a reason makes it difficult to figure out the problem later. Please define an explicit reason why it is ignored, and when it can be resolved.&lt;br&gt;&lt;br&gt;Issue id: IgnoreWithoutReason&lt;br&gt;&lt;br&gt;Available options:&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;allow-comments&lt;/b&gt; (default is true):&lt;br/&gt;
Whether to allow a comment next to the @Ignore tag to be considered providing a reason.&lt;br/&gt;
&lt;br/&gt;
Normally you have to specify an annotation argument to the &lt;code&gt;@Ignore&lt;/code&gt; annotation, but with this option you can configure whether it should also allow ignore reasons to specified by a comment adjacent to the ignore tag.&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="IgnoreWithoutReason"&gt;
        &amp;lt;option name="allow-comments" value="true" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="MySQL" path=""><inspection shortName="MysqlSpaceAfterFunctionNameInspection" defaultSeverity="ERROR" displayName="함수 이름 내의 공백 및 열린 소괄호" enabled="false" language="MySQL" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
기본적으로 지원되지 않는 함수 이름과 여는 소괄호 사이에 있는 함수 호출의 공백을 보고합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT MAX (qty) FROM orders;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MysqlSpaceAfterFunctionNameInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MysqlLoadDataPathInspection" defaultSeverity="WARNING" displayName="LOAD 문 경로" enabled="false" language="MySQL based" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
LOAD 구문 내 물결표 문자로 시작하는 경로를 보고합니다.
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code lang="mysql"&gt;CREATE TABLE table_name (id int);
LOAD DATA LOCAL INFILE '~/Documents/some_file.txt'
INTO TABLE table_name FIELDS TERMINATED BY ',' LINES TERMINATED BY '\n'
IGNORE 1 LINES;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물결표 문자 대신 전체 파일 경로를 사용하세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MysqlLoadDataPathInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MysqlParsingInspection" defaultSeverity="WARNING" displayName="8.0 이전 버전에서 지원되지 않는 구문" enabled="false" language="MySQL based" pluginId="com.intellij.database" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
쿼리 내 UNION의 유효하지 않은 사용 위치를 보고합니다.
&lt;p&gt;이 검사는 MySQL 8.0 이전 버전에서 작동합니다.&lt;/p&gt;
&lt;p&gt;예시(MySQL):&lt;/p&gt;
&lt;pre&gt;&lt;code lang="mysql"&gt;
SELECT * FROM (SELECT 1 UNION (SELECT 1 UNION SELECT 2)) a;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MysqlParsingInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="클래스 메트릭" path="Java"><inspection shortName="ConstructorCount" defaultSeverity="WARNING" displayName="생성자가 너무 많은 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
생성자 개수가 지정된 최댓값을 초과하는 클래스를 보고합니다.
&lt;p&gt;생성자가 너무 많은 클래스는 초기화 오류가 발생하기 쉽습니다. 종종 이러한 클래스는 여러 하위 클래스로 모델링하는 것이 좋습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;생성자 수 제한&lt;/b&gt; 필드를 사용하여 클래스에서 허용되는 최대 생성자 수를 지정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;지원 중단되는 생성자 무시&lt;/b&gt; 옵션을 사용하여 곧 사용할 수 없게 될 생성자가 총 개수에 추가되지 않게 방지합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConstructorCount&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodCount" defaultSeverity="WARNING" displayName="메서드가 너무 많은 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
메서드 수가 지정된 최댓값을 초과하는 클래스를 보고합니다.
&lt;p&gt;메서드가 너무 많은 클래스는 종종 '너무 많은 처리'를 시도합니다. 이러한 클래스를 더 작은 여러 클래스로 분할해보세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;메서드 수 제한&lt;/b&gt; 필드를 사용하여 클래스에서 허용되는 최대 메서드 수를 지정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;간단한 getter 및 setter 메서드 무시&lt;/b&gt; 옵션을 사용하여 메서드 수에서 간단한 getter 및 setter 메서드를 무시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;상위 메서드를 재정의/구현하는 메서드 무시&lt;/b&gt;를 사용하여 상위 클래스의 메서드를 재정의하거나 구현하는
    메서드를 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MethodCount&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousClassMethodCount" defaultSeverity="WARNING" displayName="메서드가 너무 많은 익명 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스 내 메서드 총 개수가 지정된 최댓값을 초과하는 익명의 내부 클래스를 보고합니다.
&lt;p&gt;여러 가지 메서드가 포함된 익명 클래스는 이해하기 어려울 수 있으므로 명명된 내부 클래스가 되도록 승격시켜야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;메서드 수 제한&lt;/b&gt; 필드를 사용하여 익명의 내부 클래스에서 허용되는 최대 메서드 수를 지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AnonymousClassMethodCount&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassNestingDepth" defaultSeverity="WARNING" displayName="내부 클래스가 너무 깊게 중첩" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
중첩된 내부 클래스의 수가 지정된 최댓값을 초과하는 클래스를 보고합니다.
&lt;p&gt;다른 내부 클래스 내에서 중첩된 내부 클래스는 혼란을 주며 리팩터링이 필요할 수 있음을 나타냅니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;중첩 제한&lt;/b&gt; 필드를 사용하여 클래스에 허용되는 최대 중첩 깊이를 지정합니다.&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassNestingDepth&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassCoupling" defaultSeverity="WARNING" displayName="지나치게 결합된 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
너무 많은 다른 클래스를 참조하는 클래스를 보고합니다.
&lt;p&gt;결합이 너무 지나친 클래스는 매우 취약할 수 있으며, 더 작은 클래스로 분할해야 할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;클래스 결합 제한&lt;/b&gt; 필드를 사용하여 클래스에 허용되는 최대 결합을 지정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;Java 시스템 클래스에 대한 결합 포함&lt;/b&gt; 옵션을 사용하여 시스템 클래스에 대한 참조(&lt;code&gt;java.&lt;/code&gt; 또는 &lt;code&gt;javax.&lt;/code&gt; 패키지의 참조)를 집계해야 하는지 여부를 지정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;라이브러리 클래스에 대한 결합 포함&lt;/b&gt; 옵션을 사용하여 라이브러리 클래스에 대한 참조를 집계해야 하는지 여부를 지정합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassCoupling&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousClassComplexity" defaultSeverity="WARNING" displayName="지나치게 복잡한 익명 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
총 복잡도가 지정된 최댓값을 초과하는 익명의 내부 클래스를 보고합니다.
&lt;p&gt;클래스의 총 복잡도는 클래스가 선언하는 모든 메서드 및 이니셜라이저의 순환 복잡도 합계입니다. 상속된 메서드와 이니셜라이저는 총 복잡도에 집계되지 않습니다.&lt;/p&gt;
&lt;p&gt;익명 클래스의 복잡도는 매우 낮아야 합니다. 그렇지 않으면 이해하기 어렵기 때문에 명명된 내부 클래스가 되도록 승격시켜야 합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;순환 복잡도 제한&lt;/b&gt; 필드를 사용하여 클래스에 허용되는 최대 복잡도를 지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AnonymousClassComplexity&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassComplexity" defaultSeverity="WARNING" displayName="지나치게 복잡한 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
총 복잡도가 지정된 최댓값을 초과하는 클래스를 보고합니다.
&lt;p&gt;클래스의 총 복잡도는 클래스가 선언하는 모든 메서드 및 이니셜라이저의 순환 복잡도 합계입니다. 상속된 메서드와 이니셜라이저는 총 복잡도에 집계되지 않습니다.&lt;/p&gt;
&lt;p&gt;너무 높은 복잡도는 클래스를 더 작은 여러 클래스로 리팩터링해야 함을 나타냅니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;아래의 &lt;b&gt;순환 복잡도 제한&lt;/b&gt; 필드를 사용하여 클래스에 허용되는 최대 복잡도를 지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassComplexity&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldCount" defaultSeverity="WARNING" displayName="필드가 너무 많은 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
필드 개수가 지정된 최댓값을 초과하는 클래스를 보고합니다.
&lt;p&gt;많은 필드가 있는 클래스는 종종 너무 많은 처리를 시도합니다. 이러한 클래스를 더 작은 여러 클래스로 분할해보세요.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;필드 수 제한&lt;/b&gt; 필드를 사용하여 클래스에서 허용되는 최대 필드 수를 지정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;계산 시 상수 필드 포함&lt;/b&gt; 옵션을 사용하여 상수 필드를 계산해야 하는지 여부를 나타냅니다.&lt;/li&gt;
  &lt;li&gt;기본적으로 불변 &lt;code&gt;static final&lt;/code&gt; 객체만 상수로 계산됩니다. &lt;b&gt;'static final' 필드를 상수로 간주&lt;/b&gt; 옵션을 사용하여
    &lt;code&gt;static final&lt;/code&gt; 필드를 상수로 간주합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;계산 시 열거형 상수 포함&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;enum&lt;/code&gt; 클래스의&lt;code&gt;enum&lt;/code&gt; 상수를 계산해야 하는지
    지정합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FieldCount&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassInheritanceDepth" defaultSeverity="WARNING" displayName="상속 트리에서 너무 깊이 있는 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상속 계층 구조에서 너무 깊이 있는 클래스를 보고합니다.
&lt;p&gt;너무 깊이 상속된 클래스는 혼란스러울 수 있으며 리팩터링해야 함을 나타냅니다.&lt;/p&gt;
&lt;p&gt;라이브러리의 모든 상위 클래스는 단일 상위 클래스로 처리되며, 라이브러리는 수정 불가능한 것으로 간주됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;상속 깊이 제한&lt;/b&gt; 필드를 사용하여 클래스의 최대 상속 깊이를 지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ClassInheritanceDepth&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="코드 커버리지" path=""><inspection shortName="JsCoverageInspection" defaultSeverity="WARNING" displayName="JavaScript 및 TypeScript 소스 코드 커버리지 확인" enabled="false" language="JavaScript" pluginId="org.intellij.qodana" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
커버리지가 특정 임곗값 미만인 메서드, 클래스 및 파일을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JsCoverageInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JvmCoverageInspection" defaultSeverity="WARNING" displayName="Kotlin 및 Java 소스 코드 커버리지 확인" enabled="false" language="UAST" pluginId="org.intellij.qodana" pluginVersion="252.23892.409" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
커버리지가 특정 임곗값보다 낮은 메서드 및 클래스를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JvmCoverageInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="메서드 메트릭" path="Java"><inspection shortName="OverlyLongLambda" defaultSeverity="WARNING" displayName="지나치게 긴 람다 표현식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구문 수가 지정된 최댓값을 초과하는 람다 식을 보고합니다.
&lt;p&gt;너무 긴 람다 식은 혼동될 수 있으므로 구문을 별도의 메서드로 추출하는 것이 좋습니다.&lt;p&gt;
&lt;p&gt;다음 구문은 집계되지 않습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;빈 구문(세미콜론)&lt;/li&gt;
  &lt;li&gt;블록 구문&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for&lt;/code&gt; 루프 초기화 구문, 즉, &lt;code&gt;for(int i = ...;...)&lt;/code&gt; 문 내의 &lt;code&gt;int i = ...&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for&lt;/code&gt; 루프 업데이트 구문, 즉, &lt;code&gt;for(int i = ...;...; i += 2)&lt;/code&gt; 문 내의 &lt;code&gt;i += 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;비 주석 소스 구문 제한&lt;/b&gt; 필드를 사용하여 람다 식의 최대 허용 수치를 지정합니다.&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: OverlyLongLambda&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodWithMultipleLoops" defaultSeverity="WARNING" displayName="여러 루프가 있는 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
두 개 이상의 루프 구문이 포함된 메서드를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;다음 메서드는 2개의 루프를 포함하고 있기 때문에 보고됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void methodWithTwoLoops(int n1, int n2) {
    for (int i = 0; i &amp;lt; n1; i++) {
      System.out.println(i);
    }

    int j = 0;
    while (j &amp;lt; n2) {
      System.out.println(j);
      j++;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;또한 다음 메서드는 중첩 루프를 포함하고 있기 때문에 보고됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void methodWithNestedLoop(int n1, int n2) {
    for (int i = 0; i &amp;lt; n1; i++) {
      for (int j = 0; j &amp;lt; n2; j++) {
        System.out.println(i + j);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MethodWithMultipleLoops&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonCommentSourceStatements" defaultSeverity="WARNING" displayName="지나치게 긴 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구문 수가 지정된 최댓값을 초과하는 메서드를 보고합니다.
&lt;p&gt;너무 많은 구문을 가진 메서드는 혼동될 수 있으며 리팩터링이 필요하다는 의미입니다.&lt;/p&gt;
&lt;p&gt;다음 구문은 집계되지 않습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;빈 구문(세미콜론)&lt;/li&gt;
  &lt;li&gt;블록 구문&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for&lt;/code&gt; 루프 초기화 구문, 즉, &lt;code&gt;for(int i = ...;...)&lt;/code&gt; 문 내의 &lt;code&gt;int i = ...&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for&lt;/code&gt; 루프 업데이트 구문, 즉, &lt;code&gt;for(int i = ...;...; i += 2)&lt;/code&gt; 문 내의 &lt;code&gt;i += 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;메서드당 최대 구문 수&lt;/b&gt; 필드를 사용하여 메서드에 허용되는 최대 구문 수를 지정합니다.&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonCommentSourceStatements&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleReturnPointsPerMethod" defaultSeverity="WARNING" displayName="여러 반환점이 있는 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;return&lt;/code&gt; 지점 수가 지정된 최댓값을 초과하는 메서드를 보고합니다.
&lt;code&gt;return&lt;/code&gt; 지점이 너무 많은 메서드는 혼란을 주고 리팩터링하기 어려울 수 있습니다.
&lt;p&gt;&lt;code&gt;return&lt;/code&gt; 지점은 &lt;code&gt;return&lt;/code&gt; 문이거나 &lt;code&gt;void&lt;/code&gt; 메서드 또는 생성자의 하단에 도달하는 것을 나타냅니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;두 개의 &lt;code&gt;return&lt;/code&gt; 문만 허용되는 경우 아래 메서드가 보고됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doSmth(User[] users) {
    for (User user : users) {
      if (cond1(user)) {
        user.setId(getId());
        return;
      } else if (cond2(user)) {
        if (cond3(user)) {
          user.setId(getId());
          return;
        }
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이해하기 더 쉽도록 이 메서드를 다시 작성하는 것을 고려하세요.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doSmth(User[] users) {
    for (User user : users) {
      if (cond1(user) || cond2(user) &amp;&amp; cond3(user)) {
        user.setId(getId());
        return;
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;반환점 제한&lt;/b&gt; 필드를 사용하여 메서드에 대한 &lt;code&gt;return&lt;/code&gt; 지점의 최대 허용 개수를 지정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;guard 절 무시&lt;/b&gt; 옵션을 사용하여 guard 절을 무시합니다.
    guard 절은 &lt;code&gt;return&lt;/code&gt; 문만 포함된 &lt;code&gt;if&lt;/code&gt; 문입니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;'equals()' 메서드 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;equals()&lt;/code&gt; 메서드 내의 &lt;code&gt;return&lt;/code&gt; 지점을 무시합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MultipleReturnPointsPerMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CyclomaticComplexity" defaultSeverity="WARNING" displayName="지나치게 복잡한 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
브랜치 지점이 너무 많은 메서드를 보고합니다.
&lt;p&gt;브랜치 지점은 다음 중 하나입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;루프 구문&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;if&lt;/code&gt; 구문&lt;/li&gt;
  &lt;li&gt;삼항식&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;catch&lt;/code&gt; 섹션&lt;/li&gt;
  &lt;li&gt;하나 이상의 &lt;code&gt;&amp;&amp;&lt;/code&gt; 또는 &lt;code&gt;||&lt;/code&gt; 연산자가 내부에 포함된 표현식&lt;/li&gt;
  &lt;li&gt;비 기본 브랜치로 블록 &lt;code&gt;전환&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;순환 복잡도가 너무 높은 메서드는 혼란스럽거나 테스트하기 어려울 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;메서드 복잡도 제한&lt;/b&gt; 필드를 사용하여 메서드에서 허용되는 최대 순환 복잡도를 지정합니다.&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CyclomaticComplexity&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParametersPerMethod" defaultSeverity="WARNING" displayName="매개변수가 너무 많은 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
매개변수 수가 지정된 최댓값을 초과하는 메서드를 보고합니다.
너무 많은 매개변수를 가진 메서드는 리팩터링이 필요할 수 있습니다.
&lt;p&gt;상위 메서드를 가진 메서드는 보고하지 않습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;매개변수 제한&lt;/b&gt; 필드를 사용하여 메서드의 최대 허용 매개변수 개수를 지정합니다.&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ParametersPerMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrownExceptionsPerMethod" defaultSeverity="WARNING" displayName="예외가 너무 많은 메서드 선언" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;throws&lt;/code&gt; 목록에 너무 많은 예외 타입을 포함하는 메서드를 보고합니다.
&lt;p&gt;메서드로 선언된 예외의 수가 너무 많은 경우 에러 취급 코드가 과도하게 복잡하게 될 가능성이 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;던져진 예외 제한&lt;/b&gt; 필드를 사용하여 메서드의 &lt;code&gt;throws&lt;/code&gt; 목록에 포함할 수 있는 예외 유형의 최대 개수를 지정합니다.&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThrownExceptionsPerMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreeNegationsPerMethod" defaultSeverity="WARNING" displayName="3개 이상의 부정이 있는 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
세 개 이상의 부정을 사용하는 메서드를 보고합니다.
그러한 메서드는 혼란을 일으킬 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doSmth(int a, int b, boolean flag1, boolean flag2) {
    if (!flag &amp;&amp; !flag2) {
      if (a != b) {
        doOther();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;부정이 없으면 메서드를 더 쉽게 이해할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doSmth(int a, int b, boolean flag1, boolean flag2) {
    if (flag1 || flag2 || a == b) return;
    doOther();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;'equals()' 메서드의 부정 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;equals()&lt;/code&gt; 메서드 내의 검사를 비활성화합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;'assert' 문의 부정 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;assert&lt;/code&gt; 문 내의 검사를 비활성화합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ThreeNegationsPerMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestingDepth" defaultSeverity="WARNING" displayName="지나치게 중첩된 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문에 지나치게 중첩된 구문이 있는 메서드를 보고합니다.
&lt;p&gt;너무 깊은 구문 중첩이 있는 메서드는 혼동될 수 있으며 리팩터링이 필요할 수 있음을 의미합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;중첩 깊이 제한&lt;/b&gt; 필드를 사용하여 메서드에 허용되는 최대 중첩 깊이를 지정합니다.&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NestingDepth&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParametersPerConstructor" defaultSeverity="WARNING" displayName="매개변수가 너무 많은 생성자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
매개변수 수가 지정된 최댓값을 초과하는 생성자를 보고합니다.
특히 일부 매개변수가 선택적인 경우 이러한 객체를 인스턴스화하기가 어렵습니다.
너무 많은 매개변수를 가진 생성자는 리팩터링이 필요할 수 있습니다.
예를 들면, Builder 패턴을 적용하는 것을 고려할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public BankAccount(long accountNumber,
                     String owner,
                     double balance,
                     double interestRate) {
    // fields initialization
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;매개변수 제한&lt;/b&gt; 필드를 사용하여 생성자의 최대 허용 매개변수 개수를 지정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;가시성을 가진 생성자 무시&lt;/b&gt; 목록을 사용하여 이 검사를 통해 특정한 가시성을 가진 생성자의 무시 여부를 지정합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ParametersPerConstructor&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodCoupling" defaultSeverity="WARNING" displayName="지나치게 결합된 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
다른 클래스를 너무 많이 참조하는 메서드를 보고합니다.
결합이 너무 지나친 메서드는 매우 취약할 수 있으며, 더 작은 메서드로 분할해야 할 수 있습니다.
&lt;p&gt;참조된 각 클래스는 참조 횟수에 관계없이 한 번만 집계됩니다.&lt;/p&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;메서드 결합 제한&lt;/b&gt; 필드를 사용하여 메서드에 허용되는 최대 결합을 지정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;Java 시스템 클래스에 대한 결합 포함&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;java&lt;/code&gt; 또는 &lt;code&gt;javax&lt;/code&gt; 패키지의 클래스에 대한 참조를 집계합니다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;라이브러리 클래스에 대한 결합 포함&lt;/b&gt; 옵션을 사용하여 타사 라이브러리 클래스에 대한 참조를 집계합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MethodCoupling&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="코드 마이그레이션" path="Kotlin"><inspection shortName="ContextParametersMigration" defaultSeverity="ERROR" displayName="오래된 컨텍스트 리시버가 사용됨" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
컨텍스트 매개변수로 마이그레이션되어야 하는 컨텍스트 리시버를 보고합니다.
&lt;p&gt;
    Kotlin 2.0부터 컨텍스트 리시버가 컨텍스트 매개변수로 대체됩니다.
    이 검사는 컨텍스트 리시버를 활성화했지만 아직 컨텍스트 매개변수 구문으로 마이그레이션하지 않은 프로젝트에서 컨텍스트 리시버를 컨텍스트 매개변수로 마이그레이션할 때 도움이 됩니다.
&lt;/p&gt;
&lt;p&gt;
    예:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
context(MutableList&amp;lt;String&amp;gt;, C)
private fun foo() {
    add("new")
    bar()
    baz()
}

class C {
    fun bar() {}
}

fun C.baz() {}
&lt;/code&gt;&lt;/pre&gt;
마이그레이션 후:
&lt;pre&gt;&lt;code&gt;
context(strings: MutableList&amp;lt;String&amp;gt;, c: C)
private fun foo() {
    strings.add("new")
    c.bar()
    c.baz()
}

class C {
    fun bar() {}
}

fun C.baz() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ContextParametersMigration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertFromMultiDollarToRegularString" defaultSeverity="INFORMATION" displayName="제거할 수 있는 여러 개의 달러 기호로 구성된 보간 접두사" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
모든 문자열을 보간 접두사로 보고합니다.

&lt;p&gt;
    검사의 빠른 수정을 통해 보간 접두사를 제거하고, 보간 항목을 업데이트하며 안전하지 않은 달러 문자를 이스케이프합니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
val foo = $$"""
{
    "foo": $ref,
    "bar": {
        "baz": "$20"
        "boo": "$${100 + 200}"
    }
}
"""
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;빠른 수정 적용 후:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
val foo = """
{
    "foo": ${'$'}ref,
    "bar": {
        "baz": "$20"
        "boo": "${100 + 200}"
    }
}
"""
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ConvertFromMultiDollarToRegularString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InfixCallToOrdinary" defaultSeverity="INFORMATION" displayName="infix 호출은 마침표 호출일 수 있습니다" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
마침표로 한정된 함수 호출로 대체될 수 있는 infix 함수 호출을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    1 xor 2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
    1.xor(2)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: InfixCallToOrdinary&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CanConvertToMultiDollarString" defaultSeverity="WEAK WARNING" displayName="다중 달러 보간을 문자열 리터럴에 사용 가능(2.1부터)" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="252.23892.409-IJ" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
문자열을 여러 개의 달러 기호로 구성된 보간 접두사가 있는 버전으로 변환하는 게 나은 경우 보고합니다.
&lt;p&gt;
접두사가 있는 문자열은 추가적인 이스케이프 없이 달러 리터럴을 사용하기 때문에 보간 접두사를 사용하면 문자열을 쉽게 이해할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
val jsonSchema: String = """
{
  "${'$'}id": "https://example.com/product.schema.json",
}"""
&lt;/code&gt;&lt;/pre&gt;
빠른 수정이 안전하게 바꿀 수 있는 이스케이프된 달러 문자를 모두 일반적인 달러 문자로 변환합니다.
&lt;pre&gt;&lt;code&gt;
val jsonSchema: String = $$"""
{
  "$id": "https://example.com/product.schema.json",
}"""
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: CanConvertToMultiDollarString&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="사용하지 않는 심볼" path="JavaScript 및 TypeScript"><inspection shortName="JSUnusedLocalSymbols" defaultSeverity="WARNING" displayName="사용하지 않는 지역 심볼" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
로컬에서 접근 가능한 미사용 매개변수, 지역 변수, 함수, 클래스 또는 private 멤버 선언을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSUnusedLocalSymbols&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnusedAssignment" defaultSeverity="WARNING" displayName="사용하지 않는 대입" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
대입 후에 값이 전혀 사용되지 않는 변수를 보고합니다.&lt;br&gt;
미사용 변수를 삭제해 코드를 단축하고 불필요한 할당을 피할 것을 제안합니다.
&lt;p&gt;다음과 같은 경우가 보고됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;변수가 대입 후 한 번도 읽히지 않습니다.&lt;/li&gt;
  &lt;li&gt;변수 값은 변수가 다음에 읽히기 전에 항상 다른 대입으로 덮어쓰기됩니다.&lt;/li&gt;
  &lt;li&gt;변수의 이니셜라이저는 불필요합니다(위에서 언급한 이유 중 하나로).&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSUnusedAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSUnusedGlobalSymbols" defaultSeverity="WARNING" displayName="사용하지 않는 전역 심볼" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
모든 곳에서 접근 가능한 사용되지 않은 public 함수, 변수, 클래스 또는 프로퍼티를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSUnusedGlobalSymbols&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="제어 흐름 이슈" path="Java"><inspection shortName="ConfusingElse" defaultSeverity="INFORMATION" displayName="중복 'else'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;if&lt;/code&gt;&amp;mdash;&lt;code&gt;else&lt;/code&gt; 에서 불필요한 &lt;code&gt;else&lt;/code&gt; 키워드 구문 및 구문 체인을 보고합니다.
&lt;p&gt;
이전의 모든 브랜치가 &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; 문으로 끝나는 경우, &lt;code&gt;else&lt;/code&gt; 키워드는 불필요합니다. 이 경우 &lt;code&gt;else&lt;/code&gt; 분기의 구문은 &lt;code&gt;if&lt;/code&gt; 문 뒤로 이동할 수 있으며 &lt;code&gt;else&lt;/code&gt; 키워드는 제거될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (name == null) {
      throw new IllegalArgumentException();
  } else {
      System.out.println(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (name == null) {
      throw new IllegalArgumentException();
  }
  System.out.println(name);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt;&amp;mdash;&lt;code&gt;else&lt;/code&gt; 문이 코드 블록의 마지막 구문인 경우를 무시하려면, &lt;b&gt;'if' 문 다음에 구문이 없는 경우 보고&lt;/b&gt;를 비활성화하세요.&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ConfusingElse&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementDensity" defaultSeverity="WARNING" displayName="브랜치 밀도가 너무 낮은 'switch' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
실행문 대비 switch 라벨의 비율이 너무 낮은 &lt;code&gt;switch&lt;/code&gt; 문 또는 식을 보고합니다.
&lt;p&gt;그러한 &lt;code&gt;switch&lt;/code&gt; 문은 혼란을 일으킬 수 있으므로 리팩터링되어야 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch (i) { // 하나의 case와 5개의 실행문 -&gt; 20% 밀도
        case 1:
            System.out.println("1");
            System.out.println("2");
            System.out.println("3");
            System.out.println("4");
            System.out.println("5");
            break;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;b&gt;최소 브랜치 밀도&lt;/b&gt; 필드를 사용하여 허용되는 실행문 대비 switch 필드 비율을 지정하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SwitchStatementDensity&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WhileCanBeDoWhile" defaultSeverity="WEAK WARNING" displayName="'while'은 'do while'로 대체될 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  &lt;code&gt;do-while&lt;/code&gt; 루프로 작성하면 더 효율적일 수 있는 &lt;code&gt;while&lt;/code&gt; 루프를 보고합니다.
  &lt;code&gt;while&lt;/code&gt; 루프에서 루프 바로 앞의 코드가 루프 본문의 코드와 동일한 경우,
  &lt;code&gt;do-while&lt;/code&gt; 반복문으로 대체하면 중복 코드를 제거할 수 있습니다.
  그러한 중복 코드가 없는 &lt;code&gt;while&lt;/code&gt; 반복문을 위한 빠른 수정이 에디터에서 제안되지만 강조 표시는 되지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  foo();
  while (x) {
      foo();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음으로 대체 가능:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  do {
    foo();
  } while (x);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;small&gt;2024.1의 새로운 기능&lt;/small&gt;
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: WhileCanBeDoWhile&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopWithImplicitTerminationCondition" defaultSeverity="WARNING" displayName="묵시적 종료 조건이 있는 루프" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
유일한 조건으로 &lt;code&gt;true&lt;/code&gt;가 있는 &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;do-while&lt;/code&gt; 및 &lt;code&gt;for&lt;/code&gt; 루프를 보고합니다. 동시에, 이러한 루프는 루프 밖으로 벗어날 수 있는 포함 &lt;code&gt;if&lt;/code&gt; 문으로 여전히 종료할 수 있습니다.
&lt;p&gt;이러한 &lt;code&gt;if&lt;/code&gt; 구문은 &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;for&lt;/code&gt; 루프에서 첫 번째 또는 유일한 구문이어야 하고
&lt;code&gt;do-while&lt;/code&gt; 루프에서 마지막 또는 유일한 구문이어야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt; 구문을 제거하고 해당 조건을 명시적 루프 조건으로 만들면 루프가 단순화됩니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: LoopWithImplicitTerminationCondition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedSwitchStatement" defaultSeverity="WARNING" displayName="중첩된 'switch' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
중첩된 &lt;code&gt;switch&lt;/code&gt; 문 또는 표현식을 보고합니다.
&lt;p&gt;중첩된 &lt;code&gt;switch&lt;/code&gt; 문을 사용하면 코드가 매우 혼동될 수 있습니다. 이러한 구문은 별도의 메서드로 추출할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int res = switch (i) {
            case 0 -&gt; 0;
            default -&gt; switch (i) {
                case 100 -&gt; 0;
                default -&gt; i;
            };
        };
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: NestedSwitchStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueStatement" defaultSeverity="WARNING" displayName="'continue' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;continue&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;&lt;code&gt;continue&lt;/code&gt; 문을 사용하면 리팩터링이 복잡해져 혼란스러울 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(List&amp;lt;String&amp;gt; strs) {
    for (String str : strs) {
      if (str.contains("skip")) continue;
      handleStr(str);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ContinueStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalCanBePushedInsideExpression" defaultSeverity="INFORMATION" displayName="조건을 브랜치 표현식 내부로 넣을 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;then&lt;/code&gt; 및 &lt;c&gt;else&lt;/c&gt; 브랜치가 포함되어 있으며 이 브랜치가 너무나 유사하여 표현식을 내부로 이동할 수 있는 조건식을 보고합니다. 이 액션은 코드를 단축합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double g(int a, int b) {
    return a == b ? Math.cos(0) : Math.cos(1);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double g(int a, int b) {
    return Math.cos(a == b ? 0 : 1);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConditionalCanBePushedInsideExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegatedConditional" defaultSeverity="WARNING" displayName="부정된 조건이 있는 조건식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
조건이 부정된 조건식을 보고합니다.
&lt;p&gt;조건식 브랜치의 순서를 반전시키면 보통 그러한 구문의 명확도가 높아집니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;obj != null&lt;/code&gt; 또는 &lt;code&gt;num != 0&lt;/code&gt; 형식의 비교를 무시하려면 &lt;b&gt;'!=null' 비교 무시&lt;/b&gt; 및 &lt;b&gt;'!= 0' 비교 무시&lt;/b&gt; 옵션을 사용하세요.
  &lt;code&gt;obj != null&lt;/code&gt;은 실질적으로 '객체가 있음'을 의미하므로 전체 표현식의 의미는 부정을 포함하지 않아 이해하기 쉽습니다.
&lt;p&gt;
  특히 비트 마스크 사용 시 같은 이유가 &lt;code&gt;num != 0&lt;/code&gt; 표현식에 적용됩니다.
&lt;p&gt;
  이러한 형태에는 흥미로운 case를 먼저 언급하는 추가적인 이점이 있습니다.
  대부부의 경우에 다음 예시에서와 마찬가지로 &lt;code&gt;== null&lt;/code&gt; 브랜치의 값은 &lt;code&gt;null&lt;/code&gt; 자신입니다.

&lt;pre&gt;&lt;code&gt;
    static String getName(Person p) {
        return p != null ? p.getName() : null;
    }

    static String getExecutableString(int fileMode) {
        return (fileMode &amp; 0b001001001) != 0 ? "executable" : "non-executable";
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: NegatedConditional&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessIndexOfComparison" defaultSeverity="WARNING" displayName="무의미한 'indexOf()' 비교" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;.indexOf()&lt;/code&gt; 식을 사용한 불필요한 비교를 보고합니다. 이러한 표현식의 예시로는 &lt;code&gt;.indexOf()&lt;/code&gt;의 결과를 -1보다 작은 숫자와 비교하는 것이 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PointlessIndexOfComparison&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnumSwitchStatementWhichMissesCases" defaultSeverity="INFORMATION" displayName="case가 누락된 열거형 'switch' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
열거형 타입에 사용된, 누락된 것이 있는 &lt;code&gt;switch&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;enum&lt;/b&gt; AlphaBetaGamma {
    A, B, C;

    &lt;b&gt;void&lt;/b&gt; x(AlphaBetaGamma e) {
      &lt;b&gt;switch&lt;/b&gt; (e) {

      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;enum&lt;/b&gt; AlphaBetaGamma {
    A, B, C;

    &lt;b&gt;void&lt;/b&gt; x(AlphaBetaGamma e) {
      &lt;b&gt;switch&lt;/b&gt; (e) {
        &lt;b&gt;case&lt;/b&gt; A -&gt; {}
        &lt;b&gt;case&lt;/b&gt; B -&gt; {}
        &lt;b&gt;case&lt;/b&gt; C -&gt; {}
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;code&gt;default&lt;/code&gt; 분기가 있는 &lt;code&gt;switch&lt;/code&gt; 문을 무시하려면 &lt;b&gt;default 분기가 있는 switch 문 무시&lt;/b&gt; 옵션을 사용하세요.
&lt;p&gt;

&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;열거형&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: EnumSwitchStatementWhichMissesCases&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IdempotentLoopBody" defaultSeverity="WARNING" displayName="멱등 루프 본문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
두 번째 및 그 후의 모든 이터레이션이 첫 번째 이터레이션에서 생성된 것 외의 부수 효과를 추가로 생성하지 않는 루프를 보고합니다. 이러한 부수 효과는 프로그래밍 오류의 징후일 수 있습니다.
&lt;p&gt;이러한 루프는 0번, 1번 또는 무한 번 반복할 수 있습니다.
case가 무한 번 시도를 통해 도달할 수 없는 경우 이러한 루프를 &lt;code&gt;if&lt;/code&gt; 문으로 바꿀 수 있습니다.
  그렇지 않으면, 프로그램이 멈출 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    public void foo(String baseName, String names) {
        int suffix = 1;
        String name = baseName;
        while (names.contains(name)) {
            // 오류: suffix가 업데이트되지 않으므로 루프 본문이 여러 번 실행된 결과가 한 번 실행된 결과와 같습니다
            name = baseName + suffix;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IdempotentLoopBody&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementWithTooManyBranches" defaultSeverity="WARNING" displayName="최대 'switch' 브랜치" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;case&lt;/code&gt; 라벨이 너무 많은 &lt;code&gt;switch&lt;/code&gt; 문 또는 식을 보고합니다.
&lt;p&gt;그러한 긴 switch 문은 혼란을 일으킬 수 있으므로 리팩터링이 필요할 수 있습니다.
  이러한 구문이 문제가 아닌 경우도 있습니다(예: 도메인이 매우 복잡하며 상수가 많은 열거형을 포함하는 경우).&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch (x) {
        case 1 -&gt; {}
        case 2 -&gt; {}
        case 3 -&gt; {}
        case 4 -&gt; {}
        case 5 -&gt; {}
        case 6 -&gt; {}
        case 7 -&gt; {}
        case 8 -&gt; {}
        case 9 -&gt; {}
        case 10 -&gt; {}
        case 11,12,13 -&gt; {}
        default -&gt; {}
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;최대 브랜치 수&lt;/b&gt; 필드를 사용하여 필요한 &lt;code&gt;case&lt;/code&gt; 라벨의 최대 개수를 지정하세요.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SwitchStatementWithTooManyBranches&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableConditionalExpression" defaultSeverity="WARNING" displayName="단순화 가능한 조건식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
조건식을 보고하고 이를 단순화하도록 제안합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;condition ? true : foo &amp;rarr; condition || foo&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;condition ? false : foo &amp;rarr; !condition &amp;&amp; foo&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;condition ? foo : !foo &amp;rarr; condition == foo&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;condition ? true : false &amp;rarr; condition&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;a == b ? b : a &amp;rarr; a&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;result != null ? result : null &amp;rarr; result&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SimplifiableConditionalExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedConditionalExpression" defaultSeverity="WARNING" displayName="중첩된 조건식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
코드를 매우 혼란스럽게 만들 수 있는 중첩된 조건식을 보고한다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = a == 10 ? b == 20 ? 10 : a : b;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: NestedConditionalExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalBreakInInfiniteLoop" defaultSeverity="WARNING" displayName="루프 내 조건부 break" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루프의 시작 또는 끝 부분에 조건부 줄 바꿈을 보고하고 코드를 줄이기 위해 루프 조건을 추가할 것을 제안합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;while&lt;/b&gt; (true) {
    &lt;b&gt;if&lt;/b&gt; (i  == 23) &lt;b&gt;break&lt;/b&gt;;
    i++;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;while&lt;/b&gt; (i != 23) {
    i++;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConditionalBreakInInfiniteLoop&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantConditionalExpression" defaultSeverity="WARNING" displayName="상수 조건식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 상수가 조건인 조건식을 보고합니다.
이러한 식은 때때로 자동 리팩터링의 결과로 나타나며 단순화할 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return true ? "Yes" : "No";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return "Yes";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConstantConditionalExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfCanBeAssertion" defaultSeverity="INFORMATION" displayName="구문을 'assert' 또는 'Objects.requireNonNull'로 바꾸기 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;then&lt;/code&gt; 분기에서 &lt;code&gt;java.lang.Throwable&lt;/code&gt;만 던지며 &lt;code&gt;else&lt;/code&gt; 분기를 갖지 않는 &lt;code&gt;if&lt;/code&gt; 구문을 보고합니다. 이러한 구문은 좀 더 압축된 &lt;code&gt;assert&lt;/code&gt; 구문으로 변환될 수 있습니다.
&lt;p&gt;
이 검사는 또한 Guava의 &lt;code&gt;Preconditions.checkNotNull()&lt;/code&gt;을 보고합니다.
  이들은 라이브러리가 필요하지 않은 &lt;code&gt;Objects.requireNonNull()&lt;/code&gt; 호출로 바꿀 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;if&lt;/b&gt; (x == 2) &lt;b&gt;throw new&lt;/b&gt; RuntimeException("fail");
  &lt;b&gt;if&lt;/b&gt; (y == null) &lt;b&gt;throw new&lt;/b&gt; AssertionError();
  Preconditions.checkNotNull(z, "z");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;assert&lt;/b&gt; x != 2 : "fail";
  Objects.requireNonNull(y);
  Objects.requireNonNull(z, "z");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;디폴트로 이 검사는 에디터에서 코드 강조 표시 없이 빠른 수정을 제공합니다.&lt;/p&gt;
&lt;p&gt;이 검사는 Java 1.4부터 사용할 수 있는 Java 기능 &amp;#39;어설션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: IfCanBeAssertion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifiableBooleanExpression" defaultSeverity="WARNING" displayName="단순화 가능한 부울 표현식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단순화할 수 있는 bool 표현식을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(boolean foo, boolean bar) {
    boolean b = !(foo ^ bar);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(boolean foo, boolean bar) {
    boolean b = foo == bar;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(boolean foo, boolean bar) {
    boolean b = (foo &amp;&amp; bar) || !foo;
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(boolean foo, boolean bar) {
    boolean b = !foo || bar;
  }
  &lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SimplifiableBooleanExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementWithTooFewBranches" defaultSeverity="WARNING" displayName="최소 'switch' 브랜치" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;case&lt;/code&gt; 라벨 수가 너무 적은 &lt;code&gt;switch&lt;/code&gt; 문을 보고하고, 이를 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else if&lt;/code&gt; 문으로 다시 작성하도록 제안합니다.
&lt;p&gt;Example (minimum branches == 3):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (expression) {
    case "foo" -&amp;gt; foo();
    case "bar" -&amp;gt; bar();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if ("foo".equals(expression)) {
    foo();
  } else if ("bar".equals(expression)) {
    bar();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;'default' 브랜치가 없는 완전한 switch 식(Java 14+) 또는 패턴 switch 문(Java 17 테스트 버전)은 보고되지 않습니다.
  이 경우 &lt;code&gt;switch&lt;/code&gt;가 바람직하지 않은 &lt;code&gt;if&lt;/code&gt;로 변환될 때 컴파일 시간 완전성 검사가 손실되기 때문입니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;&lt;b&gt;최소 분기 수&lt;/b&gt; 필드를 사용하여 &lt;code&gt;case&lt;/code&gt; 라벨의 최소 개수를 지정하세요.&lt;/p&gt;
&lt;p&gt;패턴 브랜치가 있는 switch 문 및 식을 보고하지 않으려면 &lt;b&gt;패턴 switch 문을 보고하지 않음&lt;/b&gt; 옵션을 사용합니다. 예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String result = switch(obj) {
    case String str -&gt; str.trim();
    default -&gt; "none";
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt; 문을 사용하는 것보다 단일 패턴 브랜치로 switch를 유지하는 것이 좋을 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SwitchStatementWithTooFewBranches&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DoubleNegation" defaultSeverity="WARNING" displayName="이중 부정" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단순화할 수 있는 이중 부정을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (!!functionCall()) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (functionCall()) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (!(a != b)) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (a == b) {}
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: DoubleNegation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyComplexBooleanExpression" defaultSeverity="WARNING" displayName="지나치게 복잡한 부울 표현식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
항이 너무 많은 bool 표현식을 보고합니다. 그러한 표현식은 혼동을 일으키고 버그가 발생하기 쉽습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  cond(x1) &amp;amp;&amp;amp; cond(x2) ^ cond(x3) &amp;amp;&amp;amp; cond(x4);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;최대 항 수&lt;/b&gt; 필드를 사용하여 bool 표현식에 허용되는 항의 최대 개수를 지정하세요.&lt;/li&gt;
  &lt;li&gt;하나의 부울 연산자를 반복적으로 사용하는 bool 식을 무시하려면 &lt;b&gt;순수 결합어 및 분리어 무시&lt;/b&gt; 옵션을 사용하세요.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: OverlyComplexBooleanExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExpressionMayBeFactorized" defaultSeverity="INFORMATION" displayName="표현식을 인수분해할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;!-- Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
인수분해 가능한, 즉, 재구성하여 공통 인수 추출이 가능한 표현식을 보고합니다.
이는 중복을 줄이고 코드의 가독성을 높일 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a &amp;amp;&amp;amp; b || a &amp;amp;&amp;amp; c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a &amp;amp;&amp;amp; (b || c)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2021.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExpressionMayBeFactorized&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConditionalExpressionWithIdenticalBranches" defaultSeverity="WARNING" displayName="동일한 브랜치가 있는 조건식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동일한 &lt;code&gt;then&lt;/code&gt; 브랜치와 &lt;code&gt;else&lt;/code&gt; 브랜치를 가진 조건식을 보고합니다.
&lt;p&gt;이러한 표현식은 거의 확실히 버그를 나타냅니다. 이 검사는 조건식을 접는 수정을 제공합니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = x == 10 ? 4 : 4;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = 4;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ConditionalExpressionWithIdenticalBranches&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementsWithoutDefault" defaultSeverity="INFORMATION" displayName="'default' 브랜치가 없는 'switch' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;default&lt;/code&gt; 라벨을 포함하지 않는 &lt;code&gt;switch&lt;/code&gt; 구문을 보고합니다.
&lt;p&gt;&lt;code&gt;default&lt;/code&gt; 라벨 추가는 모든 가능한 시나리오가 포함됨을 보장하며 프로그램의 현재 상태에 대한 가정을 하기가 쉬워집니다.&lt;/p&gt;
&lt;p&gt;
&lt;!-- tooltip end --&gt;
  기본적으로 이 검사는 열거형의 모든 case 또는 &lt;code&gt;sealed&lt;/code&gt; 클래스가 포함된 경우 &lt;code&gt;switch&lt;/code&gt; 문을 보고하지 않습니다.
  이 동작을 변경하려면 &lt;b&gt;완전한 switch 문 무시&lt;/b&gt; 옵션을 사용합니다.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: SwitchStatementsWithoutDefault&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrivialIf" defaultSeverity="WARNING" displayName="중복 'if' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
단일 대입, &lt;code&gt;return&lt;/code&gt; 또는 &lt;code&gt;assert&lt;/code&gt; 문으로 단순화할 수 있는 &lt;code&gt;if&lt;/code&gt; 문을 
보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (foo()) {
    return true;
  } else {
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;체인 &lt;code&gt;if&lt;/code&gt; 문에 대한 경고를 숨기고 싶은 경우 &lt;b&gt;체인 'if' 문 무시&lt;/b&gt;를 사용하세요.&lt;/p&gt;
&lt;p&gt;예를 들어, 다음 코드에서 경고는 숨겨지지만 빠른 수정은 계속 사용할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (condition1) return true;
  if (condition2) return false;
  return true;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;조건에 부수 효과가 있는 경우 assert가 비활성화될 때 &lt;code&gt;if (isTrue()) assert false;&lt;/code&gt;를 &lt;code&gt;assert isTrue();&lt;/code&gt;로 대체하면 프로그램 의미가 변경될 수 있습니다.
  본문에 &lt;code&gt;assert&lt;/code&gt; 문만 포함된 &lt;code&gt;if&lt;/code&gt; 문에 대한 경고를 숨기려면 &lt;b&gt;사소한 'assert'가 있는 'if' 문 무시&lt;/b&gt; 옵션을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: TrivialIf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfStatementWithIdenticalBranches" defaultSeverity="WEAK WARNING" displayName="동일한 브랜치나 공통 부분이 있는 'if' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
분기에서 공통 부분을 추출 할 수있는 &lt;code&gt;if&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;이러한 공통 부분은 조건으로부터 독립적이며 &lt;code&gt;if&lt;/code&gt; 문을 이해하기 어렵게 만듭니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x &amp;gt; 12) {
    doSomethingBefore();
    doSomethingDifferent1();
    doSomethingAfter();
  } else {
    doSomethingBefore();
    doSomethingDifferent2();
    doSomethingAfter();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  doSomethingBefore();
  if (x &amp;gt; 12) {
    doSomethingDifferent1();
  } else {
    doSomethingDifferent2();
  }
  doSomethingAfter();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;2018.1에 업데이트됨&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IfStatementWithIdenticalBranches&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="BooleanExpressionMayBeConditional" defaultSeverity="INFORMATION" displayName="부울식을 조건식으로 대체 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
조건식을 사용하는 것보다 간결하고 틀림없이 명확한 방법으로 공식화할 수 있는 &lt;code&gt;bool&lt;/code&gt; 식을 보고합니다.
&lt;p&gt;빠른 수정을 사용하여 &lt;code&gt;bool&lt;/code&gt; 식을 조건식으로 바꿉니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a &amp;amp;&amp;amp; b || !a &amp;amp;&amp;amp; c;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a ? b : c;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: BooleanExpressionMayBeConditional&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FallthruInSwitchStatement" defaultSeverity="WARNING" displayName="'switch' 문의 폴스루" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;switch&lt;/code&gt; 문 내 '폴스루'를 보고합니다.
&lt;p&gt;폴스루는 &lt;code&gt;case&lt;/code&gt; 라벨 뒤에 오는 일련의 실행 가능한 구문이 다음 &lt;code&gt;case&lt;/code&gt; 라벨 앞에서 제어를 전달하도록 보장되지 않는 경우 발생합니다. 예를 들어, 이는 브랜치에 &lt;code&gt;break&lt;/code&gt; 문이 누락된 경우 발생할 수 있습니다.
그러한 경우, &lt;code&gt;switch&lt;/code&gt; 식이 폴스루된 라벨의 값과 같지 않더라도 제어는 해당 &lt;code&gt;switch&lt;/code&gt; 라벨 뒤에 오는 구문으로 폴스루합니다. 이러한 구문은 의도된 경우도 있으나 혼란스러울 수 있으며 보통 오타가 난 결과입니다.&lt;/p&gt;
&lt;p&gt;
이 검사는 정규식 패턴 &lt;code&gt;(?i)falls?\s*thro?u&lt;/code&gt;과 일치하는 텍스트로 된 주석이 추가된 모든 폴스루를 무시합니다.
&lt;/p&gt;
&lt;p&gt;다음 브랜치로 폴스루할 수 있는 브랜치에 &lt;code&gt;break&lt;/code&gt;를 추가하는 수정이 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch(x) {
      case (4):
          if (condition) {
              System.out.println("3");
              // break 없음
          } else {
              break;
          }
      case (6):
          System.out.println("4");
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch(x) {
        case (4):
            if (condition) {
                System.out.println("3");
            } else {
                break;
            }
            break;
        case (6):
            System.out.println("4");
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: FallthruInSwitchStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LabeledStatement" defaultSeverity="WARNING" displayName="라벨 지정된 구문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
리펙터링 및 메서드의 제어 흐름을 복잡하게 할 수 있는 라벨이 지정된 구문을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  label:
  while (true) {
      // 코드
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: LabeledStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessNullCheck" defaultSeverity="WARNING" displayName="메서드 호출 전 불필요한 'null' 검사" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;null&lt;/code&gt;이 전달되는 경우 반드시 &lt;code&gt;false&lt;/code&gt;를 반환하는 메서드 호출(예: &lt;code&gt;Class.isInstance&lt;/code&gt;)이 뒤따르는 &lt;code&gt;null&lt;/code&gt; 검사를 보고합니다.
&lt;p&gt;이 경우 메서드 호출이 항상 &lt;code&gt;false&lt;/code&gt;를 반환하므로 이 검사는 필요하지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x != null &amp;&amp; myClass.isInstance(x)) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (myClass.isInstance(x)) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: PointlessNullCheck&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AssertionCanBeIf" defaultSeverity="INFORMATION" displayName="어설션을 'if' 문으로 바꾸기 가능" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;assert&lt;/code&gt; 문을 보고하고 이를 &lt;code&gt;java.lang.AssertionError&lt;/code&gt;를 던지는 &lt;code&gt;if&lt;/code&gt; 문으로 바꿀 것을 제안합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assert param != null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (param == null) throw new AssertionError();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;이 검사는 Java 1.4부터 사용할 수 있는 Java 기능 &amp;#39;어설션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AssertionCanBeIf&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfStatementWithTooManyBranches" defaultSeverity="WARNING" displayName="브랜치가 너무 많은 'if' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
브랜치가 너무 많은 &lt;code&gt;if&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;그러한 구문은 혼동될 수 있으며 보통 적절하지 않은 수준의 설계 추상화를 나타냅니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;b&gt;최대 브랜치 수&lt;/b&gt; 필드를 사용하여 &lt;code&gt;if&lt;/code&gt; 문에 허용되는 브랜치의 최대 개수를 지정하세요.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: IfStatementWithTooManyBranches&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForLoopReplaceableByWhile" defaultSeverity="WARNING" displayName="'for' 루프를 'while' 루프로 바꿀 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구성 요소의 초기화 또는 업데이트를 포함하지 않는 &lt;code&gt;for&lt;/code&gt; 루프를 보고하고, 이를 &lt;code&gt;while&lt;/code&gt;로 변환할 것을 제안합니다. 이는 코드의 가독성을 좋게 합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for(; exitCondition(); ) {
    process();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  while(exitCondition()) {
    process();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정은 다른 &lt;code&gt;for&lt;/code&gt; 루프에도 사용 가능하며, 모든 &lt;code&gt;for&lt;/code&gt; 루프는 &lt;code&gt;while&lt;/code&gt; 로 변환할 수 있습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;자명하거나 존재하지 않는 조건을 가진 &lt;code&gt;for&lt;/code&gt; 루프를 무시하고 싶은 경우 &lt;b&gt;조건 없는 루프의 'infinite' 무시&lt;/b&gt; 옵션을 사용하세요.
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ForLoopReplaceableByWhile&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementWithConfusingDeclaration" defaultSeverity="WARNING" displayName="지역 변수가 다른 'switch' 브랜치에서 사용 및 선언됨" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;switch&lt;/code&gt; 문의 한 브랜치에서 선언되어 다른 브랜치에서 사용된 지역 변수를 보고합니다. 그러한 선언은 매우 혼동될 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch(i) {
      case 2:
          int x = 0;
          break;
      case 3:
          x = 3;
          System.out.println(x);
          break;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;


&lt;p&gt;&lt;small&gt;Inspection ID: SwitchStatementWithConfusingDeclaration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueStatementWithLabel" defaultSeverity="WARNING" displayName="라벨이 있는 'continue' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
라벨이 지정된 &lt;code&gt;continue&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;라벨이 지정된 &lt;code&gt;continue&lt;/code&gt; 문을 사용하면 리팩터링이 복잡해져 혼란스러울 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void handle(List&amp;lt;String&amp;gt; strs) {
    outer:
    for (String s: strs) {
      for (char ch : s.toCharArray()) {
        if ('s' == ch) continue outer;
        handleChar(ch);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ContinueStatementWithLabel&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegatedIfElse" defaultSeverity="WARNING" displayName="부정된 조건이 있는 'if' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
조건이 부정된 &lt;code&gt;else&lt;/code&gt; 브랜치를 포함하는 &lt;code&gt;if&lt;/code&gt; 구문을 보고합니다.
&lt;p&gt;&lt;code&gt;if&lt;/code&gt; 브랜치와 &lt;code&gt;else&lt;/code&gt; 브랜치의 순서를 반전시키면 보통 그러한 구문의 명확도가 높아집니다.&lt;/p&gt;
&lt;p&gt;현재 &lt;code&gt;if&lt;/code&gt; 문을 반전시키는 수정이 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void m(Object o1, Object o2) {
        if (o1 != o2) {
            System.out.println(1);
        }
        else {
            System.out.println(2);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void m(Object o1, Object o2) {
        if (o1 == o2) {
            System.out.println(2);
        } else {
            System.out.println(1);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;code&gt;!= null&lt;/code&gt; 형식의 비교를 무시하려면 &lt;b&gt;'!=null' 비교 무시&lt;/b&gt; 옵션을 사용하세요.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;!= 0&lt;/code&gt; 형식의 비교를 무시하려면 &lt;b&gt;'!= 0' 비교 무시&lt;/b&gt; 옵션을 사용하세요.&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: NegatedIfElse&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BreakStatementWithLabel" defaultSeverity="WARNING" displayName="라벨이 있는 'break' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
라벨이 지정된 &lt;code&gt;break&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;라벨이 지정된 &lt;code&gt;break&lt;/code&gt; 문을 사용하면 리팩터링이 복잡해져 혼란스러울 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void handle(List&amp;lt;String&amp;gt; strs) {
    outer:
    for (String s: strs) {
      for (char ch : s.toCharArray()) {
        if ('s' == ch) break outer;
        handleChar(ch);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: BreakStatementWithLabel&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateCondition" defaultSeverity="WARNING" displayName="중복 조건" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 표현식과 &lt;code&gt;if&lt;/code&gt; 문 브랜치 내 중복된 조건을 보고합니다.
이러한 중복 조건은 의도된 것일 때도 있지만, 대부분의 경우 실수입니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean result = digit1 != digit2 || digit1 != digit2;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  부작용을 생성할 수 있는 조건을 무시하려면, &lt;b&gt;부작용이 있는 조건 무시&lt;/b&gt; 옵션을 사용하세요.
이 옵션을 비활성화하면 예를 들어 같은 메서드가 후속 호출에 따라 다른 값을 반환하는 경우와 같이 거짓 양성으로 이어질 수 있습니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  native boolean unknownMethod();
  
  ...
  
  if (unknownMethod() || unknownMethod()) {
    System.out.println("Got it");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;unknownMethod()&lt;/code&gt;의 잠재적인 부수 효과(예시) 때문에 &lt;b&gt;부수 효과가 있는 조건 무시&lt;/b&gt; 옵션이 비활성화된 경우에만 경고가 트리거됩니다.&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: DuplicateCondition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessBooleanExpression" defaultSeverity="WARNING" displayName="무의미한 부울 표현식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
불필요하거나 지나치게 복잡한 부울 표현식을 보고합니다.
&lt;p&gt;이러한 표현식은 &lt;code&gt;true&lt;/code&gt;와 &lt;code&gt;&amp;&amp;&lt;/code&gt;연산, &lt;code&gt;false&lt;/code&gt;와 &lt;code&gt;||&lt;/code&gt;연산, 부울 리터럴과 상등 비교 또는 부울 리터럴 부정을 포함합니다. 이러한 표현식은 단순화할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; a = !(x &amp;&amp; &lt;b&gt;false&lt;/b&gt;);
  &lt;b&gt;boolean&lt;/b&gt; b = &lt;b&gt;false&lt;/b&gt; || x;
  &lt;b&gt;boolean&lt;/b&gt; c = x != &lt;b&gt;true&lt;/b&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; a = &lt;b&gt;true&lt;/b&gt;;
  &lt;b&gt;boolean&lt;/b&gt; b = x;
  &lt;b&gt;boolean&lt;/b&gt; c = !x;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
표현식이 무의미한지 판단할 때 이름이 지정된 상수를 무시하려면 &lt;b&gt;무의미한 표현식 결정 시 이름 지정된 상수 무시&lt;/b&gt; 옵션을 사용하세요.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: PointlessBooleanExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopStatementsThatDontLoop" defaultSeverity="WARNING" displayName="루프를 실행하지 않는 루프 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
본문이 최대 1번 실행되는 &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; 및 &lt;code&gt;do&lt;/code&gt; 문의 인스턴스를 보고합니다. 일반적으로 이는 버그를 나타냅니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
foreach 루프를 무시하려면 &lt;b&gt;향상된 for 루프 무시&lt;/b&gt; 옵션을 사용합니다.
이는 반복 가능한 객체의 첫 번째 항목에서만 간략한 방식으로 액션을 수행하기 위해 사용되는 경우도 있습니다.
&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;for&lt;/b&gt; (String s : stringIterable) {
    doSomethingOnFirstString(s);
    &lt;b&gt;break&lt;/b&gt;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: LoopStatementsThatDontLoop&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchExpressionCanBePushedDown" defaultSeverity="INFORMATION" displayName="공통 하위식은 'switch'에서 추출할 수 있습니다" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
브랜치가 공통된 하위식을 포함하므로 switch가 내부로 이동될 수 있는 &lt;code&gt;switch&lt;/code&gt; 식 및 문을 보고합니다.
이 액션은 코드를 단축합니다. 대부분의 경우, 결과 switch 식을 별도의 변수나 메서드로 추출하는 것이 좋습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (value) {
    case 0 -&gt; System.out.println("zero");
    case 1 -&gt; System.out.println("one");
    case 2, 3, 4 -&gt; System.out.println("few");
    default -&gt; System.out.println("many");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(switch (value) {
    case 0 -&gt; "zero";
    case 1 -&gt; "one";
    case 2, 3, 4 -&gt; "few";
    default -&gt; "many";
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  이 검사는 화살표 구문으로 강화된 switch에만 적용됩니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2022.3의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;이 검사는 Java 14부터 사용할 수 있는 Java 기능 &amp;#39;&amp;#39;switch&amp;#39; 식&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: SwitchExpressionCanBePushedDown&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatement" defaultSeverity="WARNING" displayName="'switch' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;switch&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt; 문은 (항상은 아니지만) 보통 좋지 못한 객체 지향 설계를 나타냅니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (i) {
    // 코드
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: SwitchStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DefaultNotLastCaseInSwitch" defaultSeverity="WARNING" displayName="'default'가 'switch'의 마지막 case가 아님" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;default&lt;/code&gt; 브랜치가 다른 case 앞에 오는 &lt;code&gt;switch&lt;/code&gt; 문 또는 식을 보고합니다.
이러한 구문은 불필요하게 혼동을 줄 수 있습니다.
가능한 경우 &lt;code&gt;default&lt;/code&gt; 브랜치를 마지막 위치로 옮기는 빠른 수정이 제공됩니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (n) {
      default:
          System.out.println();
          break;
      case 1:
          break;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (n) {
    case 1:
        break;
    default:
        System.out.println();
        break;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: DefaultNotLastCaseInSwitch&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InfiniteLoopStatement" defaultSeverity="WARNING" displayName="무한 루프 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
예외를 던져야만 종료할 수 있는 &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;do&lt;/code&gt; 문을 보고합니다. 이러한 구문은 올바를 수 있으나 종종 코딩 오류일 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (;;) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;b&gt;Thread.run에 배치될 경우 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;Thread.run&lt;/code&gt; 내 무한 루프 구문을 무시합니다.
데몬 스레드에 유용할 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Thread(() -&amp;gt; {
    while (true) {
    }
  }).start();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InfiniteLoopStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopConditionNotUpdatedInsideLoop" defaultSeverity="WARNING" displayName="루프 변수가 루프 내에서 업데이트되지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
루프 조건에서 사용되며 루프 내부에서 업데이트되지 않는 모든 변수 및 매개변수를 보고합니다.
&lt;p&gt;이러한 변수 및 매개변수는 실행될 때 무한 루프를 일으킬 수 있기 때문에 보통 실수로 인한 것입니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void loopDoesNotLoop(boolean b) {
    while (b) {
      System.out.println();
      break;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;
  조건이 간접적으로 업데이트될 수 있는 경우 (예를 들어, 호출된 메서드 또는 다른 스레드와 동시 실행으로 인해)&lt;b&gt;가능한 비 로컬 변경 내용 무시&lt;/b&gt; 옵션을 사용하여 이 검사를 비활성화하세요.
&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: LoopConditionNotUpdatedInsideLoop&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegatedConditionalExpression" defaultSeverity="WARNING" displayName="부정된 조건식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
접두사 표현식으로 부정된 조건식을 보고합니다. 그러한 생성은 혼란을 일으킬 수 있기 때문입니다.
&lt;p&gt;외부 부정을 양쪽 브랜치에 전달하는 수정이 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  !(i == 1 ? a : b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  i == 1 ? !a : !b
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NegatedConditionalExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalExpression" defaultSeverity="INFORMATION" displayName="조건식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
삼항 조건 연산자가 사용된 위치를 보고하고, 이를 &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;구문으로 변환할 것을 제안합니다.
&lt;p&gt;일부 코드 표준은 조건 연산자의 사용을 금지합니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object result = (condition) ? foo() : bar();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object result;
  if (condition) {
    comp = foo();
  }
  else {
    comp = bar();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;단순한 대입 및 반환을 무시하고 다음 구문을 허용하려면 &lt;b&gt;단순한 대입 및 반환 무시 &lt;/b&gt; 옵션을 사용하세요.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = (foo == null) ? "" : foo.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  if 구문으로 자동 바꿈이 불가능한 경우 (예를 들어, 조건식이 &lt;code&gt;super()&lt;/code&gt; 생성자 호출의 인수로 사용된 경우) 컨텍스트에서 조건식을 무시하려면 &lt;b&gt;if 문이 불가능한 위치 무시 &lt;/b&gt; 옵션을 사용하세요.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ConditionalExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegatedEqualityExpression" defaultSeverity="WARNING" displayName="부정된 상등 표현식" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
접두사 표현식에 의해 부정되는 상등 표현식을 보고합니다.
&lt;p&gt;그러한 표현식은 &lt;code&gt;!=&lt;/code&gt; 연산자를 사용하여 단순화할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  !(i == 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  i != 1
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NegatedEqualityExpression&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BreakStatement" defaultSeverity="WARNING" displayName="'break' 문" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;switch&lt;/code&gt; 문 브랜치의 끝이 아닌 다른 곳에서 사용되는 &lt;code&gt;break&lt;/code&gt; 문을 보고합니다.
&lt;p&gt;&lt;code&gt;break&lt;/code&gt; 문을 사용하면 리팩터링이 복잡해져 혼란스러울 수 있습니다.&lt;/p&gt;
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
void foo(List&amp;lt;String&amp;gt; strs) {
  for (String str : strs) {
    if (str.contains("stop")) break;
    handleStr(str);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: BreakStatement&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForLoopWithMissingComponent" defaultSeverity="WARNING" displayName="구성 요소가 누락된 'for' 루프" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
초기화, 조건, 또는 업데이트 절이 누락된 &lt;code&gt;for&lt;/code&gt; 루프를 보고합니다. 일부 코드 스타일은 그러한 루프를 금지합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i = 0;;i++) {
    // 본문
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
반복자를 사용하는 루프를 무시하려면 &lt;b&gt;컬렉션 반복 무시&lt;/b&gt; 옵션을 사용하세요.
이는 컬렉션을 반복하기 위한 표준 방식으로 &lt;code&gt;for&lt;/code&gt; 루프에 업데이트 절이 없습니다.
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ForLoopWithMissingComponent&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Jakarta Data" path=""><inspection shortName="JakartaDataRepositoryMethodParameters" defaultSeverity="WARNING" displayName="잘못된 저장소 메서드 매개변수" enabled="false" language="UAST" pluginId="com.intellij.javaee.jakarta.data" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;잘못된 저장소 메서드 매개변수 타입을 보고합니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class Person {
    private int id;
    @Column
    private String lastname;

    @Column
    private int age;
  }

  public interface CustomerRepository extends Repository&amp;lt;Person, Integer&amp;gt; {
    List&amp;lt;Person&amp;gt; &lt;strong&gt;findByAddress&lt;/strong&gt;(int lastname);  // 'String' 타입 필요
    List&amp;lt;Person&amp;gt; &lt;strong&gt;deleteByAge&lt;/strong&gt;(String str);   // 'int' 타입 필요
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JakartaDataRepositoryMethodParameters&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JakartaDataRepositoryMethodInconsistency" defaultSeverity="WARNING" displayName="Jakarta Data 저장소 메서드 오류" enabled="false" language="UAST" pluginId="com.intellij.javaee.jakarta.data" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  빌더가 해당하는 쿼리를 생성할 수 없는 Jakarta Dat 저장소 메서드를 보고합니다.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
interface PersonRepository extends Repository&amp;lt;Person, Long&amp;gt; {
  List&amp;lt;Person&amp;gt; findByEmailAndLastname(String email, String lastname);
  List&amp;lt;Person&amp;gt; findByUnknownAndLastname(EmailAddress emailAddress, String lastname); // 'Unknown' 프로퍼티를 해결할 수 없음
  List&amp;lt;Person&amp;gt; findByAndLastname(String email, String lastname); // 프로퍼티 이름 누락

  List&amp;lt;Person&amp;gt; findByLastnameOrderByFirstnameAsc(String lastname);
  List&amp;lt;Person&amp;gt; findByLastnameOrderByUnknownDesc(String lastname);  // 'Unknown' 프로퍼티를 해결할 수 없음
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JakartaDataRepositoryMethodInconsistency&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Reactor" path="Reactive Streams"><inspection shortName="CallingSubscribeInNonBlockingScope" defaultSeverity="WARNING" displayName="'reactive' 메서드에서 'subscribe' 호출" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;'reactive' 메서드의 &lt;code&gt;subscribe()&lt;/code&gt; 호출을 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Publisher&lt;/code&gt; 타입을 반환하는 메서드(&lt;code&gt;Flux&lt;/code&gt; 및 &lt;code&gt;Mono&lt;/code&gt; 포함)의 경우 &lt;code&gt;subscribe()&lt;/code&gt; 메서드를 직접 호출해서는 안 됩니다. 그러면 Reactive 호출 체인이 끊어질 수 있기 때문입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;subscribe()&lt;/code&gt; 대신 &lt;code&gt;flatMap()&lt;/code&gt;, &lt;code&gt;zip()&lt;/code&gt;, &lt;code&gt;then()&lt;/code&gt; 등의 합성 연산자를 사용해보세요.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  Flux&amp;lt;String&amp;gt; stringFlux(){
    Flux&amp;lt;String&amp;gt; flux = Flux.just("abc");
    flux.subscribe(); // &amp;lt;- 비차단 컨텍스트에서 'subscribe' 호출 차단
    return flux;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: CallingSubscribeInNonBlockingScope&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactorTransformationOnMonoVoid" defaultSeverity="WARNING" displayName="Mono&lt;Void&gt; 타입인 리시버에서 변환 함수를 호출하는 중" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reactive 체인에서 &lt;code&gt;Mono&amp;lt;Void&amp;gt;&lt;/code&gt; 값에 대해 호출된 변환 연산을 보고합니다.&lt;/p&gt;

&lt;p&gt;
  &lt;code&gt;Mono&amp;lt;Void&amp;gt;&lt;/code&gt;는 값이 없어도 완료되기 때문에 변환 함수를 호출할 대상이 없습니다.
  빠른 수정에서는 &lt;code&gt;map()&lt;/code&gt; 및 &lt;code&gt;flatMap()&lt;/code&gt;을 &lt;code&gt;then()&lt;/code&gt;으로 바꾸도록 제안합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;Mono.when(Mono.just(1), Mono.just(2))
                .map(v -&gt; "New value")
                .doFinally(System.out::println);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;Mono.when(Mono.just(1), Mono.just(2))
                .then(Mono.fromCallable(() -&gt; "New value"))
                .doFinally(System.out::println);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;2023.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReactorTransformationOnMonoVoid&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactorAutomaticDebugger" defaultSeverity="WEAK WARNING" displayName="불필요한 디버그 초기화" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;불필요한 &lt;code&gt;ReactorDebugAgent.init()&lt;/code&gt; 호출을 보고합니다.&lt;/p&gt;
&lt;p&gt;
  IDE에서 Reactor 디버그 모드를 자동으로 초기화할 수 있으므로 사용자가 &lt;code&gt;ReactorDebugAgent.init()&lt;/code&gt; 또는 &lt;code&gt;Hooks.onOperatorDebug()&lt;/code&gt;를 명시적으로 호출할 필요가 없습니다.
  &lt;/p&gt;

  &lt;p&gt;또한 &lt;code&gt;ReactorDebugAgent.init()&lt;/code&gt; 및 &lt;code&gt;Hooks.onOperatorDebug()&lt;/code&gt;를 모두 호출할 경우 Reactor에서 생성된 디버그 스택 프레임이 두 배로 증가합니다.
  &lt;/p&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ReactorAutomaticDebugger&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReactorZipWithMonoVoid" defaultSeverity="WARNING" displayName="Zip에 Mono&lt;Void&gt; 타입인 매개변수가 있습니다" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reactor 체인에서 &lt;code&gt;Mono&amp;lt;Void&amp;gt;&lt;/code&gt; 반환값을 가진 인수를 포함한 zip 연산을 보고합니다.&lt;/p&gt;

&lt;p&gt;
  들어오는 &lt;code&gt;Mono&amp;lt;Void&amp;gt;&lt;/code&gt;가 완료되는 즉시 &lt;code&gt;Zip&lt;/code&gt;이 빈 채로 완료됩니다.
  빠른 수정에서는 &lt;code&gt;zip()&lt;/code&gt;, &lt;code&gt;zipWhen()&lt;/code&gt; 및 &lt;code&gt;zipWith()&lt;/code&gt;를 &lt;code&gt;when&lt;/code&gt;으로 바꾸도록 제안합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;Mono.zip(Mono.just(1), Mono.fromRunnable(() -&gt; System.out.println("value")))
                .map(v -&gt; "New value")
                .doFinally(System.out::println);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;Mono.when(Mono.just(1), Mono.fromRunnable(() -&gt; System.out.println("value")))
                .then(Mono.fromCallable(() -&gt; "New value"))
                .doFinally(System.out::println);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;2023.1의 새로운 기능&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ReactorZipWithMonoVoid&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnfinishedStepVerifier" defaultSeverity="WARNING" displayName="완료되지 않은 StepVerifier" enabled="false" language="UAST" pluginId="com.intellij.reactivestreams" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;누락된 &lt;code&gt;StepVerifier&lt;/code&gt; 터미널 호출을 보고합니다.
&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;Publisher&lt;/code&gt; 구독 및 어설션을 초기화하려면 &lt;code&gt;verify()&lt;/code&gt;, &lt;code&gt;verifyComplete()&lt;/code&gt; 등의 터미널 검증 메서드를 호출해야 합니다.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
StepVerifier.create(Flux.just(1,2,3)).expectNext(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
StepVerifier.create(Flux.just(1,2,3)).expectNext(1).verifyComplete();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: UnfinishedStepVerifier&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="상속 문제" path="Java"><inspection shortName="ImplicitSubclassInspection" defaultSeverity="ERROR" displayName="런타임에 final 선언을 재정의할 수 없습니다." enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
런타임 시 일부 프레임워크(예: Spring 또는 Hibernate)에 의해 클래스가 하위 클래스로 지정되는 것을 방지하는 코드를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;필수적이지만 불가능한 하위 클래스 지정의 대표적 예시:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프레임워크 전용 어노테이션이 표시된 &lt;code&gt;final&lt;/code&gt; 클래스(예: Spring &lt;code&gt;@Configuration&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;프레임워크 전용 어노테이션이 표시된 &lt;code&gt;final&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt; 또는 &lt;code&gt;private&lt;/code&gt; 메서드(예: Spring &lt;code&gt;@Transactional&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;final&lt;/code&gt; 클래스 내부에서 프레임워크 전용 어노테이션이 표시된 메서드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;보고된 사례의 목록은 사용된 프레임워크에 따라 다릅니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ImplicitSubclassInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RefusedBequest" defaultSeverity="WARNING" displayName="메서드가 상위 메서드를 호출하지 않음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상위 메서드를 호출하지 않고 재정의하는 메서드를 보고합니다.
이는 &lt;i&gt;상속 거부&lt;/i&gt;라고도 합니다.
이러한 메서드는 추상화 실패를 의미할 수 있으며, 이로 인해 추적이 어려운 버그가 발생할 수 있습니다.
&lt;p&gt;
  이 검사는 &lt;code&gt;clone()&lt;/code&gt;을 제외한 &lt;code&gt;java.lang.Object&lt;/code&gt;에서 재정의된 메서드를 보고하지 않습니다.
  &lt;code&gt;clone()&lt;/code&gt; 메서드가 규칙에 따라 상위 메서드를 호출해야 올바른 타입의 객체가 반환됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예시 1:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
    @Override
    public Object clone() {
      // 'super.clone()'을 호출하지 않습니다
      return new A();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;예시 2:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface I {
    default void foo() {}
  }

  class A implements I {
    // ''default' 상위 메서드 무시'가
    // 비활성화되면 메서드에 대해 경고합니다
    @Override
    public void foo(){}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;b&gt;상위 메서드에 다음으로 어노테이션이 추가된 경우에만 보고&lt;/b&gt; 옵션을 사용하여, 제공된 목록의 어노테이션이 표시된 상위 메서드를 무시합니다. 목록에 어노테이션을 수동으로 추가할 수 있습니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;b&gt;빈 상위 메서드 무시&lt;/b&gt; 옵션을 사용하여 비어 있거나 예외만을 던지는 상위 메서드를 무시합니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;b&gt;'default' 상위 메서드 무시&lt;/b&gt; 옵션을 사용하여 인터페이스에서 &lt;code&gt;default&lt;/code&gt; 상위 메서드를 무시합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: RefusedBequest&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsAnnotation" defaultSeverity="WARNING" displayName="클래스가 어노테이션 인터페이스를 확장" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
어노테이션 인터페이스의 구현 또는 확장으로 선언된 클래스를 보고합니다.
&lt;p&gt;어노테이션 인터페이스 확장은 허용되지만 실수로 수행되는 경우가 많으며, 결과를 어노테이션으로 사용할 수 없습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;어노테이션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ExtendsAnnotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProblematicVarargsMethodOverride" defaultSeverity="WARNING" displayName="비 vararg 메서드는 vararg 메서드를 재정의" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
가변 인자(vararg라고도 함) 메서드를 재정의하지만 가변 인자 매개변수를 배열 매개변수로 바꾸는 메서드를 보고합니다.
이 코드는 올바르지만 혼란을 일으킬 수 있으므로 사용을 피해야 합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ProblematicVarargsMethodOverride&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractMethodWithMissingImplementations" defaultSeverity="WARNING" displayName="구현이 누락된 추상 메서드" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
모든 구체 하위 클래스에서 구현되지 않은 &lt;code&gt;abstract&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;
  이러한 메서드가 있으면 하위 클래스에서 컴파일 타임 오류가 발생합니다. 이 검사는 추상 메서드 지점에서 문제를 보고하므로 문제를 더욱 빠르게 탐지할 수 있습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: AbstractMethodWithMissingImplementations&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractClassExtendsConcreteClass" defaultSeverity="WARNING" displayName="추상 클래스가 구체 클래스를 확장" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구체 클래스를 확장하는 &lt;code&gt;abstract&lt;/code&gt; 클래스를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AbstractClassExtendsConcreteClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractClassNeverImplemented" defaultSeverity="WARNING" displayName="구체 하위 클래스가 없는 추상 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구체 하위 클래스가 없는 &lt;code&gt;abstract&lt;/code&gt; 클래스를 보고합니다. 지원이 중단된 abstract 클래스는 보고되지 않습니다.
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: AbstractClassNeverImplemented&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantImplements" defaultSeverity="WARNING" displayName="중복 인터페이스 선언" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
클래스의 &lt;code&gt;implements&lt;/code&gt; 목록의 인터페이스 또는 상위 클래스에 의해 이미 구현되었거나 상위 인터페이스에 의해 확장된 인터페이스의 &lt;code&gt;extends&lt;/code&gt; 목록을 보고합니다.
그러한 선언은 불필요하며 안전하게 제거할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X implements One, Two {
  }
  interface One {}
  interface Two extends One {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X implements Two {
  }
  interface One {}
  interface Two extends One {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;code&gt;extends&lt;/code&gt; 또는 &lt;code&gt;implements&lt;/code&gt; 목록의 
&lt;code&gt;Serializable&lt;/code&gt; 또는 &lt;code&gt;Externalizable&lt;/code&gt;에 대해 보고하지 않으려면 이 옵션을 사용합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantImplements&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractClassWithoutAbstractMethods" defaultSeverity="WARNING" displayName="'abstract' 메서드가 없는 추상 클래스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;abstract&lt;/code&gt; 메서드가 없는 &lt;code&gt;abstract&lt;/code&gt; 클래스를 보고합니다.
대부분의 경우 &lt;code&gt;abstract&lt;/code&gt; 메서드가 없는 &lt;code&gt;abstract&lt;/code&gt; 클래스에는 의미가 없고, &lt;code&gt;abstract&lt;/code&gt; 제어자를 클래스에서 제거할 수 있습니다.
인스턴스화를 방지하기 위해 클래스가 &lt;code&gt;abstract&lt;/code&gt;로 선언된 경우, &lt;code&gt;private&lt;/code&gt; 생성자를 사용하는 것이 더 나은 선택지인 경우가 많습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Example {
    public String getName() {
      return "IntelliJ IDEA";
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;유틸리티 클래스를 무시하려면 이 옵션을 사용합니다.
&lt;p&gt;&lt;small&gt;Inspection ID: AbstractClassWithoutAbstractMethods&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsUtilityClass" defaultSeverity="WARNING" displayName="클래스가 유틸리티 클래스를 확장" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
유틸리티 클래스를 확장하는 클래스를 보고합니다.
&lt;p&gt;
유틸리티 클래스는 모든 필드 및 메서드가 static인 비어 있지 않은 클래스입니다.
  유틸리티 클래스를 확장하면 유틸리티 클래스의 의도치 않은 객체 인스턴스화가 발생할 수도 있습니다. 확장을 허용하기 위해 생성자를 private으로 만들 수 없기 때문입니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 구성:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    유틸리티 클래스를 재정의하지만 자신이 유틸리티 클래스이기도 한 모든 클래스를 무시하려면 &lt;b&gt;재정의 클래스가 유틸리티 클래스인 경우 무시&lt;/b&gt; 옵션을 사용하세요.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ExtendsUtilityClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractMethodOverridesAbstractMethod" defaultSeverity="WARNING" displayName="추상 메서드가 추상 메서드를 재정의" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;abstract&lt;/code&gt; 메서드를 재정의하는 &lt;code&gt;abstract&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;결국 구체 하위 클래스가 추상 메서드를 구현해야 하기 때문에 그러한 메서드는 의미가 없습니다.&lt;/p&gt;
&lt;p&gt;
  반환 타입, 예외 선언, 어노테이션, 제어자가 재정의된 메서드와 다른 메서드는 이 검사에서 보고되지 않습니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 구성:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    JavaDoc 주석이 상위 메서드와 다른 모든 구체 메서드를 무시하려면 &lt;b&gt;Javadoc이 상위 메서드와 다른 메서드 무시&lt;/b&gt; 옵션을 사용하세요.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AbstractMethodOverridesAbstractMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InterfaceNeverImplemented" defaultSeverity="WARNING" displayName="구체 하위 클래스가 없는 인터페이스" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구체 하위 클래스가 없는 인터페이스를 보고합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    아래 목록을 사용하여 어노테이션을 추가하세요. 이러한 어노테이션 중 하나에서 선언된 인터페이스는 검사에서 무시됩니다.
  &lt;/li&gt;
  &lt;li&gt;
    상수 필드만을 선언하는 인터페이스를 무시하려면 아래 체크박스를 사용하세요.
    그러한 인터페이스는 구현 없이도 여전히 사용 가능합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: InterfaceNeverImplemented&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsConcreteCollection" defaultSeverity="WARNING" displayName="클래스가 'Collection' 클래스를 명시적으로 확장" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Collection&lt;/code&gt; 또는 &lt;code&gt;java.util.Map&lt;/code&gt; 클래스의 구체 하위 클래스를 확장하는 클래스를 보고합니다.
&lt;p&gt;
  구체 컬렉션 타입을 하위 클래스로 만드는 것은 흔하지만 좋지 않은 방법입니다. 컬렉션 호출을 위임하는 것보다 훨씬 더 불안정합니다.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExtendsConcreteCollection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticInheritance" defaultSeverity="WARNING" displayName="정적 상속" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상수에 대한 액세스를 제공하기 위해서만 구현된 인터페이스를 보고합니다.
이러한 종류의 상속은 혼란을 일으키기 쉽고, 중요한 종속성 정보를 숨길 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: StaticInheritance&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonProtectedConstructorInAbstractClass" defaultSeverity="WARNING" displayName="Abstract 클래스의 public 생성자" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;abstract&lt;/code&gt; 클래스의 &lt;code&gt;public&lt;/code&gt; 생성자를 보고합니다.
&lt;p&gt;
  &lt;code&gt;abstract&lt;/code&gt; 클래스의 생성자는 하위 클래스의 생성자에서만 호출할 수 있으므로 생성자를 &lt;code&gt;public&lt;/code&gt;으로 선언하면 혼란스러울 수 있습니다.
&lt;/p&gt;
&lt;p&gt;빠른 수정은 그러한 생성자를 protected로 만듭니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public abstract class&lt;/b&gt; Foo {
    &lt;b&gt;public&lt;/b&gt; Foo () { // 경고: 'public' 제어자가 있습니다
        /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public abstract class&lt;/b&gt; Foo {
    &lt;b&gt;protected&lt;/b&gt; Foo () {
        /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;p&gt;아래의 &lt;b&gt;public이 아닌 클래스에서 무시&lt;/b&gt; 옵션을 사용하면 &lt;code&gt;public&lt;/code&gt; 생성자를 public이 아닌 클래스에서 무시합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: NonProtectedConstructorInAbstractClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingOverrideAnnotation" defaultSeverity="INFORMATION" displayName="'@Override' 어노테이션 누락" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  &lt;code&gt;@java.lang.Override&lt;/code&gt; 어노테이션이 없는 상위 클래스 메서드를 재정의하는 메서드를 보고합니다.
  &lt;p&gt;
  메서드에 &lt;code&gt;@java.lang.Override&lt;/code&gt; 어노테이션을 추가하면 의도를 알 수 있기 때문에 코드 가독성이 향상됩니다.
  또한 컴파일러는 재정의된 메서드의 시그니처가상위 클래스 메서드와 일치하지 않는 경우 오류를 표시합니다.
  &lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;
    class X {
      public String toString() {
        return "hello world";
      }
    }
  &lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;
    class X {
      @Override
      public String toString() {
        return "hello world";
      }
    }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 구성:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;b&gt;'equals()', 'hashCode()', 'toString()' 무시&lt;/b&gt; 옵션을 사용하여 &lt;code&gt;java.lang.Object&lt;/code&gt; 메서드인 &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt;, &lt;code&gt;toString()&lt;/code&gt;을 무시합니다. 이러한 메서드가 &lt;code&gt;@Override&lt;/code&gt; 어노테이션 때문에 사라지고 코드가 더 이상 컴파일되지 않을
위험은 비교적 적습니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;b&gt;익명 클래스의 메서드 무시&lt;/b&gt; 옵션을 사용하여 익명 클래스에 있는 메서드를 무시합니다.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;@Override&lt;/code&gt; 어노테이션이 누락된 메서드만 경고하고, 하나 이상의 하위 항목에 &lt;code&gt;@Override&lt;/code&gt; 어노테이션이 누락된 재정의된 메서드는 경고하지 않으려면, &lt;b&gt;Highlight method when its overriding methods do not all have the '@Override' annotation(재정의하는 메서드에 '@Override' 어노테이션이 모두 없을 때 메서드 강조 표시)&lt;/b&gt; 옵션을 비활성화합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;어노테이션&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: MissingOverrideAnnotation&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ParameterTypePreventsOverriding" defaultSeverity="WARNING" displayName="매개변수 타입으로 인해 재정의 불가" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
하위 클래스 메서드의 매개변수 타입이 해당 상위 메서드의 매개변수 타입과 이름은 같지만 다른 패키지에 속하는 경우를 보고합니다.
이러한 경우에 하위 클래스 메서드는 상위 메서드를 재정의할 수 없습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;b&gt;public class&lt;/b&gt; A {
 &lt;b&gt;public void&lt;/b&gt; method(Object o) {}
}

&lt;b&gt;public class&lt;/b&gt; B &lt;b&gt;extends&lt;/b&gt; A {
 &lt;b&gt;public void&lt;/b&gt; method(Object o) {} // 매개변수 타입 경고
 &lt;b&gt;class&lt;/b&gt; Object {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;b&gt;public class&lt;/b&gt; A {
 &lt;b&gt;public void&lt;/b&gt; method(Object o) {}
}

&lt;b&gt;public class&lt;/b&gt; B &lt;b&gt;extends&lt;/b&gt; A {
 &lt;b&gt;public void&lt;/b&gt; method(java.lang.Object o) {} // 새 매개변수 타입
 &lt;b&gt;class&lt;/b&gt; Object {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ParameterTypePreventsOverriding&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractMethodOverridesConcreteMethod" defaultSeverity="WARNING" displayName="추상 메서드가 구체 메서드를 재정의" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구체 상위 메서드를 재정의하는 &lt;code&gt;abstract&lt;/code&gt; 메서드를 보고합니다.
&lt;p&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;로부터 재정의된 메서드는 이 검사에서 보고되지 않습니다.&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: AbstractMethodOverridesConcreteMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeParameterExtendsFinalClass" defaultSeverity="WARNING" displayName="타입 매개변수가 'final' 클래스를 확장" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;final&lt;/code&gt; 클래스를 확장하도록 선언된 타입 매개변수를 보고합니다.
&lt;p&gt;&lt;code&gt;final&lt;/code&gt; 클래스는 확장할 수 없으므로 타입 매개변수를 지정된 &lt;code&gt;final&lt;/code&gt; 클래스의 타입으로 바꿀 것을 제안합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo() {
    List&amp;lt;? &lt;b&gt;extends&lt;/b&gt; Integer&amp;gt; list; // 경고: Integer 클래스가 final 클래스입니다
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo() {
    List&amp;lt;Integer&amp;gt; list;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;이 검사는 Java 5부터 사용할 수 있는 Java 기능 &amp;#39;제네릭&amp;#39;에 의존합니다.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Inspection ID: TypeParameterExtendsFinalClass&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantMethodOverride" defaultSeverity="WARNING" displayName="메서드가 상위 메서드와 동일" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
상위 메서드와 동일한 메서드를 보고합니다. 그러한 메서드는 상위 메서드와 시그니처가 같거나 본문이 동일하거나 상위 메서드 호출만을 본문에 포함합니다.
이러한 메서드는 불필요하며 제거할 수 있습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  아래의 첫 번째 체크박스를 사용하여 라이브러리 메서드를 재정의하는 메서드에 대한 검사를 실행하세요.
  라이브러리 메서드를 검사하면 검사 속도가 느려질 수 있습니다.
&lt;p&gt;
  아래의 두 번째 체크박스를 사용하여 호출을 상위 메서드로 위임하기만 하는 메서드를 무시하세요.
&lt;p&gt;&lt;small&gt;Inspection ID: RedundantMethodOverride&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FrequentlyUsedInheritorInspection" defaultSeverity="INFORMATION" displayName="클래스가 일반적으로 사용되는 기본 클래스를 확장할 수 있음" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
더 구체적이며 일반적으로 사용되는 클래스 또는 인터페이스의 구현 또는 확장으로 대체 가능한 클래스 또는 인터페이스를 보고합니다.
&lt;p&gt;이 검사가 작동하려면 상위 클래스는 프로젝트 소스 파일에 있어야 하며 프로젝트는 IntelliJ IDEA 빌드 시스템을 사용해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyInheritor implements A {} // A 참조에 제안된 B

  interface A {}

  abstract class B implements A {}

  abstract class C1 extends B {}
  abstract class C2 extends B {}
  abstract class C3 extends B {}
  abstract class C4 extends B {}
  abstract class C5 extends B {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;기본적으로 이 검사는 에디터 내 이슈를 강조 표시하지 않으며, 빠른 수정만을 제공합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;2017.2의 새로운 기능&lt;/small&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: FrequentlyUsedInheritorInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JUnit" path=""><inspection shortName="MigrateAssertToMatcherAssert" defaultSeverity="WARNING" displayName="JUnit 어설션은 'assertThat()' 호출이 될 수 있음" enabled="false" language="UAST" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Hamcrest 선언 스타일의 &lt;code&gt;Assert.assertThat()&lt;/code&gt; 호출로 마이그레이션할 수 있는 &lt;code&gt;Assert.assertEquals()&lt;/code&gt;, &lt;code&gt;Assert.assertTrue()&lt;/code&gt; 등의 메서드에 대한 호출을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class SubstantialTest {
    @Test
    public void testContents(Collection&amp;lt;String&amp;gt; c, String s) {
      Assert.assertTrue(c.contains(s));
      Assert.assertEquals(c, s);
      Assert.assertNotNull(c);
      Assert.assertNull(c);
      Assert.assertFalse(c.contains(s));
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;제공되는 빠른 수정에서는 마이그레이션을 수행합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class SubstantialTest {
    @Test
    public void testContents(Collection&amp;lt;String&amp;gt; c, String s) {
      assertThat(c, hasItem(o));
      assertThat(o, is(c));
      assertThat(c, notNullValue());
      assertThat(c, nullValue());
      assertThat(c, not(hasItem(o)));
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사를 사용하려면 Hamcrest 라이브러리가 클래스 경로에 있어야 합니다.
&lt;p&gt;&lt;b&gt;매처 메서드를 정적으로 가져오기&lt;/b&gt;라는 옵션을 사용하여 빠른 수정으로 Hamcrest 매처 메서드를 정적으로 가져올지 여부를 지정할 수 있습니다.
&lt;p&gt;&lt;small&gt;Inspection ID: MigrateAssertToMatcherAssert&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Junit4Converter" defaultSeverity="INFORMATION" displayName="JUnit 3 테스트가 JUnit 4가 될 수 있음" enabled="false" language="UAST" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JUnit 4 테스트 클래스로 변환 가능한 JUnit 3 테스트 클래스를 보고합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class MainTestCase extends junit.framework.TestCase {
    public void test() {
      Assert.assertTrue(true);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class MainTestCase {
    @org.junit.Test
    public void test() {
      Assert.assertTrue(true);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사는 프로젝트 또는 모듈의 언어 수준이 5 이상이고, JUnit 4가 클래스 경로에 있는 경우에만 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: Junit4Converter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertEqualsMayBeAssertSame" defaultSeverity="WARNING" displayName="'assertEquals()'가 'assertSame()'이 될 수 있음" enabled="false" language="UAST" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
동등한 &lt;code&gt;assertSame()&lt;/code&gt; 호출로 바꿀 수 있는 JUnit &lt;code&gt;assertEquals()&lt;/code&gt; 호출을 보고합니다.
&lt;code&gt;Object.equals()&lt;/code&gt; 메서드를 재정의하지 않은 채 객체 ID가 비교됨을 명시적으로 만드는 &lt;code&gt;final&lt;/code&gt; 클래스의 인스턴스가 인수인 경우, 이러한 대체가 가능합니다.
&lt;p&gt;&lt;code&gt;assertEquals()&lt;/code&gt;를 &lt;code&gt;assertSame()&lt;/code&gt;으로 바꿀 것을 제안합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Test
  public void testObjectType() {
    Object o = getObject();
    Assert.assertEquals(String.class, o.getClass());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정 적용 후:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  public void testSort() {
    Object o = getObject();
    Assert.assertSame(String.class, o.getClass());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AssertEqualsMayBeAssertSame&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnit5Converter" defaultSeverity="WARNING" displayName="JUnit 4 테스트가 JUnit 5가 될 수 있음" enabled="false" language="UAST" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JUnit 5로 자동 마이그레이션되는 JUnit 4 테스트를 보고합니다.
디폴트 러너는 자동으로 변환되지만, 사용자 지정 러너, 메서드 규칙 및 필드 규칙은 자동으로 변환되지 않으므로 수동으로 변경해야 합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  import org.junit.Assert;
  import org.junit.Test;

  public class RelevantTest {
    @Test
    public void testIt() {
      Assert.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  import org.junit.jupiter.api.Assertions;
  import org.junit.jupiter.api.Test;

  public class RelevantTest {
    @Test
    public void testIt() {
      Assertions.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;이 검사를 수행하려면 JUnit 5 라이브러리가 클래스 경로에 있고, 프로젝트에 대해 JDK 1.8 이상이 구성되어 있어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JUnit5Converter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnit5AssertionsConverter" defaultSeverity="WARNING" displayName="JUnit 5 이전 버전의 어설션" enabled="false" language="UAST" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;JUnit 5 테스트의 &lt;code&gt;junit.framework.Assert&lt;/code&gt;, &lt;code&gt;org.junit.Assert&lt;/code&gt; 또는 &lt;code&gt;org.junit.Assume&lt;/code&gt; 클래스에 있는 메서드에 대한 호출을 보고합니다.&lt;/p&gt;
&lt;p&gt;테스트가 올바르게 작동하더라도 &lt;code&gt;org.junit.jupiter.api.Assertions&lt;/code&gt;/&lt;code&gt;org.junit.jupiter.api.Assumptions&lt;/code&gt;로 마이그레이션하는 편이 이전 JUnit 버전의 종속성을 방지하는 데 도움이 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  import org.junit.Assert;
  import org.junit.jupiter.api.Test;

  public class MyTest {
    @Test
    public void simpleTest() {
      Assert.assertEquals(4, 2 + 2);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  import org.junit.jupiter.api.Assertions;
  import org.junit.jupiter.api.Test;

  public class MyTest {
    @Test
    public void simpleTest() {
      Assertions.assertEquals(4, 2 + 2);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JUnit5AssertionsConverter&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Junit4RunWithInspection" defaultSeverity="WARNING" displayName="'@RunWith' 어노테이션이 이미 상위 클래스에 있습니다" enabled="false" language="UAST" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JUnit 테스트 계층 구조에서 상위 및 하위 클래스에 &lt;code&gt;@RunWith&lt;/code&gt; 어노테이션이 추가된 경우 보고합니다.
테스트가 예기치 않은 방식으로 동작할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @RunWith(Suite.class)
  @SuiteClasses(MySuiteClass.class)
  public abstract Parent {
  }

  @RunWith(Parameterized.class)
  public MyTest {
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;small&gt;2024.1의 새로운 기능&lt;/small&gt;
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: Junit4RunWithInspection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertEqualsCalledOnArray" defaultSeverity="WARNING" displayName="배열에서 'assertEquals()' 호출" enabled="false" language="UAST" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열 타입의 인수를 사용하는 JUnit &lt;code&gt;assertEquals()&lt;/code&gt; 호출을 보고합니다.
이러한 메서드는 배열의 내용 대신 배열의 ID를 비교합니다.
배열의 내용은 &lt;code&gt;assertArrayEquals()&lt;/code&gt; 메서드를 사용하여 검사해야 합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Test
  public void testSort() {
    int[] actual = {248, 496, 0, 56};
    Arrays.sort(actual);
    Assert.assertEquals(new int[] {0, 56, 248, 496}, actual);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Test
  public void testSort() {
    int[] actual = {248, 496, 0, 56};
    Arrays.sort(actual);
    Assert.assertArrayEquals(new int[] {0, 56, 248, 496}, actual);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AssertEqualsCalledOnArray&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExpectedExceptionNeverThrown" defaultSeverity="WARNING" displayName="테스트 메서드 본문에 필요한 예외가 던져지지 않음" enabled="false" language="JAVA" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JUnit 4 테스트 메서드에 필요하고, 메서드 본문 내에서 한 번도 던져지지 않은 확인된 예외를 보고합니다.
이러한 테스트 메서드는 절대 성공하지 못합니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Test(expected = CloneNotSupportedException.class)
  public void testIt() { }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: ExpectedExceptionNeverThrown&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnitMixedFramework" defaultSeverity="WARNING" displayName="하나의 TestCase 내에 여러 버전의 JUnit API 사용" enabled="false" language="JVM" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JUnit 어노테이션이 추가된 메서드가 다른 JUnit 버전의 테스트 사례에 사용되는 경우를 보고합니다. 이 검사는 테스트 사례의 프레임워크 버전을 확인하기 위해, 사용 가능한 경우 상위 클래스의 프레임워크 버전을 확인합니다. 상위 클래스를 사용할 수 없는 경우 테스트 사례에서 가장 많이 사용되는 프레임워크를 사용합니다.
&lt;p&gt;예시(JUnit 3 테스트 사례의 JUnit 4 어노테이션):&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class MyTest extends TestCase {
      @Test
      public void foo() { }

      @Test
      @Ignore
      public void testBar() { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class MyTest extends TestCase {
      public void testFoo() {}

      public void _testBar() {}
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예시(JUnit 4 테스트 사례의 JUnit 5 어노테이션):&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class MyTest {
      @BeforeAll // JUnit 5 수명 주기 메서드
      public void initialize() { }

      @org.junit.Test  // JUnit 4 테스트 어노테이션
      public void test() {}

      @org.junit.Test  // JUnit 4 테스트 어노테이션
      public void testWouldBeExecuted() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class MyTest {
      @BeforeClass // JUnit 4 수명 주기 메서드
      public void initialize() { }

      @org.junit.Test  // JUnit 4 테스트 어노테이션
      public void test() {}

      @org.junit.Test  // JUnit 4 테스트 어노테이션
      public void testWouldBeExecuted() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JUnitMixedFramework&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnitMalformedDeclaration" defaultSeverity="ERROR" displayName="JUnit 잘못된 형식의 선언" enabled="false" language="UAST" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
형식이 잘못되어 JUnit 테스트 프레임워크에서 인식되지 않는 JUnit 테스트 멤버 선언을 보고합니다.
이 검사에서는 다음 문제를 보고합니다.
&lt;ul&gt;
  &lt;li&gt;생성할 수 없는 테스트 클래스&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@RegisterExtension&lt;/code&gt; 어노테이션이 추가되었으며 타입이 잘못되었거나, 필요한 경우 static으로 선언되지 않은 필드&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Nested&lt;/code&gt; 어노테이션이 추가된 static 또는 private 내부 클래스&lt;/li&gt;
  &lt;li&gt;소스 없이 정의된 매개변수화된 테스트&lt;/li&gt;
  &lt;li&gt;알 수 없거나 static이 아니거나 인수 타깃이 없는 &lt;code&gt;@MethodSource&lt;/code&gt;를 사용하는 매개변수화된 테스트&lt;/li&gt;
  &lt;li&gt;매개변수화된 테스트 메서드 매개변수와 지정된 &lt;code&gt;@ValueSource&lt;/code&gt; 또는 &lt;code&gt;@EnumSource&lt;/code&gt; 값 간에 일치하지 않는 타입&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@Test&lt;/code&gt;, &lt;code&gt;@ParameterizedTest&lt;/code&gt; 또는 &lt;code&gt;@RepeatedTest&lt;/code&gt; 중 2개 이상의 어노테이션이 추가된 테스트&lt;/li&gt;
  &lt;li&gt;public이 아니거나, 반환 타입이 void가 아니거나, 인수를 취하는 &lt;code&gt;setup()&lt;/code&gt; 또는 &lt;code&gt;teropDown()&lt;/code&gt; 메서드&lt;/li&gt;
  &lt;li&gt;private이거나, 인수를 취하거나, static이 아닌 &lt;code&gt;suite()&lt;/code&gt; 메서드&lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;@BeforeClass&lt;/code&gt;, &lt;code&gt;@AfterClass&lt;/code&gt;, &lt;code&gt;@BeforeAll&lt;/code&gt; 또는 &lt;code&gt;@AfterAll&lt;/code&gt; 어노테이션이 추가되었으며, public이 아니거나, static이 아니거나, 반환 타입이 void가 아니거나, 올바른 매개변수 목록이 없는 메서드
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;@Before&lt;/code&gt;, &lt;code&gt;@After&lt;/code&gt;, &lt;code&gt;@BeforeEach&lt;/code&gt; 또는 &lt;code&gt;@AfterEach&lt;/code&gt; 어노테이션이 추가되었으며, public이 아니거나, 반환 타입이 void가 아니거나, 인수를 취하는 메서드
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@BeforeAll&lt;/code&gt; 또는 &lt;code&gt;@AfterAll&lt;/code&gt; 메서드에 삽입된 &lt;code&gt;RepetitionInfo&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;@Test&lt;/code&gt; 어노테이션이 추가된 테스트에서 사용되는 &lt;code&gt;@BeforeEach&lt;/code&gt; 또는 &lt;code&gt;@AfterEach&lt;/code&gt; 메서드에 삽입된 &lt;code&gt;RepetitionInfo&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@DataPoint&lt;/code&gt; 또는 &lt;code&gt;@DataPoints&lt;/code&gt; 어노테이션이 추가되었으며, public이 아니거나, static이 아닌 필드 및 메서드&lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;@Rule&lt;/code&gt; 어노테이션이 추가되었으며, public이 아니거나, &lt;code&gt;TestRule&lt;/code&gt; 또는 &lt;code&gt;MethodRule&lt;/code&gt;의 하위 타입이 아닌 필드 및 메서드
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@ClassRule&lt;/code&gt; 어노테이션이 추가되었으며, public이 아니거나, static이 아니거나, &lt;code&gt;TestRule&lt;/code&gt;의 하위 타입이 아닌 필드 및 메서드&lt;/li&gt;
  &lt;li&gt;
    접두사가 &lt;code&gt;test&lt;/code&gt;인 &lt;code&gt;TestCase&lt;/code&gt;의 하위 클래스 내에 있으며, public이 아니거나, 반환 타입이 void가 아니거나, 인수를 취하거나, static인 메서드
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;@Test&lt;/code&gt; 어노테이션이 추가되었으며, public이 아니거나, 반환 타입이 void가 아니거나, 인수를 취하거나, static인 메서드
  &lt;/li&gt;
&lt;/ul&gt;

Kotlin에서 일시 중지 함수는 인수를 가지며 void가 아닌 반환 타입을 취합니다. 따라서 JUnit 테스트 러너에 의해 실행되지 않습니다. 이 검사는 이 문제에 대해서도 보고합니다.

&lt;p&gt;&lt;b&gt;잘못된 형식의 &lt;code&gt;@Before&lt;/code&gt; 메서드 예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Before private int foo(int arg) { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Before public void foo() { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;누락된 메서드 소스의 예시(Kotlin):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="kotlin"&gt;
  class Example {
    @MethodSource("parameters")
    @ParameterizedTest
    fun foo(param: String) { ... }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="kotlin"&gt;
  class Example {
    @MethodSource("parameters")
    @ParameterizedTest
    fun foo(param: String) { ... }

    companion object {
      @JvmStatic
      fun parameters(): Stream&amp;lt;Arguments&amp;gt; {
        TODO("Not yet implemented")
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;검사 옵션을 사용하여 어노테이션을 지정합니다. 해당 어노테이션 중 하나가 추가된 매개변수는 보고되지 않습니다.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JUnitMalformedDeclaration&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IgnoredJUnitTest" defaultSeverity="WARNING" displayName="JUnit 테스트에 '@Ignore'/'@Disabled' 어노테이션 추가" enabled="false" language="UAST" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JUnit 4의 &lt;code&gt;@Ignore&lt;/code&gt; 또는 JUnit 5의 &lt;code&gt;@Disabled&lt;/code&gt; 어노테이션이 사용된 경우를 보고합니다.
이러한 어노테이션이 추가된 테스트를 오래 보유하고 있는 경우, 특히 이유가 지정되어 있지 않으면 코드 스멜로 간주됩니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Ignore
  &lt;b&gt;public class&lt;/b&gt; UrgentTest {

    @Test
    &lt;b&gt;public void&lt;/b&gt; testIt() {
      Assert.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  검사 구성:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;b&gt;이유가 지정되지 않은 어노테이션만 보고&lt;/b&gt;라는 옵션을 사용하여 어노테이션의 &lt;code&gt;value&lt;/code&gt; 속성으로 지정된 이유가 없는 사례만 보고합니다.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: IgnoredJUnitTest&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfObsoleteAssert" defaultSeverity="WARNING" displayName="곧 사용할 수 없게 될 'junit.framework.Assert' 메서드 사용" enabled="false" language="JAVA" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;junit.framework.Assert&lt;/code&gt; 클래스에서 이루어지는 모든 메서드 호출을 보고합니다. 이 클래스는 사용이 중단되었으며 이 호출은 &lt;code&gt;org.junit.Assert&lt;/code&gt; 클래스의 메서드 호출로 바꿀 수 있습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  &lt;b&gt;import&lt;/b&gt; org.junit.*;
  &lt;b&gt;public class&lt;/b&gt; NecessaryTest {
    @Test
    &lt;b&gt;public void&lt;/b&gt; testIt() {
      junit.framework.Assert.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정이 적용된 후 결과는 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  &lt;b&gt;import&lt;/b&gt; org.junit;
  &lt;b&gt;public class&lt;/b&gt; NecessaryTest {

    &lt;b&gt;public void&lt;/b&gt; testIt() {
      Assert.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: UseOfObsoleteAssert&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuperTearDownInFinally" defaultSeverity="WARNING" displayName="JUnit 3 'super.tearDown()'이 'finally' 블록에서 호출되지 않음" enabled="false" language="UAST" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;finally&lt;/code&gt; 블록 내에서 수행되지 않는 JUnit 3의 &lt;code&gt;super.tearDown()&lt;/code&gt; 메서드 호출을 보고합니다.
&lt;code&gt;super.tearDown()&lt;/code&gt; 호출 전에 예외가 던져지면 비일관성 및 누수가 발생할 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class AnotherTest extends CompanyTestCase {
    private Path path;

    @Override
    protected void setUp() throws Exception {
      super.setUp();
      path = Files.createTempFile("File", ".tmp");
    }

    @Override
    protected void tearDown() throws Exception {
      Files.delete(path);
      super.tearDown();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;개선된 코드:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  public class AnotherTest extends CompanyTestCase {
    private Path path;

    @Override
    protected void setUp() throws Exception {
      super.setUp();
      path = Files.createTempFile("File", ".tmp");
    }

    @Override
    protected void tearDown() throws Exception {
      try {
        Files.delete(path);
      } finally {
        super.tearDown();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: SuperTearDownInFinally&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnit3StyleTestMethodInJUnit4Class" defaultSeverity="WARNING" displayName="JUnit 4 클래스의 이전 스타일 JUnit 테스트 메서드" enabled="false" language="JAVA" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JUnit 3 &lt;code&gt;TestCase&lt;/code&gt;를 확장하지 않거나, JUnit 4 또는 JUnit 5 &lt;code&gt;@Test&lt;/code&gt; 어노테이션이 추가된 메서드를 포함하는 클래스 내 JUnit 3 스타일 테스트 메서드를 보고합니다.
그러한 테스트 메서드는 실행할 수 없습니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JUnit3StyleTestMethodInJUnit4Class&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterizedParametersStaticCollection" defaultSeverity="WARNING" displayName="데이터 공급자 메서드가 없는 매개변수화된 테스트 클래스" enabled="false" language="JAVA" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
JUnit 4의 &lt;a href="https://github.com/junit-team/junit4/wiki/parameterized-tests"&gt;매개변수화된 테스트&lt;/a&gt; 클래스 중 &lt;code&gt;@RunWith(Parameterized.class)&lt;/code&gt; 어노테이션이 추가되었지만, &lt;code&gt;@Parameterized.Parameters&lt;/code&gt; 어노테이션이 추가된 데이터 제공자 메서드가 없거나, 이 메서드의 시그너처가 올바르지 않은 경우를 보고합니다. 이러한 테스트 클래스는 실행할 수 없습니다.
데이터 제공자 메서드는 &lt;code&gt;public&lt;/code&gt; 및 &lt;code&gt;static&lt;/code&gt;이어야 하며, 반환 타입 &lt;code&gt;Iterable&lt;/code&gt; 또는 &lt;code&gt;Object[]&lt;/code&gt;를 가져야 합니다.
&lt;p&gt;빈 매개변수 제공자 메서드를 작성하거나 잘못된 데이터 공급자 메서드의 시그니처를 변경할 것을 제안합니다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @RunWith(Parameterized.class)
  public class ImportantTest {
    private int input;
    private int expected;

    ImportantTest(int input, int expected) {
      this.input = input;
      this.expected = expected;
    }

    // ... 테스트 케이스
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @RunWith(Parameterized.class)
  public class ImportantTest {
    private int input;
    private int expected;

    ImportantTest(int input, int expected) {
      this.input = input;
      this.expected = expected;
    }

    @Parameters
    public static Iterable&amp;lt;Object[]&gt; parameters() {
      return null;
    }

    // ... test cases
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;&lt;small&gt;Inspection ID: ParameterizedParametersStaticCollection&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleExceptionsDeclaredOnTestMethod" defaultSeverity="WARNING" displayName="테스트 메서드에서 선언된 여러 예외" enabled="false" language="JAVA" pluginId="JUnit" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
2개 이상의 예외를 포함하는 JUnit 테스트 메서드 &lt;code&gt;throws&lt;/code&gt; 절을 보고합니다.
그러한 절은 불필요하게 장황합니다.
테스트 메서드는 다른 프로젝트 코드에서 호출되지 않으므로 이러한 예외를 별도로 취급할 필요가 없습니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Test
  public void testReflection() throws NoSuchMethodException,
      InvocationTargetException, IllegalAccessException {
    String result = (String) String.class.getMethod("trim")
        .invoke(" hello ");
    assertEquals("hello", result);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;제공되는 빠른 수정에서는 여러 개의 예외 선언을 하나의 예외로 바꿉니다.&lt;/p&gt;
&lt;pre&gt;&lt;code lang="java"&gt;
  @Test
  public void testReflection() throws Exception {
    String result = (String) String.class.getMethod("trim")
        .invoke(" hello ");
    assertEquals("hello", result);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: MultipleExceptionsDeclaredOnTestMethod&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="발생할 수 있는 버그" path="JavaScript 및 TypeScript"><inspection shortName="JSPotentiallyInvalidTargetOfIndexedPropertyAccess" defaultSeverity="WARNING" displayName="색인 생성된 프로퍼티 액세스 타깃이 잘못되었을 수 있습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
잠재적으로 유효하지 않은 색인화된 프로퍼티 액세스를 보고합니다(예: &lt;code&gt;Array[1]&lt;/code&gt;).
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSPotentiallyInvalidTargetOfIndexedPropertyAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSTypeOfValues" defaultSeverity="WARNING" displayName="비표준 값과 'typeof' 비교" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
표준 타입(&lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt; object&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;, &lt;code&gt;function&lt;/code&gt; 중 하나가 아닌 리터럴 문자열과 &lt;code&gt;typeof&lt;/code&gt; 식의 비교를 보고합니다.
그러한 비교는 항상 &lt;code&gt;false&lt;/code&gt;를 반환합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSTypeOfValues&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSSuspiciousNameCombination" defaultSeverity="WARNING" displayName="의심스러운 변수/매개변수 이름 조합" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;!-- Copied from community/java/java-impl/src/inspectionDescriptions/SuspiciousNameCombination.html --&gt;
&lt;html&gt;
&lt;body&gt;
대상 변수 또는 함수 매개변수의 이름이 대입된 값의 이름과 일치하지 않는 대입 또는 함수 호출을 보고합니다.
&lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;var&lt;/b&gt; x = 0;
  &lt;b&gt;var&lt;/b&gt; y = x;
&lt;/code&gt;&lt;/pre&gt;
또는
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;var&lt;/b&gt; x = 0, y = 0;
  &lt;b&gt;var&lt;/b&gt; rc = &lt;b&gt;new&lt;/b&gt; Rectangle(y, x, 20, 20);
&lt;/code&gt;&lt;/pre&gt;
여기서 검사는 &lt;code&gt;x&lt;/code&gt;와 &lt;code&gt;y&lt;/code&gt;가 혼합되어 있다고 추측합니다.
&lt;!-- tooltip end --&gt;
&lt;p&gt;함께 사용해서는 안 되는 이름을 지정합니다. 매개변수 이름 또는 대입 대상 이름에 한 그룹에 속한 단어가 포함되어 있으나 대입된 변수 또는 전달된 변수의 이름에는 다른 그룹의 단어가 포함되어 있는 경우에 오류를 보고합니다.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: JSSuspiciousNameCombination&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSPotentiallyInvalidUsageOfThis" defaultSeverity="WARNING" displayName="클로저에서 'this'에 대한 참조가 잘못되었을 수 있습니다." enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
외부 컨텍스트의 프로퍼티 참조를 위해 사용된 클로저 내 &lt;code&gt;this&lt;/code&gt;를 보고합니다. &lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function Outer() {
  this.outerProp = 1;
  function inner() {
    // Outer의 'outerProp' 때문에 좋지 않음
    // 여기서 업데이트 안 함
    // 'new Outer()'를 호출할 수 있음
    this.outerProp = 2;
  }
  inner();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSPotentiallyInvalidUsageOfThis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectAllocationIgnoredJS" defaultSeverity="WARNING" displayName="객체 대입의 결과가 무시됨" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
아무 대입이 없이 구문으로 &lt;code&gt;new Error();&lt;/code&gt;를 사용하는 경우와 같이 할당된 객체의 결과가 무시되는 객체 할당을 보고합니다.
그런 할당식은 이상한 객체 초기화 전략을 나타낼 수 있습니다. 
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ObjectAllocationIgnoredJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSIncompatibleTypesComparison" defaultSeverity="WEAK WARNING" displayName="호환되지 않는 타입이 있는 표현식 비교" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
호환성이 없는 타입의 피연산자 또는 가능한 공통 값이 없는 타입의 피연산자와의 비교를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSIncompatibleTypesComparison&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSPotentiallyInvalidConstructorUsage" defaultSeverity="WARNING" displayName="생성자 사용 위치가 잘못되었을 수 있습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
잠재적으로 유효하지 않은 생성자 함수의 사용 위치를 보고합니다(예: &lt;code&gt;new&lt;/code&gt; 뒤의 생성자가 아닌 함수, 생성자 프로토타입 사용 또는 &lt;code&gt;new&lt;/code&gt; 없이 생성자 호출). 생성자 함수에 대문자 이름(옵션)이나 명시적 JSDoc &lt;code&gt;@constructor&lt;/code&gt; 태그가 있다고 가정합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSPotentiallyInvalidConstructorUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSConsecutiveCommasInArrayLiteral" defaultSeverity="WARNING" displayName="배열 리터럴 내 연속 쉼표" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
배열 리터럴 내 연속적인 쉼표를 보고합니다. 건너뛴 요소는 &lt;code&gt;undefined&lt;/code&gt; 값을 받아들이지만 
쉼표가 행의 끝과 다음 행의 시작에 있는 경우와 같이 의도치 않게 쉼표가 삽입되는 경우가 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSConsecutiveCommasInArrayLiteral&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSPotentiallyInvalidUsageOfClassThis" defaultSeverity="WARNING" displayName="클로저에서 클래스의 'this'에 대한 참조가 잘못되었을 수 있습니다." enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
람다가 아닌 중첩 함수의 &lt;code&gt;this.&lt;/code&gt; 한정자를 통해 ECMAScript 클래스의 멤버를 참조하려는 시도를 보고합니다.&lt;br/&gt;
람다가 아닌 중첩 함수의 &lt;code&gt;this&lt;/code&gt;는 함수 자체의 &lt;code&gt;this&lt;/code&gt;이며, 외부 클래스와는 관계가 없습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSPotentiallyInvalidUsageOfClassThis&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSSuspiciousEqPlus" defaultSeverity="WARNING" displayName="의심스러운 '=+' 대입" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;a =+ b&lt;/code&gt; 양식의 대입을 보고합니다.
&lt;code&gt;a += b&lt;/code&gt;으로 바꿀 것을 제안합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSSuspiciousEqPlus&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DivideByZeroJS" defaultSeverity="WARNING" displayName="0으로 나누기" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
0에 의한 나누기 또는 나머지를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: DivideByZeroJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSVoidFunctionReturnValueUsed" defaultSeverity="WARNING" displayName="void 함수 반환 값이 사용됨" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
어떤 것도 반환하지 않는 함수의 반환값을 보고합니다.
그러한 함수를 호출하면 항상 &lt;code&gt;undefined&lt;/code&gt; 값이 생성되며 그러한 대입은 에러를 나타낼 수 있습니다. &lt;p&gt;예:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
let a = console.log('foo');
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
다음 사용 위치가 무시됩니다:
&lt;ul&gt;
  &lt;li&gt;return 문 내부&lt;/li&gt;
  &lt;li&gt;일부 이항연산 내&lt;/li&gt;
  &lt;li&gt;재정의된 비 void 함수&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSVoidFunctionReturnValueUsed&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ES6BindWithArrowFunction" defaultSeverity="WARNING" displayName="의심스러운 화살표 함수와 'bind' 사용 위치" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
화살표 함수와 함께 사용된 &lt;code&gt;bind&lt;/code&gt;를 보고합니다.&lt;br/&gt;
화살표 함수는 렉시컬 &lt;code&gt;this&lt;/code&gt;를 사용하기 때문에 &lt;code&gt;bind&lt;/code&gt; 호출에 아무런 영향을 미치지 않습니다.&lt;br/&gt;
자세한 내용은 &lt;a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Lexical_this"&gt;여기&lt;/a&gt;를 참고하십시오.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ES6BindWithArrowFunction&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSComparisonWithNaN" defaultSeverity="WARNING" displayName="NaN과 비교" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
NaN과의 비교를 보고합니다. &lt;code&gt;expr == NaN&lt;/code&gt; 또는 &lt;code&gt;expr === NaN&lt;/code&gt;와 같은 비교는 반드시&lt;code&gt;false&lt;/code&gt;로 평가됩니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSComparisonWithNaN&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForLoopThatDoesntUseLoopVariableJS" defaultSeverity="WARNING" displayName="업데이트 또는 조건이 루프 변수를 사용하지 않는 'for' 루프" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
조건 또는 업데이트가 &lt;code&gt;for&lt;/code&gt; 루프 변수를 사용하지 않는 &lt;code&gt;for&lt;/code&gt; 루프를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: ForLoopThatDoesntUseLoopVariableJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InfiniteRecursionJS" defaultSeverity="WARNING" displayName="무한 재귀" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
무한으로 재귀하거나 예외를 던지는 
함수를 보고합니다. 그러한 함수는 일반적으로 반환하지 않습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: InfiniteRecursionJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InfiniteLoopJS" defaultSeverity="WARNING" displayName="무한 루프 문" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
예외를 던져야만 종료할 수 있는 &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, 또는&lt;code&gt;do&lt;/code&gt; 문을 보고합니다. 그러한 구문은 보통 코딩 오류를 나타냅니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: InfiniteLoopJS&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JSEqualityComparisonWithCoercion" defaultSeverity="WARNING" displayName="동치 연산자는 타입 강제 변환을 일으킬 수 있습니다" enabled="false" language="JavaScript" pluginId="JavaScript" pluginVersion="252.23892.458" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
예기치 않은 타입 강제 변환을 일으키는 상등 연산자의 사용 위치를 보고합니다.
&lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt;을 타입 안전 상등 연산자 &lt;code&gt;===&lt;/code&gt; 및 &lt;code&gt;!==&lt;/code&gt;로 바꿀 것을 제안합니다.
&lt;p&gt;선택한 옵션에 따라 다음 중 하나가 보고됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 연산자의 모든 사용 위치.
  &lt;/li&gt;
  &lt;li&gt;
    null과의 비교를 제외한 모든 사용 위치. 일부 코드 스타일은 &lt;code&gt;x === null || x === undefined&lt;/code&gt; 대신 &lt;code&gt;x == null&lt;/code&gt;을 사용할 수 있도록 허용합니다.
  &lt;/li&gt;
  &lt;li&gt;
    의심스러운 표현식만(예: &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;''&lt;/code&gt;, 
&lt;code&gt;null&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, 
&lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt;와의 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 비교).
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: JSEqualityComparisonWithCoercion&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="GPath" path="Groovy"><inspection shortName="GroovyListGetCanBeKeyedAccess" defaultSeverity="WARNING" displayName="List.get 호출이 키 액세스일 수 있습니다" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.List.get()&lt;/code&gt; 메서드 호출을 보고합니다. 그러한 호출은 더 짧고 명확한 키를 사용하는 액세스 형식으로 바꿀 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
def str = list.get(0) // list.get(0)을 list[0]로 바꿀 수 있습니다
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
def str = list[0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyListGetCanBeKeyedAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMapPutCanBeKeyedAccess" defaultSeverity="WARNING" displayName="Map.put 호출이 키 액세스일 수 있습니다" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Map.put()&lt;/code&gt; 메서드 호출을 보고합니다. 그러한 호출은 더 짧고 명확한 키를 사용하는 액세스 형식으로 바꿀 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = ["foo": "bar"]
map.put("foo", "baz") // map.put("foo", "baz")을 map["foo"] = "baz"로 바꿀 수 있습니다
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = ["foo": "bar"]
map["foo"] = "baz"
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyMapPutCanBeKeyedAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyListSetCanBeKeyedAccess" defaultSeverity="WARNING" displayName="List.set 호출이 키 액세스일 수 있습니다" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.List.set()&lt;/code&gt; 메서드 호출을 보고합니다. 그러한 호출은 더 짧고 명확한 키를 사용하는 액세스 형식으로 바꿀 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
list.set(0, "bar") // list.set(0, "bar")을 list[0] = "bar"로 바꿀 수 있습니다
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
list[0] = "bar"
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyListSetCanBeKeyedAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMapGetCanBeKeyedAccess" defaultSeverity="WARNING" displayName="Map.get 호출이 키 액세스일 수 있습니다" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;java.util.Map.get()&lt;/code&gt; 메서드 호출을 보고합니다. 그러한 호출은 더 짧고 명확한 키를 사용하는 액세스 형식으로 바꿀 수 있습니다.
&lt;p&gt;&lt;b&gt;예:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = ["foo": "bar"]
def str = map.get("foo") // map.get("foo")을 map["foo"]으로 바꿀 수 있습니다
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;빠른 수정을 적용한 후:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = ["foo": "bar"]
def str = map["foo"]
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: GroovyMapGetCanBeKeyedAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Android Lint: Interoperability" path=""><inspection shortName="AndroidLintUnknownNullness" defaultSeverity="WARNING" displayName="Unknown nullness" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unknown nullness&lt;br&gt;&lt;br&gt;To improve referencing this code from Kotlin, consider adding explicit nullness information here with either &lt;code&gt;@NonNull&lt;/code&gt; or &lt;code&gt;@Nullable&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: UnknownNullness&lt;br&gt;&lt;br&gt;Available options:&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;ignore-deprecated&lt;/b&gt; (default is false):&lt;br/&gt;
Whether to ignore classes and members that have been annotated with &lt;code&gt;@Deprecated&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Normally this lint check will flag all unannotated elements, but by setting this option to &lt;code&gt;true&lt;/code&gt; it will skip any deprecated elements.&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="UnknownNullness"&gt;
        &amp;lt;option name="ignore-deprecated" value="false" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/kotlin/interop#nullability_annotations"&gt;https://developer.android.com/kotlin/interop#nullability_annotations&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintJavaPluginLanguageLevel" defaultSeverity="WARNING" displayName="No Explicit Java Language Level Given" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;No Explicit Java Language Level Given&lt;br&gt;&lt;br&gt;In modules using plugins deriving from the Gradle &lt;code&gt;java&lt;/code&gt; plugin (e.g. &lt;code&gt;java-library&lt;/code&gt; or &lt;code&gt;application&lt;/code&gt;), the java source and target compatibility default to the version of the JDK being used to run Gradle, which may cause compatibility problems with Android (or other) modules.&lt;br/&gt;
&lt;br/&gt;
You can specify an explicit sourceCompatibility and targetCompatibility in this module to maintain compatibility no matter which JDK is used to run Gradle.&lt;br&gt;&lt;br&gt;Issue id: JavaPluginLanguageLevel&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintKotlinPropertyAccess" defaultSeverity="WARNING" displayName="Kotlin Property Access" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Kotlin Property Access&lt;br&gt;&lt;br&gt;For a method to be represented as a property in Kotlin, strict &amp;#8220;bean&amp;#8221;-style prefixing must be used.&lt;br/&gt;
&lt;br/&gt;
Accessor methods require a &lt;code&gt;get&lt;/code&gt; prefix or for boolean-returning methods an &lt;code&gt;is&lt;/code&gt; prefix can be used.&lt;br&gt;&lt;br&gt;Issue id: KotlinPropertyAccess&lt;br&gt;&lt;br&gt;&lt;a href="https://android.github.io/kotlin-guides/interop.html#property-prefixes"&gt;https://android.github.io/kotlin-guides/interop.html#property-prefixes&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLambdaLast" defaultSeverity="WARNING" displayName="Lambda Parameters Last" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Lambda Parameters Last&lt;br&gt;&lt;br&gt;To improve calling this code from Kotlin, parameter types eligible for SAM conversion should be last.&lt;br&gt;&lt;br&gt;Issue id: LambdaLast&lt;br&gt;&lt;br&gt;&lt;a href="https://android.github.io/kotlin-guides/interop.html#lambda-parameters-last"&gt;https://android.github.io/kotlin-guides/interop.html#lambda-parameters-last&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNoHardKeywords" defaultSeverity="WARNING" displayName="No Hard Kotlin Keywords" enabled="false" pluginId="org.jetbrains.android" pluginVersion="252.23892.458" isGlobalTool="true">&lt;html&gt;&lt;body&gt;No Hard Kotlin Keywords&lt;br&gt;&lt;br&gt;Do not use Kotlin&amp;#8217;s hard keywords as the name of methods or fields. These require the use of backticks to escape when calling from Kotlin. Soft keywords, modifier keywords, and special identifiers are allowed.&lt;br/&gt;
&lt;br/&gt;
For example, ActionEvent's &lt;code&gt;getWhen()&lt;/code&gt; method requires backticks when used from Kotlin:
&lt;pre&gt;
val timestamp = event.`when`
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;Issue id: NoHardKeywords&lt;br&gt;&lt;br&gt;&lt;a href="https://android.github.io/kotlin-guides/interop.html#no-hard-keywords"&gt;https://android.github.io/kotlin-guides/interop.html#no-hard-keywords&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Angular" path=""><inspection shortName="AngularUnsupportedSyntax" defaultSeverity="ERROR" displayName="지원되지 않는 Angular 식 구문" enabled="false" language="Angular2" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
오래된 버전의 Angular에서는 지원되지 않아 문제가 있는 Angular 식 구문을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularUnsupportedSyntax&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularIncorrectTemplateDefinition" defaultSeverity="ERROR" displayName="잘못된 구성 요소 템플릿 정의" enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
연결된 템플릿을 포함하지 않거나 &lt;code&gt;template&lt;/code&gt; 및 &lt;code&gt;templateUrl&lt;/code&gt; 프로퍼티를 둘 다 사용하는 구성 요소를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularIncorrectTemplateDefinition&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularUndefinedBinding" defaultSeverity="ERROR" displayName="정의되지 않은 바인딩" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
요소에 대한 정의되지 않은 프로퍼티, 이벤트, 또는 구조 지시문 바인딩을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularUndefinedBinding&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularNonStandaloneComponentImports" defaultSeverity="ERROR" displayName="독립 실행형이 아닌 구성 요소의 올바르지 않은 import 사용 위치" enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
독립실행형이 아닌 구성 요소 데코레이터 내에서 imports 프로퍼티가 사용된 경우를 보고합니다. Imports는 독립실행형 구성 요소에서만 사용될 수 있습니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularNonStandaloneComponentImports&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularAmbiguousComponentTag" defaultSeverity="ERROR" displayName="모호한 구성 요소 태그" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
임베딩된 템플릿 요소의 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt;에서 일치하는 구성 요소 또는 기타 임의의 요소에서 일치하는 여러 구성 요소를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularAmbiguousComponentTag&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularInaccessibleSymbol" defaultSeverity="ERROR" displayName="액세스할 수 없는 구성 요소 멤버 또는 지시문 입력" enabled="false" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Angular 템플릿의 보이지 않는(private 또는 protected) 구성 요소 멤버 또는 지시문 입력에 대한 액세스를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularInaccessibleSymbol&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularInsecureBindingToEvent" defaultSeverity="WARNING" displayName="안전하지 않은 이벤트로의 바인드" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;(click)&lt;/code&gt;이 아닌 이벤트 프로퍼티 또는 속성에 대한 바인딩을 보고합니다(예: &lt;code&gt;[onclick]&lt;/code&gt; 또는 &lt;code&gt;[attr.onclick]&lt;/code&gt;).
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularInsecureBindingToEvent&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularInvalidI18nAttribute" defaultSeverity="WARNING" displayName="잘못된 i18n 속성" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;i18n-*&lt;/code&gt; 속성 문제를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularInvalidI18nAttribute&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularInvalidEntryComponent" defaultSeverity="ERROR" displayName="잘못된 입력 구성 요소" enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
모듈의 &lt;code&gt;bootstrap&lt;/code&gt; 또는 &lt;code&gt;entryComponents&lt;/code&gt; 프로퍼티에 지정된 잘못된 Angular 구성 요소를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularInvalidEntryComponent&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularDeferBlockOnTrigger" defaultSeverity="ERROR" displayName="@defer 'on' 트리거의 문제" enabled="false" language="Angular2Html" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
`@defer` 블록 내 `on` 매개변수에서 트리거와 관련된 문제를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularDeferBlockOnTrigger&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularMissingEventHandler" defaultSeverity="ERROR" displayName="이벤트 핸들러 누락" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
이벤트 바인딩의 이벤트 핸들러 구문 누락을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularMissingEventHandler&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularIllegalForLoopTrackAccess" defaultSeverity="ERROR" displayName="잘못된 @for 루프 액세스" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;@for&lt;/code&gt; 루프 &lt;code&gt;track&lt;/code&gt; 식 내의 템플릿 변수에 대한 부적절한 액세스를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularIllegalForLoopTrackAccess&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularUndefinedModuleExport" defaultSeverity="ERROR" displayName="Angular 모듈에서 정의되지 않은 내보내기" enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Angular 모듈에서 선언되어 있지 않거나 가져오지 않은 구성 요소, 지시문, 파이프의 내보내기를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularUndefinedModuleExport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularIncorrectBlockUsage" defaultSeverity="ERROR" displayName="Angular 블록의 잘못된 사용" enabled="false" language="Angular2Html" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Angular 블록 문제를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularIncorrectBlockUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularIncorrectLetUsage" defaultSeverity="ERROR" displayName="@let 선언의 잘못된 사용" enabled="false" language="Angular2" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
@let 선언 사용 위치의 문제를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularIncorrectLetUsage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularMultipleStructuralDirectives" defaultSeverity="ERROR" displayName="하나의 요소에 대한 여러 개의 구조 지시문" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
하나의 요소에 있는 여러 구조 지시문을 보고합니다(&lt;code&gt;*ngIf&lt;/code&gt;, &lt;code&gt;*ngFor&lt;/code&gt; 등).
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularMultipleStructuralDirectives&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularRecursiveModuleImportExport" defaultSeverity="ERROR" displayName="Angular 모듈 또는 독립실행형 구성 요소의 재귀적 가져오기 또는 내보내기" enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Angular 모듈과 독립실행형 모듈 간의 순환 종속성을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularRecursiveModuleImportExport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularBindingTypeMismatch" defaultSeverity="ERROR" displayName="잘못된 바인딩 타입" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
실제 지시문 바인딩 타입과 필요한 타입이 불일치하면 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularBindingTypeMismatch&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularForBlockNonIterableVar" defaultSeverity="ERROR" displayName="@for 블록 내 반복할 수 없는 타입" enabled="false" language="Angular2Html" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
반복 처리할 변수 타입에 반복자를 반환하는 &lt;code&gt;[Symbol.iterator]()&lt;/code&gt; 메서드가 없는 경우를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularForBlockNonIterableVar&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularMissingOrInvalidDeclarationInModule" defaultSeverity="ERROR" displayName="모듈 내 구성 요소, 지시문 또는 파이프 선언이 누락되었거나 잘못되었습니다." enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
어떤 모듈에서도 선언되지 않았거나 여러 모듈에서 선언된 비독립실행형 Angular 구성 요소, 지시문 또는 파이프를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularMissingOrInvalidDeclarationInModule&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AngularInvalidTemplateReferenceVariable" defaultSeverity="ERROR" displayName="바운드되지 않거나 모호한 템플릿 참조 변수" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;exportAs&lt;/code&gt; 사용 시 지시문에 대입되어 있지 않거나 복수의 지시문에 대입되어 있는 템플릿 참조 변수를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularInvalidTemplateReferenceVariable&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularUndefinedTag" defaultSeverity="ERROR" displayName="정의되지 않은 태그" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
현재 범위 바깥의 구성 요소 또는 지시문에 의해 정의된 태그를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularUndefinedTag&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularNgOptimizedImage" defaultSeverity="WEAK WARNING" displayName="img 태그 내 ngSrc 사용과 관련된 문제" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;code&gt;img&lt;/code&gt; 태그에서 &lt;code&gt;ngSrc&lt;/code&gt;(&lt;a href="https://angular.io/guide/image-directive"&gt;NgOptimizedDirective&lt;/a&gt;)의 사용과 관련된 문제를 보고합니다.
&lt;p&gt;
다음과 같은 문제가 보고됩니다.
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ngSrc&lt;/code&gt; 대신 &lt;code&gt;src&lt;/code&gt;를 사용하는 &lt;code&gt;img&lt;/code&gt; 태그
  &lt;li&gt;&lt;code&gt;ngSrc&lt;/code&gt;가 사용될 때 &lt;code&gt;width&lt;/code&gt; 및 &lt;code&gt;height&lt;/code&gt; 또는 &lt;code&gt;fill&lt;/code&gt; 속성이 없는 경우
  &lt;li&gt;&lt;code&gt;ngSrc&lt;/code&gt;이 사용될 때 동일한 요소에 &lt;code&gt;width&lt;/code&gt; 또는 &lt;code&gt;height&lt;/code&gt; 및 &lt;code&gt;fill&lt;/code&gt; 속성이 있는 경우
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Inspection ID: AngularNgOptimizedImage&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularInvalidAnimationTriggerAssignment" defaultSeverity="ERROR" displayName="잘못된 애니메이션 트리거 대입" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
애니메이션 트리거의 잘못된 대입을 보고합니다. 애니메이션을 요소에 연결하려면, &lt;code&gt;[@triggerName]="expression"&lt;/code&gt;을 사용하거나 &lt;code&gt;@triggerName&lt;/code&gt;값 없이 속성을 사용하세요.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularInvalidAnimationTriggerAssignment&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularInvalidImportedOrDeclaredSymbol" defaultSeverity="ERROR" displayName="가져오거나 선언된 잘못된 심볼" enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
모듈이나 구성 요소, 지시문, 파이프가 아니거나 프로퍼티의 컨텍스트에서 사용될 수 없는 Angular 모듈 또는 독립실행형 구성 요소에서 선언하거나, 가져오거나 내보낸 심볼을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularInvalidImportedOrDeclaredSymbol&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularNonEmptyNgContent" defaultSeverity="ERROR" displayName="&lt;ng-content&gt; 태그 내 내용" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
콘텐츠 프로젝션에 사용된 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 태그 내에 텍스트 또는 태그가 있는 경우를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularNonEmptyNgContent&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularUnusedComponentImport" defaultSeverity="ERROR" displayName="Angular 구성 요소 선언 내 사용되지 않는 import" enabled="false" language="TypeScript" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Angular 구성 요소에서 사용되지 않은 import를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularUnusedComponentImport&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularCliAddDependency" defaultSeverity="WARNING" displayName="Angular CLI 종속 요소 추가" enabled="false" language="JSON" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
종속성 설치에 &lt;code&gt;ng add&lt;/code&gt; 명령어를 사용할 것을 제안합니다.
&lt;p&gt;&lt;code&gt;ng add&lt;/code&gt;는 패키지 관리자를 사용해 종속성을 다운로드하여 구성 변경에 따른 프로젝트 업데이트, 그 외의 종속성 추가(예: polyfill), 또는 패키지용 초기화 코드 스캐폴드를 수행할 수 있는 스키매틱을 호출합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularCliAddDependency&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularMissingRequiredDirectiveInputBinding" defaultSeverity="ERROR" displayName="필수 지시문 입력 누락" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
필수 지시문 입력에서 누락된 바인딩을 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularMissingRequiredDirectiveInputBinding&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularUnresolvedPipe" defaultSeverity="ERROR" displayName="해결되지 않은 파이프" enabled="false" language="HtmlCompatible" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
사용되지 않는 파이프를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularUnresolvedPipe&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AngularInvalidSelector" defaultSeverity="ERROR" displayName="누락되었거나 잘못된 선택자" enabled="false" pluginId="AngularJS" pluginVersion="252.23892.409" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
구성 요소 또는 지시문의 잘못된 &lt;code&gt;selector&lt;/code&gt; 프로퍼티를 보고합니다.
&lt;!-- tooltip end --&gt;&lt;p&gt;&lt;small&gt;Inspection ID: AngularInvalidSelector&lt;/small&gt;&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;</inspection></group></inspections>